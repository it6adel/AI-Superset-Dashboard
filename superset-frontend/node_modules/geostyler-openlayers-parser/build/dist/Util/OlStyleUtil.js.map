{"version":3,"file":"OlStyleUtil.js","sourceRoot":"","sources":["../../../src/Util/OlStyleUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Expression,\n  Fcase,\n  GeoStylerBooleanFunction,\n  GeoStylerFunction,\n  GeoStylerNumberFunction,\n  GeoStylerStringFunction,\n  GeoStylerUnknownFunction,\n  isGeoStylerBooleanFunction,\n  isGeoStylerFunction,\n  isGeoStylerNumberFunction,\n  isGeoStylerStringFunction,\n  isGeoStylerUnknownFunction,\n  MarkSymbolizer,\n  PropertyType,\n  Style,\n  TextSymbolizer\n} from 'geostyler-style';\nimport { Feature as OlFeature } from 'ol';\nimport { colors } from './colors';\n\nconst WELLKNOWNNAME_TTF_REGEXP = /^ttf:\\/\\/(.+)#(.+)$/;\nexport const DUMMY_MARK_SYMBOLIZER_FONT = 'geostyler-mark-symbolizer';\n\n/**\n * Offers some utility functions to work with OpenLayers Styles.\n */\nclass OlStyleUtil {\n\n  /**\n   * Transforms a HEX encoded color and an opacity value to a RGB(A) notation.\n   *\n   * @param colorString HEX encoded color\n   * @param opacity  Opacity (Betweeen 0 and 1)\n   * @return the RGB(A) value of the input color\n   */\n  public static getRgbaColor(colorString: string | GeoStylerStringFunction, opacity: number | GeoStylerNumberFunction) {\n    if (isGeoStylerStringFunction(colorString)) {\n      colorString = OlStyleUtil.evaluateStringFunction(colorString);\n    }\n\n    if (typeof(colorString) !== 'string') {\n      return;\n    }\n    if (colorString.startsWith('rgba(')) {\n      return colorString;\n    }\n\n    // check if is valid HEX color - see also here\n    // https://stackoverflow.com/questions/8027423/how-to-check-if-a-string-is-a-valid-hex-color-representation/8027444\n    const isHexColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(colorString);\n    if (!isHexColor) {\n      return;\n    }\n\n    const r = parseInt(colorString.slice(1, 3), 16);\n    const g = parseInt(colorString.slice(3, 5), 16);\n    const b = parseInt(colorString.slice(5, 7), 16);\n\n    if (isGeoStylerNumberFunction(opacity)) {\n      opacity = OlStyleUtil.evaluateNumberFunction(opacity);\n    }\n\n    if (opacity < 0) {\n      opacity = 1;\n    }\n\n    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + opacity + ')';\n  }\n\n  /**\n   * Splits a RGBA encoded color into its color values.\n   *\n   * @param {string} rgbaColor RGB(A) encoded color\n   * @return {number[]} Numeric color values as array\n   */\n  public static splitRgbaColor(rgbaColor: string): number[] {\n    const colorsOnly = rgbaColor.substring(rgbaColor.indexOf('(') + 1, rgbaColor.lastIndexOf(')')).split(/,\\s*/);\n    const red = parseInt(colorsOnly[0], 10);\n    const green = parseInt(colorsOnly[1], 10);\n    const blue = parseInt(colorsOnly[2], 10);\n    const opacity = parseFloat(colorsOnly[3]);\n\n    return [red, green, blue, opacity];\n  }\n\n  /**\n   * Transforms a RGB(A) or named color value to a HEX encoded notation.\n   * If a HEX color is provided it will be returned untransformed.\n   *\n   * @param {string} inColor The color to transform\n   * @return {string | undefined} The HEX color representation of the given color\n   */\n  public static getHexColor(inColor: string): string | undefined {\n    // if passing in a hex code we just return it\n    if (inColor.startsWith('#')) {\n      return inColor;\n    } else if (inColor.startsWith('rgb')) {\n      const colorArr = OlStyleUtil.splitRgbaColor(inColor);\n      return OlStyleUtil.getHexCodeFromRgbArray(colorArr);\n    } else if (colors[inColor.toLocaleLowerCase()] !== undefined) {\n      const rgbColorArr = colors[inColor.toLocaleLowerCase()];\n      return OlStyleUtil.getHexCodeFromRgbArray(rgbColorArr);\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Returns the hex code for a given RGB(A) array.\n   *\n   * @param colorArr RGB(A) array. e.g. [255,0,0]\n   * @return {string} The HEX color representation of the given color\n   */\n  public static getHexCodeFromRgbArray(colorArr: number[]): string {\n    return '#' + colorArr.map((x, idx) => {\n      const hex = x.toString(16);\n      // skip opacity if passed as fourth entry\n      if (idx < 3) {\n        return hex.length === 1 ? '0' + hex : hex;\n      }\n      return '';\n    }).join('');\n  }\n\n  /**\n   * Returns the opacity value of a RGB(A) color value.\n   *\n   * @param rgbaColor RGBA encoded color\n   * @return {string | undefined} The opacity value of the given RGBA color\n   */\n  public static getOpacity(rgbaColor: string): number | undefined {\n    if (!rgbaColor.startsWith('rgba(')) {\n      return;\n    }\n\n    const colorArr = OlStyleUtil.splitRgbaColor(rgbaColor);\n\n    if (colorArr.length === 4) {\n      return colorArr[3];\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Returns an OL compliant font string.\n   *\n   * @param symbolizer The TextSymbolizer to derive the font string from\n   */\n  public static getTextFont(symbolizer: TextSymbolizer) {\n    const fontWeight = symbolizer.fontWeight ?? 'normal';\n    const fontStyle = symbolizer.fontStyle ?? 'normal';\n\n    const size = symbolizer.size;\n    const font = symbolizer.font;\n    return fontWeight + ' ' + fontStyle + ' ' + size + 'px ' + font?.join(', ');\n  }\n\n\n  /**\n   * Returns true if the given mark symbolizer is based on a font glyph\n   * (i.e. has a well known name property starting with 'ttf://').\n   *\n   * @param symbolizer The TextSymbolizer to derive the font string from\n   */\n  public static getIsFontGlyphBased(symbolizer: MarkSymbolizer) {\n    return WELLKNOWNNAME_TTF_REGEXP.test(symbolizer.wellKnownName);\n  }\n\n  /**\n   * Returns whether the given font (as used in the OpenLayers Text Style `font` property)\n   * is intended for a mark symbolizer or not.\n   * This is done by checking whether the dummy DUMMY_MARK_SYMBOLIZER_FONT font name is present.\n   *\n   * @param font The text font to analyze\n   */\n  public static getIsMarkSymbolizerFont(font: string) {\n    if (!font) {\n      return false;\n    }\n    const search = DUMMY_MARK_SYMBOLIZER_FONT;\n    return font.substring(font.length - search.length, font.length) === search;\n  }\n\n  /**\n   * Returns an OL compliant font string, to be used for mark symbolizers\n   * using a font glyph.\n   * This also includes a dummy DUMMY_MARK_SYMBOLIZER_FONT font name at the end of the\n   * string to allow determining that this font was intended for a mark symbolizer\n   * later on.\n   *\n   * @param symbolizer The TextSymbolizer to derive the font string from\n   */\n  public static getTextFontForMarkSymbolizer(symbolizer: MarkSymbolizer) {\n    const parts = symbolizer.wellKnownName.match(WELLKNOWNNAME_TTF_REGEXP);\n    if (!parts) {\n      throw new Error(`Could not parse font-based well known name: ${symbolizer.wellKnownName}`);\n    }\n    const fontFamily = parts[1];\n    return `Normal ${symbolizer.radius || 5}px '${fontFamily}', ${DUMMY_MARK_SYMBOLIZER_FONT}`;\n  }\n\n  /**\n   * Returns a 1-char string to be used as text for mark symbolizers using a font glyph.\n   *\n   * @param symbolizer The MarkSymbolizer to derive the character string from\n   */\n  public static getCharacterForMarkSymbolizer(symbolizer: MarkSymbolizer) {\n    const parts = symbolizer.wellKnownName.match(WELLKNOWNNAME_TTF_REGEXP);\n    if (!parts) {\n      throw new Error(`Could not parse font-based well known name: ${symbolizer.wellKnownName}`);\n    }\n    return String.fromCharCode(parseInt(parts[2], 16));\n  }\n\n  /**\n   * Returns the font name used in the OpenLayers text style `font` property.\n   *\n   * @param olFont the `font` property of an OpenLayers text style\n   */\n  public static getFontNameFromOlFont(olFont: string) {\n    const parts = olFont.match(/(?:\\d+\\S+) '?\"?([^,'\"]+)/);\n    if (!parts) {\n      throw new Error(`Could not find font family name in the following string: ${olFont}`);\n    }\n    return parts[1];\n  }\n\n  /**\n   * Returns the size in pixels specified in the OpenLayers text style `font` property,\n   * or 0 if not found.\n   *\n   * @param olFont the `font` property of an OpenLayers text style\n   */\n  public static getSizeFromOlFont(olFont: string) {\n    const parts = olFont.match(/(?:(\\d+)px)/);\n    return parts ? parseInt(parts[1], 10) : 0;\n  }\n\n  /**\n   * Resolves the given template string with the given feature attributes, e.g.\n   * the template \"Size of area is {{AREA_SIZE}} km²\" would be to resolved\n   * to \"Size of area is 1909 km²\" (assuming the feature's attribute AREA_SIZE\n   * really exists).\n   *\n   * @param feature The feature to get the attributes from.\n   * @param template The template string to resolve.\n   * @param [noValueFoundText] The text to apply, if the templated value\n   *   could not be found, default is to 'n.v.'.\n   * @param [valueAdjust] A method that will be called with each\n   *   key/value match, we'll use what this function returns for the actual\n   *   replacement. Optional, defaults to a function which will return the raw\n   *   value it received. This can be used for last minute adjustments before\n   *   replacing happens, e.g. to filter out falsy values or to do number\n   *   formatting and such.\n   * @return The resolved template string.\n   */\n  static resolveAttributeTemplate(\n    feature: OlFeature,\n    template: string,\n    noValueFoundText: string = 'n.v.',\n    valueAdjust: Function = (key: string, val: any) => val\n  ) {\n\n    let attributeTemplatePrefix = '\\\\{\\\\{';\n    let attributeTemplateSuffix = '\\\\}\\\\}';\n\n    // Find any character between two braces (including the braces in the result)\n    let regExp = new RegExp(attributeTemplatePrefix + '(.*?)' + attributeTemplateSuffix, 'g');\n    let regExpRes = template.match(regExp);\n\n    // If we have a regex result, it means we found a placeholder in the\n    // template and have to replace the placeholder with its appropriate value.\n    if (regExpRes) {\n      // Iterate over all regex match results and find the proper attribute\n      // for the given placeholder, finally set the desired value to the hover.\n      // field text\n      regExpRes.forEach(res => {\n        // We count every non matching candidate. If this count is equal to\n        // the objects length, we assume that there is no match at all and\n        // set the output value to the value of \"noValueFoundText\".\n        let noMatchCnt = 0;\n\n        for (let [key, value] of Object.entries(feature.getProperties())) {\n          // Remove the suffixes and find the matching attribute column.\n          let attributeName = res.slice(2, res.length - 2);\n\n          if (attributeName.toLowerCase() === key.toLowerCase()) {\n            template = template.replace(res, valueAdjust(key, value));\n            break;\n          } else {\n            noMatchCnt++;\n          }\n        }\n\n        // No key match found for this feature (e.g. if key not\n        // present or value is null).\n        if (noMatchCnt === Object.keys(feature.getProperties()).length) {\n          template = template.replace(res, noValueFoundText);\n        }\n      });\n    }\n\n    return template;\n  }\n\n  public static evaluateFunction(func: GeoStylerFunction, feature?: OlFeature): PropertyType {\n    if (func.name === 'property') {\n      if (!feature) {\n        throw new Error(`Could not evalute 'property' function. Feature ${feature} is not defined.`);\n      }\n      if (isGeoStylerStringFunction(func.args[0])) {\n        return feature?.get(OlStyleUtil.evaluateStringFunction(func.args[0], feature));\n      } else {\n        return feature?.get(func.args[0]);\n      }\n    }\n\n    if (isGeoStylerUnknownFunction(func)) {\n      return OlStyleUtil.evaluateUnknownFunction(func, feature);\n    }\n    if (isGeoStylerStringFunction(func)) {\n      return OlStyleUtil.evaluateStringFunction(func, feature);\n    }\n    if (isGeoStylerNumberFunction(func)) {\n      return OlStyleUtil.evaluateNumberFunction(func, feature);\n    }\n    if (isGeoStylerBooleanFunction(func)) {\n      return OlStyleUtil.evaluateBooleanFunction(func, feature);\n    }\n    return;\n  }\n\n  public static evaluateBooleanFunction(func: GeoStylerBooleanFunction, feature?: OlFeature): boolean {\n    const args = func.args.map(arg => {\n      if (isGeoStylerFunction(arg)) {\n        return OlStyleUtil.evaluateFunction(arg, feature);\n      }\n      return arg;\n    });\n    switch (func.name) {\n      case 'all':\n        return args.map(arg => this.evaluateBooleanFunction(arg as GeoStylerBooleanFunction, feature))\n          .every(result => result === true);\n      case 'any':\n        return args.map(arg => this.evaluateBooleanFunction(arg as GeoStylerBooleanFunction, feature))\n          .some(result => result === true);\n      case 'between':\n        return (args[0] as number) >= (args[1] as number) && (args[0] as number) <= (args[2] as number);\n      case 'double2bool':\n        // TODO: evaluate this correctly\n        return false;\n      case 'equalTo':\n        return args[0] === args[1];\n      case 'greaterThan':\n        return (args[0] as number) > (args[1] as number);\n      case 'greaterThanOrEqualTo':\n        return (args[0] as number) >= (args[1] as number);\n      case 'in':\n        return args.slice(1).includes(args[0]);\n      case 'lessThan':\n        return (args[0] as number) < (args[1] as number);\n      case 'lessThanOrEqualTo':\n        return (args[0] as number) <= (args[1] as number);\n      case 'not':\n        return !args[0];\n      case 'notEqualTo':\n        return args[0] !== args[1];\n      case 'parseBoolean':\n        return !!args[0];\n      case 'strEndsWith':\n        return (args[0] as string).endsWith(args[1] as string);\n      case 'strEqualsIgnoreCase':\n        return (args[0] as string).toLowerCase() === (args[1] as string).toLowerCase() ;\n      case 'strMatches':\n        const regEx = (args[1] as string);\n        const regexArray = regEx.match(/\\/(.*?)\\/([gimy]{0,4})$/);\n        if (regexArray && regexArray.length === 3){\n          return new RegExp(regexArray[1], regexArray[2]).test(args[0] as string);\n        } else {\n          return false;\n        }\n      case 'strStartsWith':\n        return (args[0] as string).startsWith(args[1] as string);\n      default:\n        return false;\n    }\n  }\n\n  public static evaluateNumberFunction(func: GeoStylerNumberFunction, feature?: OlFeature): number {\n    if (func.name === 'pi') {\n      return Math.PI;\n    }\n    if (func.name === 'random') {\n      return Math.random();\n    }\n    const args = func.args.map(arg => {\n      if (isGeoStylerFunction(arg)) {\n        return OlStyleUtil.evaluateFunction(arg, feature);\n      }\n      return arg;\n    });\n    switch (func.name) {\n      case 'abs':\n        return Math.abs(args[0] as number);\n      case 'acos':\n        return Math.acos(args[0] as number);\n      case 'add':\n        return (args[0] as number) + (args[1] as number);\n      case 'asin':\n        return Math.asin(args[0] as number);\n      case 'atan':\n        return Math.atan(args[0] as number);\n      case 'atan2':\n        // TODO: evaluate this correctly\n        return args[0] as number;\n      case 'ceil':\n        return Math.ceil(args[0] as number);\n      case 'cos':\n        return Math.cos(args[0] as number);\n      case 'div':\n        return (args[0] as number) / (args[1] as number);\n      case 'exp':\n        return Math.exp(args[0] as number);\n      case 'floor':\n        return Math.floor(args[0] as number);\n      case 'log':\n        return Math.log(args[0] as number);\n      case 'max':\n        return Math.max(...(args as number[]));\n      case 'min':\n        return Math.min(...(args as number[]));\n      case 'modulo':\n        return (args[0] as number) % (args[1] as number);\n      case 'mul':\n        return (args[0] as number) * (args[1] as number);\n      case 'pow':\n        return Math.pow(args[0] as number, args[1] as number);\n      case 'rint':\n        // TODO: evaluate this correctly\n        return args[0] as number;\n      case 'round':\n        return Math.round(args[0] as number);\n      case 'sin':\n        return Math.sin(args[0] as number);\n      case 'sqrt':\n        return Math.sqrt(args[0] as number);\n      case 'strIndexOf':\n        return (args[0] as string).indexOf(args[1] as string);\n      case 'strLastIndexOf':\n        return (args[0] as string).lastIndexOf(args[1] as string);\n      case 'strLength':\n        return (args[0] as string).length;\n      case 'sub':\n        return (args[0] as number) - (args[1] as number);\n      case 'tan':\n        return Math.tan(args[0] as number);\n      case 'toDegrees':\n        return (args[0] as number) * (180/Math.PI);\n      case 'toRadians':\n        return (args[0] as number) * (Math.PI/180);\n      default:\n        return args[0] as number;\n    }\n  }\n\n  public static evaluateUnknownFunction(func: GeoStylerUnknownFunction, feature?: OlFeature): unknown {\n    const args = func.args.map(arg => {\n      if (isGeoStylerFunction(arg)) {\n        return OlStyleUtil.evaluateFunction(arg, feature);\n      }\n      return arg;\n    });\n    switch (func.name) {\n      case 'property':\n        return feature?.get(args[0] as string);\n      case 'case':\n        type FCaseParameter = {\n          case: Expression<boolean>;\n          value: Expression<PropertyType>;\n        };\n        const caseArgs: Fcase['args'] = args as Fcase['args'];\n        let match;\n        for (let index = 0; index < caseArgs.length; index++) {\n          const caseArg = caseArgs[index] as FCaseParameter;\n          // last arg of the case-function-expression is the default value\n          if (index === caseArgs.length - 1) {\n            match = caseArg;\n            break;\n          // the case can be a boolean\n          } else if (caseArg.case === true) {\n            match = caseArg.value;\n            break;\n          // … or a boolean function that has to be evaluated first\n          } else if (OlStyleUtil.evaluateBooleanFunction(caseArg.case as GeoStylerBooleanFunction, feature)) {\n            match = caseArg.value;\n            break;\n          }\n        }\n        return match;\n      default:\n        return args[0];\n    }\n  }\n\n  public static evaluateStringFunction(func: GeoStylerStringFunction, feature?: OlFeature): string {\n    const args = func.args.map(arg => {\n      if (isGeoStylerFunction(arg)) {\n        return OlStyleUtil.evaluateFunction(arg, feature);\n      }\n      return arg;\n    });\n    switch (func.name) {\n      case 'numberFormat':\n        // TODO: evaluate this correctly\n        return args[0] as string;\n      case 'strAbbreviate':\n        // TODO: evaluate this correctly\n        return args[0] as string;\n      case 'strCapitalize':\n        // https://stackoverflow.com/a/32589289/10342669\n        var splitStr = (args[0] as string).toLowerCase().split(' ');\n        for (let part of splitStr) {\n          part = part.charAt(0).toUpperCase() + part.substring(1);\n        }\n        return splitStr.join(' ');\n      case 'strConcat':\n        return args.join();\n      case 'strDefaultIfBlank':\n        return (args[0] as string)?.length < 1 ? args[1] as string : args[0] as string;\n      case 'strReplace':\n        if (args[3] === true) {\n          return (args[0] as string).replaceAll(args[1] as string, args[2] as string);\n        } else {\n          return (args[0] as string).replace(args[1] as string, args[2] as string);\n        }\n      case 'strStripAccents':\n        // https://stackoverflow.com/a/37511463/10342669\n        return (args[0] as string).normalize('NFKD').replace(/[\\u0300-\\u036f]/g, '');\n      case 'strSubstring':\n        return (args[0] as string).substring(args[1] as number, args[2] as number);\n      case 'strSubstringStart':\n        return (args[0] as string).substring(args[1] as number);\n      case 'strToLowerCase':\n        return (args[0] as string).toLowerCase();\n      case 'strToUpperCase':\n        return (args[0] as string).toUpperCase();\n      case 'strTrim':\n        return (args[0] as string).trim();\n      default:\n        return args[0] as string;\n    }\n  }\n\n  public static containsGeoStylerFunctions(style: Style) {\n    return style.rules.some(rule => {\n      const filterHasFunction = Array.isArray(rule.filter) && rule.filter?.some(isGeoStylerFunction);\n      const styleHasFunction = rule.symbolizers?.some(symbolizer => {\n        return Object.values(symbolizer).some(isGeoStylerFunction);\n      });\n      const scaleDenominatorHasFunction = isGeoStylerFunction(rule?.scaleDenominator?.max)\n      || isGeoStylerFunction(rule?.scaleDenominator?.min);\n      return filterHasFunction || styleHasFunction || scaleDenominatorHasFunction;\n    });\n  }\n}\n\nexport default OlStyleUtil;\n"]}