"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OlStyleParser = void 0;
var css_font_parser_1 = require("css-font-parser");
var geostyler_style_1 = require("geostyler-style");
var ImageState_1 = __importDefault(require("ol/ImageState"));
var Point_1 = __importDefault(require("ol/geom/Point"));
var Style_1 = __importDefault(require("ol/style/Style"));
var Image_1 = __importDefault(require("ol/style/Image"));
var Stroke_1 = __importDefault(require("ol/style/Stroke"));
var Text_1 = __importDefault(require("ol/style/Text"));
var Circle_1 = __importDefault(require("ol/style/Circle"));
var Fill_1 = __importDefault(require("ol/style/Fill"));
var Icon_1 = __importDefault(require("ol/style/Icon"));
var RegularShape_1 = __importDefault(require("ol/style/RegularShape"));
var Units_1 = require("ol/proj/Units");
var OlStyleUtil_1 = __importDefault(require("./Util/OlStyleUtil"));
var render_1 = require("ol/render");
/**
 * This parser can be used with the GeoStyler.
 * It implements the GeoStyler-Style Parser interface to work with OpenLayers styles.
 *
 * @class OlStyleParser
 * @implements StyleParser
 */
var OlStyleParser = /** @class */ (function () {
    function OlStyleParser(ol) {
        this.unsupportedProperties = {
            Symbolizer: {
                MarkSymbolizer: {
                    avoidEdges: 'none',
                    blur: 'none',
                    offsetAnchor: 'none',
                    pitchAlignment: 'none',
                    pitchScale: 'none'
                },
                FillSymbolizer: {
                    antialias: 'none',
                    opacity: {
                        support: 'none',
                        info: 'Use fillOpacity instead.'
                    }
                },
                IconSymbolizer: {
                    allowOverlap: 'none',
                    anchor: 'none',
                    avoidEdges: 'none',
                    color: 'none',
                    haloBlur: 'none',
                    haloColor: 'none',
                    haloWidth: 'none',
                    keepUpright: 'none',
                    offsetAnchor: 'none',
                    size: {
                        support: 'partial',
                        info: 'Will set/get the width of the ol Icon.'
                    },
                    optional: 'none',
                    padding: 'none',
                    pitchAlignment: 'none',
                    rotationAlignment: 'none',
                    textFit: 'none',
                    textFitPadding: 'none'
                },
                LineSymbolizer: {
                    blur: 'none',
                    gapWidth: 'none',
                    gradient: 'none',
                    miterLimit: 'none',
                    roundLimit: 'none',
                    spacing: 'none',
                    graphicFill: 'none',
                    graphicStroke: 'none',
                    perpendicularOffset: 'none'
                },
                RasterSymbolizer: 'none',
                TextSymbolizer: {
                    placement: {
                        support: 'partial',
                        info: 'point and line supported. line-center will be mapped to line.'
                    }
                }
            },
            Function: {
                double2bool: {
                    support: 'none',
                    info: 'Always returns false'
                },
                atan2: {
                    support: 'none',
                    info: 'Currently returns the first argument'
                },
                rint: {
                    support: 'none',
                    info: 'Currently returns the first argument'
                },
                numberFormat: {
                    support: 'none',
                    info: 'Currently returns the first argument'
                },
                strAbbreviate: {
                    support: 'none',
                    info: 'Currently returns the first argument'
                }
            }
        };
        this.title = 'OpenLayers Style Parser';
        this.olIconStyleCache = {};
        this.OlStyleConstructor = Style_1.default;
        this.OlStyleImageConstructor = Image_1.default;
        this.OlStyleFillConstructor = Fill_1.default;
        this.OlStyleStrokeConstructor = Stroke_1.default;
        this.OlStyleTextConstructor = Text_1.default;
        this.OlStyleCircleConstructor = Circle_1.default;
        this.OlStyleIconConstructor = Icon_1.default;
        this.OlStyleRegularshapeConstructor = RegularShape_1.default;
        this.isOlParserStyleFct = function (x) {
            return typeof x === 'function';
        };
        if (ol) {
            this.OlStyleConstructor = ol.style.Style;
            this.OlStyleImageConstructor = ol.style.Image;
            this.OlStyleFillConstructor = ol.style.Fill;
            this.OlStyleStrokeConstructor = ol.style.Stroke;
            this.OlStyleTextConstructor = ol.style.Text;
            this.OlStyleCircleConstructor = ol.style.Circle;
            this.OlStyleIconConstructor = ol.style.Icon;
            this.OlStyleRegularshapeConstructor = ol.style.RegularShape;
        }
    }
    /**
     * Get the GeoStyler-Style PointSymbolizer from an OpenLayers Style object.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style PointSymbolizer
     */
    OlStyleParser.prototype.getPointSymbolizerFromOlStyle = function (olStyle) {
        var pointSymbolizer;
        if (olStyle.getImage() instanceof this.OlStyleCircleConstructor) {
            // circle
            var olCircleStyle = olStyle.getImage();
            var olFillStyle = olCircleStyle.getFill();
            var olStrokeStyle = olCircleStyle.getStroke();
            var offset = olCircleStyle.getDisplacement();
            var circleSymbolizer = {
                kind: 'Mark',
                wellKnownName: 'circle',
                color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
                opacity: olCircleStyle.getOpacity() !== 1 ? olCircleStyle.getOpacity() : undefined,
                fillOpacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
                radius: (olCircleStyle.getRadius() !== 0) ? olCircleStyle.getRadius() : 5,
                strokeColor: olStrokeStyle ? olStrokeStyle.getColor() : undefined,
                strokeOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
                strokeWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
                offset: offset[0] || offset[1] ? offset : undefined
            };
            pointSymbolizer = circleSymbolizer;
        }
        else if (olStyle.getImage() instanceof this.OlStyleRegularshapeConstructor) {
            // square, triangle, star, cross or x
            var olRegularStyle = olStyle.getImage();
            var olFillStyle = olRegularStyle.getFill();
            var olStrokeStyle = olRegularStyle.getStroke();
            var radius = olRegularStyle.getRadius();
            var radius2 = olRegularStyle.getRadius2();
            var points = olRegularStyle.getPoints();
            var angle = olRegularStyle.getAngle();
            var offset = olRegularStyle.getDisplacement();
            var markSymbolizer = {
                kind: 'Mark',
                color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
                opacity: olRegularStyle.getOpacity() !== 1 ? olRegularStyle.getOpacity() : undefined,
                fillOpacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
                strokeColor: olStrokeStyle ? olStrokeStyle.getColor() : undefined,
                strokeOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
                strokeWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
                radius: (radius !== 0) ? radius : 5,
                // Rotation in openlayers is radians while we use degree
                rotate: olRegularStyle.getRotation() / Math.PI * 180,
                offset: offset[0] || offset[1] ? offset : undefined
            };
            switch (points) {
                case 2:
                    switch (angle) {
                        case 0:
                            markSymbolizer.wellKnownName = 'shape://vertline';
                            break;
                        case Math.PI / 2:
                            markSymbolizer.wellKnownName = 'shape://horline';
                            break;
                        case Math.PI / 4:
                            markSymbolizer.wellKnownName = 'shape://slash';
                            break;
                        case 2 * Math.PI - (Math.PI / 4):
                            markSymbolizer.wellKnownName = 'shape://backslash';
                            break;
                        default:
                            break;
                    }
                    break;
                case 3:
                    switch (angle) {
                        case 0:
                            markSymbolizer.wellKnownName = 'triangle';
                            break;
                        case Math.PI / 2:
                            markSymbolizer.wellKnownName = 'shape://carrow';
                            break;
                        default:
                            break;
                    }
                    break;
                case 4:
                    if (Number.isFinite(radius2)) {
                        // cross or x
                        if (olRegularStyle.getAngle() === 0) {
                            // cross
                            markSymbolizer.wellKnownName = 'cross';
                        }
                        else {
                            // x
                            markSymbolizer.wellKnownName = 'x';
                        }
                    }
                    else {
                        // square
                        markSymbolizer.wellKnownName = 'square';
                    }
                    break;
                case 5:
                    // star
                    markSymbolizer.wellKnownName = 'star';
                    break;
                default:
                    throw new Error('Could not parse OlStyle. Only 2, 3, 4 or 5 point regular shapes are allowed');
            }
            pointSymbolizer = markSymbolizer;
        }
        else if (olStyle.getText() instanceof this.OlStyleTextConstructor) {
            var olTextStyle = olStyle.getText();
            var olFillStyle = olTextStyle.getFill();
            var olStrokeStyle = olTextStyle.getStroke();
            var rotation = olTextStyle.getRotation();
            var char = olTextStyle.getText() || 'a';
            var font = olTextStyle.getFont() || '10px sans-serif';
            var fontName = OlStyleUtil_1.default.getFontNameFromOlFont(font);
            var radius = OlStyleUtil_1.default.getSizeFromOlFont(font);
            var offset = [olTextStyle.getOffsetX(), olTextStyle.getOffsetY()];
            if (Array.isArray(char)) {
                char = char[0];
            }
            pointSymbolizer = {
                kind: 'Mark',
                wellKnownName: "ttf://".concat(fontName, "#0x").concat(char.charCodeAt(0).toString(16)),
                color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
                opacity: olFillStyle ? OlStyleUtil_1.default.getOpacity(olFillStyle.getColor()) : undefined,
                strokeColor: olStrokeStyle ? olStrokeStyle.getColor() : undefined,
                strokeOpacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
                strokeWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
                radius: (radius !== 0) ? radius : 5,
                // Rotation in openlayers is radians while we use degree
                rotate: rotation ? rotation / Math.PI * 180 : 0,
                offset: offset[0] || offset[1] ? offset : undefined
            };
        }
        else {
            // icon
            var olIconStyle = olStyle.getImage();
            var displacement = olIconStyle.getDisplacement();
            // initialOptions_ as fallback when image is not yet loaded
            var image = this.getImageFromIconStyle(olIconStyle);
            // this always gets calculated from ol so this might not have been set initially
            var size = olIconStyle.getWidth();
            var rotation = olIconStyle.getRotation() / Math.PI * 180;
            var opacity = olIconStyle.getOpacity();
            var iconSymbolizer = {
                kind: 'Icon',
                image: image,
                opacity: opacity < 1 ? opacity : undefined,
                size: size,
                // Rotation in openlayers is radians while we use degree
                rotate: rotation !== 0 ? rotation : undefined,
                offset: displacement[0] || displacement[1] ? displacement : undefined
            };
            pointSymbolizer = iconSymbolizer;
        }
        return pointSymbolizer;
    };
    /**
     *
     * @param olIconStyle An ol style Icon representation
     * @returns A string or Sprite configuration
     */
    OlStyleParser.prototype.getImageFromIconStyle = function (olIconStyle) {
        var size = olIconStyle.getSize();
        if (Array.isArray(size)) {
            // TODO: create getters (and setters?) in openlayers
            // @ts-ignore
            var position = olIconStyle.offset_;
            // @ts-ignore
            var offsetOrigin = olIconStyle.offsetOrigin_;
            if (offsetOrigin && offsetOrigin !== 'top-left') {
                throw new Error("Offset origin ".concat(offsetOrigin, " not supported"));
            }
            return {
                source: olIconStyle.getSrc(),
                position: position,
                size: size
            };
        }
        else {
            return olIconStyle.getSrc() ? olIconStyle.getSrc() : undefined;
        }
    };
    /**
     * Get the GeoStyler-Style LineSymbolizer from an OpenLayers Style object.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style LineSymbolizer
     */
    OlStyleParser.prototype.getLineSymbolizerFromOlStyle = function (olStyle) {
        var olStrokeStyle = olStyle.getStroke();
        // getLineDash returns null not undefined. So we have to double check
        var dashArray = olStrokeStyle ? olStrokeStyle.getLineDash() : undefined;
        return {
            kind: 'Line',
            color: olStrokeStyle ? OlStyleUtil_1.default.getHexColor(olStrokeStyle.getColor()) : undefined,
            opacity: olStrokeStyle ? OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor()) : undefined,
            width: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
            cap: olStrokeStyle ? olStrokeStyle.getLineCap() : 'butt',
            join: olStrokeStyle ? olStrokeStyle.getLineJoin() : 'miter',
            dasharray: dashArray ? dashArray : undefined,
            dashOffset: olStrokeStyle ? olStrokeStyle.getLineDashOffset() : undefined
        };
    };
    /**
     * Get the GeoStyler-Style FillSymbolizer from an OpenLayers Style object.
     *
     * PolygonSymbolizer Stroke is just partially supported.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style FillSymbolizer
     */
    OlStyleParser.prototype.getFillSymbolizerFromOlStyle = function (olStyle) {
        var olFillStyle = olStyle.getFill();
        var olStrokeStyle = olStyle.getStroke();
        // getLineDash returns null not undefined. So we have to double check
        var outlineDashArray = olStrokeStyle ? olStrokeStyle.getLineDash() : undefined;
        var symbolizer = {
            kind: 'Fill'
        };
        if (olFillStyle) {
            symbolizer.color = OlStyleUtil_1.default.getHexColor(olFillStyle.getColor());
        }
        if (olFillStyle) {
            symbolizer.fillOpacity = OlStyleUtil_1.default.getOpacity(olFillStyle.getColor());
        }
        if (olStrokeStyle) {
            symbolizer.outlineColor = OlStyleUtil_1.default.getHexColor(olStrokeStyle.getColor());
        }
        if (outlineDashArray) {
            symbolizer.outlineDasharray = outlineDashArray;
        }
        if (olStrokeStyle) {
            symbolizer.outlineOpacity = OlStyleUtil_1.default.getOpacity(olStrokeStyle.getColor());
        }
        if (olStrokeStyle && olStrokeStyle.getWidth()) {
            symbolizer.outlineWidth = olStrokeStyle.getWidth();
        }
        return symbolizer;
    };
    /**
     * Get the GeoStyler-Style TextSymbolizer from an OpenLayers Style object.
     *
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style TextSymbolizer
     */
    OlStyleParser.prototype.getTextSymbolizerFromOlStyle = function (olStyle) {
        var olTextStyle = olStyle.getText();
        if (!olTextStyle) {
            throw new Error('Could not get text from olStyle.');
        }
        var olFillStyle = olTextStyle.getFill();
        var olStrokeStyle = olTextStyle.getStroke();
        var offsetX = olTextStyle.getOffsetX();
        var offsetY = olTextStyle.getOffsetY();
        var font = olTextStyle.getFont();
        var rotation = olTextStyle.getRotation();
        var allowOverlap = olTextStyle.getOverflow() ? olTextStyle.getOverflow() : undefined;
        var placement = olTextStyle.getPlacement();
        var text = olTextStyle.getText();
        var label = Array.isArray(text) ? text[0] : text;
        var fontSize = Infinity;
        var fontFamily = undefined;
        var fontWeight = undefined;
        var fontStyle = undefined;
        if (font) {
            var fontObj = (0, css_font_parser_1.parseFont)(font);
            if (fontObj['font-weight']) {
                fontWeight = fontObj['font-weight'];
            }
            if (fontObj['font-size']) {
                fontSize = parseInt(fontObj['font-size'], 10);
            }
            if (fontObj['font-family']) {
                var fontFamilies = fontObj['font-family'];
                fontFamily = fontFamilies === null || fontFamilies === void 0 ? void 0 : fontFamilies.map(function (f) { return f.includes(' ') ? '"' + f + '"' : f; });
            }
            if (fontObj['font-style']) {
                fontStyle = fontObj['font-style'];
            }
        }
        return {
            kind: 'Text',
            label: label,
            placement: placement,
            allowOverlap: allowOverlap,
            color: olFillStyle ? OlStyleUtil_1.default.getHexColor(olFillStyle.getColor()) : undefined,
            size: isFinite(fontSize) ? fontSize : undefined,
            font: fontFamily,
            fontWeight: fontWeight || undefined,
            fontStyle: fontStyle || undefined,
            offset: (offsetX !== undefined) && (offsetY !== undefined) ? [offsetX, offsetY] : [0, 0],
            haloColor: olStrokeStyle && olStrokeStyle.getColor() ?
                OlStyleUtil_1.default.getHexColor(olStrokeStyle.getColor()) : undefined,
            haloWidth: olStrokeStyle ? olStrokeStyle.getWidth() : undefined,
            rotate: (rotation !== undefined) ? rotation / Math.PI * 180 : undefined
        };
    };
    /**
     * Get the GeoStyler-Style Symbolizer from an OpenLayers Style object.
     *
     * @param olStyles The OpenLayers Style object
     * @return The GeoStyler-Style Symbolizer array
     */
    OlStyleParser.prototype.getSymbolizersFromOlStyle = function (olStyles) {
        var _this = this;
        var symbolizers = [];
        olStyles.forEach(function (olStyle) {
            var symbolizer;
            var styleType = _this.getStyleTypeFromOlStyle(olStyle);
            switch (styleType) {
                case 'Point':
                    if (olStyle.getText() && !OlStyleUtil_1.default.getIsMarkSymbolizerFont(olStyle.getText().getFont())) {
                        symbolizer = _this.getTextSymbolizerFromOlStyle(olStyle);
                    }
                    else {
                        symbolizer = _this.getPointSymbolizerFromOlStyle(olStyle);
                    }
                    break;
                case 'Line':
                    symbolizer = _this.getLineSymbolizerFromOlStyle(olStyle);
                    break;
                case 'Fill':
                    symbolizer = _this.getFillSymbolizerFromOlStyle(olStyle);
                    break;
                default:
                    throw new Error('Failed to parse SymbolizerKind from OpenLayers Style');
            }
            symbolizers.push(symbolizer);
        });
        return symbolizers;
    };
    /**
     * Get the GeoStyler-Style Rule from an OpenLayers Style object.
     *
     * @param olStyles The OpenLayers Style object
     * @return The GeoStyler-Style Rule
     */
    OlStyleParser.prototype.getRuleFromOlStyle = function (olStyles) {
        var symbolizers;
        var name = 'OL Style Rule 0';
        if (Array.isArray(olStyles)) {
            symbolizers = this.getSymbolizersFromOlStyle(olStyles);
        }
        else {
            symbolizers = this.getSymbolizersFromOlStyle([olStyles]);
        }
        return {
            name: name,
            symbolizers: symbolizers
        };
    };
    /**
     * Get the GeoStyler-Style Symbolizer from an OpenLayers Style object.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style Symbolizer
     */
    OlStyleParser.prototype.getStyleTypeFromOlStyle = function (olStyle) {
        var styleType;
        if (olStyle.getImage() instanceof this.OlStyleImageConstructor) {
            styleType = 'Point';
        }
        else if (olStyle.getText() instanceof this.OlStyleTextConstructor) {
            styleType = 'Point';
        }
        else if (olStyle.getFill() instanceof this.OlStyleFillConstructor) {
            styleType = 'Fill';
        }
        else if (olStyle.getStroke() && !olStyle.getFill()) {
            styleType = 'Line';
        }
        else {
            throw new Error('StyleType could not be detected');
        }
        return styleType;
    };
    /**
     * Get the GeoStyler-Style Style from an OpenLayers Style object.
     *
     * @param olStyle The OpenLayers Style object
     * @return The GeoStyler-Style Style
     */
    OlStyleParser.prototype.olStyleToGeoStylerStyle = function (olStyle) {
        var name = 'OL Style';
        var rule = this.getRuleFromOlStyle(olStyle);
        return {
            name: name,
            rules: [rule]
        };
    };
    /**
     * The readStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads an OpenLayers Style, an array of OpenLayers Styles or an olParserStyleFct and returns a Promise.
     *
     * The Promise itself resolves with a GeoStyler-Style Style.
     *
     * @param olStyle The style to be parsed
     * @return The Promise resolving with the GeoStyler-Style Style
     */
    OlStyleParser.prototype.readStyle = function (olStyle) {
        var _this = this;
        return new Promise(function (resolve) {
            try {
                if (_this.isOlParserStyleFct(olStyle)) {
                    resolve({
                        output: olStyle.__geoStylerStyle
                    });
                }
                else {
                    olStyle = olStyle;
                    var geoStylerStyle = _this.olStyleToGeoStylerStyle(olStyle);
                    var unsupportedProperties = _this.checkForUnsupportedProperties(geoStylerStyle);
                    resolve({
                        output: geoStylerStyle,
                        unsupportedProperties: unsupportedProperties
                    });
                }
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    /**
     * The writeStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads a GeoStyler-Style Style and returns a Promise.
     * The Promise itself resolves one of three types
     *
     * 1. OlStyle if input Style consists of
     *    one rule with one symbolizer, no filter, no scaleDenominator, no TextSymbolizer
     * 2. OlStyle[] if input Style consists of
     *    one rule with multiple symbolizers, no filter, no scaleDenominator, no TextSymbolizer
     * 3. OlParserStyleFct for everything else
     *
     * @param geoStylerStyle A GeoStyler-Style Style.
     * @return The Promise resolving with one of above mentioned style types.
     */
    OlStyleParser.prototype.writeStyle = function (geoStylerStyle) {
        var _this = this;
        return new Promise(function (resolve) {
            var clonedStyle = structuredClone(geoStylerStyle);
            var unsupportedProperties = _this.checkForUnsupportedProperties(clonedStyle);
            try {
                var olStyle = _this.getOlStyleTypeFromGeoStylerStyle(clonedStyle);
                resolve({
                    output: olStyle,
                    unsupportedProperties: unsupportedProperties,
                    warnings: unsupportedProperties && ['Your style contains unsupportedProperties!']
                });
            }
            catch (error) {
                resolve({
                    errors: [error]
                });
            }
        });
    };
    OlStyleParser.prototype.checkForUnsupportedProperties = function (geoStylerStyle) {
        var _this = this;
        var capitalizeFirstLetter = function (a) { return a[0].toUpperCase() + a.slice(1); };
        var unsupportedProperties = {};
        geoStylerStyle.rules.forEach(function (rule) {
            // ScaleDenominator and Filters are completly supported so we just check for symbolizers
            rule.symbolizers.forEach(function (symbolizer) {
                var _a, _b;
                var key = capitalizeFirstLetter("".concat(symbolizer.kind, "Symbolizer"));
                var value = (_b = (_a = _this.unsupportedProperties) === null || _a === void 0 ? void 0 : _a.Symbolizer) === null || _b === void 0 ? void 0 : _b[key];
                if (value) {
                    if (typeof value === 'string') {
                        if (!unsupportedProperties.Symbolizer) {
                            unsupportedProperties.Symbolizer = {};
                        }
                        unsupportedProperties.Symbolizer[key] = value;
                    }
                    else {
                        Object.keys(symbolizer).forEach(function (property) {
                            if (value[property]) {
                                if (!unsupportedProperties.Symbolizer) {
                                    unsupportedProperties.Symbolizer = {};
                                }
                                if (!unsupportedProperties.Symbolizer[key]) {
                                    unsupportedProperties.Symbolizer[key] = {};
                                }
                                unsupportedProperties.Symbolizer[key][property] = value[property];
                            }
                        });
                    }
                }
            });
        });
        if (Object.keys(unsupportedProperties).length > 0) {
            return unsupportedProperties;
        }
        return undefined;
    };
    /**
     * Decides which OlStyleType should be returned depending on given geoStylerStyle.
     * Three OlStyleTypes are possible:
     *
     * 1. OlStyle if input Style consists of
     *    one rule with one symbolizer, no filter, no scaleDenominator, no TextSymbolizer
     * 2. OlStyle[] if input Style consists of
     *    one rule with multiple symbolizers, no filter, no scaleDenominator, no TextSymbolizer
     * 3. OlParserStyleFct for everything else
     *
     * @param geoStylerStyle A GeoStyler-Style Style
     */
    OlStyleParser.prototype.getOlStyleTypeFromGeoStylerStyle = function (geoStylerStyle) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var rules = geoStylerStyle.rules;
        var nrRules = rules.length;
        if (nrRules === 1) {
            var hasFilter = ((_b = (_a = geoStylerStyle === null || geoStylerStyle === void 0 ? void 0 : geoStylerStyle.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.filter) !== undefined ? true : false;
            var hasMinScale = ((_e = (_d = (_c = geoStylerStyle === null || geoStylerStyle === void 0 ? void 0 : geoStylerStyle.rules) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.scaleDenominator) === null || _e === void 0 ? void 0 : _e.min) !== undefined ? true : false;
            var hasMaxScale = ((_h = (_g = (_f = geoStylerStyle === null || geoStylerStyle === void 0 ? void 0 : geoStylerStyle.rules) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.scaleDenominator) === null || _h === void 0 ? void 0 : _h.max) !== undefined ? true : false;
            var hasScaleDenominator = hasMinScale || hasMaxScale ? true : false;
            var hasFunctions = OlStyleUtil_1.default.containsGeoStylerFunctions(geoStylerStyle);
            var nrSymbolizers = geoStylerStyle.rules[0].symbolizers.length;
            var hasTextSymbolizer = rules[0].symbolizers.some(function (symbolizer) {
                return symbolizer.kind === 'Text';
            });
            var hasDynamicIconSymbolizer = rules[0].symbolizers.some(function (symbolizer) {
                return symbolizer.kind === 'Icon' && typeof (symbolizer.image) === 'string' && symbolizer.image.includes('{{');
            });
            if (!hasFilter && !hasScaleDenominator && !hasTextSymbolizer && !hasDynamicIconSymbolizer && !hasFunctions) {
                if (nrSymbolizers === 1) {
                    return this.geoStylerStyleToOlStyle(geoStylerStyle);
                }
                else {
                    return this.geoStylerStyleToOlStyleArray(geoStylerStyle);
                }
            }
            else {
                return this.geoStylerStyleToOlParserStyleFct(geoStylerStyle);
            }
        }
        else {
            return this.geoStylerStyleToOlParserStyleFct(geoStylerStyle);
        }
    };
    /**
     * Parses the first symbolizer of the first rule of a GeoStyler-Style Style.
     *
     * @param geoStylerStyle GeoStyler-Style Style
     * @return An OpenLayers Style Object
     */
    OlStyleParser.prototype.geoStylerStyleToOlStyle = function (geoStylerStyle) {
        var rule = geoStylerStyle.rules[0];
        var symbolizer = rule.symbolizers[0];
        var olSymbolizer = this.getOlSymbolizerFromSymbolizer(symbolizer);
        return olSymbolizer;
    };
    /**
     * Parses all symbolizers of the first rule of a GeoStyler-Style Style.
     *
     * @param geoStylerStyle GeoStyler-Style Style
     * @return An array of OpenLayers Style Objects
     */
    OlStyleParser.prototype.geoStylerStyleToOlStyleArray = function (geoStylerStyle) {
        var _this = this;
        var rule = geoStylerStyle.rules[0];
        var olStyles = [];
        rule.symbolizers.forEach(function (symbolizer) {
            var olSymbolizer = _this.getOlSymbolizerFromSymbolizer(symbolizer);
            olStyles.push(olSymbolizer);
        });
        return olStyles;
    };
    /**
     * Get the OpenLayers Style object from an GeoStyler-Style Style
     *
     * @param geoStylerStyle A GeoStyler-Style Style.
     * @return An OlParserStyleFct
     */
    OlStyleParser.prototype.geoStylerStyleToOlParserStyleFct = function (geoStylerStyle) {
        var _this = this;
        var rules = structuredClone(geoStylerStyle.rules);
        var olStyle = function (feature, resolution) {
            var styles = [];
            // calculate scale for resolution (from ol-util MapUtil)
            var dpi = 25.4 / 0.28;
            var mpu = Units_1.METERS_PER_UNIT.m;
            var inchesPerMeter = 39.37;
            var scale = resolution * mpu * inchesPerMeter * dpi;
            rules.forEach(function (rule) {
                var _a, _b;
                // handling scale denominator
                var minScale = (_a = rule === null || rule === void 0 ? void 0 : rule.scaleDenominator) === null || _a === void 0 ? void 0 : _a.min;
                var maxScale = (_b = rule === null || rule === void 0 ? void 0 : rule.scaleDenominator) === null || _b === void 0 ? void 0 : _b.max;
                var isWithinScale = true;
                if (minScale || maxScale) {
                    minScale = (0, geostyler_style_1.isGeoStylerFunction)(minScale) ? OlStyleUtil_1.default.evaluateNumberFunction(minScale) : minScale;
                    maxScale = (0, geostyler_style_1.isGeoStylerFunction)(maxScale) ? OlStyleUtil_1.default.evaluateNumberFunction(maxScale) : maxScale;
                    if (minScale && scale < minScale) {
                        isWithinScale = false;
                    }
                    if (maxScale && scale >= maxScale) {
                        isWithinScale = false;
                    }
                }
                // handling filter
                var matchesFilter = false;
                if (!rule.filter) {
                    matchesFilter = true;
                }
                else {
                    try {
                        matchesFilter = _this.geoStylerFilterToOlParserFilter(feature, rule.filter);
                    }
                    catch (e) {
                        matchesFilter = false;
                    }
                }
                if (isWithinScale && matchesFilter) {
                    rule.symbolizers.forEach(function (symb) {
                        if (symb.visibility === false) {
                            styles.push(null);
                        }
                        if ((0, geostyler_style_1.isGeoStylerBooleanFunction)(symb.visibility)) {
                            var visibility = OlStyleUtil_1.default.evaluateBooleanFunction(symb.visibility);
                            if (!visibility) {
                                styles.push(null);
                            }
                        }
                        var olSymbolizer = _this.getOlSymbolizerFromSymbolizer(symb, feature);
                        // either an OlStyle or an ol.StyleFunction. OpenLayers only accepts an array
                        // of OlStyles, not ol.StyleFunctions.
                        // So we have to check it and in case of an ol.StyleFunction call that function
                        // and add the returned style to const styles.
                        if (typeof olSymbolizer !== 'function') {
                            styles.push(olSymbolizer);
                        }
                        else {
                            var styleFromFct = olSymbolizer(feature, resolution);
                            styles.push(styleFromFct);
                        }
                    });
                }
            });
            return styles;
        };
        var olStyleFct = olStyle;
        olStyleFct.__geoStylerStyle = geoStylerStyle;
        return olStyleFct;
    };
    /**
     * Checks if a feature matches given filter expression(s)
     * @param feature ol.Feature
     * @param filter Filter
     * @return boolean true if feature matches filter expression
     */
    OlStyleParser.prototype.geoStylerFilterToOlParserFilter = function (feature, filter) {
        var _this = this;
        var operatorMapping = {
            '&&': true,
            '||': true,
            '!': true
        };
        var matchesFilter = true;
        if ((0, geostyler_style_1.isGeoStylerBooleanFunction)(filter)) {
            return OlStyleUtil_1.default.evaluateBooleanFunction(filter, feature);
        }
        if (filter === true || filter === false) {
            return filter;
        }
        var operator = filter[0];
        var isNestedFilter = false;
        if (operatorMapping[operator]) {
            isNestedFilter = true;
        }
        try {
            if (isNestedFilter) {
                switch (filter[0]) {
                    case '&&':
                        var intermediate_1 = true;
                        var restFilter = filter.slice(1);
                        restFilter.forEach(function (f) {
                            if (!_this.geoStylerFilterToOlParserFilter(feature, f)) {
                                intermediate_1 = false;
                            }
                        });
                        matchesFilter = intermediate_1;
                        break;
                    case '||':
                        intermediate_1 = false;
                        restFilter = filter.slice(1);
                        restFilter.forEach(function (f) {
                            if (_this.geoStylerFilterToOlParserFilter(feature, f)) {
                                intermediate_1 = true;
                            }
                        });
                        matchesFilter = intermediate_1;
                        break;
                    case '!':
                        matchesFilter = !this.geoStylerFilterToOlParserFilter(feature, filter[1]);
                        break;
                    default:
                        throw new Error('Cannot parse Filter. Unknown combination or negation operator.');
                }
            }
            else {
                var arg1 = void 0;
                if ((0, geostyler_style_1.isGeoStylerFunction)(filter[1])) {
                    arg1 = OlStyleUtil_1.default.evaluateFunction(filter[1], feature);
                }
                else {
                    arg1 = feature.get(filter[1]);
                }
                var arg2 = void 0;
                if ((0, geostyler_style_1.isGeoStylerFunction)(filter[2])) {
                    arg2 = feature.get(OlStyleUtil_1.default.evaluateFunction(filter[2], feature));
                }
                else {
                    arg2 = filter[2];
                }
                switch (filter[0]) {
                    case '==':
                        matchesFilter = ('' + arg1) === ('' + arg2);
                        break;
                    case '*=':
                        // inspired by
                        // https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill
                        if (typeof arg2 === 'string' && typeof arg1 === 'string') {
                            if (arg2.length > arg1.length) {
                                matchesFilter = false;
                            }
                            else {
                                matchesFilter = arg1.indexOf(arg2) !== -1;
                            }
                        }
                        break;
                    case '!=':
                        matchesFilter = ('' + arg1) !== ('' + arg2);
                        break;
                    case '<':
                        matchesFilter = Number(arg1) < Number(arg2);
                        break;
                    case '<=':
                        matchesFilter = Number(arg1) <= Number(arg2);
                        break;
                    case '>':
                        matchesFilter = Number(arg1) > Number(arg2);
                        break;
                    case '>=':
                        matchesFilter = Number(arg1) >= Number(arg2);
                        break;
                    default:
                        throw new Error('Cannot parse Filter. Unknown comparison operator.');
                }
            }
        }
        catch (e) {
            throw new Error('Cannot parse Filter. Invalid structure.');
        }
        return matchesFilter;
    };
    /**
     * Get the OpenLayers Style object or an OL StyleFunction from an
     * GeoStyler-Style Symbolizer.
     *
     * @param symbolizer A GeoStyler-Style Symbolizer.
     * @return The OpenLayers Style object or a StyleFunction
     */
    OlStyleParser.prototype.getOlSymbolizerFromSymbolizer = function (symbolizer, feature) {
        var olSymbolizer;
        symbolizer = structuredClone(symbolizer);
        switch (symbolizer.kind) {
            case 'Mark':
                olSymbolizer = this.getOlPointSymbolizerFromMarkSymbolizer(symbolizer, feature);
                break;
            case 'Icon':
                olSymbolizer = this.getOlIconSymbolizerFromIconSymbolizer(symbolizer, feature);
                break;
            case 'Text':
                olSymbolizer = this.getOlTextSymbolizerFromTextSymbolizer(symbolizer, feature);
                break;
            case 'Line':
                olSymbolizer = this.getOlLineSymbolizerFromLineSymbolizer(symbolizer, feature);
                break;
            case 'Fill':
                olSymbolizer = this.getOlPolygonSymbolizerFromFillSymbolizer(symbolizer, feature);
                break;
            default:
                // Return the OL default style since the TS type binding does not allow
                // us to set olSymbolizer to undefined
                var fill = new this.OlStyleFillConstructor({
                    color: 'rgba(255,255,255,0.4)'
                });
                var stroke = new this.OlStyleStrokeConstructor({
                    color: '#3399CC',
                    width: 1.25
                });
                olSymbolizer = new this.OlStyleConstructor({
                    image: new this.OlStyleCircleConstructor({
                        fill: fill,
                        stroke: stroke,
                        radius: 5
                    }),
                    fill: fill,
                    stroke: stroke
                });
                break;
        }
        return olSymbolizer;
    };
    /**
     * Get the OL Style object  from an GeoStyler-Style MarkSymbolizer.
     *
     * @param markSymbolizer A GeoStyler-Style MarkSymbolizer.
     * @return The OL Style object
     */
    OlStyleParser.prototype.getOlPointSymbolizerFromMarkSymbolizer = function (markSymbolizer, feature) {
        var stroke;
        for (var _i = 0, _a = Object.keys(markSymbolizer); _i < _a.length; _i++) {
            var key = _a[_i];
            if ((0, geostyler_style_1.isGeoStylerFunction)(markSymbolizer[key])) {
                markSymbolizer[key] = OlStyleUtil_1.default.evaluateFunction(markSymbolizer[key], feature);
            }
        }
        var strokeColor = markSymbolizer.strokeColor;
        var strokeOpacity = markSymbolizer.strokeOpacity;
        var sColor = strokeColor && (strokeOpacity !== undefined)
            ? OlStyleUtil_1.default.getRgbaColor(strokeColor, strokeOpacity)
            : markSymbolizer.strokeColor;
        if (markSymbolizer.strokeColor || markSymbolizer.strokeWidth !== undefined) {
            stroke = new this.OlStyleStrokeConstructor({
                color: sColor,
                width: markSymbolizer.strokeWidth
            });
        }
        var color = markSymbolizer.color;
        var opacity = markSymbolizer.opacity;
        var radius = markSymbolizer.radius;
        var fillOpacity = markSymbolizer.fillOpacity;
        var fColor = color && (fillOpacity !== undefined)
            ? OlStyleUtil_1.default.getRgbaColor(color, fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1)
            : color;
        var fill = new this.OlStyleFillConstructor({
            color: fColor
        });
        var olStyle;
        var shapeOpts = {
            fill: fill,
            radius: radius !== null && radius !== void 0 ? radius : 5,
            rotation: typeof (markSymbolizer.rotate) === 'number' ? markSymbolizer.rotate * Math.PI / 180 : undefined,
            stroke: stroke,
            displacement: typeof (markSymbolizer.offset) === 'number' ? markSymbolizer.offset : undefined
        };
        switch (markSymbolizer.wellKnownName) {
            case 'shape://dot':
            case 'circle':
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleCircleConstructor(shapeOpts)
                });
                break;
            case 'square':
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 4, angle: 45 * Math.PI / 180 }))
                });
                break;
            case 'triangle':
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 3, angle: 0 }))
                });
                break;
            case 'star':
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 5, radius2: shapeOpts.radius / 2.5, angle: 0 }))
                });
                break;
            case 'shape://plus':
            case 'cross':
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 4, radius2: 0, angle: 0 }))
                });
                break;
            case 'shape://times':
            case 'x':
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 4, radius2: 0, angle: 45 * Math.PI / 180 }))
                });
                break;
            case 'shape://backslash':
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 2, angle: 2 * Math.PI - (Math.PI / 4) }))
                });
                break;
            case 'shape://horline':
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 2, angle: Math.PI / 2 }))
                });
                break;
            // so far, both arrows are closed arrows. Also, shape is a regular triangle with
            // all sides of equal length. In geoserver arrows only have two sides of equal length.
            // TODO redefine shapes of arrows?
            case 'shape://oarrow':
            case 'shape://carrow':
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 3, angle: Math.PI / 2 }))
                });
                break;
            case 'shape://slash':
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 2, angle: Math.PI / 4 }))
                });
                break;
            case 'shape://vertline':
                // openlayers does not seem to set a default stroke color,
                // which is needed for regularshapes with radius2 = 0
                if (shapeOpts.stroke === undefined) {
                    shapeOpts.stroke = new this.OlStyleStrokeConstructor({
                        color: '#000'
                    });
                }
                olStyle = new this.OlStyleConstructor({
                    image: new this.OlStyleRegularshapeConstructor(__assign(__assign({}, shapeOpts), { points: 2, angle: 0 }))
                });
                break;
            default:
                if (OlStyleUtil_1.default.getIsFontGlyphBased(markSymbolizer)) {
                    olStyle = new this.OlStyleConstructor({
                        text: new this.OlStyleTextConstructor({
                            text: OlStyleUtil_1.default.getCharacterForMarkSymbolizer(markSymbolizer),
                            font: OlStyleUtil_1.default.getTextFontForMarkSymbolizer(markSymbolizer),
                            fill: shapeOpts.fill,
                            stroke: shapeOpts.stroke,
                            rotation: shapeOpts.rotation
                        })
                    });
                    break;
                }
                throw new Error('MarkSymbolizer cannot be parsed. Unsupported WellKnownName.');
        }
        if (Number.isFinite(opacity) && olStyle.getImage()) {
            olStyle.getImage().setOpacity(opacity);
        }
        return olStyle;
    };
    /**
     * Get the OL Style object  from an GeoStyler-Style IconSymbolizer.
     *
     * @param symbolizer  A GeoStyler-Style IconSymbolizer.
     * @return The OL Style object
     */
    OlStyleParser.prototype.getOlIconSymbolizerFromIconSymbolizer = function (symbolizer, feat) {
        var _this = this;
        for (var _i = 0, _a = Object.keys(symbolizer); _i < _a.length; _i++) {
            var key = _a[_i];
            if ((0, geostyler_style_1.isGeoStylerFunction)(symbolizer[key])) {
                symbolizer[key] = OlStyleUtil_1.default.evaluateFunction(symbolizer[key], feat);
            }
        }
        var baseProps = {
            src: (0, geostyler_style_1.isSprite)(symbolizer.image) ? symbolizer.image.source : symbolizer.image,
            crossOrigin: 'anonymous',
            opacity: symbolizer.opacity,
            width: symbolizer.size,
            // Rotation in openlayers is radians while we use degree
            rotation: (typeof (symbolizer.rotate) === 'number' ? symbolizer.rotate * Math.PI / 180 : undefined),
            displacement: symbolizer.offset,
            size: (0, geostyler_style_1.isSprite)(symbolizer.image) ? symbolizer.image.size : undefined,
            offset: (0, geostyler_style_1.isSprite)(symbolizer.image) ? symbolizer.image.position : undefined,
        };
        // check if IconSymbolizer.image contains a placeholder
        var prefix = '\\{\\{';
        var suffix = '\\}\\}';
        var regExp = new RegExp(prefix + '.*?' + suffix, 'g');
        var regExpRes = typeof (symbolizer.image) === 'string' ? symbolizer.image.match(regExp) : null;
        if (regExpRes) {
            // if it contains a placeholder
            // return olStyleFunction
            var olPointStyledIconFn = function (feature) {
                var src = OlStyleUtil_1.default.resolveAttributeTemplate(feature, symbolizer.image, '');
                // src can't be blank, would trigger ol errors
                if (!src) {
                    src = symbolizer.image + '';
                }
                var image;
                if (_this.olIconStyleCache[src]) {
                    image = _this.olIconStyleCache[src];
                    if (baseProps.rotation !== undefined) {
                        image.setRotation(baseProps.rotation);
                    }
                    if (baseProps.opacity !== undefined) {
                        image.setOpacity(baseProps.opacity);
                    }
                }
                else {
                    image = new _this.OlStyleIconConstructor(__assign(__assign({}, baseProps), { src: src // order is important
                     }));
                    _this.olIconStyleCache[src] = image;
                }
                var style = new _this.OlStyleConstructor({
                    image: image
                });
                return style;
            };
            return olPointStyledIconFn;
        }
        else {
            return new this.OlStyleConstructor({
                image: new this.OlStyleIconConstructor(__assign({}, baseProps))
            });
        }
    };
    /**
     * Get the OL Style object from an GeoStyler-Style LineSymbolizer.
     *
     * @param symbolizer A GeoStyler-Style LineSymbolizer.
     * @return The OL Style object
     */
    OlStyleParser.prototype.getOlLineSymbolizerFromLineSymbolizer = function (symbolizer, feat) {
        for (var _i = 0, _a = Object.keys(symbolizer); _i < _a.length; _i++) {
            var key = _a[_i];
            if ((0, geostyler_style_1.isGeoStylerFunction)(symbolizer[key])) {
                symbolizer[key] = OlStyleUtil_1.default.evaluateFunction(symbolizer[key], feat);
            }
        }
        var color = symbolizer.color;
        var opacity = symbolizer.opacity;
        var sColor = (color && opacity !== null && opacity !== undefined) ?
            OlStyleUtil_1.default.getRgbaColor(color, opacity) : color;
        return new this.OlStyleConstructor({
            stroke: new this.OlStyleStrokeConstructor({
                color: sColor,
                width: symbolizer.width,
                lineCap: symbolizer.cap,
                lineJoin: symbolizer.join,
                lineDash: symbolizer.dasharray,
                lineDashOffset: symbolizer.dashOffset
            })
        });
    };
    /**
     * Get the OL Style object from an GeoStyler-Style FillSymbolizer.
     *
     * @param symbolizer A GeoStyler-Style FillSymbolizer.
     * @return The OL Style object
     */
    OlStyleParser.prototype.getOlPolygonSymbolizerFromFillSymbolizer = function (symbolizer, feat) {
        for (var _i = 0, _a = Object.keys(symbolizer); _i < _a.length; _i++) {
            var key = _a[_i];
            if ((0, geostyler_style_1.isGeoStylerFunction)(symbolizer[key])) {
                symbolizer[key] = OlStyleUtil_1.default.evaluateFunction(symbolizer[key], feat);
            }
        }
        var color = symbolizer.color;
        var opacity = symbolizer.fillOpacity;
        var fColor = color && Number.isFinite(opacity)
            ? OlStyleUtil_1.default.getRgbaColor(color, opacity)
            : color;
        var fill = color
            ? new this.OlStyleFillConstructor({ color: fColor })
            : undefined;
        var outlineColor = symbolizer.outlineColor;
        var outlineOpacity = symbolizer.outlineOpacity;
        var oColor = (outlineColor && Number.isFinite(outlineOpacity))
            ? OlStyleUtil_1.default.getRgbaColor(outlineColor, outlineOpacity)
            : outlineColor;
        var stroke = outlineColor || symbolizer.outlineWidth ? new this.OlStyleStrokeConstructor({
            color: oColor,
            width: symbolizer.outlineWidth,
            lineDash: symbolizer.outlineDasharray,
        }) : undefined;
        var olStyle = new this.OlStyleConstructor({
            fill: fill,
            stroke: stroke
        });
        if (symbolizer.graphicFill) {
            var pattern = this.getOlPatternFromGraphicFill(symbolizer.graphicFill);
            if (!fill) {
                fill = new this.OlStyleFillConstructor({});
            }
            if (pattern) {
                fill.setColor(pattern);
            }
            olStyle.setFill(fill);
        }
        return olStyle;
    };
    /**
     * Get the pattern for a graphicFill.
     *
     * This creates a CanvasPattern based on the
     * properties of the given PointSymbolizer. Currently,
     * only IconSymbolizer and MarkSymbolizer are supported.
     *
     * @param graphicFill The Symbolizer that holds the pattern config.
     * @returns The created CanvasPattern, or null.
     */
    OlStyleParser.prototype.getOlPatternFromGraphicFill = function (graphicFill) {
        var graphicFillStyle;
        if ((0, geostyler_style_1.isIconSymbolizer)(graphicFill)) {
            graphicFillStyle = this.getOlIconSymbolizerFromIconSymbolizer(graphicFill);
            var graphicFillImage = graphicFillStyle === null || graphicFillStyle === void 0 ? void 0 : graphicFillStyle.getImage();
            graphicFillImage === null || graphicFillImage === void 0 ? void 0 : graphicFillImage.load(); // Needed for Icon type images with a remote src
            // We can only work with the image once it's loaded
            if ((graphicFillImage === null || graphicFillImage === void 0 ? void 0 : graphicFillImage.getImageState()) !== ImageState_1.default.LOADED) {
                return null;
            }
        }
        else if ((0, geostyler_style_1.isMarkSymbolizer)(graphicFill)) {
            graphicFillStyle = this.getOlPointSymbolizerFromMarkSymbolizer(graphicFill);
        }
        else {
            return null;
        }
        // We need to clone the style and image since we'll be changing the scale below (hack)
        var graphicFillStyleCloned = graphicFillStyle.clone();
        var imageCloned = graphicFillStyleCloned.getImage();
        // Temporary canvas.
        // TODO: Can/should we reuse an pre-existing one for efficiency?
        var tmpCanvas = document.createElement('canvas');
        var tmpContext = tmpCanvas.getContext('2d');
        // Hack to make scaling work for Icons.
        // TODO: find a better way than this.
        var scale = imageCloned.getScale() || 1;
        var pixelRatio = scale;
        imageCloned.setScale(1);
        var size = imageCloned.getSize();
        // Create the context where we'll be drawing the style on
        var vectorContext = (0, render_1.toContext)(tmpContext, {
            pixelRatio: pixelRatio,
            size: size
        });
        // Draw the graphic
        vectorContext.setStyle(graphicFillStyleCloned);
        var pointCoords = size.map(function (item) { return item / 2; });
        vectorContext.drawGeometry(new Point_1.default(pointCoords));
        // Create the actual pattern and return style
        return tmpContext.createPattern(tmpCanvas, 'repeat');
    };
    /**
     * Get the OL StyleFunction object from an GeoStyler-Style TextSymbolizer.
     *
     * @param {TextSymbolizer} textSymbolizer A GeoStyler-Style TextSymbolizer.
     * @return {object} The OL StyleFunction
     */
    OlStyleParser.prototype.getOlTextSymbolizerFromTextSymbolizer = function (symbolizer, feat) {
        var _this = this;
        for (var _i = 0, _a = Object.keys(symbolizer); _i < _a.length; _i++) {
            var key = _a[_i];
            if ((0, geostyler_style_1.isGeoStylerFunction)(symbolizer[key])) {
                symbolizer[key] = OlStyleUtil_1.default.evaluateFunction(symbolizer[key], feat);
            }
        }
        var color = symbolizer.color;
        var placement = symbolizer.placement;
        if (!placement) {
            // When setting placement it must not be undefined.
            // So we set it to the OL default value.
            placement = 'point';
        }
        if (placement === 'line-center') {
            // line-center not supported by OL.
            // So we use the closest supported value.
            placement = 'line';
        }
        var opacity = symbolizer.opacity;
        var fColor = color && Number.isFinite(opacity)
            ? OlStyleUtil_1.default.getRgbaColor(color, opacity)
            : color;
        var haloColor = symbolizer.haloColor;
        var haloWidth = symbolizer.haloWidth;
        var sColor = haloColor && Number.isFinite(opacity)
            ? OlStyleUtil_1.default.getRgbaColor(haloColor, opacity)
            : haloColor;
        var baseProps = {
            font: OlStyleUtil_1.default.getTextFont(symbolizer),
            fill: new this.OlStyleFillConstructor({
                color: fColor
            }),
            stroke: new this.OlStyleStrokeConstructor({
                color: sColor,
                width: haloWidth ? haloWidth : 0
            }),
            overflow: symbolizer.allowOverlap,
            offsetX: (symbolizer.offset ? symbolizer.offset[0] : 0),
            offsetY: (symbolizer.offset ? symbolizer.offset[1] : 0),
            rotation: typeof (symbolizer.rotate) === 'number' ? symbolizer.rotate * Math.PI / 180 : undefined,
            placement: placement
            // TODO check why props match
            // textAlign: symbolizer.pitchAlignment,
            // textBaseline: symbolizer.anchor
        };
        // check if TextSymbolizer.label contains a placeholder
        var prefix = '\\{\\{';
        var suffix = '\\}\\}';
        var regExp = new RegExp(prefix + '.*?' + suffix, 'g');
        var regExpRes;
        if (!(0, geostyler_style_1.isGeoStylerStringFunction)(symbolizer.label)) {
            regExpRes = symbolizer.label ? symbolizer.label.match(regExp) : null;
        }
        if (regExpRes) {
            // if it contains a placeholder
            // return olStyleFunction
            var olPointStyledLabelFn = function (feature) {
                var text = new _this.OlStyleTextConstructor(__assign({ text: OlStyleUtil_1.default.resolveAttributeTemplate(feature, symbolizer.label, '') }, baseProps));
                var style = new _this.OlStyleConstructor({
                    text: text
                });
                return style;
            };
            return olPointStyledLabelFn;
        }
        else {
            // if TextSymbolizer does not contain a placeholder
            // return OlStyle
            return new this.OlStyleConstructor({
                text: new this.OlStyleTextConstructor(__assign({ text: symbolizer.label }, baseProps))
            });
        }
    };
    /**
     * The name of the OlStyleParser.
     */
    OlStyleParser.title = 'OpenLayers Style Parser';
    return OlStyleParser;
}());
exports.OlStyleParser = OlStyleParser;
exports.default = OlStyleParser;
//# sourceMappingURL=OlStyleParser.js.map