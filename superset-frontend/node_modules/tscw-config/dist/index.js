"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("./lib/util");
function main(strings, ...values) {
    return __awaiter(this, void 0, void 0, function* () {
        const args = (0, util_1.getArgArray)(strings, ...values);
        const rootDirForCurrentWorkSpace = (0, util_1.getRootDirForCurrentWorkSpace)();
        if (!rootDirForCurrentWorkSpace) {
            return {
                pid: null,
                exitCode: 1,
                stderr: "Error: Missing package.json file.\nPlease ensure that your project directory " +
                    "contains a package.json file to manage dependencies and configurations.",
                stdout: null,
            };
        }
        const isPnp = (0, util_1.fileExists)(path_1.default.join(rootDirForCurrentWorkSpace, ".pnp.cjs")) || !!process.versions.pnp;
        const { indexOfProjectFlag, remainingCliOptions, files, error, declarationFiles } = (0, util_1.processArgs)(args);
        if (error) {
            return error;
        }
        if (files.length === 0) {
            const newArgs = ["--pretty", ...remainingCliOptions];
            if (indexOfProjectFlag !== -1) {
                newArgs.push("-p", args[indexOfProjectFlag + 1]);
            }
            return yield (0, util_1.runTsc)(newArgs, rootDirForCurrentWorkSpace, isPnp);
        }
        const tsconfig = indexOfProjectFlag === -1
            ? (0, util_1.getNearestTsconfig)(rootDirForCurrentWorkSpace)
            : path_1.default.relative(process.cwd(), args[indexOfProjectFlag + 1]);
        if (tsconfig && (0, util_1.fileExists)(process.cwd(), tsconfig)) {
            const tmpTsconfig = path_1.default.relative(process.cwd(), path_1.default.join(path_1.default.dirname(tsconfig), `tmp-tsconfig-${Math.random().toString(36).slice(2)}.json`));
            // Attach cleanup handlers
            (0, util_1.registerCleanup)(process, tmpTsconfig);
            const rawData = fs_1.default.readFileSync(tsconfig, "utf-8");
            const relativeFiles = files.concat(declarationFiles).map(file => 
            // allow user to run the binary regardless of the current working directory
            path_1.default.relative(path_1.default.dirname(tmpTsconfig), file));
            const jsonData = yield (0, util_1.processJsonData)(rawData, relativeFiles);
            // https://nodejs.org/api/process.html#signal-events
            // On Windows, when a process is terminated by `process.kill` or `subProcess.kill`, signal will not be caught.
            if (process.platform === "win32") {
                // Create a daemon by double-forking.
                const intermediate = (0, child_process_1.spawn)(process.argv[0], [
                    path_1.default.relative(process.cwd(), path_1.default.join(__dirname, "../dist/intermediate.js")),
                    process.pid.toString(),
                    tmpTsconfig,
                ], {
                    detached: true,
                    stdio: "ignore",
                });
                intermediate.unref();
            }
            fs_1.default.writeFileSync(tmpTsconfig, JSON.stringify(jsonData, null, 2));
            const child = yield (0, util_1.runTsc)(["--pretty", "-p", tmpTsconfig, ...remainingCliOptions], rootDirForCurrentWorkSpace, isPnp);
            if ((0, util_1.fileExists)(tmpTsconfig)) {
                fs_1.default.unlinkSync(tmpTsconfig);
            }
            return child;
        }
        return {
            pid: null,
            exitCode: 1,
            stderr: tsconfig
                ? `Can't find ${args[indexOfProjectFlag + 1]}`
                : "Can't find tsconfig.json from the current working directory or level(s) up.",
            stdout: null,
        };
    });
}
module.exports = main;
//# sourceMappingURL=index.js.map