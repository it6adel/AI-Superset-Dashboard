"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCleanup = exports.getArgArray = exports.isTemplateStringsArray = exports.templateLiteralToArray = exports.isRunning = exports.processJsonData = exports.runTsc = exports.getNearestTsconfig = exports.processArgs = exports.getFilesRecursivelySync = exports.getRootDirForCurrentWorkSpace = exports.fileExists = void 0;
const node_child_process_1 = require("node:child_process");
const node_fs_1 = __importStar(require("node:fs"));
const node_path_1 = __importStar(require("node:path"));
const fileExists = (...paths) => node_fs_1.default.existsSync(node_path_1.default.join(...paths));
exports.fileExists = fileExists;
const getRootDirForCurrentWorkSpace = () => {
    let dir = process.cwd();
    while (dir !== node_path_1.default.parse(dir).root) {
        if ((0, exports.fileExists)(dir, "package.json")) {
            return dir;
        }
        dir = node_path_1.default.dirname(dir);
    }
    return null;
};
exports.getRootDirForCurrentWorkSpace = getRootDirForCurrentWorkSpace;
const getFilesRecursivelySync = (dir, regex) => {
    const files = (0, node_fs_1.readdirSync)(dir, { withFileTypes: true });
    let result = [];
    for (const file of files) {
        const fullPath = (0, node_path_1.join)(dir, file.name);
        if (file.isDirectory()) {
            result = result.concat((0, exports.getFilesRecursivelySync)(fullPath, regex));
        }
        else if (regex.test(file.name)) {
            result.push(fullPath);
        }
    }
    return result;
};
exports.getFilesRecursivelySync = getFilesRecursivelySync;
const processArgs = (args) => {
    let indexOfProjectFlag = -1;
    const remainingCliOptions = [];
    const files = [];
    let declarationFiles = [];
    let skipNext = false;
    for (const [idx, arg] of args.entries()) {
        if (skipNext) {
            skipNext = false;
            continue;
        }
        if (arg.toLowerCase() === "-p" || arg.toLowerCase() === "--project") {
            indexOfProjectFlag = idx;
            const tsconfigArg = args[idx + 1];
            if (!tsconfigArg) {
                return {
                    error: {
                        pid: null,
                        exitCode: 1,
                        stderr: `Missing argument for ${arg}`,
                        stdout: null,
                    },
                };
            }
            skipNext = true;
        }
        else if (arg.toLowerCase() === "--includedeclarationdir") {
            const declarationDir = args[idx + 1];
            if (!declarationDir) {
                return {
                    error: {
                        pid: null,
                        exitCode: 1,
                        stderr: `Missing argument for ${arg}`,
                        stdout: null,
                    },
                };
            }
            try {
                declarationFiles = (0, exports.getFilesRecursivelySync)(declarationDir, /\.d\.ts$/);
            }
            catch (_) {
                return {
                    error: {
                        pid: null,
                        exitCode: 1,
                        // stderr: e instanceof Error ? e.message : `Invalid argument for ${arg}`,
                        stderr: `Invalid argument for ${arg}`,
                        stdout: null,
                    },
                };
            }
            skipNext = true;
        }
        else if (arg.toLowerCase() === "--excludefiles") {
            remainingCliOptions.push(arg);
            const excludeFilesArg = args[idx + 1];
            if (!excludeFilesArg) {
                return {
                    error: {
                        pid: null,
                        exitCode: 1,
                        stderr: `Missing argument for ${arg}`,
                        stdout: null,
                    },
                };
            }
            remainingCliOptions.push(args[idx + 1]);
            skipNext = true;
        }
        else if (/^-.*/.test(arg)) {
            remainingCliOptions.push(arg);
        }
        else if (/\.(m|c)?(t|j)sx?$/.test(arg)) {
            files.push(arg);
        }
        else {
            remainingCliOptions.push(arg);
        }
    }
    return { indexOfProjectFlag, remainingCliOptions, files, error: null, declarationFiles };
};
exports.processArgs = processArgs;
const getNearestTsconfig = (rootDirForCurrentWorkSpace) => {
    let dir = process.cwd();
    while (dir !== rootDirForCurrentWorkSpace) {
        if ((0, exports.fileExists)(dir, "tsconfig.json")) {
            return node_path_1.default.relative(process.cwd(), node_path_1.default.join(dir, "tsconfig.json"));
        }
        dir = node_path_1.default.dirname(dir);
    }
    // Check again when dir === rootDirForCurrentWorkSpace
    if ((0, exports.fileExists)(dir, "tsconfig.json")) {
        return node_path_1.default.relative(process.cwd(), node_path_1.default.join(dir, "tsconfig.json"));
    }
    return null;
};
exports.getNearestTsconfig = getNearestTsconfig;
const runTsc = (args, rootDirForCurrentWorkSpace, isPnp) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((res, rej) => {
        const child = isPnp
            ? (0, node_child_process_1.spawn)(`yarn tsc ${args.join(" ")}`, {
                stdio: "pipe",
                shell: true,
            })
            : (0, node_child_process_1.spawn)(node_path_1.default.join(rootDirForCurrentWorkSpace, `/node_modules/.bin/tsc${
            // Windows is case-insensitive about file extension.
            process.platform === "win32" ? ".cmd" : ""}`), args, 
            // https://nodejs.org/en/blog/vulnerability/april-2024-security-releases-2#command-injection-via-args-parameter-of-child_processspawn-without-shell-option-enabled-on-windows-cve-2024-27980---high
            { stdio: "pipe", shell: process.platform === "win32" ? true : false });
        let stdout = "";
        let stderr = "";
        child.stdout.on("data", (data) => {
            stdout += data.toString();
        });
        child.stderr.on("data", (data) => {
            stderr += data.toString();
        });
        child.on("exit", exitCode => {
            res({
                pid: child.pid,
                exitCode: exitCode,
                stdout,
                stderr,
            });
        });
        child.on("error", e => {
            rej(e);
        });
    });
});
exports.runTsc = runTsc;
const processJsonData = (rawData, files) => __awaiter(void 0, void 0, void 0, function* () {
    const stripJsonComments = (yield import("strip-json-comments")).default;
    // Remove tailing comma
    const cleanedData = rawData.replace(/,\s*([}\]])/g, "$1");
    const jsonData = JSON.parse(stripJsonComments(cleanedData));
    // Overwrite "files" field
    jsonData.files = files;
    // Remove "include" field
    delete jsonData.include;
    return jsonData;
});
exports.processJsonData = processJsonData;
const isRunning = (pid) => {
    try {
        process.kill(pid, 0);
        return true;
    }
    catch (e) {
        if (e instanceof Error && "code" in e) {
            return e.code === "EPERM";
        }
        return false;
    }
};
exports.isRunning = isRunning;
const templateLiteralToArray = (strings, ...values) => {
    const str = strings.reduce((acc, curr, i) => acc +
        curr +
        (typeof values[i] === "string" || (typeof values[i] === "number" && !isNaN(values[i])) ? values[i] : ""), "");
    const arr = str.split(" ").filter(e => e !== "");
    return arr;
};
exports.templateLiteralToArray = templateLiteralToArray;
const isTemplateStringsArray = (arr) => {
    return Array.isArray(arr) && "raw" in arr;
};
exports.isTemplateStringsArray = isTemplateStringsArray;
const getArgArray = (arr, ...args) => (0, exports.isTemplateStringsArray)(arr) ? (0, exports.templateLiteralToArray)(arr, ...args) : arr;
exports.getArgArray = getArgArray;
const registerCleanup = (process, tmpTsconfig) => {
    for (const signal of ["exit", "SIGHUP", "SIGINT", "SIGTERM"]) {
        process.on(signal, () => {
            if ((0, exports.fileExists)(tmpTsconfig)) {
                node_fs_1.default.unlinkSync(tmpTsconfig);
            }
            if (signal !== "exit") {
                let exitCode;
                switch (signal) {
                    case "SIGHUP":
                        exitCode = 129;
                        break;
                    case "SIGINT":
                        exitCode = 130;
                        break;
                    case "SIGTERM":
                        exitCode = 143;
                        break;
                }
                console.log(`received signal: ${signal}`);
                process.exit(exitCode);
            }
        });
    }
};
exports.registerCleanup = registerCleanup;
//# sourceMappingURL=util.js.map