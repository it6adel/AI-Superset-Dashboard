'use strict';

const API_VERSIONS = {
  v4: 'v4',
  v5: 'v5',
  v5_2: 'v5_2',
  v6_4: 'v6_4',
  v8: 'v8',
};

function getClientAPI() {
  const frameWindow = getFrameWindow();
  const clientAPI = frameWindow.__STORYBOOK_CLIENT_API__;
  const addons = frameWindow.__STORYBOOK_ADDONS || frameWindow.__STORYBOOK_ADDONS_PREVIEW;

  return getAPI(getStorybookVersion());

  function getStorybookVersion() {
    const addonsForV4 = frameWindow.__STORYBOOK_ADDONS;

    if (!clientAPI && frameWindow.__STORYBOOK_PREVIEW__) {
      return API_VERSIONS.v8;
    } else if (frameWindow.__STORYBOOK_PREVIEW__) {
      return API_VERSIONS.v6_4;
    } else if (frameWindow.__STORYBOOK_STORY_STORE__) {
      return API_VERSIONS.v5_2;
    } else if (frameWindow.__STORYBOOK_CLIENT_API__ && frameWindow.__STORYBOOK_CLIENT_API__.raw) {
      return API_VERSIONS.v5;
    } else if (
      addonsForV4 &&
      addonsForV4.channel &&
      addonsForV4.channel._listeners &&
      addonsForV4.channel._listeners.setCurrentStory &&
      addonsForV4.channel._listeners.setCurrentStory[0]
    ) {
      return API_VERSIONS.v4;
    } else {
      throw new Error("Cannot get client API: couldn't detect storybook version");
    }
  }
  function onStoryRendered(callback) {
    const channel = addons?.getChannel?.();
    if (channel) {
      channel.once('storyRendered', () => {
        setTimeout(callback, 0);
      });
      channel.once('playFunctionThrewException', () => {
        setTimeout(callback, 0);
      });
      channel.once('storyErrored', () => {
        setTimeout(callback, 0);
      });
      channel.once('storyThrewException', () => {
        setTimeout(callback, 0);
      });
    } else {
      callback();
    }
  }
  function getAPI(version) {
    if (version) {
      let api;
      switch (version) {
        case API_VERSIONS.v4: {
          api = {
            getStories: () => {
              if (!frameWindow.__APPLITOOLS_STORIES) {
                frameWindow.__APPLITOOLS_STORIES = Object.values(clientAPI._storyStore._data)
                  .map(({stories, kind}) => Object.values(stories).map(s => ({...s, kind})))
                  .flat();
              }
              return frameWindow.__APPLITOOLS_STORIES;
            },
            selectStory: i => {
              const {kind, name: story} = api.getStories()[i];
              addons.channel._listeners.setCurrentStory[0]({kind, story});
            },
            onStoryRendered,
          };
          break;
        }

        case API_VERSIONS.v5: {
          api = {
            getStories: () => {
              return clientAPI.raw();
            },
            selectStory: i => {
              clientAPI._storyStore.setSelection(clientAPI.raw()[i]);
            },
            onStoryRendered,
          };
          break;
        }

        case API_VERSIONS.v5_2: {
          api = {
            getStories: () => {
              return clientAPI.raw();
            },
            selectStory: i => {
              frameWindow.__STORYBOOK_STORY_STORE__.setSelection({storyId: clientAPI.raw()[i].id});
            },
            onStoryRendered,
          };
          break;
        }

        case API_VERSIONS.v6_4: {
          api = {
            getStories: async () => {
              if (clientAPI.storyStore.cacheAllCSFFiles) {
                await clientAPI.storyStore.cacheAllCSFFiles();
              }
              return clientAPI.raw();
            },
            selectStory: async (i, id) => {
              let storyId = !clientAPI.storyStore.cacheAllCSFFiles ? clientAPI.raw()[i].id : id;
              if (!storyId) {
                await clientAPI.storyStore.cacheAllCSFFiles();
                storyId = clientAPI.raw()[i].id;
              }
              if (frameWindow.__STORYBOOK_PREVIEW__.urlStore) {
                frameWindow.__STORYBOOK_PREVIEW__.urlStore.setSelection({
                  storyId,
                });
              } else {
                // storybook v7
                await clientAPI.storyStore.initializationPromise;
                frameWindow.__STORYBOOK_PREVIEW__.selectionStore.setSelection({storyId});
              }
              await frameWindow.__STORYBOOK_PREVIEW__.renderSelection();
            },
            onStoryRendered,
          };
          break;
        }

        case API_VERSIONS.v8: {
          api = {
            getStories: async () => {
              await frameWindow.__STORYBOOK_PREVIEW__.ready();
              return Object.values(await frameWindow.__STORYBOOK_PREVIEW__.extract());
            },
            selectStory: async (_i, id) => {
              await frameWindow.__STORYBOOK_PREVIEW__.ready();
              frameWindow.__STORYBOOK_ADDONS_PREVIEW.channel.emit('setCurrentStory', {storyId: id});
            },
            onStoryRendered,
          };
        }
      }

      return {version, ...api};
    }
  }
}

function getFrameWindow() {
  if (/iframe.html/.test(window.location.href)) {
    return window;
  }

  const innerFrameWindow = Array.prototype.find.call(window.frames, frame => {
    try {
      return /\/iframe.html/.test(frame.location.href);
    } catch (e) {}
  });

  if (innerFrameWindow) {
    return innerFrameWindow;
  }

  if (window.__STORYBOOK_CLIENT_API__) {
    return window;
  }

  throw new Error('Cannot get client API: no frameWindow');
}

async function getClientAPIWithRetries() {
  let error = 'Unknown error';
  for (let attempt = 1; attempt <= 100; attempt++) {
    await new Promise(resolve => setTimeout(resolve, 100));
    try {
      return getClientAPI();
    } catch (e) {
      error = e;
    }
  }
  throw error;
}

module.exports = getClientAPIWithRetries;
