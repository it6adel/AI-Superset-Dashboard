'use strict';

var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var _createForOfIteratorHelperLoose = require('@babel/runtime/helpers/createForOfIteratorHelperLoose');
var prettify = require('@emotion/css-prettifier');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var prettify__default = /*#__PURE__*/_interopDefault(prettify);

function defaultClassNameReplacer(className, index) {
  return "emotion-" + index;
}

var componentSelectorClassNamePattern = /^e[a-zA-Z0-9]+[0-9]+$/;
var replaceClassNames = function replaceClassNames(classNames
/*: Array<string> */
, styles
/*: string */
, code
/*: string */
, keys
/*: Array<string> */
, classNameReplacer
/*: (
className: string,
index: number
) => string */
) {
  if (classNameReplacer
  /*: (
  className: string,
  index: number
  ) => string */
  === void 0) {
    classNameReplacer
    /*: (
    className: string,
    index: number
    ) => string */
    = defaultClassNameReplacer;
  }

  var index = 0;
  var keyPattern = new RegExp("^(" + keys.join('|') + ")-");
  return classNames.reduce(function (acc, className) {
    if (keyPattern.test(className) || componentSelectorClassNamePattern.test(className)) {
      var escapedRegex = new RegExp(className.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'), 'g');
      return acc.replace(escapedRegex, classNameReplacer(className, index++));
    }

    return acc;
  }, "" + styles + (styles ? '\n\n' : '') + code);
};

var insertedRules = new WeakMap();

if (typeof CSSStyleSheet !== 'undefined') {
  var insertRule = CSSStyleSheet.prototype.insertRule;

  CSSStyleSheet.prototype.insertRule = function () {
    var sheetRules = insertedRules.get(this);

    if (!sheetRules) {
      sheetRules = [];
      insertedRules.set(this, sheetRules);
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var rule = args[0];
    sheetRules.push(rule);
    return insertRule.apply(this, args);
  };
}

var isBrowser = typeof document !== 'undefined';

function last(arr) {
  return arr.length > 0 ? arr[arr.length - 1] : undefined;
}

function flatMap
/* <T, S> */
(arr
/*: T[] */
, iteratee
/*: (arg: T) => S[] | S */
)
/*: S[] */
{
  var _ref;

  return (_ref = []).concat.apply(_ref, arr.map(iteratee));
}
function findLast
/* <T> */
(arr
/*: T[] */
, predicate
/*: T => boolean */
) {
  for (var i = arr.length - 1; i >= 0; i--) {
    if (predicate(arr[i])) {
      return arr[i];
    }
  }
}
function findIndexFrom
/* <T> */
(arr
/*: T[] */
, fromIndex
/*: number */
, predicate
/*: T => boolean */
) {
  for (var i = fromIndex; i < arr.length; i++) {
    if (predicate(arr[i])) {
      return i;
    }
  }

  return -1;
}

function getClassNames(selectors, classes
/* ?: string */
) {
  return classes ? selectors.concat(classes.split(' ')) : selectors;
}

function getClassNamesFromTestRenderer(selectors, _ref2) {
  var _ref2$props = _ref2.props,
      props = _ref2$props === void 0 ? {} : _ref2$props;
  return getClassNames(selectors, props.className || props["class"]);
}

function shouldDive(node) {
  return typeof node.dive === 'function' && typeof node.type() !== 'string';
}

function isTagWithClassName(node) {
  return node.prop('className') && typeof node.type() === 'string';
}

function findNodeWithClassName(node) {
  // Find the first node with a className prop
  var found = node.findWhere(isTagWithClassName);
  return found.length ? found.first() : null;
}

function getClassNameProp(node) {
  return node && node.prop('className') || '';
}

function unwrapFromPotentialFragment(node) {
  if (node.type() === Symbol["for"]('react.fragment')) {
    var isShallow = !!node.dive;

    if (isShallow) {
      // render the `<Insertion/>` so it has a chance to insert rules in the JSDOM
      node.children().first().dive();
    }

    return node.children().last();
  }

  return node;
}

function getClassNamesFromEnzyme(selectors, nodeWithPotentialFragment) {
  var node = unwrapFromPotentialFragment(nodeWithPotentialFragment); // We need to dive in to get the className if we have a styled element from a shallow render

  var isShallow = shouldDive(node);
  var nodeWithClassName = findNodeWithClassName(isShallow ? node.dive() : node);
  return getClassNames(selectors, getClassNameProp(nodeWithClassName));
}

function getClassNamesFromCheerio(selectors, node) {
  var classes = node.attr('class');
  return getClassNames(selectors, classes);
}

function getClassNamesFromDOMElement(selectors, node) {
  return getClassNames(selectors, node.getAttribute('class'));
}

function isReactElement(val)
/*: boolean */
{
  return val.$$typeof === Symbol["for"]('react.test.json') || val.$$typeof === Symbol["for"]('react.element');
}
function isEmotionCssPropElementType(val)
/*: boolean */
{
  return val.$$typeof === Symbol["for"]('react.element') && val.type.displayName === 'EmotionCssPropInternal';
}
function isStyledElementType(val
/* : any */
)
/* : boolean */
{
  if (val.$$typeof !== Symbol["for"]('react.element')) {
    return false;
  }

  var type = val.type;
  return type.__emotion_real === type;
}
function isEmotionCssPropEnzymeElement(val
/* : any */
)
/*: boolean */
{
  return val.$$typeof === Symbol["for"]('react.test.json') && val.type === 'EmotionCssPropInternal';
}
var domElementPattern = /^((HTML|SVG)\w*)?Element$/;
function isDOMElement(val)
/*: boolean */
{
  return val.nodeType === 1 && val.constructor && val.constructor.name && domElementPattern.test(val.constructor.name);
}

function isEnzymeElement(val)
/*: boolean */
{
  return typeof val.findWhere === 'function';
}

function isCheerioElement(val)
/*: boolean */
{
  return val.cheerio === '[cheerio object]';
}

function getClassNamesFromNodes(nodes
/*: Array<any> */
) {
  return nodes.reduce(function (selectors, node) {
    if (isEnzymeElement(node)) {
      return getClassNamesFromEnzyme(selectors, node);
    } else if (isCheerioElement(node)) {
      return getClassNamesFromCheerio(selectors, node);
    } else if (isReactElement(node)) {
      return getClassNamesFromTestRenderer(selectors, node);
    }

    return getClassNamesFromDOMElement(selectors, node);
  }, []);
}
var keyframesPattern = /^@keyframes\s+(animation-[^{\s]+)+/;
var removeCommentPattern = /\/\*[\s\S]*?\*\//g;

var getElementRules = function
  /*: string[] */
getElementRules(element
/*: HTMLStyleElement */
) {
  var nonSpeedyRule = element.textContent;

  if (nonSpeedyRule) {
    return [nonSpeedyRule];
  }

  if (!element.sheet) {
    return [];
  }

  var rules = insertedRules.get(element.sheet);

  if (rules) {
    return rules;
  }

  return [].slice.call(element.sheet.cssRules).map(function (cssRule) {
    return cssRule.cssText;
  });
};

var getKeyframesMap = function getKeyframesMap(rules) {
  return rules.reduce(function (keyframes, rule) {
    var match = rule.match(keyframesPattern);

    if (match !== null) {
      var name = match[1];

      if (keyframes[name] === undefined) {
        keyframes[name] = '';
      }

      keyframes[name] += rule;
    }

    return keyframes;
  }, {});
};

function getStylesFromClassNames(classNames
/*: Array<string> */
, elements
/*: Array<HTMLStyleElement> */
)
/*: string */
{
  if (!classNames.length) {
    return '';
  }

  var keys = getKeys(elements);

  if (!keys.length) {
    return '';
  }

  var targetClassName = classNames.find(function (className) {
    return /^e[a-z0-9]+$/.test(className);
  });
  var keyPattern = "(" + keys.join('|') + ")-";
  var classNamesRegExp = new RegExp(targetClassName ? "^(" + keyPattern + "|" + targetClassName + ")" : "^" + keyPattern);
  var filteredClassNames = classNames.filter(function (className) {
    return classNamesRegExp.test(className);
  });

  if (!filteredClassNames.length) {
    return '';
  }

  var selectorPattern = new RegExp('\\.(?:' + filteredClassNames.map(function (cls) {
    return "(" + cls + ")";
  }).join('|') + ')');
  var rules = flatMap(elements, getElementRules);
  var styles = rules.map(function (rule
  /*: string */
  ) {
    var match = rule.match(selectorPattern);

    if (!match) {
      return null;
    } // `selectorPattern` represents all emotion-generated class names
    // each possible class name is wrapped in a capturing group
    // and those groups appear in the same order as they appear in the DOM within class attributes
    // because we've gathered them from the DOM in such order
    // given that information we can sort matched rules based on the capturing group that has been matched
    // to end up with styles in a stable order


    var matchedCapturingGroupIndex = findIndexFrom(match, 1, Boolean);
    return [rule, matchedCapturingGroupIndex];
  }).filter(Boolean).sort(function (_ref3, _ref4) {
    _ref3[0];
        var classNameIndexA = _ref3[1];
    _ref4[0];
        var classNameIndexB = _ref4[1];
    return classNameIndexA - classNameIndexB;
  }).map(function (_ref5) {
    var rule = _ref5[0];
    return rule;
  }).join('');
  var keyframesMap = getKeyframesMap(rules);
  var keyframeNameKeys = Object.keys(keyframesMap);
  var keyframesStyles = '';

  if (keyframeNameKeys.length) {
    var keyframesNamePattern = new RegExp(keyframeNameKeys.join('|'), 'g');
    var keyframesNameCache = {};
    var index = 0;
    styles = styles.replace(keyframesNamePattern, function (name) {
      if (keyframesNameCache[name] === undefined) {
        keyframesNameCache[name] = "animation-" + index++;
        keyframesStyles += keyframesMap[name];
      }

      return keyframesNameCache[name];
    });
    keyframesStyles = keyframesStyles.replace(keyframesNamePattern, function (value) {
      return keyframesNameCache[value];
    });
  }

  return (keyframesStyles + styles).replace(removeCommentPattern, '');
}
function getStyleElements()
/*: Array<HTMLStyleElement> */
{
  if (!isBrowser) {
    throw new Error('jest-emotion requires jsdom. See https://jestjs.io/docs/en/configuration#testenvironment-string for more information.');
  }

  var elements = Array.from(document.querySelectorAll('style[data-emotion]'));
  return elements;
}

var unique = function unique(arr) {
  return Array.from(new Set(arr));
};

function getKeys(elements
/*: Array<HTMLStyleElement> */
) {
  var keys = unique(elements.map(function (element) {
    return element.getAttribute('data-emotion');
  })).filter(Boolean);
  return keys;
}
function hasClassNames(classNames
/*: Array<string> */
, selectors
/*: Array<string> */
, target
/* ?: string | RegExp */
)
/*: boolean */
{
  // selectors is the classNames of specific css rule
  return selectors.some(function (selector) {
    // if no target, use className of the specific css rule and try to find it
    // in the list of received node classNames to make sure this css rule
    // applied for root element
    if (!target) {
      var lastCls = last(selector.split(' '));

      if (!lastCls) {
        return false;
      }

      return classNames.includes(lastCls.slice(1));
    } // check if selector (className) of specific css rule match target


    return target instanceof RegExp ? target.test(selector) : selector.includes(target);
  });
}
function getMediaRules(rules
/*: Array<Object> */
, media
/*: string */
)
/*: Array<any> */
{
  return flatMap(rules.filter(function (rule) {
    if (rule.type !== '@media') {
      return false;
    }

    return rule.value.replace(/\s/g, '').includes(media.replace(/\s/g, ''));
  }), function (media) {
    return media.children;
  });
}
function isPrimitive(test) {
  return test !== Object(test);
}
function hasIntersection(left
/* any[] */
, right
/* any[] */
) {
  return left.some(function (value) {
    return right.includes(value);
  });
}

var tickledCssProps = new WeakMap();
var getTickledClassName = function getTickledClassName(cssProp) {
  return tickledCssProps.get(cssProp);
};
var tickle = function tickle(wrapper) {
  var isShallow = typeof wrapper.dive === 'function';
  wrapper.find('EmotionCssPropInternal').forEach(function (el) {
    var cssProp = el.props().css;

    if (!cssProp) {
      return;
    }

    var rendered = (isShallow ? el.dive() : el.children()).last();
    tickledCssProps.set(cssProp, unwrapFromPotentialFragment(rendered).props().className);
  });
  return wrapper;
};

var _excluded = ["css", "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", "__EMOTION_LABEL_PLEASE_DO_NOT_USE__"];

function getNodes(node, nodes) {
  if (nodes === void 0) {
    nodes = [];
  }

  if (Array.isArray(node)) {
    for (var _iterator = _createForOfIteratorHelperLoose(node), _step; !(_step = _iterator()).done;) {
      var child = _step.value;
      getNodes(child, nodes);
    }

    return nodes;
  }

  if (typeof node === 'object') {
    nodes.push(node);
  }

  if (node.children) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(node.children), _step2; !(_step2 = _iterator2()).done;) {
      var _child = _step2.value;
      getNodes(_child, nodes);
    }
  }

  return nodes;
}

function copyProps(target, source) {
  return Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
}

function deepTransform(node, transform) {
  if (Array.isArray(node)) {
    return node.map(function (child) {
      return deepTransform(child, transform);
    });
  }

  var transformed = transform(node);

  if (transformed !== node && transformed.children) {
    return copyProps(transformed, {
      // flatMap to allow a child of <A><B /><C /></A> to be transformed to <B /><C />
      children: flatMap(deepTransform(transformed.children, transform), function (id) {
        return id;
      })
    });
  }

  return transformed;
}

function getPrettyStylesFromClassNames(classNames
/*: Array<string> */
, elements
/*: Array<HTMLStyleElement> */
, indentation
/*: string */
) {
  return prettify__default["default"](getStylesFromClassNames(classNames, elements), indentation);
}
/*
export type Options = {
  classNameReplacer?: (className: string, index: number) => string,
  DOMElements?: boolean,
  includeStyles?: boolean
}
*/


function filterEmotionProps(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props;
      _props.css;
      _props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
      _props.__EMOTION_LABEL_PLEASE_DO_NOT_USE__;
      var rest = _objectWithoutPropertiesLoose(_props, _excluded);

  rest.css = 'unknown styles';
  return rest;
}

function getLabelsFromClassName(keys, className) {
  return flatMap(className.split(' '), function (cls) {
    var _cls$split = cls.split('-'),
        key = _cls$split[0];
        _cls$split[1];
        var labels = _cls$split.slice(2);

    if (!keys.includes(key)) {
      return null;
    }

    return labels;
  }).filter(Boolean);
}

function isShallowEnzymeElement(element
/*: any */
, keys
/*: string[] */
, labels
/*: string[] */
) {
  var childClassNames = (element.children || []).map(function (_ref) {
    var _ref$props = _ref.props,
        props = _ref$props === void 0 ? {} : _ref$props;
    return props.className || '';
  }).filter(Boolean);
  return !childClassNames.some(function (className) {
    var childLabels = getLabelsFromClassName(keys, className);
    return childLabels.every(function (childLabel) {
      return labels.includes(childLabel);
    });
  });
}

var createConvertEmotionElements = function createConvertEmotionElements(keys
/*: string[]*/
) {
  return function (node
  /*: any*/
  ) {
    if (isPrimitive(node)) {
      return node;
    }

    if (isEmotionCssPropEnzymeElement(node)) {
      var className = getTickledClassName(node.props.css);
      var labels = getLabelsFromClassName(keys, className || '');

      if (isShallowEnzymeElement(node, keys, labels)) {
        var emotionType = node.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__; // emotionType will be a string for DOM elements

        var type = typeof emotionType === 'string' ? emotionType : emotionType.displayName || emotionType.name || 'Component';
        return _extends({}, node, {
          props: filterEmotionProps(_extends({}, node.props, {
            className: className
          })),
          type: type
        });
      } else {
        return node.children[node.children.length - 1];
      }
    }

    if (isEmotionCssPropElementType(node)) {
      return _extends({}, node, {
        props: filterEmotionProps(node.props),
        type: node.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__
      });
    }

    if (isReactElement(node)) {
      return copyProps({}, node);
    }

    return node;
  };
};

function clean(node, classNames
/*: string[] */
) {
  if (Array.isArray(node)) {
    for (var _iterator3 = _createForOfIteratorHelperLoose(node), _step3; !(_step3 = _iterator3()).done;) {
      var child = _step3.value;
      clean(child, classNames);
    }

    return;
  }

  if (node.children) {
    for (var _iterator4 = _createForOfIteratorHelperLoose(node.children), _step4; !(_step4 = _iterator4()).done;) {
      var _child2 = _step4.value;
      clean(_child2, classNames);
    }
  }

  if (node.props) {
    var className = node.props.className;

    if (!className) {
      // if it's empty, remove it
      delete node.props.className;
    } else {
      var hasKnownClass = hasIntersection(className.split(' '), classNames);

      if (hasKnownClass) {
        delete node.props.css;
      }
    }
  }
}

function createSerializer(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
      classNameReplacer = _ref2.classNameReplacer,
      _ref2$DOMElements = _ref2.DOMElements,
      DOMElements = _ref2$DOMElements === void 0 ? true : _ref2$DOMElements,
      _ref2$includeStyles = _ref2.includeStyles,
      includeStyles = _ref2$includeStyles === void 0 ? true : _ref2$includeStyles;

  var cache = new WeakSet();

  var isTransformed = function isTransformed(val) {
    return cache.has(val);
  };

  function serialize(val, config, indentation
  /*: string */
  , depth
  /*: number */
  , refs, printer
  /*: Function */
  ) {
    var elements = getStyleElements();
    var keys = getKeys(elements);
    var convertEmotionElements = createConvertEmotionElements(keys);
    var converted = deepTransform(val, convertEmotionElements);
    var nodes = getNodes(converted);
    var classNames = getClassNamesFromNodes(nodes);
    var styles = includeStyles ? getPrettyStylesFromClassNames(classNames, elements, config.indent) : '';
    clean(converted, classNames);
    nodes.forEach(cache.add, cache);
    var printedVal = printer(converted, config, indentation, depth, refs);
    nodes.forEach(cache["delete"], cache);
    return replaceClassNames(classNames, styles, printedVal, keys, classNameReplacer);
  }

  return {
    test: function test(val) {
      return val && !isTransformed(val) && (isReactElement(val) || DOMElements && isDOMElement(val));
    },
    serialize: serialize
  };
}

exports.createSerializer = createSerializer;
exports.findLast = findLast;
exports.getClassNamesFromNodes = getClassNamesFromNodes;
exports.getMediaRules = getMediaRules;
exports.getStyleElements = getStyleElements;
exports.getStylesFromClassNames = getStylesFromClassNames;
exports.hasClassNames = hasClassNames;
exports.isEmotionCssPropElementType = isEmotionCssPropElementType;
exports.isStyledElementType = isStyledElementType;
exports.tickle = tickle;
exports.unwrapFromPotentialFragment = unwrapFromPotentialFragment;
