"use strict";
/* Released under the BSD 2-Clause License
 *
 * Copyright Â© 2018-present, terrestris GmbH & Co. KG and GeoStyler contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Color = require('color');
var SymbolizerUtil_1 = __importDefault(require("./SymbolizerUtil"));
var chroma_js_1 = require("chroma-js");
/**
 * @class RuleUtil
 */
var RuleGeneratorUtil = /** @class */ (function () {
    function RuleGeneratorUtil() {
    }
    RuleGeneratorUtil.getDistinctValues = function (data, attributeName) {
        var _a;
        var distinctValues = [];
        var features = (_a = data === null || data === void 0 ? void 0 : data.exampleFeatures) === null || _a === void 0 ? void 0 : _a.features;
        if (features) {
            features.forEach(function (feature) {
                var _a;
                var value = (_a = feature === null || feature === void 0 ? void 0 : feature.properties) === null || _a === void 0 ? void 0 : _a[attributeName];
                if (value && !distinctValues.includes(value)) {
                    distinctValues.push(value);
                }
            });
            return distinctValues;
        }
        return distinctValues;
    };
    RuleGeneratorUtil.guessSymbolizerFromData = function (data) {
        var _a, _b, _c, _d;
        var firstFeatureGeometryType = (_d = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.exampleFeatures) === null || _a === void 0 ? void 0 : _a.features) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.geometry) === null || _d === void 0 ? void 0 : _d.type;
        switch (firstFeatureGeometryType) {
            case 'Point':
            case 'MultiPoint':
                return 'Mark';
            case 'LineString':
            case 'MultiLineString':
                return 'Line';
            case 'Polygon':
            case 'MultiPolygon':
                return 'Fill';
            default:
                return 'Mark';
        }
    };
    RuleGeneratorUtil.generateColors = function (colors, numberOfRules, colorSpace) {
        if (colorSpace === void 0) { colorSpace = 'hsl'; }
        try {
            return (0, chroma_js_1.scale)(colors).mode(colorSpace).colors(numberOfRules);
        }
        catch (error) {
            return undefined;
        }
    };
    RuleGeneratorUtil.generateRules = function (params) {
        var _a;
        var data = params.data, levelOfMeasurement = params.levelOfMeasurement, attributeName = params.attributeName, inputColors = params.colors, colorSpace = params.colorSpace, symbolizerKind = params.symbolizerKind, wellKnownName = params.wellKnownName, classificationMethod = params.classificationMethod;
        var numberOfRules = params.numberOfRules;
        var colors = RuleGeneratorUtil.generateColors(inputColors, numberOfRules, colorSpace);
        var rules = [];
        if (levelOfMeasurement === 'nominal') {
            var distinctValues = RuleGeneratorUtil.getDistinctValues(data, attributeName);
            distinctValues.splice(numberOfRules, distinctValues.length - 2);
            rules = distinctValues.map(function (distinctValue, index) {
                var filter = ['==', attributeName, distinctValue];
                var symbolizer = SymbolizerUtil_1.default.generateSymbolizer(symbolizerKind, {
                    color: colors[index],
                    wellKnownName: wellKnownName
                });
                return {
                    name: distinctValue,
                    filter: filter,
                    symbolizers: [symbolizer]
                };
            });
        }
        else if (levelOfMeasurement === 'cardinal') {
            if (!classificationMethod) {
                // TODO Add feedback
            }
            else {
                var features = (_a = data === null || data === void 0 ? void 0 : data.exampleFeatures) === null || _a === void 0 ? void 0 : _a.features;
                var values = features
                    ? features.map(function (feature) { var _a; return (_a = feature === null || feature === void 0 ? void 0 : feature.properties) === null || _a === void 0 ? void 0 : _a[attributeName]; })
                    : [];
                var ranges_1 = [];
                switch (classificationMethod) {
                    case 'equalInterval':
                        ranges_1 = RuleGeneratorUtil.getRanges(values, numberOfRules, 'e');
                        break;
                    case 'quantile':
                        ranges_1 = RuleGeneratorUtil.getRanges(values, numberOfRules, 'q');
                        break;
                    case 'logarithmic':
                        ranges_1 = RuleGeneratorUtil.getRanges(values, numberOfRules, 'l');
                        break;
                    case 'kmeans':
                        ranges_1 = RuleGeneratorUtil.getRanges(values, numberOfRules, 'k');
                        numberOfRules = ranges_1.length;
                        colors = RuleGeneratorUtil.generateColors(inputColors, numberOfRules, colorSpace);
                        break;
                    default:
                        break;
                }
                rules = ranges_1.map(function (range, index) {
                    var isLast = index === ranges_1.length - 1;
                    var filter = [
                        '&&',
                        ['>=', attributeName, range[0]],
                        [isLast ? '<=' : '<', attributeName, range[1]],
                    ];
                    var symbolizer = SymbolizerUtil_1.default.generateSymbolizer(symbolizerKind, {
                        color: colors[index],
                        wellKnownName: wellKnownName
                    });
                    return {
                        name: "".concat(attributeName, " ").concat(range[0], " - ").concat(range[1]),
                        filter: filter,
                        symbolizers: [symbolizer]
                    };
                });
            }
        }
        return rules;
    };
    /**
     * Get Ranges for quantile spread statistic.
     *
     * @param {number[]} series The data values.
     * @param {number} numberOfClasses The number of classes to generate.
     * @param {'e'|'q'|'l'|'k'} mode The mode in which the ranges should be generated:
     *  - e: equidistant
     *  - q: quantile
     *  - l: logarihtmic
     *  - k: k-means
     */
    RuleGeneratorUtil.getRanges = function (series, numberOfClasses, mode) {
        if (mode === void 0) { mode = 'e'; }
        var bounds = (0, chroma_js_1.limits)(series, mode, numberOfClasses);
        return RuleGeneratorUtil.boundsToRanges(bounds);
    };
    /**
     * Inspired by GeoStats.js: http://www.intermezzo-coop.eu/mapping/geostats/
     *
     * @param {number[]} bounds An array of class boundary values.
     */
    RuleGeneratorUtil.boundsToRanges = function (bounds) {
        var ranges = [];
        for (var i = 0; i < (bounds.length - 1); i++) {
            ranges[i] = [bounds[i], bounds[i + 1]];
        }
        return ranges;
    };
    /**
     * Generates a style object (CSS) from an array of color strings.
     *
     * @param {string[]} colors An array of color strings.
     * @return {Object} An style object (CSS).
     */
    RuleGeneratorUtil.generateBackgroundStyleFromColors = function (colors) {
        var gradients = colors.map(function (color) { return "linear-gradient(".concat(color, ", ").concat(color, ")"); });
        var backgroundImage = gradients.join(',');
        var size = colors.map(function (color, index) {
            var width = (index + 1) * (100 / colors.length);
            return "".concat(width, "% 100%");
        });
        var backgroundSize = size.join(',');
        var textColor = Color(colors[0]).isLight() ? '#000000' : '#FFFFFF';
        return {
            backgroundImage: backgroundImage,
            backgroundSize: backgroundSize,
            backgroundRepeat: 'no-repeat',
            color: textColor
        };
    };
    return RuleGeneratorUtil;
}());
exports.default = RuleGeneratorUtil;
//# sourceMappingURL=RuleGeneratorUtil.js.map