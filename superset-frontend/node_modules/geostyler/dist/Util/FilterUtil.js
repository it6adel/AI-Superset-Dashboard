"use strict";
/* Released under the BSD 2-Clause License
 *
 * Copyright Â© 2018-present, terrestris GmbH & Co. KG and GeoStyler contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var typeguards_1 = require("geostyler-style/dist/typeguards");
var get_1 = __importDefault(require("lodash/get"));
var set_1 = __importDefault(require("lodash/set"));
var cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
var uniqueId_1 = __importDefault(require("lodash/uniqueId"));
/**
 * @class FilterUtil
 */
var FilterUtil = /** @class */ (function () {
    function FilterUtil() {
    }
    /**
     * Calculates the number of features that are covered by more then one rule per
     * rule.
     *
     * @param {object} matches An object containing the count of matches for every
     *  filter. Separated by scales.
     * @returns {number[]} An array containing the number of duplicates for each
     *  rule.
     */
    FilterUtil.calculateDuplicates = function (matches) {
        var duplicates = [];
        var ids = [];
        matches.forEach(function (features, index) {
            var idMap = {};
            features.forEach(function (feat) { return idMap[feat.id] = true; });
            ids[index] = idMap;
        });
        matches.forEach(function (features, index) {
            var counter = 0;
            ids.forEach(function (idMap, idIndex) {
                if (index !== idIndex) {
                    features.forEach(function (feat) {
                        if (idMap[feat.id]) {
                            ++counter;
                        }
                    });
                }
            });
            duplicates[index] = counter;
        });
        return duplicates;
    };
    /**
     * Calculates the amount of matched and duplicate matched features for the rules.
     *
     * @param {Rule[]} rules An array of GeoStyler rule objects.
     * @param {VectorData} data A geostyler data object.
     * @returns {CountResult} An object containing array with the amount of matched
     * and duplicate matched features reachable through keys'counts' and 'duplicates'.
     */
    FilterUtil.calculateCountAndDuplicates = function (rules, data) {
        if (!rules || !data) {
            return {};
        }
        var result = {
            counts: [],
            duplicates: []
        };
        // Add id to feature if missing
        data.exampleFeatures.features = data.exampleFeatures.features.map(function (feature, idx) {
            if (!feature.id) {
                feature.id = idx;
            }
            return feature;
        });
        var matches = [];
        rules.forEach(function (rule, index) {
            var currentMatches = rule.filter ? FilterUtil.getMatches(rule.filter, data) : data.exampleFeatures.features;
            result.counts.push(currentMatches.length);
            matches[index] = currentMatches;
        });
        result.duplicates = FilterUtil.calculateDuplicates(matches);
        return result;
    };
    /**
     * Transforms a position String like '[2][3]' to an positionArray like [2, 3].
     */
    FilterUtil.positionStringAsArray = function (positionString) {
        return positionString
            .replace(/\]\[/g, ',')
            .replace(/\]/g, '')
            .replace(/\[/g, '')
            .split(',')
            .map(function (i) { return parseInt(i, 10); });
    };
    /**
     * Transforms am positionArray like [2, 3] to a string like '[2][3]'.
     */
    FilterUtil.positionArrayAsString = function (positionArray) {
        return "[".concat(positionArray.toString().replace(/,/g, ']['), "]");
    };
    /**
     * Returns the filter at a specific position.
     */
    FilterUtil.getFilterAtPosition = function (rootFilter, position) {
        if (position === '') {
            return rootFilter;
        }
        else {
            return (0, get_1.default)(rootFilter, position);
        }
    };
    /**
     * Removes a subfilter from a given filter at the given position.
     */
    FilterUtil.removeAtPosition = function (filter, position) {
        var newFilter = __spreadArray([], filter, true);
        var dragNodeSubPosition = position.substr(position.length - 3);
        var dragNodeIndex = parseInt(dragNodeSubPosition.slice(1, 2), 10);
        var parentPosition = position.substring(0, position.length - 3);
        var parentFilter = newFilter;
        if (parentPosition !== '') {
            parentFilter = (0, get_1.default)(newFilter, parentPosition);
        }
        parentFilter.splice(dragNodeIndex, 1);
        return newFilter;
    };
    /**
       * Inserts a given subfilter to a given parentfilter by its position and its
       * dropPosition.
       */
    FilterUtil.insertAtPosition = function (baseFilter, insertFilter, position) {
        var dropTargetParentPosition = position.substring(0, position.length - 3);
        var dropTargetSubPosition = position.substring(position.length - 3);
        var dropTargetSubIndex = parseInt(dropTargetSubPosition.slice(1, 2), 10);
        var dropTargetIsComparison = !['&&', '||', '!'].includes(insertFilter[0]);
        var newFilter = __spreadArray([], baseFilter, true);
        var newSubFilter = dropTargetParentPosition === ''
            ? newFilter
            : (0, get_1.default)(newFilter, dropTargetParentPosition);
        if (dropTargetIsComparison) {
            if (newFilter.length - 1 === dropTargetSubIndex) {
                newSubFilter.push(insertFilter);
            }
            else {
                newSubFilter.splice(dropTargetSubIndex, 0, insertFilter);
            }
        }
        else {
            newSubFilter.push(insertFilter);
        }
        return newFilter;
    };
    /**
     * Handler for the add button.
     * Adds a filter of a given type at the given position.
     *
     */
    FilterUtil.addFilter = function (rootFilter, position, type) {
        var addedFilter;
        var newFilter = (0, cloneDeep_1.default)(rootFilter);
        switch (type) {
            case 'and':
                addedFilter = ['&&', ['==', '', ''], ['==', '', '']];
                break;
            case 'or':
                addedFilter = ['||', ['==', '', ''], ['==', '', '']];
                break;
            case 'not':
                addedFilter = ['!', ['==', '', '']];
                break;
            case 'comparison':
            default:
                addedFilter = ['==', '', ''];
                break;
        }
        if (position === '') {
            newFilter = newFilter;
            newFilter.push(addedFilter);
        }
        else {
            var previousFilter = (0, get_1.default)(newFilter, position);
            previousFilter.push(addedFilter);
            (0, set_1.default)(newFilter, position, previousFilter);
        }
        return newFilter;
    };
    /**
     * Changes a filter at a position to a given typ.
     *
     */
    FilterUtil.changeFilter = function (rootFilter, position, type) {
        var addedFilter;
        var newFilter = (0, cloneDeep_1.default)(rootFilter);
        var previousFilter = position === '' ? newFilter : (0, get_1.default)(newFilter, position);
        switch (type) {
            case 'and':
                if (previousFilter && (previousFilter[0] === '&&' || previousFilter[0] === '||')) {
                    addedFilter = previousFilter;
                    addedFilter[0] = '&&';
                }
                else {
                    addedFilter = ['&&', ['==', '', ''], ['==', '', '']];
                }
                break;
            case 'or':
                if (previousFilter && (previousFilter[0] === '&&' || previousFilter[0] === '||')) {
                    addedFilter = previousFilter;
                    addedFilter[0] = '||';
                }
                else {
                    addedFilter = ['||', ['==', '', ''], ['==', '', '']];
                }
                break;
            case 'not':
                addedFilter = ['!', ['==', '', '']];
                break;
            case 'comparison':
            default:
                addedFilter = ['==', '', ''];
                break;
        }
        if (position === '') {
            return addedFilter;
        }
        else {
            (0, set_1.default)(newFilter, position, addedFilter);
            return newFilter;
        }
    };
    FilterUtil.nestingOperators = ['&&', '||', '!'];
    /**
     * Handle nested filters.
     */
    FilterUtil.handleNestedFilter = function (filter, feature) {
        switch (filter[0]) {
            case '&&':
                var intermediate_1 = true;
                var restFilter = filter.slice(1);
                restFilter.forEach(function (f) {
                    if (!FilterUtil.featureMatchesFilter(f, feature)) {
                        intermediate_1 = false;
                    }
                });
                return intermediate_1;
            case '||':
                intermediate_1 = false;
                restFilter = filter.slice(1);
                restFilter.forEach(function (f) {
                    if (FilterUtil.featureMatchesFilter(f, feature)) {
                        intermediate_1 = true;
                    }
                });
                return intermediate_1;
            case '!':
                return !FilterUtil.featureMatchesFilter(filter[1], feature);
            default:
                throw new Error('Cannot parse Filter. Unknown combination or negation operator.');
        }
    };
    /**
     * Handle simple filters, i.e. non-nested filters.
     */
    FilterUtil.handleSimpleFilter = function (filter, feature) {
        var featureValue = (0, get_1.default)(feature, 'properties[' + filter[1] + ']');
        var filterValue = filter[2];
        switch (filter[0]) {
            case '==':
                return (('' + featureValue) === ('' + filterValue));
            case '*=':
                filterValue = filterValue;
                if (featureValue && filterValue.length > featureValue.length) {
                    return false;
                }
                else if (featureValue) {
                    return (featureValue.indexOf(filterValue) !== -1);
                }
                else {
                    return false;
                }
            case '!=':
                return (('' + featureValue) !== ('' + filterValue));
            case '<':
                return (parseFloat(featureValue) < Number(filterValue));
            case '<=':
                return (parseFloat(featureValue) <= Number(filterValue));
            case '>':
                return (parseFloat(featureValue) > Number(filterValue));
            case '>=':
                return (parseFloat(featureValue) >= Number(filterValue));
            default:
                throw new Error('Cannot parse Filter. Unknown comparison operator.');
        }
    };
    /**
     * Checks if a feature matches the specified filter.
     * Returns true if it matches, otherwise returns false.
     */
    FilterUtil.featureMatchesFilter = function (filter, feature) {
        if (filter.length === 0) {
            return true;
        }
        var matchesFilter = true;
        if ((0, typeguards_1.isComparisonFilter)(filter)) {
            matchesFilter = FilterUtil.handleSimpleFilter(filter, feature);
        }
        else if ((0, typeguards_1.isCombinationFilter)(filter) || (0, typeguards_1.isNegationFilter)(filter)) {
            matchesFilter = FilterUtil.handleNestedFilter(filter, feature);
        }
        return matchesFilter;
    };
    /**
     * Returns those features that match a given filter.
     * If no feature matches, returns an empty array.
     *
     * @param {Filter} filter A geostyler filter object.
     * @param {VectorData} data A geostyler data object.
     * @return {Feature[]} An Array of geojson feature objects.
     */
    FilterUtil.getMatches = function (filter, data) {
        return data.exampleFeatures.features.filter((function (feature) {
            return FilterUtil.featureMatchesFilter(filter, feature);
        }));
    };
    /**
     * Removes a filter at a given position.
     *
     */
    FilterUtil.removeFilter = function (rootFilter, position) {
        var parentPosition = position.substring(0, position.length - 3);
        var parentFilter = FilterUtil.getFilterAtPosition(rootFilter, parentPosition);
        var newFilter;
        if (position === '') {
            newFilter = undefined;
        }
        else if (parentFilter.length <= 2) {
            newFilter = FilterUtil.removeAtPosition(rootFilter, parentPosition);
        }
        else {
            newFilter = FilterUtil.removeAtPosition(rootFilter, position);
        }
        return newFilter;
    };
    /**
     * Helper method for FilterUtil.filterToTree().
     */
    FilterUtil.filterToTreeHelper = function (filter) {
        var tree = {
            key: (0, uniqueId_1.default)()
        };
        var filterClone = (0, cloneDeep_1.default)(filter);
        var operator = filterClone.shift();
        if ((0, typeguards_1.isComparisonOperator)(operator)) {
            tree.title = "".concat(filterClone[0], " ").concat(operator, " ").concat(filterClone[1]);
        }
        else if ((0, typeguards_1.isCombinationOperator)(operator)) {
            tree.title = operator;
            tree.children = filterClone.map(function (f) {
                if ((0, typeguards_1.isFilter)(f)) {
                    return FilterUtil.filterToTreeHelper(f);
                }
            });
        }
        else if ((0, typeguards_1.isNegationOperator)(operator)) {
            tree.title = operator;
            tree.children = filterClone.map(function (f) {
                if ((0, typeguards_1.isFilter)(f)) {
                    return FilterUtil.filterToTreeHelper(f);
                }
            });
        }
        // TODO str_matchesFilter is missing but also not yet supported in UI
        return tree;
    };
    /**
     * Maps a GeoStyler filter to an antd treeData object.
     */
    FilterUtil.filterToTree = function (filter) {
        return [FilterUtil.filterToTreeHelper(filter)];
    };
    return FilterUtil;
}());
exports.default = FilterUtil;
//# sourceMappingURL=FilterUtil.js.map