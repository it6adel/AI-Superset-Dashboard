{"version":3,"file":"FilterUtil.js","sourceRoot":"","sources":["../../src/Util/FilterUtil.ts"],"names":[],"mappings":"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","sourcesContent":["/* Released under the BSD 2-Clause License\n *\n * Copyright Â© 2018-present, terrestris GmbH & Co. KG and GeoStyler contributors\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport {\n  Filter,\n  ComparisonFilter,\n  Rule,\n  CombinationFilter,\n  NegationFilter,\n  CombinationOperator\n} from 'geostyler-style';\n\nimport {\n  isCombinationFilter,\n  isComparisonFilter,\n  isNegationFilter,\n  isComparisonOperator,\n  isCombinationOperator,\n  isNegationOperator,\n  isFilter\n} from 'geostyler-style/dist/typeguards';\n\nimport {\n  VectorData\n} from 'geostyler-data';\n\nimport _get from 'lodash/get';\nimport _set from 'lodash/set';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport _uniqueId from 'lodash/uniqueId';\n\nexport type CountResult = {\n  counts?: number[];\n  duplicates?: number[];\n};\n\n/**\n * @class FilterUtil\n */\nclass FilterUtil {\n\n  static nestingOperators = ['&&', '||', '!'];\n\n  /**\n   * Handle nested filters.\n   */\n  static handleNestedFilter = (filter: CombinationFilter | NegationFilter, feature: any): boolean => {\n    switch (filter[0]) {\n      case '&&':\n        let intermediate = true;\n        let restFilter = filter.slice(1);\n        restFilter.forEach((f: Filter | CombinationOperator) => {\n          if (!FilterUtil.featureMatchesFilter(f, feature)) {\n            intermediate = false;\n          }\n        });\n        return intermediate;\n      case '||':\n        intermediate = false;\n        restFilter = filter.slice(1);\n        restFilter.forEach((f: Filter | CombinationOperator) => {\n          if (FilterUtil.featureMatchesFilter(f, feature)) {\n            intermediate = true;\n          }\n        });\n        return intermediate;\n      case '!':\n        return !FilterUtil.featureMatchesFilter(filter[1], feature);\n      default:\n        throw new Error('Cannot parse Filter. Unknown combination or negation operator.');\n    }\n  };\n\n  /**\n   * Handle simple filters, i.e. non-nested filters.\n   */\n  static handleSimpleFilter = (filter: ComparisonFilter, feature: any): boolean => {\n    const featureValue = _get(feature, 'properties[' + filter[1] + ']');\n    let filterValue = filter[2];\n    switch (filter[0]) {\n      case '==':\n        return (('' + featureValue) === ('' + filterValue));\n      case '*=':\n        filterValue = filterValue as string;\n        if (featureValue && filterValue.length > featureValue.length) {\n          return false;\n        } else if (featureValue) {\n          return (featureValue.indexOf(filterValue) !== -1);\n        } else {\n          return false;\n        }\n      case '!=':\n        return (('' + featureValue) !== ('' + filterValue));\n      case '<':\n        return (parseFloat(featureValue) < Number(filterValue));\n      case '<=':\n        return (parseFloat(featureValue) <= Number(filterValue));\n      case '>':\n        return (parseFloat(featureValue) > Number(filterValue));\n      case '>=':\n        return (parseFloat(featureValue) >= Number(filterValue));\n      default:\n        throw new Error('Cannot parse Filter. Unknown comparison operator.');\n    }\n  };\n\n  /**\n   * Checks if a feature matches the specified filter.\n   * Returns true if it matches, otherwise returns false.\n   */\n  static featureMatchesFilter = (filter: Filter | CombinationOperator, feature: any): boolean => {\n    if (filter.length === 0) {\n      return true;\n    }\n    let matchesFilter: boolean = true;\n    if (isComparisonFilter(filter)) {\n      matchesFilter = FilterUtil.handleSimpleFilter(filter, feature);\n    } else if (isCombinationFilter(filter) || isNegationFilter(filter)) {\n      matchesFilter = FilterUtil.handleNestedFilter(filter, feature);\n    }\n    return matchesFilter;\n  };\n\n  /**\n   * Returns those features that match a given filter.\n   * If no feature matches, returns an empty array.\n   *\n   * @param {Filter} filter A geostyler filter object.\n   * @param {VectorData} data A geostyler data object.\n   * @return {Feature[]} An Array of geojson feature objects.\n   */\n  static getMatches = (filter: Filter, data: VectorData): any[] => {\n    return data.exampleFeatures.features.filter((feature => {\n      return FilterUtil.featureMatchesFilter(filter, feature);\n    }));\n  };\n\n  /**\n   * Calculates the number of features that are covered by more then one rule per\n   * rule.\n   *\n   * @param {object} matches An object containing the count of matches for every\n   *  filter. Separated by scales.\n   * @returns {number[]} An array containing the number of duplicates for each\n   *  rule.\n   */\n  static calculateDuplicates(matches: any): number[] {\n    const duplicates: number[] = [];\n\n    const ids: any[] = [];\n\n    matches.forEach((features: any, index: number) => {\n      const idMap = {};\n      features.forEach((feat: any) => idMap[feat.id] = true);\n      ids[index] = idMap;\n    });\n\n    matches.forEach((features: any, index: number) => {\n      let counter = 0;\n      ids.forEach((idMap, idIndex) => {\n        if (index !== idIndex) {\n          features.forEach((feat: any) => {\n            if (idMap[feat.id]) {\n              ++counter;\n            }\n          });\n        }\n      });\n      duplicates[index] = counter;\n    });\n\n    return duplicates;\n  }\n\n  /**\n   * Calculates the amount of matched and duplicate matched features for the rules.\n   *\n   * @param {Rule[]} rules An array of GeoStyler rule objects.\n   * @param {VectorData} data A geostyler data object.\n   * @returns {CountResult} An object containing array with the amount of matched\n   * and duplicate matched features reachable through keys'counts' and 'duplicates'.\n   */\n  static calculateCountAndDuplicates(rules: Rule[], data: VectorData): CountResult {\n    if (!rules || !data) {\n      return {};\n    }\n    const result: CountResult = {\n      counts: [],\n      duplicates: []\n    };\n\n    // Add id to feature if missing\n    data.exampleFeatures.features = data.exampleFeatures.features.map((feature, idx) => {\n      if (!feature.id) {\n        feature.id = idx;\n      }\n      return feature;\n    });\n\n    const matches: any = [];\n    rules.forEach((rule, index) => {\n      const currentMatches = rule.filter ? FilterUtil.getMatches(rule.filter, data) : data.exampleFeatures.features;\n      result.counts.push(currentMatches.length);\n      matches[index] = currentMatches;\n    });\n\n    result.duplicates = FilterUtil.calculateDuplicates(matches);\n    return result;\n  }\n\n  /**\n   * Transforms a position String like '[2][3]' to an positionArray like [2, 3].\n   */\n  static positionStringAsArray(positionString: string) {\n    return positionString\n      .replace(/\\]\\[/g, ',')\n      .replace(/\\]/g, '')\n      .replace(/\\[/g, '')\n      .split(',')\n      .map(i => parseInt(i, 10));\n  }\n\n  /**\n   * Transforms am positionArray like [2, 3] to a string like '[2][3]'.\n   */\n  static positionArrayAsString(positionArray: number[] | string[]) {\n    return `[${positionArray.toString().replace(/,/g, '][')}]`;\n  }\n\n  /**\n   * Returns the filter at a specific position.\n   */\n  static getFilterAtPosition(rootFilter: Filter, position: string) {\n    if (position === '') {\n      return rootFilter;\n    } else {\n      return _get(rootFilter, position);\n    }\n  }\n\n  /**\n   * Removes a subfilter from a given filter at the given position.\n   */\n  static removeAtPosition(filter: Filter, position: string): Filter {\n    let newFilter = [...filter] as Filter;\n    const dragNodeSubPosition = position.substr(position.length - 3);\n    const dragNodeIndex = parseInt(dragNodeSubPosition.slice(1, 2), 10);\n    const parentPosition = position.substring(0, position.length - 3);\n\n    let parentFilter = newFilter;\n    if (parentPosition !== '') {\n      parentFilter = _get(newFilter, parentPosition);\n    }\n    parentFilter.splice(dragNodeIndex, 1);\n    return newFilter;\n  }\n\n  /**\n     * Inserts a given subfilter to a given parentfilter by its position and its\n     * dropPosition.\n     */\n  static insertAtPosition(\n    baseFilter: Filter,\n    insertFilter: Filter,\n    position: string\n  ): Filter {\n    const dropTargetParentPosition = position.substring(0, position.length - 3);\n    const dropTargetSubPosition = position.substring(position.length - 3);\n    const dropTargetSubIndex = parseInt(dropTargetSubPosition.slice(1, 2), 10);\n    const dropTargetIsComparison = !['&&', '||', '!'].includes(insertFilter[0]);\n    let newFilter: Filter = [...baseFilter];\n\n    const newSubFilter = dropTargetParentPosition === ''\n      ? newFilter\n      : _get(newFilter, dropTargetParentPosition);\n\n    if (dropTargetIsComparison) {\n      if (newFilter.length - 1 === dropTargetSubIndex) {\n        newSubFilter.push(insertFilter);\n      } else {\n        newSubFilter.splice(dropTargetSubIndex, 0, insertFilter);\n      }\n    } else {\n      newSubFilter.push(insertFilter);\n    }\n\n    return newFilter;\n  }\n\n  /**\n   * Handler for the add button.\n   * Adds a filter of a given type at the given position.\n   *\n   */\n  static addFilter(rootFilter: Filter, position: string, type: string) {\n\n    let addedFilter: Filter ;\n    let newFilter: Filter = _cloneDeep(rootFilter);\n\n    switch (type) {\n      case 'and':\n        addedFilter = ['&&', ['==', '', ''], ['==', '', '']] as CombinationFilter;\n        break;\n      case 'or':\n        addedFilter = ['||', ['==', '', ''], ['==', '', '']] as CombinationFilter;\n        break;\n      case 'not':\n        addedFilter = ['!', ['==', '', '']] as NegationFilter;\n        break;\n      case 'comparison':\n      default:\n        addedFilter = ['==', '', ''] as ComparisonFilter;\n        break;\n    }\n\n    if (position === '') {\n      newFilter = newFilter as CombinationFilter;\n      newFilter.push(addedFilter);\n    } else {\n      const previousFilter: CombinationFilter = _get(newFilter, position);\n      previousFilter.push(addedFilter);\n      _set(newFilter, position, previousFilter);\n    }\n\n    return newFilter;\n  }\n\n  /**\n   * Changes a filter at a position to a given typ.\n   *\n   */\n  static changeFilter(rootFilter: Filter, position: string, type: string) {\n\n    let addedFilter: Filter ;\n    const newFilter: Filter = _cloneDeep(rootFilter);\n    const previousFilter = position === '' ? newFilter : _get(newFilter, position);\n\n    switch (type) {\n      case 'and':\n        if (previousFilter && (previousFilter[0] === '&&' || previousFilter[0] === '||' )) {\n          addedFilter = previousFilter;\n          addedFilter[0] = '&&';\n        } else {\n          addedFilter = ['&&', ['==', '', ''], ['==', '', '']];\n        }\n        break;\n      case 'or':\n        if (previousFilter && (previousFilter[0] === '&&' || previousFilter[0] === '||' )) {\n          addedFilter = previousFilter;\n          addedFilter[0] = '||';\n        } else {\n          addedFilter = ['||', ['==', '', ''], ['==', '', '']];\n        }\n        break;\n      case 'not':\n        addedFilter = ['!', ['==', '', '']];\n        break;\n      case 'comparison':\n      default:\n        addedFilter = ['==', '', ''];\n        break;\n    }\n\n    if (position === '') {\n      return addedFilter;\n    } else {\n      _set(newFilter, position, addedFilter);\n      return newFilter;\n    }\n\n  }\n\n  /**\n   * Removes a filter at a given position.\n   *\n   */\n  static removeFilter = (rootFilter: Filter, position: string) => {\n    const parentPosition = position.substring(0, position.length - 3);\n    const parentFilter: Filter = FilterUtil.getFilterAtPosition(rootFilter, parentPosition);\n    let newFilter: Filter;\n\n    if (position === '') {\n      newFilter = undefined;\n    } else if (parentFilter.length <= 2) {\n      newFilter = FilterUtil.removeAtPosition(rootFilter, parentPosition);\n    } else {\n      newFilter = FilterUtil.removeAtPosition(rootFilter, position);\n    }\n\n    return newFilter;\n  };\n\n  /**\n   * Helper method for FilterUtil.filterToTree().\n   */\n  static filterToTreeHelper = (filter: Filter) => {\n    let tree: any = {\n      key: _uniqueId()\n    };\n\n    let filterClone = _cloneDeep(filter);\n    const operator = filterClone.shift();\n    if (isComparisonOperator(operator)) {\n      tree.title = `${filterClone[0]} ${operator} ${filterClone[1]}`;\n    } else if (isCombinationOperator(operator)) {\n      tree.title = operator;\n      tree.children = filterClone.map((f: any) => {\n        if (isFilter(f)) {\n          return FilterUtil.filterToTreeHelper(f);\n        }\n      });\n    } else if (isNegationOperator(operator)) {\n      tree.title = operator;\n      tree.children = filterClone.map((f: any) => {\n        if (isFilter(f)) {\n          return FilterUtil.filterToTreeHelper(f);\n        }\n      });\n    }\n    // TODO str_matchesFilter is missing but also not yet supported in UI\n    return tree;\n\n  };\n\n  /**\n   * Maps a GeoStyler filter to an antd treeData object.\n   */\n  static filterToTree = (filter: Filter) => {\n    return [FilterUtil.filterToTreeHelper(filter)];\n  };\n\n}\n\nexport default FilterUtil;\n"]}