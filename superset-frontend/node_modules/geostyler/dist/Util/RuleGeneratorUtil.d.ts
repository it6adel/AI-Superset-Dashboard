import * as CSS from 'csstype';
import { VectorData } from 'geostyler-data';
import { LevelOfMeasurement } from 'src/Component/RuleGenerator/RuleGenerator';
import { Rule, SymbolizerKind, WellKnownName } from 'geostyler-style';
import { InterpolationMode } from 'chroma-js';
import { ClassificationMethod } from 'src/Component/RuleGenerator/ClassificationCombo/ClassificationCombo';
export interface RuleGenerationParams {
    data: VectorData;
    levelOfMeasurement: LevelOfMeasurement;
    numberOfRules: number;
    attributeName: string;
    colors: string[];
    colorSpace?: InterpolationMode;
    symbolizerKind: SymbolizerKind;
    wellKnownName?: WellKnownName;
    classificationMethod?: ClassificationMethod;
}
/**
 * @class RuleUtil
 */
declare class RuleGeneratorUtil {
    static getDistinctValues(data: VectorData, attributeName: string): any[];
    static guessSymbolizerFromData(data: VectorData): SymbolizerKind;
    static generateColors(colors: string[], numberOfRules: number, colorSpace?: InterpolationMode): string[];
    static generateRules(params: RuleGenerationParams): Rule[];
    /**
     * Generates a style object (CSS) from an array of color strings.
     *
     * @param {string[]} colors An array of color strings.
     * @return {Object} An style object (CSS).
     */
    static generateBackgroundStyleFromColors: (colors: string[]) => CSS.Properties;
    /**
     * Get Ranges for quantile spread statistic.
     *
     * @param {number[]} series The data values.
     * @param {number} numberOfClasses The number of classes to generate.
     * @param {'e'|'q'|'l'|'k'} mode The mode in which the ranges should be generated:
     *  - e: equidistant
     *  - q: quantile
     *  - l: logarihtmic
     *  - k: k-means
     */
    static getRanges(series: number[], numberOfClasses: number, mode?: 'e' | 'q' | 'l' | 'k'): number[][];
    /**
     * Inspired by GeoStats.js: http://www.intermezzo-coop.eu/mapping/geostats/
     *
     * @param {number[]} bounds An array of class boundary values.
     */
    static boundsToRanges(bounds: number[]): number[][];
}
export default RuleGeneratorUtil;
