"use strict";
/* Released under the BSD 2-Clause License
 *
 * Copyright Â© 2018-present, terrestris GmbH & Co. KG and GeoStyler contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterTree = void 0;
var React = __importStar(require("react"));
var antd_1 = require("antd");
var icons_1 = require("@ant-design/icons");
var get_1 = __importDefault(require("lodash/get"));
var set_1 = __importDefault(require("lodash/set"));
var isEqual_1 = __importDefault(require("lodash/isEqual"));
var cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
var TreeNode = antd_1.Tree.TreeNode;
require("./FilterTree.css");
var ComparisonFilter_1 = __importDefault(require("../ComparisonFilter/ComparisonFilter"));
var LocaleWrapper_1 = require("../../LocaleWrapper/LocaleWrapper");
var typeguards_1 = require("geostyler-style/dist/typeguards");
var FilterUtil_1 = __importDefault(require("../../../Util/FilterUtil"));
var en_US_1 = __importDefault(require("../../../locale/en_US"));
/**
 * UI for a ComparisonFilter consisting of
 *
 *   - A combo to select the attribute
 *   - A combo to select the operator
 *   - An input field for the value
 */
var FilterTree = function (_a) {
    var _b = _a.filter, rootFilter = _b === void 0 ? ['==', '', null] : _b, internalDataDef = _a.internalDataDef, _c = _a.locale, locale = _c === void 0 ? en_US_1.default.FilterTree : _c, onFilterChange = _a.onFilterChange, filterUiProps = _a.filterUiProps, passThroughProps = __rest(_a, ["filter", "internalDataDef", "locale", "onFilterChange", "filterUiProps"]);
    /**
     * Changehandler for ComparsionFilters.
     *
     */
    var onComparisonFilterChange = function (filter, position) {
        if ((0, isEqual_1.default)(filter, rootFilter)) {
            onFilterChange(filter);
        }
        var newFilter = (0, cloneDeep_1.default)(rootFilter);
        if (position === '') {
            newFilter = filter;
        }
        else {
            (0, set_1.default)(newFilter, position, filter);
        }
        if (onFilterChange) {
            onFilterChange(newFilter);
        }
    };
    /**
     * Handler for the add button.
     * Adds a filter of a given type at the given position.
     *
     */
    var onAddFilterClicked = function (position, type) {
        var newFilter = FilterUtil_1.default.addFilter(rootFilter, position, type);
        onFilterChange(newFilter);
    };
    /**
     * Changes a filter at a position to a given typ.
     *
     */
    var onChangeFilterClicked = function (position, type) {
        var newFilter = FilterUtil_1.default.changeFilter(rootFilter, position, type);
        onFilterChange(newFilter);
    };
    /**
     * Removes a filter at a given position.
     *
     */
    var removeFilter = function (position) {
        var newFilter = FilterUtil_1.default.removeFilter(rootFilter, position);
        onFilterChange(newFilter);
    };
    /**
     * Creates a TreeNode for a given filter at the given position.
     *
     * @return Tree.TreeNode
     */
    // TODO: This should be a single component
    var getNodeByFilter = function (filter, position) {
        if (position === void 0) { position = ''; }
        var onMenuClick = function (e) {
            var keyPath = e.keyPath;
            var reversedKeyPath = keyPath.reverse();
            switch (reversedKeyPath[0]) {
                case 'add':
                    onAddFilterClicked(position, reversedKeyPath[1].toString());
                    break;
                case 'change':
                    onChangeFilterClicked(position, reversedKeyPath[1].toString());
                    break;
                case 'remove':
                    removeFilter(position);
                    break;
                default:
                    break;
            }
        };
        var items = [];
        if ((0, typeguards_1.isCombinationFilter)(filter)) {
            items.push({
                label: locale.addFilterLabel,
                key: 'add',
                icon: React.createElement(icons_1.PlusOutlined, null),
                children: [{
                        label: locale.andDrpdwnLabel,
                        key: 'and'
                    }, {
                        label: locale.orDrpdwnLabel,
                        key: 'or'
                    }, {
                        label: locale.notDrpdwnLabel,
                        key: 'not'
                    }, {
                        label: locale.comparisonDrpdwnLabel,
                        key: 'comparison'
                    }],
            });
        }
        items.push({
            label: locale.changeFilterLabel,
            key: 'change',
            icon: React.createElement(icons_1.FilterOutlined, null),
            children: [{
                    label: locale.andDrpdwnLabel,
                    key: 'and'
                }, {
                    label: locale.orDrpdwnLabel,
                    key: 'or'
                }, {
                    label: locale.notDrpdwnLabel,
                    key: 'not'
                }, {
                    label: locale.comparisonDrpdwnLabel,
                    key: 'comparison'
                }],
        });
        items.push({
            key: 'remove',
            icon: React.createElement(icons_1.MinusOutlined, null)
        });
        var menu = (React.createElement(antd_1.Dropdown, { overlay: React.createElement(antd_1.Menu, { onClick: onMenuClick, items: items }) },
            React.createElement(antd_1.Button, { className: "filter-menu-button", size: "small", icon: React.createElement(icons_1.EllipsisOutlined, null) })));
        var extraClassName = '';
        var title;
        var isLeaf = !((0, typeguards_1.isCombinationFilter)(filter) || (0, typeguards_1.isNegationFilter)(filter));
        var children = null;
        if ((0, typeguards_1.isCombinationFilter)(filter)) {
            var text = filter[0] === '&&' ? locale.andFilterText : locale.orFilterText;
            extraClassName = "".concat(filter[0] === '&&' ? 'and' : 'or', "-filter");
            title = (React.createElement("span", { className: "node-title" },
                React.createElement("span", { className: "filter-text" }, text),
                menu));
            children = filter.slice(1).map(function (subFilter, index) {
                var pos = "".concat(position, "[").concat(index + 1, "]");
                return getNodeByFilter(subFilter, pos);
            });
        }
        else if ((0, typeguards_1.isNegationFilter)(filter)) {
            extraClassName = 'not-filter';
            title = (React.createElement("span", { className: "node-title" },
                React.createElement("span", { className: "filter-text" }, locale.notFilterText),
                menu));
            children = getNodeByFilter(filter[1], "".concat(position, "[1]"));
        }
        else if ((0, typeguards_1.isComparisonFilter)(filter)) {
            extraClassName = 'comparison-filter';
            title = (React.createElement("span", { className: "node-title" },
                React.createElement(ComparisonFilter_1.default, __assign({ microUI: true, internalDataDef: internalDataDef, filter: filter, onFilterChange: function (f) { return onComparisonFilterChange(f, position); } }, filterUiProps)),
                menu));
        }
        else if ((0, typeguards_1.isGeoStylerFunction)(filter)) {
            extraClassName = 'function-filter';
            title = (React.createElement("span", { className: "node-title" },
                "GeoStyler function not supported yet.",
                menu));
        }
        else {
            extraClassName = 'unknown-filter';
            title = (React.createElement("span", { className: "node-title" },
                "Unknown filter supplied.",
                menu));
        }
        return (React.createElement(TreeNode, { className: "style-filter-node ".concat(extraClassName), key: position, isLeaf: isLeaf, title: title }, children));
    };
    /**
     * Drop handler which is passed to the Tree.
     * Removes filter from the dragged position and adds it to the dropped position.
     */
    var onDrop = function (dropObject) {
        var dragNode = dropObject.dragNode, node = dropObject.node;
        var newFilter = __spreadArray([], rootFilter, true);
        var dragNodePosition = dragNode.props.eventKey;
        var draggedFilter = (0, get_1.default)(rootFilter, dragNodePosition);
        var dragParentPosition = dragNodePosition.substring(0, dragNodePosition.length - 3);
        var dragParentFilter = dragParentPosition === ''
            ? rootFilter
            : (0, get_1.default)(rootFilter, dragParentPosition);
        var dragPositionArray = FilterUtil_1.default.positionStringAsArray(dragNodePosition);
        var dragSubPosition = dragPositionArray[dragPositionArray.length - 1];
        var dropTargetPosition = node.props.eventKey === '0-0' ? '' : node.props.eventKey;
        var dropParentPosition = dropTargetPosition.substring(0, dropTargetPosition.length - 3);
        var dropPositionArray = FilterUtil_1.default.positionStringAsArray(dropTargetPosition);
        var dropSubPosition = dropPositionArray[dropPositionArray.length - 1];
        var sameParent = dragParentPosition === dropParentPosition;
        var draggedLastRemaingChild = dragParentFilter.length <= 2;
        var removePositionArray = __spreadArray([], dragPositionArray, true);
        // Get remove position. Calculate the modified indexes after the node is added.
        // We dropped to the root node
        if (dropTargetPosition === '' || dropParentPosition === '') {
            var droppedBefore = dropTargetPosition === '' || dropPositionArray[0] < dragPositionArray[0];
            if (droppedBefore) {
                removePositionArray[0] = dragPositionArray[0] + 1;
            }
        }
        // We dropped inside the same CompositionFilter
        if (sameParent) {
            if (dropSubPosition < dragSubPosition) {
                var subIndex = removePositionArray.length - 1;
                removePositionArray[subIndex] = dragSubPosition + 1;
            }
        }
        else {
            if (draggedLastRemaingChild) {
                removePositionArray = FilterUtil_1.default.positionStringAsArray(dragParentPosition);
            }
        }
        var removePosition = FilterUtil_1.default.positionArrayAsString(removePositionArray);
        // Insert into new position
        newFilter = FilterUtil_1.default.insertAtPosition(newFilter, draggedFilter, dropTargetPosition);
        // Remove from old position
        newFilter = FilterUtil_1.default.removeAtPosition(newFilter, removePosition);
        onFilterChange(newFilter);
    };
    return (React.createElement(antd_1.Tree, __assign({ className: "gs-filter-tree", draggable: true, defaultExpandAll: true }, passThroughProps, { onDrop: onDrop }), getNodeByFilter(rootFilter)));
};
exports.FilterTree = FilterTree;
exports.default = (0, LocaleWrapper_1.localize)(exports.FilterTree, 'FilterTree');
//# sourceMappingURL=FilterTree.js.map