"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CqlParser = void 0;
var geostyler_style_1 = require("geostyler-style");
var lodash_1 = require("lodash");
// @ts-ignore:next-line
var cql_parser_1 = __importDefault(require("./cql-parser"));
var CqlParser = /** @class */ (function () {
    function CqlParser() {
        this.tokens = [
            'PROPERTY', 'COMPARISON', 'VALUE', 'LOGICAL'
        ];
        this.operatorsMap = {
            '=': '==',
            '<>': '!=',
            '<': '<',
            '<=': '<=',
            '>': '>',
            '>=': '>=',
            LIKE: '*=',
            BETWEEN: '<=x<='
        };
        this.operatorReverseMap = {};
        this.combinationOperatorsMap = {
            AND: '&&',
            OR: '||'
        };
        this.combinationOperatorsReverseMap = {};
        this.precedence = {
            RPAREN: 3,
            LOGICAL: 2,
            COMPARISON: 1
        };
        var _a = this, combinationOperatorsMap = _a.combinationOperatorsMap, combinationOperatorsReverseMap = _a.combinationOperatorsReverseMap, operatorsMap = _a.operatorsMap, operatorReverseMap = _a.operatorReverseMap;
        Object.keys(operatorsMap)
            .forEach(function (operator) {
            var value = operatorsMap[operator];
            operatorReverseMap[value] = operator;
        });
        Object.keys(combinationOperatorsMap)
            .forEach(function (combinationOperator) {
            var value = combinationOperatorsMap[combinationOperator];
            combinationOperatorsReverseMap[value] = combinationOperator;
        });
        this.read = this.read.bind(this);
        this.write = this.write.bind(this);
    }
    CqlParser.prototype.read = function (text) {
        try {
            return cql_parser_1.default.parse(text);
        }
        catch (e) {
            return undefined;
        }
    };
    CqlParser.prototype.write = function (filter, isChild) {
        var _this = this;
        var _a = this, operatorReverseMap = _a.operatorReverseMap, combinationOperatorsReverseMap = _a.combinationOperatorsReverseMap, write = _a.write;
        if (filter && (0, geostyler_style_1.isGeoStylerFunction)(filter)) {
            if (filter.name === 'pi' || filter.name === 'random') {
                return filter.name;
            }
            else {
                var args = filter.args.map(function (a) { return _this.write(a); }).join(', ');
                return "".concat(filter.name, "(").concat(args, ")");
            }
        }
        // catch illegal filters
        if (Array.isArray(filter)) {
            if (filter.length < 2) {
                return undefined;
            }
            if (!(0, geostyler_style_1.isOperator)(filter[0])) {
                throw new Error("Can't encode: ".concat(filter));
            }
        }
        if ((0, geostyler_style_1.isFilter)(filter)) {
            var operator = filter[0];
            var cqlOperator = operatorReverseMap[operator];
            switch (operator) {
                case '!':
                    // TODO this should be better typed, get rid of `as any`
                    return "NOT ( ".concat(write(filter[1]), " )");
                case '&&':
                case '||':
                    var cqlFilter = '';
                    var cqlCombinationOperator = combinationOperatorsReverseMap[operator];
                    cqlFilter += filter
                        .slice(1)
                        // TODO this should be better typed, get rid of `f: any`
                        .map(function (f) { return write(f, true); })
                        .join(" ".concat(cqlCombinationOperator, " "));
                    if (isChild) {
                        return "(".concat(cqlFilter, ")");
                    }
                    else {
                        return cqlFilter;
                    }
                case '==':
                case '*=':
                case '!=':
                case '<':
                case '<=':
                case '>':
                case '>=':
                    var valueIsString = (0, lodash_1.isString)(filter[2]);
                    var value = filter[2];
                    if (valueIsString) {
                        value = "'".concat(value, "'");
                    }
                    return "".concat(filter[1], " ").concat(cqlOperator, " ").concat(value);
                case '<=x<=':
                    return "".concat(filter[1], " ").concat(cqlOperator, " ").concat(this.write(filter[2]), " AND ").concat(this.write(filter[3]));
                case undefined:
                    break;
                default:
                    break;
            }
        }
        return filter;
    };
    return CqlParser;
}());
exports.CqlParser = CqlParser;
exports.default = CqlParser;
//# sourceMappingURL=CqlParser.js.map