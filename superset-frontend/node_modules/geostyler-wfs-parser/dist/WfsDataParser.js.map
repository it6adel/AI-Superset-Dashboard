{"version":3,"file":"WfsDataParser.js","sourceRoot":"","sources":["../src/WfsDataParser.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DataParser,\n  VectorData,\n  DataSchema,\n  SchemaProperty\n} from 'geostyler-data';\n\nimport { JSONSchema4TypeName } from 'json-schema';\n\nconst isEmpty = require('lodash/isEmpty');\nconst isFinite = require('lodash/isFinite');\n\nimport {\n  XMLParser\n} from 'fast-xml-parser';\n\nimport {\n  FeatureCollection\n} from 'geojson';\n\nexport type RequestBaseParams = {\n  service: 'WFS';\n  request: 'GetFeature' | 'DescribeFeatureType';\n  exceptions?: string;\n};\n\nexport type GetFeatureOptionalParams = {\n  featureID?: string;\n  propertyName?: string;\n  sortBy?: string;\n  srsName?: string;\n};\n\nexport type RequestParams1_1_0 = {\n  version: '1.1.0';\n  typeName: string;\n  maxFeatures?: number;\n  outputFormat?: 'application/json' | 'application/geo+json';\n};\n\nexport type RequestParams2_0_0 = {\n  version: '2.0.0';\n  typeNames: string;\n  count?: number;\n  outputFormat?: 'application/json' | 'application/geo+json';\n};\n\nexport type RequestParams = GetFeatureOptionalParams & (RequestParams1_1_0 | RequestParams2_0_0);\nexport type DescribeFeatureTypeParams = RequestBaseParams & (RequestParams1_1_0 | RequestParams2_0_0);\nexport type GetFeatureParams = DescribeFeatureTypeParams & GetFeatureOptionalParams;\n\n/**\n * Interface representing the parameters to be send to WFS\n */\nexport interface ReadParams {\n  url: string;\n  requestParams: RequestParams;\n  fetchParams?: RequestInit;\n}\n\n/**\n * Class implementing DataParser to fetch schema and sample data\n * using WFS requests (DescribeFeatureType resp. GetFeature)\n */\nexport class WfsDataParser implements DataParser {\n\n  /**\n   * The name of the WfsDataParser.\n   */\n  public static title = 'WFS Data Parser';\n\n  title = 'WFS Data Parser';\n\n  /**\n   * Generate request parameter string for a passed object\n   *\n   * @param {Object} params Object holding request params\n   * @return {string} The URI encoded request parameter string joined with &\n   */\n  generateRequestParamString(params: any): string {\n    return Object.keys(params)\n      .filter(key => !isEmpty(params[key]) || isFinite(params[key]))\n      .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))\n      .join('&');\n  }\n\n  /**\n   * Map XSD datatypes (SimpleType) to json schema data stypes\n   *\n   * @param qualifiedXsdDataType The XSD datatype as string (including namespace)\n   * @returns {JSONSchema4TypeName} The corresponding JSON schema type name\n   */\n  mapXsdTypeToJsonDataType(qualifiedXsdDataType: string): JSONSchema4TypeName {\n    const xsdDataType = qualifiedXsdDataType.indexOf(':') > -1\n      ? qualifiedXsdDataType.split(':')[1]\n      : qualifiedXsdDataType;\n\n    switch (xsdDataType) {\n      case 'string':\n        return 'string';\n      case 'boolean':\n        return 'boolean';\n      case 'float':\n      case 'double':\n      case 'long':\n      case 'byte':\n      case 'decimal':\n      case 'integer':\n      case 'int':\n      case 'positiveInteger':\n      case 'negativeInteger':\n      case 'nonPositiveInteger':\n      case 'nonNegativeInteger':\n      case 'short':\n      case 'unsignedLong':\n      case 'unsignedInt':\n      case 'unsignedShort':\n      case 'unsignedByte':\n        return 'number';\n      default:\n        return 'string';\n    }\n  }\n\n  /**\n   * Fetch schema and sample data and transforms it to the GeoStyler data model.\n   *\n   * Currently, WFS service must support application/json as outputFormat\n   * and needs CORS headers (only needed if WFS Service is not located on the same origin\n   * as the component using this parser) to be available in responses\n   *\n   * @param wfsConfig The parameters of the WFS\n   */\n  async readData({\n    url,\n    requestParams,\n    fetchParams = {}\n  }: ReadParams): Promise<VectorData> {\n\n    let desribeFeatureTypeOpts;\n\n    if (!requestParams.outputFormat) {\n      requestParams.outputFormat = 'application/json';\n    }\n\n    if (requestParams.version === '1.1.0') {\n      desribeFeatureTypeOpts = {\n        version: requestParams.version,\n        maxFeatures: requestParams.maxFeatures,\n        typeName: requestParams.typeName,\n        outputFormat: requestParams.outputFormat\n      };\n    } else {\n      desribeFeatureTypeOpts = {\n        version: requestParams.version,\n        count: requestParams.count,\n        typeNames: requestParams.typeNames,\n        outputFormat: requestParams.outputFormat\n      };\n    }\n\n    // Fetch data schema via describe feature type\n    let schema: DataSchema;\n    try {\n      const requestParamsString =  this.generateRequestParamString({\n        ...desribeFeatureTypeOpts,\n        service: 'WFS',\n        request: 'DescribeFeatureType',\n      });\n      const requestDescribeFeatureType = `${url}?${requestParamsString}`;\n      const describeFeatureTypeResponse = await fetch(requestDescribeFeatureType, fetchParams);\n      const describeFeatueTypeResult = await describeFeatureTypeResponse.text();\n      const parser = new XMLParser({\n        removeNSPrefix: true,\n        ignoreDeclaration: true,\n        ignoreAttributes: false\n      });\n      const result = parser.parse(describeFeatueTypeResult);\n\n      let attributes = result?.schema?.complexType?.complexContent?.extension?.sequence?.element\n\n      const properties: { [name: string]: SchemaProperty } = {};\n      if (attributes) {\n        if (!Array.isArray(attributes)) {\n          attributes = [attributes];\n        }\n        attributes.forEach((attr: any) => {\n          const name = attr['@_name'];\n          const type = attr['@_type'];\n          if (!properties[name]) {\n            const propertyType: SchemaProperty = {type: this.mapXsdTypeToJsonDataType(type)};\n            properties[name] = propertyType;\n          }\n        });\n      }\n\n      const title = result?.schema?.element?.['@_name'];\n\n      schema = {\n        type: 'object',\n        title,\n        properties\n      };\n    } catch (error) {\n      throw `Could not parse XML document: ${error}`;\n    }\n\n    // Fetch sample data via WFS GetFeature\n    let exampleFeatures: FeatureCollection;\n    try {\n      const requestGetFeature = `${url}?${this.generateRequestParamString({\n        ...requestParams,\n        service: 'WFS',\n        request: 'GetFeature',\n        outputFormat: 'application/json',\n      })}`;\n      const getFeatureResponse = await fetch(requestGetFeature, fetchParams);\n      const getFeatureResult = await getFeatureResponse.json();\n      exampleFeatures = getFeatureResult as FeatureCollection;\n    } catch (error) {\n      exampleFeatures = {\n        type: 'FeatureCollection',\n        features: []\n      };\n    }\n\n    return {\n      schema,\n      exampleFeatures\n    };\n  }\n\n}\n\nexport default WfsDataParser;\n"]}