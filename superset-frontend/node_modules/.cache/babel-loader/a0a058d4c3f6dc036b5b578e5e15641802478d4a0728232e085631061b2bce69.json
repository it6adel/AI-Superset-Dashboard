{"ast":null,"code":"import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport cx from 'classnames';\nimport { useCallback, useEffect, useRef, useMemo, useState, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport { styled, t, logging } from '@superset-ui/core';\n\nimport { useHistory } from 'react-router-dom';\nimport { bindActionCreators } from 'redux';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { exportChart, mountExploreUrl } from 'src/explore/exploreUtils';\nimport ChartContainer from 'src/components/Chart/ChartContainer';\nimport {\n  LOG_ACTIONS_CHANGE_DASHBOARD_FILTER,\n  LOG_ACTIONS_EXPLORE_DASHBOARD_CHART,\n  LOG_ACTIONS_EXPORT_CSV_DASHBOARD_CHART,\n  LOG_ACTIONS_EXPORT_XLSX_DASHBOARD_CHART,\n  LOG_ACTIONS_FORCE_REFRESH_CHART } from\n'src/logger/LogUtils';\nimport { postFormData } from 'src/explore/exploreUtils/formData';\nimport { URL_PARAMS } from 'src/constants';\nimport { enforceSharedLabelsColorsArray } from 'src/utils/colorScheme';\n\nimport SliceHeader from '../SliceHeader';\nimport MissingChart from '../MissingChart';\nimport {\n  addDangerToast,\n  addSuccessToast } from\n'../../../components/MessageToasts/actions';\nimport {\n  setFocusedFilterField,\n  toggleExpandSlice,\n  unsetFocusedFilterField } from\n'../../actions/dashboardState';\nimport { changeFilter } from '../../actions/dashboardFilters';\nimport { refreshChart } from '../../../components/Chart/chartAction';\nimport { logEvent } from '../../../logger/actions';\nimport {\n  getActiveFilters,\n  getAppliedFilterValues } from\n'../../util/activeDashboardFilters';\nimport getFormDataWithExtraFilters from '../../util/charts/getFormDataWithExtraFilters';\nimport { PLACEHOLDER_DATASOURCE } from '../../constants';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nconst propTypes = {\n  id: PropTypes.number.isRequired,\n  componentId: PropTypes.string.isRequired,\n  dashboardId: PropTypes.number.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  updateSliceName: PropTypes.func.isRequired,\n  isComponentVisible: PropTypes.bool,\n  handleToggleFullSize: PropTypes.func.isRequired,\n  setControlValue: PropTypes.func,\n  sliceName: PropTypes.string.isRequired,\n  isFullSize: PropTypes.bool,\n  extraControls: PropTypes.object,\n  isInView: PropTypes.bool\n};\n\n// we use state + shouldComponentUpdate() logic to prevent perf-wrecking\n// resizing across all slices on a dashboard on every update\nconst RESIZE_TIMEOUT = 500;\nconst DEFAULT_HEADER_HEIGHT = 22;\n\nconst ChartWrapper = styled.div`\n  overflow: hidden;\n  position: relative;\n\n  &.dashboard-chart--overflowable {\n    overflow: visible;\n  }\n`;\n\nconst ChartOverlay = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 5;\n`;\n\nconst SliceContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  max-height: 100%;\n`;\n\nconst EMPTY_OBJECT = {};\n\nconst Chart = (props) => {var _chart$form_data, _dataMask$props$id, _dataMask$props$id2;\n  const dispatch = useDispatch();\n  const descriptionRef = useRef(null);\n  const headerRef = useRef(null);\n\n  const boundActionCreators = useMemo(\n    () =>\n    bindActionCreators(\n      {\n        addSuccessToast,\n        addDangerToast,\n        toggleExpandSlice,\n        changeFilter,\n        setFocusedFilterField,\n        unsetFocusedFilterField,\n        refreshChart,\n        logEvent\n      },\n      dispatch\n    ),\n    [dispatch]\n  );\n\n  const chart = useSelector((state) => state.charts[props.id] || EMPTY_OBJECT);\n  const slice = useSelector(\n    (state) => state.sliceEntities.slices[props.id] || EMPTY_OBJECT\n  );\n  const editMode = useSelector((state) => state.dashboardState.editMode);\n  const isExpanded = useSelector(\n    (state) => !!state.dashboardState.expandedSlices[props.id]\n  );\n  const supersetCanExplore = useSelector(\n    (state) => !!state.dashboardInfo.superset_can_explore\n  );\n  const supersetCanShare = useSelector(\n    (state) => !!state.dashboardInfo.superset_can_share\n  );\n  const supersetCanCSV = useSelector(\n    (state) => !!state.dashboardInfo.superset_can_csv\n  );\n  const timeout = useSelector(\n    (state) => state.dashboardInfo.common.conf.SUPERSET_WEBSERVER_TIMEOUT\n  );\n  const emitCrossFilters = useSelector(\n    (state) => !!state.dashboardInfo.crossFiltersEnabled\n  );\n  const datasource = useSelector(\n    (state) =>\n    chart &&\n    chart.form_data &&\n    state.datasources[chart.form_data.datasource] ||\n    PLACEHOLDER_DATASOURCE\n  );\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n\n  const [descriptionHeight, setDescriptionHeight] = useState(0);\n  const [height, setHeight] = useState(props.height);\n  const [width, setWidth] = useState(props.width);\n  const history = useHistory();\n  const resize = useCallback(\n    _debounce(() => {\n      const { width, height } = props;\n      setHeight(height);\n      setWidth(width);\n    }, RESIZE_TIMEOUT),\n    [props.width, props.height]\n  );\n\n  const ownColorScheme = (_chart$form_data = chart.form_data) == null ? void 0 : _chart$form_data.color_scheme;\n\n  const addFilter = useCallback(\n    (newSelectedValues = {}) => {\n      boundActionCreators.logEvent(LOG_ACTIONS_CHANGE_DASHBOARD_FILTER, {\n        id: chart.id,\n        columns: Object.keys(newSelectedValues).filter(\n          (key) => newSelectedValues[key] !== null\n        )\n      });\n      boundActionCreators.changeFilter(chart.id, newSelectedValues);\n    },\n    [boundActionCreators.logEvent, boundActionCreators.changeFilter, chart.id]\n  );\n\n  useEffect(() => {\n    if (isExpanded) {var _descriptionRef$curre;\n      const descriptionHeight =\n      isExpanded && descriptionRef.current ? (_descriptionRef$curre =\n      descriptionRef.current) == null ? void 0 : _descriptionRef$curre.offsetHeight :\n      0;\n      setDescriptionHeight(descriptionHeight);\n    }\n  }, [isExpanded]);\n\n  useEffect(\n    () => () => {\n      resize.cancel();\n    },\n    [resize]\n  );\n\n  useEffect(() => {\n    resize();\n  }, [resize, props.isFullSize]);\n\n  const getHeaderHeight = useCallback(() => {\n    if (headerRef.current) {\n      const computedStyle = getComputedStyle(\n        headerRef.current\n      ).getPropertyValue('margin-bottom');\n      const marginBottom = parseInt(computedStyle, 10) || 0;\n      return headerRef.current.offsetHeight + marginBottom;\n    }\n    return DEFAULT_HEADER_HEIGHT;\n  }, [headerRef]);\n\n  const getChartHeight = useCallback(() => {\n    const headerHeight = getHeaderHeight();\n    return Math.max(height - headerHeight - descriptionHeight, 20);\n  }, [getHeaderHeight, height, descriptionHeight]);\n\n  const handleFilterMenuOpen = useCallback(\n    (chartId, column) => {\n      boundActionCreators.setFocusedFilterField(chartId, column);\n    },\n    [boundActionCreators.setFocusedFilterField]\n  );\n\n  const handleFilterMenuClose = useCallback(\n    (chartId, column) => {\n      boundActionCreators.unsetFocusedFilterField(chartId, column);\n    },\n    [boundActionCreators.unsetFocusedFilterField]\n  );\n\n  const logExploreChart = useCallback(() => {\n    boundActionCreators.logEvent(LOG_ACTIONS_EXPLORE_DASHBOARD_CHART, {\n      slice_id: slice.slice_id,\n      is_cached: props.isCached\n    });\n  }, [boundActionCreators.logEvent, slice.slice_id, props.isCached]);\n\n  const chartConfiguration = useSelector(\n    (state) => {var _state$dashboardInfo$;return (_state$dashboardInfo$ = state.dashboardInfo.metadata) == null ? void 0 : _state$dashboardInfo$.chart_configuration;}\n  );\n  const colorScheme = useSelector((state) => state.dashboardState.colorScheme);\n  const colorNamespace = useSelector(\n    (state) => state.dashboardState.colorNamespace\n  );\n  const datasetsStatus = useSelector(\n    (state) => state.dashboardState.datasetsStatus\n  );\n  const allSliceIds = useSelector((state) => state.dashboardState.sliceIds);\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  const dataMask = useSelector((state) => state.dataMask);\n  const labelsColor = useSelector(\n    (state) => {var _state$dashboardInfo, _state$dashboardInfo$2;return ((_state$dashboardInfo = state.dashboardInfo) == null ? void 0 : (_state$dashboardInfo$2 = _state$dashboardInfo.metadata) == null ? void 0 : _state$dashboardInfo$2.label_colors) || EMPTY_OBJECT;}\n  );\n  const labelsColorMap = useSelector(\n    (state) => {var _state$dashboardInfo2, _state$dashboardInfo3;return ((_state$dashboardInfo2 = state.dashboardInfo) == null ? void 0 : (_state$dashboardInfo3 = _state$dashboardInfo2.metadata) == null ? void 0 : _state$dashboardInfo3.map_label_colors) || EMPTY_OBJECT;}\n  );\n  const sharedLabelsColors = useSelector((state) => {var _state$dashboardInfo4, _state$dashboardInfo5;return (\n      enforceSharedLabelsColorsArray((_state$dashboardInfo4 =\n      state.dashboardInfo) == null ? void 0 : (_state$dashboardInfo5 = _state$dashboardInfo4.metadata) == null ? void 0 : _state$dashboardInfo5.shared_label_colors\n      ));}\n  );\n\n  const formData = useMemo(\n    () =>\n    getFormDataWithExtraFilters({\n      chart,\n      chartConfiguration,\n      filters: getAppliedFilterValues(props.id),\n      colorScheme,\n      colorNamespace,\n      sliceId: props.id,\n      nativeFilters,\n      allSliceIds,\n      dataMask,\n      extraControls: props.extraControls,\n      labelsColor,\n      labelsColorMap,\n      sharedLabelsColors,\n      ownColorScheme\n    }),\n    [\n    chart,\n    chartConfiguration,\n    props.id,\n    props.extraControls,\n    colorScheme,\n    colorNamespace,\n    nativeFilters,\n    allSliceIds,\n    dataMask,\n    labelsColor,\n    labelsColorMap,\n    sharedLabelsColors,\n    ownColorScheme]\n\n  );\n\n  formData.dashboardId = dashboardInfo.id;\n\n  const onExploreChart = useCallback(\n    async (clickEvent) => {\n      const isOpenInNewTab =\n      clickEvent.shiftKey || clickEvent.ctrlKey || clickEvent.metaKey;\n      try {\n        const lastTabId = window.localStorage.getItem('last_tab_id');\n        const nextTabId = lastTabId ?\n        String(Number.parseInt(lastTabId, 10) + 1) :\n        undefined;\n        const key = await postFormData(\n          datasource.id,\n          datasource.type,\n          formData,\n          slice.slice_id,\n          nextTabId\n        );\n        const url = mountExploreUrl(null, {\n          [URL_PARAMS.formDataKey.name]: key,\n          [URL_PARAMS.sliceId.name]: slice.slice_id\n        });\n        if (isOpenInNewTab) {\n          window.open(url, '_blank', 'noreferrer');\n        } else {\n          history.push(url);\n        }\n      } catch (error) {\n        logging.error(error);\n        boundActionCreators.addDangerToast(\n          t('An error occurred while opening Explore')\n        );\n      }\n    },\n    [\n    datasource.id,\n    datasource.type,\n    formData,\n    slice.slice_id,\n    boundActionCreators.addDangerToast,\n    history]\n\n  );\n\n  const exportTable = useCallback(\n    (format, isFullCSV, isPivot = false) => {\n      const logAction =\n      format === 'csv' ?\n      LOG_ACTIONS_EXPORT_CSV_DASHBOARD_CHART :\n      LOG_ACTIONS_EXPORT_XLSX_DASHBOARD_CHART;\n      boundActionCreators.logEvent(logAction, {\n        slice_id: slice.slice_id,\n        is_cached: props.isCached\n      });\n      exportChart({\n        formData: isFullCSV ?\n        { ...formData, row_limit: props.maxRows } :\n        formData,\n        resultType: isPivot ? 'post_processed' : 'full',\n        resultFormat: format,\n        force: true,\n        ownState: props.ownState\n      });\n    },\n    [\n    slice.slice_id,\n    props.isCached,\n    formData,\n    props.maxRows,\n    props.ownState,\n    boundActionCreators.logEvent]\n\n  );\n\n  const exportCSV = useCallback(\n    (isFullCSV = false) => {\n      exportTable('csv', isFullCSV);\n    },\n    [exportTable]\n  );\n\n  const exportFullCSV = useCallback(() => {\n    exportCSV(true);\n  }, [exportCSV]);\n\n  const exportPivotCSV = useCallback(() => {\n    exportTable('csv', false, true);\n  }, [exportTable]);\n\n  const exportXLSX = useCallback(() => {\n    exportTable('xlsx', false);\n  }, [exportTable]);\n\n  const exportFullXLSX = useCallback(() => {\n    exportTable('xlsx', true);\n  }, [exportTable]);\n\n  const forceRefresh = useCallback(() => {\n    boundActionCreators.logEvent(LOG_ACTIONS_FORCE_REFRESH_CHART, {\n      slice_id: slice.slice_id,\n      is_cached: props.isCached\n    });\n    return boundActionCreators.refreshChart(chart.id, true, props.dashboardId);\n  }, [\n  boundActionCreators.refreshChart,\n  chart.id,\n  props.dashboardId,\n  slice.slice_id,\n  props.isCached,\n  boundActionCreators.logEvent]\n  );\n\n  if (chart === EMPTY_OBJECT || slice === EMPTY_OBJECT) {\n    return _jsx(MissingChart, { height: getChartHeight() });\n  }\n\n  const { queriesResponse, chartUpdateEndTime, chartStatus, annotationQuery } =\n  chart;\n  const isLoading = chartStatus === 'loading';\n  // eslint-disable-next-line camelcase\n  const isCached = (queriesResponse == null ? void 0 : queriesResponse.map(({ is_cached }) => is_cached)) || [];\n  const cachedDttm =\n  // eslint-disable-next-line camelcase\n  (queriesResponse == null ? void 0 : queriesResponse.map(({ cached_dttm }) => cached_dttm)) || [];\n\n  return (\n    _jsxs(SliceContainer, {\n      className: \"chart-slice\",\n\n      \"data-test-chart-id\": props.id,\n      \"data-test-viz-type\": slice.viz_type,\n      \"data-test-chart-name\": slice.slice_name, children: [\n\n      _jsx(SliceHeader, {\n        ref: headerRef,\n        slice: slice,\n        isExpanded: isExpanded,\n        isCached: isCached,\n        cachedDttm: cachedDttm,\n        updatedDttm: chartUpdateEndTime,\n        toggleExpandSlice: boundActionCreators.toggleExpandSlice,\n        forceRefresh: forceRefresh,\n        editMode: editMode,\n        annotationQuery: annotationQuery,\n        logExploreChart: logExploreChart,\n        logEvent: boundActionCreators.logEvent,\n        onExploreChart: onExploreChart,\n        exportCSV: exportCSV,\n        exportPivotCSV: exportPivotCSV,\n        exportXLSX: exportXLSX,\n        exportFullCSV: exportFullCSV,\n        exportFullXLSX: exportFullXLSX,\n        updateSliceName: props.updateSliceName,\n        sliceName: props.sliceName,\n        supersetCanExplore: supersetCanExplore,\n        supersetCanShare: supersetCanShare,\n        supersetCanCSV: supersetCanCSV,\n        componentId: props.componentId,\n        dashboardId: props.dashboardId,\n        filters: getActiveFilters() || EMPTY_OBJECT,\n        addSuccessToast: boundActionCreators.addSuccessToast,\n        addDangerToast: boundActionCreators.addDangerToast,\n        handleToggleFullSize: props.handleToggleFullSize,\n        isFullSize: props.isFullSize,\n        chartStatus: chartStatus,\n        formData: formData,\n        width: width,\n        height: getHeaderHeight() }\n      ),\n\n\n\n\n\n\n\n\n      isExpanded && slice.description_markeddown &&\n      _jsx(\"div\", {\n        className: \"slice_description bs-callout bs-callout-default\",\n        ref: descriptionRef\n        // eslint-disable-next-line react/no-danger\n        , dangerouslySetInnerHTML: { __html: slice.description_markeddown },\n        role: \"complementary\" }\n      ),\n\n\n      _jsxs(ChartWrapper, {\n        className: cx('dashboard-chart'),\n        \"aria-label\": slice.description, children: [\n\n        isLoading &&\n        _jsx(ChartOverlay, {\n          style: {\n            width,\n            height: getChartHeight()\n          } }\n        ),\n\n\n        _jsx(ChartContainer, {\n          width: width,\n          height: getChartHeight(),\n          addFilter: addFilter,\n          onFilterMenuOpen: handleFilterMenuOpen,\n          onFilterMenuClose: handleFilterMenuClose,\n          annotationData: chart.annotationData,\n          chartAlert: chart.chartAlert,\n          chartId: props.id,\n          chartStatus: chartStatus,\n          datasource: datasource,\n          dashboardId: props.dashboardId,\n          initialValues: EMPTY_OBJECT,\n          formData: formData,\n          labelsColor: labelsColor,\n          labelsColorMap: labelsColorMap,\n          ownState: (_dataMask$props$id = dataMask[props.id]) == null ? void 0 : _dataMask$props$id.ownState,\n          filterState: (_dataMask$props$id2 = dataMask[props.id]) == null ? void 0 : _dataMask$props$id2.filterState,\n          queriesResponse: chart.queriesResponse,\n          timeout: timeout,\n          triggerQuery: chart.triggerQuery,\n          vizType: slice.viz_type,\n          setControlValue: props.setControlValue,\n          datasetsStatus: datasetsStatus,\n          isInView: props.isInView,\n          emitCrossFilters: emitCrossFilters }\n        )] }\n      )] }\n    ));\n\n};\n\nChart.propTypes = propTypes;\n\nexport default /*#__PURE__*/memo(Chart, (prevProps, nextProps) => {\n  if (prevProps.cacheBusterProp !== nextProps.cacheBusterProp) {\n    return false;\n  }\n  return (\n    !nextProps.isComponentVisible ||\n    prevProps.isInView === nextProps.isInView &&\n    prevProps.componentId === nextProps.componentId &&\n    prevProps.id === nextProps.id &&\n    prevProps.dashboardId === nextProps.dashboardId &&\n    prevProps.extraControls === nextProps.extraControls &&\n    prevProps.handleToggleFullSize === nextProps.handleToggleFullSize &&\n    prevProps.isFullSize === nextProps.isFullSize &&\n    prevProps.setControlValue === nextProps.setControlValue &&\n    prevProps.sliceName === nextProps.sliceName &&\n    prevProps.updateSliceName === nextProps.updateSliceName &&\n    prevProps.width === nextProps.width &&\n    prevProps.height === nextProps.height);\n\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}