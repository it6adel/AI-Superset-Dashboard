{"ast":null,"code":"import _isObject from \"lodash/isObject\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { convertKeysToCamelCase } from '@superset-ui/core';\n\nconst COLUMN_SEPARATOR = ', ';\n/**\n * Get the indices of columns where the title is a geojson.\n *\n * @param columns List of column names.\n * @returns List of indices containing geojsonColumns.\n */\nexport const getGeojsonColumns = (columns) => columns.reduce((prev, current, idx) => {\n  let parsedColName;\n  try {\n    parsedColName = JSON.parse(current);\n  }\n  catch {\n    parsedColName = undefined;\n  }\n  if (!parsedColName || !_isObject(parsedColName)) {\n    return [...prev];\n  }\n  if (!('type' in parsedColName) || !('coordinates' in parsedColName)) {\n    return [...prev];\n  }\n  return [...prev, idx];\n}, []);\n/**\n * Create a column name ignoring provided indices.\n *\n * @param columns List of column names.\n * @param ignoreIdx List of indices to ignore.\n * @returns Column name.\n */\nexport const createColumnName = (columns, ignoreIdx) => columns.filter((l, idx) => !ignoreIdx.includes(idx)).join(COLUMN_SEPARATOR);\n/**\n * Group data by location for data providing a generic\n * x-axis.\n *\n * @param data The data to group.\n * @param params The data params.\n * @returns Data grouped by location.\n */\nexport const groupByLocationGenericX = (data, params, queryData) => {\n  const locations = {};\n  if (!data) {\n    return locations;\n  }\n  data.forEach((d) => {\n    Object.keys(d).\n    filter((k) => k !== params.x_axis).\n    forEach((k) => {var _queryData$label_map;\n      const labelMap = (_queryData$label_map = queryData.label_map) == null ? void 0 : _queryData$label_map[k];\n      if (!labelMap) {\n        console.log('Cannot extract location from queryData. label_map not defined');\n        return;\n      }\n      const geojsonCols = getGeojsonColumns(labelMap);\n      if (geojsonCols.length > 1) {\n        // TODO what should we do, if there is more than one geom column?\n        console.log('More than one geometry column detected. Using first found.');\n      }\n      const location = labelMap[geojsonCols[0]];\n      const filter = geojsonCols.length ? [geojsonCols[0]] : [];\n      const leftOverKey = createColumnName(labelMap, filter);\n      if (!Object.keys(locations).includes(location)) {\n        locations[location] = [];\n      }\n      let dataAtX = locations[location].find((i) => i[params.x_axis] === d[params.x_axis]);\n      if (!dataAtX) {\n        dataAtX = {\n          // add the x_axis value explicitly, since we\n          // filtered it out for the rest of the computation.\n          [params.x_axis]: d[params.x_axis]\n        };\n        locations[location].push(dataAtX);\n      }\n      dataAtX[leftOverKey] = d[k];\n    });\n  });\n  return locations;\n};\n/**\n * Group data by location.\n *\n * @param data The incoming dataset\n * @param geomColumn The name of the geometry column\n * @returns The grouped data\n */\nexport const groupByLocation = (data, geomColumn) => {\n  const locations = {};\n  data.forEach((d) => {\n    const loc = d[geomColumn];\n    if (!loc) {\n      return;\n    }\n    if (!Object.keys(locations).includes(loc)) {\n      locations[loc] = [];\n    }\n    const newData = {\n      ...d\n    };\n    delete newData[geomColumn];\n    locations[loc].push(newData);\n  });\n  return locations;\n};\n/**\n * Strips the geom from colnames and coltypes.\n *\n * @param queryData The querydata.\n * @param geomColumn Name of the geom column.\n * @returns colnames and coltypes without the geom.\n */\nexport const stripGeomFromColnamesAndTypes = (queryData, geomColumn) => {var _queryData$colnames;\n  const newColnames = [];\n  const newColtypes = [];\n  (_queryData$colnames = queryData.colnames) == null ? void 0 : _queryData$colnames.forEach((colname, idx) => {\n    if (colname === geomColumn) {\n      return;\n    }\n    const parts = colname.split(COLUMN_SEPARATOR);\n    const geojsonColumns = getGeojsonColumns(parts);\n    const filter = geojsonColumns.length ? [geojsonColumns[0]] : [];\n    const newColname = createColumnName(parts, filter);\n    if (newColnames.includes(newColname)) {\n      return;\n    }\n    newColnames.push(newColname);\n    newColtypes.push(queryData.coltypes[idx]);\n  });\n  return {\n    colnames: newColnames,\n    coltypes: newColtypes\n  };\n};\n/**\n * Strips the geom from labelMap.\n *\n * @param queryData The querydata.\n * @param geomColumn Name of the geom column.\n * @returns labelMap without the geom column.\n */\nexport const stripGeomColumnFromLabelMap = (labelMap, geomColumn) => {\n  const newLabelMap = {};\n  Object.entries(labelMap).forEach(([key, value]) => {\n    if (key === geomColumn) {\n      return;\n    }\n    const geojsonCols = getGeojsonColumns(value);\n    const filter = geojsonCols.length ? [geojsonCols[0]] : [];\n    const columnName = createColumnName(value, filter);\n    const restItems = value.filter((v, idx) => !geojsonCols.includes(idx));\n    newLabelMap[columnName] = restItems;\n  });\n  return newLabelMap;\n};\n/**\n * Strip occurrences of the geom column from the query data.\n *\n * @param queryDataClone The query data\n * @param geomColumn The name of the geom column\n * @returns query data without geom column.\n */\nexport const stripGeomColumnFromQueryData = (queryData, geomColumn) => {\n  const queryDataClone = {\n    ...structuredClone(queryData),\n    ...stripGeomFromColnamesAndTypes(queryData, geomColumn)\n  };\n  if (queryDataClone.label_map) {\n    queryDataClone.label_map = stripGeomColumnFromLabelMap(queryData.label_map, geomColumn);\n  }\n  return queryDataClone;\n};\n/**\n * Create the chart configurations depending on the referenced Superset chart.\n *\n * @param selectedChart The configuration of the referenced Superset chart\n * @param geomColumn The name of the geometry column\n * @param chartProps The properties provided within this OL plugin\n * @param chartTransformer The transformer function\n * @returns The chart configurations\n */\nexport const getChartConfigs = (selectedChart, geomColumn, chartProps, chartTransformer) => {\n  const chartFormDataSnake = selectedChart.params;\n  const chartFormData = convertKeysToCamelCase(chartFormDataSnake);\n  const baseConfig = {\n    ...chartProps,\n    // We overwrite width and height, which are not needed\n    // here, but leads to unnecessary updating of the UI.\n    width: null,\n    height: null,\n    formData: chartFormData,\n    rawFormData: chartFormDataSnake,\n    datasource: {}\n  };\n  const { queriesData } = chartProps;\n  const [queryData] = queriesData;\n  const data = queryData.data;\n  let dataByLocation;\n  const chartConfigs = {\n    type: 'FeatureCollection',\n    features: []\n  };\n  if (!data) {\n    return chartConfigs;\n  }\n  if ('x_axis' in selectedChart.params) {\n    dataByLocation = groupByLocationGenericX(data, selectedChart.params, queryData);\n  } else\n  {\n    dataByLocation = groupByLocation(data, geomColumn);\n  }\n  const strippedQueryData = stripGeomColumnFromQueryData(queryData, geomColumn);\n  Object.keys(dataByLocation).forEach((location) => {\n    const config = {\n      ...baseConfig,\n      queriesData: [\n      {\n        ...strippedQueryData,\n        data: dataByLocation[location]\n      }]\n\n    };\n    const transformedProps = chartTransformer(config);\n    const feature = {\n      type: 'Feature',\n      geometry: JSON.parse(location),\n      properties: {\n        ...transformedProps\n      }\n    };\n    chartConfigs.features.push(feature);\n  });\n  return chartConfigs;\n};\n/**\n * Return the same chart configuration with parsed values for of the stringified \"params\" object.\n *\n * @param selectedChart Incoming chart configuration\n * @returns Chart configuration with parsed values for \"params\"\n */\nexport const parseSelectedChart = (selectedChart) => {\n  const selectedChartParsed = JSON.parse(selectedChart);\n  selectedChartParsed.params = JSON.parse(selectedChartParsed.params);\n  return selectedChartParsed;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}