{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Children, cloneElement, useRef, useMemo, useLayoutEffect, useCallback } from 'react';\nimport getScrollBarSize from '../utils/getScrollBarSize';\nimport needScrollBar from '../utils/needScrollBar';\nimport useMountedMemo from '../utils/useMountedMemo';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nexport var ReducerActions;\n(function (ReducerActions) {\n  ReducerActions[\"Init\"] = \"init\";\n  ReducerActions[\"SetStickyState\"] = \"setStickyState\";\n})(ReducerActions || (ReducerActions = {}));\nconst sum = (a, b) => a + b;\nconst mergeStyleProp = (node, style) => ({\n  style: {\n    ...node.props.style,\n    ...style\n  }\n});\nconst fixedTableLayout = { tableLayout: 'fixed' };\n/**\n * An HOC for generating sticky header and fixed-height scrollable area\n */\nfunction StickyWrap({ sticky = {}, width: maxWidth, height: maxHeight, children: table, setStickyState }) {\n  if (!table || table.type !== 'table') {\n    throw new Error('<StickyWrap> must have only one <table> element as child');\n  }\n  let thead;\n  let tbody;\n  let tfoot;\n  Children.forEach(table.props.children, (node) => {\n    if (!node) {\n      return;\n    }\n    if (node.type === 'thead') {\n      thead = node;\n    } else\n    if (node.type === 'tbody') {\n      tbody = node;\n    } else\n    if (node.type === 'tfoot') {\n      tfoot = node;\n    }\n  });\n  if (!thead || !tbody) {\n    throw new Error('<table> in <StickyWrap> must contain both thead and tbody.');\n  }\n  const columnCount = useMemo(() => {var _thead;\n    const headerRows = Children.toArray((_thead = thead) == null ? void 0 : _thead.props.children).pop();\n    return headerRows.props.children.length;\n  }, [thead]);\n  const theadRef = useRef(null); // original thead for layout computation\n  const tfootRef = useRef(null); // original tfoot for layout computation\n  const scrollHeaderRef = useRef(null); // fixed header\n  const scrollFooterRef = useRef(null); // fixed footer\n  const scrollBodyRef = useRef(null); // main body\n  const scrollBarSize = getScrollBarSize();\n  const { bodyHeight, columnWidths } = sticky;\n  const needSizer = !columnWidths ||\n  sticky.width !== maxWidth ||\n  sticky.height !== maxHeight ||\n  sticky.setStickyState !== setStickyState;\n  // update scrollable area and header column sizes when mounted\n  useLayoutEffect(() => {var _bodyThead$childNodes, _bodyThead$childNodes2;\n    if (!theadRef.current) {\n      return;\n    }\n    const bodyThead = theadRef.current;\n    const theadHeight = bodyThead.clientHeight;\n    const tfootHeight = tfootRef.current ? tfootRef.current.clientHeight : 0;\n    if (!theadHeight) {\n      return;\n    }\n    const fullTableHeight = bodyThead.parentNode.\n    clientHeight;\n    // instead of always using the first tr, we use the last one to support\n    // multi-level headers assuming the last one is the more detailed one\n    const ths = (_bodyThead$childNodes = bodyThead.childNodes) == null ? void 0 : _bodyThead$childNodes[((_bodyThead$childNodes2 = bodyThead.childNodes) == null ? void 0 : _bodyThead$childNodes2.length) - 1 || 0].\n    childNodes;\n    const widths = Array.from(ths).map((th) => {var _th$getBoundingClient;return ((_th$getBoundingClient = th.getBoundingClientRect()) == null ? void 0 : _th$getBoundingClient.width) || th.clientWidth;});\n    const [hasVerticalScroll, hasHorizontalScroll] = needScrollBar({\n      width: maxWidth,\n      height: maxHeight - theadHeight - tfootHeight,\n      innerHeight: fullTableHeight,\n      innerWidth: widths.reduce(sum),\n      scrollBarSize\n    });\n    // real container height, include table header, footer and space for\n    // horizontal scroll bar\n    const realHeight = Math.min(maxHeight, hasHorizontalScroll ? fullTableHeight + scrollBarSize : fullTableHeight);\n    setStickyState({\n      hasVerticalScroll,\n      hasHorizontalScroll,\n      setStickyState,\n      width: maxWidth,\n      height: maxHeight,\n      realHeight,\n      tableHeight: fullTableHeight,\n      bodyHeight: realHeight - theadHeight - tfootHeight,\n      columnWidths: widths\n    });\n  }, [maxWidth, maxHeight, setStickyState, scrollBarSize]);\n  let sizerTable;\n  let headerTable;\n  let footerTable;\n  let bodyTable;\n  if (needSizer) {\n    const theadWithRef = /*#__PURE__*/cloneElement(thead, { ref: theadRef });\n    const tfootWithRef = tfoot && /*#__PURE__*/cloneElement(tfoot, { ref: tfootRef });\n    sizerTable = _jsx(\"div\", { style: {\n        height: maxHeight,\n        overflow: 'auto',\n        visibility: 'hidden',\n        scrollbarGutter: 'stable'\n      }, role: \"presentation\", children: /*#__PURE__*/\n      cloneElement(table, { role: 'presentation' }, theadWithRef, tbody, tfootWithRef) }, \"sizer\"\n    );\n  }\n  // reuse previously column widths, will be updated by `useLayoutEffect` above\n  const colWidths = columnWidths == null ? void 0 : columnWidths.slice(0, columnCount);\n  if (colWidths && bodyHeight) {\n    const colgroup = _jsx(\"colgroup\", { children:\n      colWidths.map((w, i) =>\n      // eslint-disable-next-line react/no-array-index-key\n      _jsx(\"col\", { width: w }, i)) }\n    );\n    headerTable = _jsxs(\"div\", { ref: scrollHeaderRef, style: {\n        overflow: 'hidden',\n        scrollbarGutter: 'stable'\n      }, role: \"presentation\", children: [/*#__PURE__*/\n      cloneElement(/*#__PURE__*/cloneElement(table, { role: 'presentation' }), mergeStyleProp(table, fixedTableLayout), colgroup, thead),\n      headerTable] }, \"header\"\n    );\n    footerTable = tfoot && _jsxs(\"div\", { ref: scrollFooterRef, style: {\n        overflow: 'hidden',\n        scrollbarGutter: 'stable'\n      }, role: \"presentation\", children: [/*#__PURE__*/\n      cloneElement(/*#__PURE__*/cloneElement(table, { role: 'presentation' }), mergeStyleProp(table, fixedTableLayout), colgroup, tfoot),\n      footerTable] }, \"footer\"\n    );\n    const onScroll = (e) => {\n      if (scrollHeaderRef.current) {\n        scrollHeaderRef.current.scrollLeft = e.currentTarget.scrollLeft;\n      }\n      if (scrollFooterRef.current) {\n        scrollFooterRef.current.scrollLeft = e.currentTarget.scrollLeft;\n      }\n    };\n    bodyTable = _jsx(\"div\", { ref: scrollBodyRef, style: {\n        height: bodyHeight,\n        overflow: 'auto',\n        scrollbarGutter: 'stable'\n      }, onScroll: sticky.hasHorizontalScroll ? onScroll : undefined, role: \"presentation\", children: /*#__PURE__*/\n      cloneElement(/*#__PURE__*/cloneElement(table, { role: 'presentation' }), mergeStyleProp(table, fixedTableLayout), colgroup, tbody) }, \"body\"\n    );\n  }\n  return _jsxs(\"div\", { style: {\n      width: maxWidth,\n      height: sticky.realHeight || maxHeight,\n      overflow: 'hidden'\n    }, role: \"table\", children: [\n    headerTable,\n    bodyTable,\n    footerTable,\n    sizerTable] }\n  );\n}\nfunction useInstance(instance) {\n  const { dispatch, state: { sticky }, data, page, rows, allColumns, getTableSize = () => undefined } = instance;\n  const setStickyState = useCallback((size) => {\n    dispatch({\n      type: ReducerActions.SetStickyState,\n      size\n    });\n  },\n  // turning pages would also trigger a resize\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [dispatch, getTableSize, page, rows]);\n  const useStickyWrap = (renderer) => {\n    const { width, height } = useMountedMemo(getTableSize, [getTableSize]) || sticky;\n    // only change of data should trigger re-render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const table = useMemo(renderer, [page, rows, allColumns]);\n    useLayoutEffect(() => {\n      if (!width || !height) {\n        setStickyState();\n      }\n    }, [width, height]);\n    if (!width || !height) {\n      return null;\n    }\n    if (data.length === 0) {\n      return table;\n    }\n    return _jsx(StickyWrap, { width: width, height: height, sticky: sticky, setStickyState: setStickyState, children:\n      table }\n    );\n  };\n  Object.assign(instance, {\n    setStickyState,\n    wrapStickyTable: useStickyWrap\n  });\n}\nexport default function useSticky(hooks) {\n  hooks.useInstance.push(useInstance);\n  hooks.stateReducers.push((newState, action_, prevState) => {\n    const action = action_;\n    if (action.type === ReducerActions.Init) {\n      return {\n        ...newState,\n        sticky: {\n          ...(prevState == null ? void 0 : prevState.sticky)\n        }\n      };\n    }\n    if (action.type === ReducerActions.SetStickyState) {\n      const { size } = action;\n      if (!size) {\n        return { ...newState };\n      }\n      return {\n        ...newState,\n        sticky: {\n          ...(prevState == null ? void 0 : prevState.sticky),\n          ...(newState == null ? void 0 : newState.sticky),\n          ...action.size\n        }\n      };\n    }\n    return newState;\n  });\n}\nuseSticky.pluginName = 'useSticky';","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}