{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// eslint-disable-next-line no-restricted-syntax -- whole React import is required for `ControlPopover.test.tsx` Jest test passing.\nimport React, { useCallback, useRef, useEffect, useState } from 'react';\nimport Popover from 'src/components/Popover';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst sectionContainerId = 'controlSections';\nexport const getSectionContainerElement = () => {var _document$getElementB;return (_document$getElementB = document.getElementById(sectionContainerId)) == null ? void 0 : _document$getElementB.lastElementChild;};\nconst getElementVisibilityRatio = (node) => {var _window, _window2;\n  const containerHeight = (_window = window) == null ? void 0 : _window.innerHeight;\n  const containerWidth = (_window2 = window) == null ? void 0 : _window2.innerWidth;\n  const rect = node == null ? void 0 : node.getBoundingClientRect();\n  if (!containerHeight || !containerWidth || !(rect != null && rect.top)) {\n    return { yRatio: 0, xRatio: 0 };\n  }\n  const yRatio = rect.top / containerHeight;\n  const xRatio = rect.left / containerWidth;\n  return { yRatio, xRatio };\n};\nconst ControlPopover = ({ getPopupContainer, getVisibilityRatio = getElementVisibilityRatio, open: visibleProp, destroyTooltipOnHide = false, placement: initialPlacement = 'right', ...props }) => {\n  const triggerElementRef = useRef();\n  const [visible, setVisible] = useState(visibleProp === undefined ? props.defaultOpen : visibleProp);\n  const [placement, setPlacement] = React.useState(initialPlacement);\n  const calculatePlacement = useCallback(() => {\n    if (!triggerElementRef.current)\n    return;\n    const { yRatio, xRatio } = getVisibilityRatio(triggerElementRef.current);\n    const horizontalPlacement = xRatio < 0.35 ? 'right' : xRatio > 0.65 ? 'left' : '';\n    const verticalPlacement = (() => {\n      if (yRatio < 0.35)\n      return horizontalPlacement ? 'top' : 'bottom';\n      if (yRatio > 0.65)\n      return horizontalPlacement ? 'bottom' : 'top';\n      return '';\n    })();\n    const newPlacement = (horizontalPlacement ?\n    horizontalPlacement +\n    verticalPlacement.charAt(0).toUpperCase() +\n    verticalPlacement.slice(1) :\n    verticalPlacement) || 'left';\n    if (newPlacement !== placement) {\n      setPlacement(newPlacement);\n    }\n  }, [getVisibilityRatio]);\n  const changeContainerScrollStatus = useCallback((visible) => {\n    const element = getSectionContainerElement();\n    if (element) {\n      element.style.setProperty('overflow-y', visible ? 'hidden' : 'auto', 'important');\n    }\n  }, [calculatePlacement]);\n  const handleGetPopupContainer = useCallback((triggerNode) => {\n    triggerElementRef.current = triggerNode;\n    return (getPopupContainer == null ? void 0 : getPopupContainer(triggerNode)) || document.body;\n  }, [calculatePlacement, getPopupContainer]);\n  const handleOnVisibleChange = useCallback((visible) => {\n    if (visible === undefined) {\n      changeContainerScrollStatus(visible);\n    }\n    setVisible(!!visible);\n    props.onOpenChange == null ? void 0 : props.onOpenChange(!!visible);\n  }, [props, changeContainerScrollStatus]);\n  const handleDocumentKeyDownListener = useCallback((event) => {\n    if (event.key === 'Escape') {\n      setVisible(false);\n      props.onOpenChange == null ? void 0 : props.onOpenChange(false);\n    }\n  }, [props]);\n  useEffect(() => {\n    if (visibleProp !== undefined) {\n      setVisible(!!visibleProp);\n    }\n  }, [visibleProp]);\n  useEffect(() => {\n    if (visible !== undefined) {\n      changeContainerScrollStatus(visible);\n    }\n  }, [visible, changeContainerScrollStatus]);\n  useEffect(() => {\n    if (visible) {\n      document.addEventListener('keydown', handleDocumentKeyDownListener);\n    }\n    return () => {\n      document.removeEventListener('keydown', handleDocumentKeyDownListener);\n    };\n  }, [handleDocumentKeyDownListener, visible]);\n  useEffect(() => {\n    if (visible) {\n      calculatePlacement();\n    }\n  }, [visible, calculatePlacement]);\n  return _jsx(Popover, { ...props, open: visible, arrow: { pointAtCenter: true }, placement: placement, onOpenChange: handleOnVisibleChange, getPopupContainer: handleGetPopupContainer, destroyTooltipOnHide: destroyTooltipOnHide });\n};\nexport default ControlPopover;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}