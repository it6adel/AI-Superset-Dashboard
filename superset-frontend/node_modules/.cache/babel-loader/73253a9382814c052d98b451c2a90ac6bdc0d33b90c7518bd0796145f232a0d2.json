{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getMetricLabel, tooltipHtml } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA, DEFAULT_TREE_SERIES_OPTION } from './constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function formatTooltip({ params, metricLabel }) {\n  const { value, treeAncestors } = params;\n  const treePath = (treeAncestors != null ? treeAncestors : []).\n  map((pathInfo) => (pathInfo == null ? void 0 : pathInfo.name) || '').\n  filter((path) => path !== '');\n  const row = value ? [metricLabel, String(value)] : [];\n  return tooltipHtml([row], treePath.join(' â–¸ '));\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, queriesData } = chartProps;\n  const refs = {};\n  const data = queriesData[0].data || [];\n  const { id, parent, name, metric = '', rootNodeId, layout, orient, symbol, symbolSize, roam, nodeLabelPosition, childLabelPosition, emphasis } = { ...DEFAULT_FORM_DATA, ...formData };\n  const metricLabel = getMetricLabel(metric);\n  const nameColumn = name || id;\n  function findNodeName(rootNodeId) {\n    let nodeName = '';\n    data.some((node) => {\n      if (node[id].toString() === rootNodeId) {\n        nodeName = node[nameColumn];\n        return true;\n      }\n      return false;\n    });\n    return nodeName;\n  }\n  function getTotalChildren(tree) {\n    let totalChildren = 0;\n    function traverse(tree) {\n      tree.children.forEach((node) => {\n        traverse(node);\n      });\n      totalChildren += 1;\n    }\n    traverse(tree);\n    return totalChildren;\n  }\n  function createTree(rootNodeId) {\n    const rootNodeName = findNodeName(rootNodeId);\n    const tree = { name: rootNodeName, children: [] };\n    const children = [];\n    const indexMap = {};\n    if (!rootNodeName) {\n      return tree;\n    }\n    // index indexMap with node ids\n    for (let i = 0; i < data.length; i += 1) {\n      const nodeId = data[i][id];\n      indexMap[nodeId] = i;\n      children[i] = [];\n    }\n    // generate tree\n    for (let i = 0; i < data.length; i += 1) {var _node$parent;\n      const node = data[i];\n      if (((_node$parent = node[parent]) == null ? void 0 : _node$parent.toString()) === rootNodeId) {var _tree$children;\n        (_tree$children = tree.children) == null ? void 0 : _tree$children.push({\n          name: node[nameColumn],\n          children: children[i],\n          value: node[metricLabel]\n        });\n      } else\n      {\n        const parentId = node[parent];\n        if (data[indexMap[parentId]]) {\n          const parentIndex = indexMap[parentId];\n          children[parentIndex].push({\n            name: node[nameColumn],\n            children: children[i],\n            value: node[metricLabel]\n          });\n        }\n      }\n    }\n    return tree;\n  }\n  let finalTree = {};\n  if (rootNodeId) {\n    finalTree = createTree(rootNodeId);\n  } else\n  {\n    /*\n      to select root node,\n      1.find parent nodes with only 1 child.\n      2.build tree for each such child nodes as root\n      3.select tree with most children\n    */\n    // create map of parent:children\n    const parentChildMap = {};\n    data.forEach((node) => {\n      const parentId = node[parent];\n      if (parentId in parentChildMap) {\n        parentChildMap[parentId].push({ id: node[id] });\n      } else\n      {\n        parentChildMap[parentId] = [{ id: node[id] }];\n      }\n    });\n    // for each parent node which has only 1 child,find tree and select node with max number of children.\n    let maxChildren = 0;\n    Object.keys(parentChildMap).forEach((key) => {\n      if (parentChildMap[key].length === 1) {\n        const tree = createTree(parentChildMap[key][0].id);\n        const totalChildren = getTotalChildren(tree);\n        if (totalChildren > maxChildren) {\n          maxChildren = totalChildren;\n          finalTree = tree;\n        }\n      }\n    });\n  }\n  const series = [\n  {\n    type: 'tree',\n    data: [finalTree],\n    label: {\n      ...DEFAULT_TREE_SERIES_OPTION.label,\n      position: nodeLabelPosition\n    },\n    emphasis: { focus: emphasis },\n    animation: DEFAULT_TREE_SERIES_OPTION.animation,\n    layout,\n    orient,\n    symbol,\n    roam,\n    symbolSize,\n    lineStyle: DEFAULT_TREE_SERIES_OPTION.lineStyle,\n    select: DEFAULT_TREE_SERIES_OPTION.select,\n    leaves: { label: { position: childLabelPosition } }\n  }];\n\n  const echartOptions = {\n    animationDuration: DEFAULT_TREE_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_TREE_SERIES_OPTION.animationEasing,\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: (params) => formatTooltip({\n        params,\n        metricLabel\n      })\n    }\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    refs\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}