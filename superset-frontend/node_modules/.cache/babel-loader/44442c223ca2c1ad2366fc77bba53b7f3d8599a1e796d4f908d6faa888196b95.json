{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-env browser */\nimport { createRef, PureComponent } from 'react';\nimport { Radio } from 'src/components/Radio';\nimport { Input } from 'src/components/Input';\nimport Button from 'src/components/Button';\nimport { t } from '@superset-ui/core';\nimport ModalTrigger from 'src/components/ModalTrigger';\nimport Checkbox from 'src/components/Checkbox';\nimport { SAVE_TYPE_OVERWRITE, SAVE_TYPE_NEWDASHBOARD } from 'src/dashboard/util/constants';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst defaultProps = {\n  saveType: SAVE_TYPE_OVERWRITE,\n  colorNamespace: undefined,\n  colorScheme: undefined,\n  shouldPersistRefreshFrequency: false\n};\nclass SaveModal extends PureComponent {\n\n\n\n  constructor(props) {\n    super(props);this.modal = void 0;this.onSave = void 0;\n    this.state = {\n      saveType: props.saveType,\n      newDashName: `${props.dashboardTitle} ${t('[copy]')}`,\n      duplicateSlices: false\n    };\n    this.handleSaveTypeChange = this.handleSaveTypeChange.bind(this);\n    this.handleNameChange = this.handleNameChange.bind(this);\n    this.saveDashboard = this.saveDashboard.bind(this);\n    this.toggleDuplicateSlices = this.toggleDuplicateSlices.bind(this);\n    this.onSave = this.props.onSave.bind(this);\n    this.modal = /*#__PURE__*/createRef();\n  }\n  toggleDuplicateSlices() {\n    this.setState((prevState) => ({\n      duplicateSlices: !prevState.duplicateSlices\n    }));\n  }\n  handleSaveTypeChange(event) {\n    this.setState({\n      saveType: event.target.value\n    });\n  }\n  handleNameChange(name) {\n    this.setState({\n      newDashName: name,\n      saveType: SAVE_TYPE_NEWDASHBOARD\n    });\n  }\n  saveDashboard() {var _dashboardInfo$metada;\n    const { saveType, newDashName } = this.state;\n    const { dashboardTitle, dashboardInfo, layout: positions, customCss, dashboardId, refreshFrequency: currentRefreshFrequency, shouldPersistRefreshFrequency, lastModifiedTime } = this.props;\n    // check refresh frequency is for current session or persist\n    const refreshFrequency = shouldPersistRefreshFrequency ?\n    currentRefreshFrequency : (_dashboardInfo$metada =\n    dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada.refresh_frequency; // eslint-disable camelcase\n    const data = {\n      certified_by: dashboardInfo.certified_by,\n      certification_details: dashboardInfo.certification_details,\n      css: customCss,\n      dashboard_title: saveType === SAVE_TYPE_NEWDASHBOARD ? newDashName : dashboardTitle,\n      duplicate_slices: this.state.duplicateSlices,\n      last_modified_time: lastModifiedTime,\n      owners: dashboardInfo.owners,\n      roles: dashboardInfo.roles,\n      metadata: {\n        ...(dashboardInfo == null ? void 0 : dashboardInfo.metadata),\n        positions,\n        refresh_frequency: refreshFrequency\n      }\n    };\n    if (saveType === SAVE_TYPE_NEWDASHBOARD && !newDashName) {\n      this.props.addDangerToast(t('You must pick a name for the new dashboard'));\n    } else\n    {var _this$modal, _this$modal$current;\n      this.onSave(data, dashboardId, saveType).then((resp) => {var _resp$json, _resp$json$result;\n        if (saveType === SAVE_TYPE_NEWDASHBOARD && (_resp$json = resp.json) != null && (_resp$json$result = _resp$json.result) != null && _resp$json$result.id) {\n          window.location.href = `/superset/dashboard/${resp.json.result.id}/`;\n        }\n      });\n      (_this$modal = this.modal) == null ? void 0 : (_this$modal$current = _this$modal.current) == null ? void 0 : _this$modal$current.close == null ? void 0 : _this$modal$current.close();\n    }\n  }\n  render() {\n    return _jsx(ModalTrigger, { ref: this.modal, triggerNode: this.props.triggerNode, modalTitle: t('Save dashboard'), modalBody: _jsxs(\"div\", { children: [\n        _jsx(Radio, { value: SAVE_TYPE_OVERWRITE, onChange: this.handleSaveTypeChange, checked: this.state.saveType === SAVE_TYPE_OVERWRITE, disabled: !this.props.canOverwrite, children:\n          t('Overwrite Dashboard [%s]', this.props.dashboardTitle) }\n        ),\n        _jsx(\"hr\", {}),\n        _jsx(Radio, { value: SAVE_TYPE_NEWDASHBOARD, onChange: this.handleSaveTypeChange, checked: this.state.saveType === SAVE_TYPE_NEWDASHBOARD, children:\n          t('Save as:') }\n        ),\n        _jsx(Input, { type: \"text\", placeholder: t('[dashboard name]'), value: this.state.newDashName, onFocus: (e) => this.handleNameChange(e.target.value), onChange: (e) => this.handleNameChange(e.target.value) }),\n        _jsxs(\"div\", { className: \"m-l-25 m-t-5\", children: [\n          _jsx(Checkbox, { checked: this.state.duplicateSlices, onChange: () => this.toggleDuplicateSlices() }),\n          _jsx(\"span\", { className: \"m-l-5\", children: t('also copy (duplicate) charts') })] }\n        )] }\n      ), modalFooter: _jsx(\"div\", { children:\n        _jsx(Button, { buttonStyle: \"primary\", onClick: this.saveDashboard, children:\n          t('Save') }\n        ) }\n      ) });\n  }\n}SaveModal.defaultProps = defaultProps;\nexport default SaveModal;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}