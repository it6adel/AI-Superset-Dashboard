{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getTimeFormatter, getColumnLabel, getNumberFormatter } from '@superset-ui/core';\nimport { useCallback } from 'react';\nimport Echart from '../components/Echart';\nimport { NULL_STRING } from '../constants';\nimport { extractTreePathInfo } from './constants';\nimport { formatSeriesName } from '../utils/series';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport default function EchartsTreemap({ echartOptions, emitCrossFilters, groupby, height, labelMap, onContextMenu, refs, setDataMask, selectedValues, width, formData, coltypeMapping }) {\n  const getCrossFilterDataMask = useCallback((data, treePathInfo) => {\n    if (data != null && data.children) {\n      return undefined;\n    }\n    const { treePath } = extractTreePathInfo(treePathInfo);\n    const name = treePath.join(',');\n    const selected = Object.values(selectedValues);\n    let values;\n    if (selected.includes(name)) {\n      values = selected.filter((v) => v !== name);\n    } else\n    {\n      values = [name];\n    }\n    const groupbyValues = values.map((value) => labelMap[value]);\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: values.length === 0 ?\n          [] :\n          groupby.map((col, idx) => {\n            const val = groupbyValues.map((v) => v[idx]);\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL'\n            };\n            return {\n              col,\n              op: 'IN',\n              val: val\n            };\n          })\n        },\n        filterState: {\n          value: groupbyValues.length ? groupbyValues : null,\n          selectedValues: values.length ? values : null\n        }\n      },\n      isCurrentValueSelected: selected.includes(name)\n    };\n  }, [groupby, labelMap, selectedValues]);\n  const handleChange = useCallback((data, treePathInfo) => {var _getCrossFilterDataMa;\n    if (!emitCrossFilters || groupby.length === 0) {\n      return;\n    }\n    const dataMask = (_getCrossFilterDataMa = getCrossFilterDataMask(data, treePathInfo)) == null ? void 0 : _getCrossFilterDataMa.dataMask;\n    if (dataMask) {\n      setDataMask(dataMask);\n    }\n  }, [emitCrossFilters, getCrossFilterDataMask, setDataMask]);\n  const eventHandlers = {\n    click: (props) => {\n      const { data, treePathInfo } = props;\n      handleChange(data, treePathInfo);\n    },\n    contextmenu: async (eventParams) => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, treePathInfo } = eventParams;\n        const { treePath } = extractTreePathInfo(treePathInfo);\n        if (treePath.length > 0) {\n          const pointerEvent = eventParams.event.event;\n          const drillToDetailFilters = [];\n          const drillByFilters = [];\n          treePath.forEach((path, i) => {\n            const val = path === 'null' ? NULL_STRING : path;\n            drillToDetailFilters.push({\n              col: groupby[i],\n              op: '==',\n              val,\n              formattedVal: path\n            });\n            drillByFilters.push({\n              col: groupby[i],\n              op: '==',\n              val,\n              formattedVal: formatSeriesName(val, {\n                timeFormatter: getTimeFormatter(formData.dateFormat),\n                numberFormatter: getNumberFormatter(formData.numberFormat),\n                coltype: coltypeMapping == null ? void 0 : coltypeMapping[getColumnLabel(groupby[i])]\n              })\n            });\n          });\n          onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n            drillToDetail: drillToDetailFilters,\n            crossFilter: groupby.length > 0 ?\n            getCrossFilterDataMask(data, treePathInfo) :\n            undefined,\n            drillBy: { filters: drillByFilters, groupbyFieldName: 'groupby' }\n          });\n        }\n      }\n    }\n  };\n  return _jsx(Echart, { refs: refs, height: height, width: width, echartOptions: echartOptions, eventHandlers: eventHandlers, selectedValues: selectedValues });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}