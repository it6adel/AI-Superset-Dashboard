{"ast":null,"code":"import _pick from \"lodash/pick\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { createSelector } from '@reduxjs/toolkit';\nimport { LabelsColorMapSource, getLabelsColorMap } from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\n\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { useChartIds } from 'src/dashboard/util/charts/useChartIds';\nimport { applyDashboardLabelsColorOnLoad, updateDashboardLabelsColor, persistDashboardLabelsColor, ensureSyncedSharedLabelsColors, ensureSyncedLabelsColorMap } from 'src/dashboard/actions/dashboardState';\nimport { CHART_TYPE } from 'src/dashboard/util/componentTypes';\nimport { getColorNamespace, resetColors } from 'src/utils/colorScheme';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';import { Fragment as _Fragment, jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport const renderedChartIdsSelector = createSelector([(state) => state.charts], (charts) => Object.values(charts).\nfilter((chart) => chart.chartStatus === 'rendered').\nmap((chart) => chart.id));\nconst useRenderedChartIds = () => {\n  const renderedChartIds = useSelector(renderedChartIdsSelector);\n  return useMemo(() => renderedChartIds, [JSON.stringify(renderedChartIds)]);\n};\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  return useMemo(() => nativeFilters ?\n  Object.values(nativeFilters).map((filter) => _pick(filter, ['id', 'scope', 'type'])) :\n  [], [nativeFilters]);\n};\nconst TOP_OF_PAGE_RANGE = 220;\nconst DashboardContainer = ({ topLevelTabs }) => {var _dashboardInfo$metada2;\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const chartIds = useChartIds();\n  const renderedChartIds = useRenderedChartIds();\n  const [dashboardLabelsColorInitiated, setDashboardLabelsColorInitiated] = useState(false);\n  const prevRenderedChartIds = useRef([]);\n  const prevTabIndexRef = useRef();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild\n    });\n    if (nextTabIndex === -1) {var _prevTabIndexRef$curr;\n      return (_prevTabIndexRef$curr = prevTabIndexRef.current) != null ? _prevTabIndexRef$curr : 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n  // when all charts have rendered, enforce fresh shared labels\n  const shouldForceFreshSharedLabelsColors = dashboardLabelsColorInitiated &&\n  renderedChartIds.length > 0 &&\n  chartIds.length === renderedChartIds.length &&\n  prevRenderedChartIds.current.length < renderedChartIds.length;\n  const onBeforeUnload = useCallback(() => {var _dashboardInfo$metada;\n    dispatch(persistDashboardLabelsColor());\n    resetColors(getColorNamespace(dashboardInfo == null ? void 0 : (_dashboardInfo$metada = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada.color_namespace));\n    prevRenderedChartIds.current = [];\n  }, [dashboardInfo == null ? void 0 : (_dashboardInfo$metada2 = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada2.color_namespace, dispatch]);\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map((filterScope) => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: []\n        };\n      }\n      const chartLayoutItems = Object.values(dashboardLayout).filter((item) => (item == null ? void 0 : item.type) === CHART_TYPE);\n      const chartsInScope = getChartIdsInFilterScope(filterScope.scope, chartIds, chartLayoutItems);\n      const tabsInScope = findTabsWithChartsInScope(chartLayoutItems, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [chartIds, JSON.stringify(nativeFilterScopes), dashboardLayout, dispatch]);\n  const childIds = useMemo(() => topLevelTabs ? topLevelTabs.children : [DASHBOARD_GRID_ID], [topLevelTabs]);\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  useEffect(() => {\n    if (shouldForceFreshSharedLabelsColors) {\n      // all available charts have rendered, enforce freshest shared label colors\n      dispatch(ensureSyncedSharedLabelsColors(dashboardInfo.metadata, true));\n    }\n  }, [dashboardInfo.metadata, dispatch, shouldForceFreshSharedLabelsColors]);\n  useEffect(() => {\n    // verify freshness of color map\n    // when charts render to catch new labels\n    const numRenderedCharts = renderedChartIds.length;\n    if (dashboardLabelsColorInitiated &&\n    numRenderedCharts > 0 &&\n    prevRenderedChartIds.current.length < numRenderedCharts) {\n      const newRenderedChartIds = renderedChartIds.filter((id) => !prevRenderedChartIds.current.includes(id));\n      prevRenderedChartIds.current = renderedChartIds;\n      dispatch(updateDashboardLabelsColor(newRenderedChartIds));\n      // new data may have appeared in the map (data changes)\n      // or new slices may have appeared while changing tabs\n      dispatch(ensureSyncedLabelsColorMap(dashboardInfo.metadata));\n      if (!shouldForceFreshSharedLabelsColors) {\n        dispatch(ensureSyncedSharedLabelsColors(dashboardInfo.metadata));\n      }\n    }\n  }, [\n  renderedChartIds,\n  dispatch,\n  dashboardLabelsColorInitiated,\n  dashboardInfo.metadata,\n  shouldForceFreshSharedLabelsColors]\n  );\n  useEffect(() => {\n    const labelsColorMap = getLabelsColorMap();\n    labelsColorMap.source = LabelsColorMapSource.Dashboard;\n    if (dashboardInfo != null && dashboardInfo.id && !dashboardLabelsColorInitiated) {\n      dispatch(applyDashboardLabelsColorOnLoad(dashboardInfo.metadata));\n      // apply labels color as dictated by stored metadata (if any)\n      setDashboardLabelsColorInitiated(true);\n    }\n    return () => {\n      onBeforeUnload();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dashboardInfo == null ? void 0 : dashboardInfo.id, dispatch]);\n  useEffect(() => {\n    // 'beforeunload' event interferes with Cypress data cleanup process.\n    // This code prevents 'beforeunload' from triggering in Cypress tests,\n    // as it is not required for end-to-end testing scenarios.\n    if (!window.Cypress) {\n      window.addEventListener('beforeunload', onBeforeUnload);\n    }\n    return () => {\n      window.removeEventListener('beforeunload', onBeforeUnload);\n    };\n  }, [onBeforeUnload]);\n  const renderTabBar = useCallback(() => _jsx(_Fragment, {}), []);\n  const handleFocus = useCallback((e) => {\n    if (\n    // prevent scrolling when tabbing to the tab pane\n    e.target.classList.contains('ant-tabs-tabpane') &&\n    window.scrollY < TOP_OF_PAGE_RANGE) {\n      // prevent window from jumping down when tabbing\n      // if already at the top of the page\n      // to help with accessibility when using keyboard navigation\n      window.scrollTo(window.scrollX, 0);\n    }\n  }, []);\n  const renderParentSizeChildren = useCallback(({ width }) =>\n  /*\n  We use a TabContainer irrespective of whether top-level tabs exist to maintain\n  a consistent React component tree. This avoids expensive mounts/unmounts of\n  the entire dashboard upon adding/removing top-level tabs, which would otherwise\n  happen because of React's diffing algorithm\n  */\n  _jsx(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: renderTabBar, fullWidth: false, animated: false, allowOverflow: true, onFocus: handleFocus, children:\n    childIds.map((id, index) =>\n    // Matching the key of the first TabPane irrespective of topLevelTabs\n    // lets us keep the same React component tree when !!topLevelTabs changes.\n    // This avoids expensive mounts/unmounts of the entire dashboard.\n    _jsx(Tabs.TabPane, { children:\n      _jsx(DashboardGrid, { gridComponent: dashboardLayout[id]\n        // see isValidChild for why tabs do not increment the depth of their children\n        , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n        , width: width, isComponentVisible: index === tabIndex }) }, index === 0 ? DASHBOARD_GRID_ID : index.toString()\n    )) }\n  ), [activeKey, childIds, dashboardLayout, handleFocus, renderTabBar, tabIndex]);\n  return _jsx(\"div\", { className: \"grid-container\", children:\n    _jsx(ParentSize, { children: renderParentSizeChildren }) }\n  );\n};\nexport default /*#__PURE__*/memo(DashboardContainer);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}