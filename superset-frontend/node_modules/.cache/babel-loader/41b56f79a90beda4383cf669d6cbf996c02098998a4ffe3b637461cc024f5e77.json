{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint no-use-before-define: [\"error\", { \"functions\": false }] */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable react/sort-prop-types */\nimport d3 from 'd3';\nimport PropTypes from 'prop-types';\nimport nv from 'nvd3-fork';\nimport {\n  getTimeFormatter,\n  getNumberFormatter,\n  CategoricalColorNamespace } from\n'@superset-ui/core';\n\nconst propTypes = {\n  // Data is an object hashed by numeric value, perhaps timestamp\n  data: PropTypes.objectOf(\n    PropTypes.arrayOf(\n      PropTypes.shape({\n        key: PropTypes.arrayOf(PropTypes.string),\n        name: PropTypes.arrayOf(PropTypes.string),\n        time: PropTypes.number,\n        value: PropTypes.number\n      })\n    )\n  ),\n  width: PropTypes.number,\n  height: PropTypes.number,\n  dateTimeFormat: PropTypes.string,\n  numberFormat: PropTypes.string,\n  useRichTooltip: PropTypes.bool,\n  useAreaProportions: PropTypes.bool,\n  colorScheme: PropTypes.string\n};\n\nfunction copyArc(d) {\n  return {\n    startAngle: d.startAngle,\n    endAngle: d.endAngle,\n    innerRadius: d.innerRadius,\n    outerRadius: d.outerRadius\n  };\n}\n\nfunction sortValues(a, b) {\n  if (a.value === b.value) {\n    return a.name > b.name ? 1 : -1;\n  }\n\n  return b.value - a.value;\n}\n\nfunction Rose(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorScheme,\n    dateTimeFormat,\n    numberFormat,\n    useRichTooltip,\n    useAreaProportions,\n    sliceId\n  } = props;\n\n  const div = d3.select(element);\n  div.classed('superset-legacy-chart-rose', true);\n\n  const datum = data;\n  const times = Object.keys(datum).\n  map((t) => parseInt(t, 10)).\n  sort((a, b) => a - b);\n  const numGrains = times.length;\n  const numGroups = datum[times[0]].length;\n  const format = getNumberFormatter(numberFormat);\n  const timeFormat = getTimeFormatter(dateTimeFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n\n  d3.select('.nvtooltip').remove();\n  div.selectAll('*').remove();\n\n  const arc = d3.svg.arc();\n  const legend = nv.models.legend();\n  const tooltip = nv.models.tooltip();\n  const state = { disabled: datum[times[0]].map(() => false) };\n\n  const svg = div.append('svg').attr('width', width).attr('height', height);\n\n  const g = svg.append('g').attr('class', 'rose').append('g');\n\n  const legendWrap = g.append('g').attr('class', 'legendWrap');\n\n  function legendData(adatum) {\n    return adatum[times[0]].map((v, i) => ({\n      disabled: state.disabled[i],\n      key: v.name\n    }));\n  }\n\n  function tooltipData(d, i, adatum) {\n    const timeIndex = Math.floor(d.arcId / numGroups);\n    const series = useRichTooltip ?\n    adatum[times[timeIndex]].\n    filter((v) => !state.disabled[v.id % numGroups]).\n    map((v) => ({\n      key: v.name,\n      value: v.value,\n      color: colorFn(v.name, sliceId),\n      highlight: v.id === d.arcId\n    })) :\n    [\n    {\n      key: d.name,\n      value: d.val,\n      color: colorFn(d.name, sliceId)\n    }];\n\n\n    return {\n      key: 'Date',\n      value: d.time,\n      series\n    };\n  }\n\n  legend.width(width).color((d) => colorFn(d.key, sliceId));\n  legendWrap.datum(legendData(datum)).call(legend);\n\n  tooltip.headerFormatter(timeFormat).valueFormatter(format);\n  tooltip.classes('tooltip');\n\n  // Compute max radius, which the largest value will occupy\n  const roseHeight = height - legend.height();\n  const margin = { top: legend.height() };\n  const edgeMargin = 35; // space between outermost radius and slice edge\n  const maxRadius = Math.min(width, roseHeight) / 2 - edgeMargin;\n  const labelThreshold = 0.05;\n  const gro = 8; // mouseover radius growth in pixels\n  const mini = 0.075;\n\n  const centerTranslate = `translate(${width / 2},${\n  roseHeight / 2 + margin.top})`;\n\n  const roseWrap = g.\n  append('g').\n  attr('transform', centerTranslate).\n  attr('class', 'roseWrap');\n\n  const labelsWrap = g.\n  append('g').\n  attr('transform', centerTranslate).\n  attr('class', 'labelsWrap');\n\n  const groupLabelsWrap = g.\n  append('g').\n  attr('transform', centerTranslate).\n  attr('class', 'groupLabelsWrap');\n\n  // Compute inner and outer angles for each data point\n  function computeArcStates(adatum) {\n    // Find the max sum of values across all time\n    let maxSum = 0;\n    let grain = 0;\n    const sums = [];\n    for (const t of times) {\n      const sum = datum[t].reduce(\n        (a, v, i) => a + (state.disabled[i] ? 0 : v.value),\n        0\n      );\n      maxSum = sum > maxSum ? sum : maxSum;\n      sums[grain] = sum;\n      grain += 1;\n    }\n\n    // Compute angle occupied by each time grain\n    const dtheta = Math.PI * 2 / numGrains;\n    const angles = [];\n    for (let i = 0; i <= numGrains; i += 1) {\n      angles.push(dtheta * i - Math.PI / 2);\n    }\n\n    // Compute proportion\n    const P = maxRadius / maxSum;\n    const Q = P * maxRadius;\n    const computeOuterRadius = (value, innerRadius) =>\n    useAreaProportions ?\n    Math.sqrt(Q * value + innerRadius * innerRadius) :\n    P * value + innerRadius;\n\n    const arcSt = {\n      data: [],\n      extend: {},\n      push: {},\n      pieStart: {},\n      pie: {},\n      pieOver: {},\n      mini: {},\n      labels: [],\n      groupLabels: []\n    };\n    let arcId = 0;\n    for (let i = 0; i < numGrains; i += 1) {\n      const t = times[i];\n      const startAngle = angles[i];\n      const endAngle = angles[i + 1];\n      const G = 2 * Math.PI / sums[i];\n      let innerRadius = 0;\n      let outerRadius;\n      let pieStartAngle = 0;\n      let pieEndAngle;\n      for (const v of adatum[t]) {\n        const val = state.disabled[arcId % numGroups] ? 0 : v.value;\n        const { name, time } = v;\n        v.id = arcId;\n        outerRadius = computeOuterRadius(val, innerRadius);\n        arcSt.data.push({\n          startAngle,\n          endAngle,\n          innerRadius,\n          outerRadius,\n          name,\n          arcId,\n          val,\n          time\n        });\n        arcSt.extend[arcId] = {\n          startAngle,\n          endAngle,\n          innerRadius,\n          name,\n          outerRadius: outerRadius + gro\n        };\n        arcSt.push[arcId] = {\n          startAngle,\n          endAngle,\n          innerRadius: innerRadius + gro,\n          outerRadius: outerRadius + gro\n        };\n        arcSt.pieStart[arcId] = {\n          startAngle,\n          endAngle,\n          innerRadius: mini * maxRadius,\n          outerRadius: maxRadius\n        };\n        arcSt.mini[arcId] = {\n          startAngle,\n          endAngle,\n          innerRadius: innerRadius * mini,\n          outerRadius: outerRadius * mini\n        };\n        arcId += 1;\n        innerRadius = outerRadius;\n      }\n      const labelArc = { ...arcSt.data[i * numGroups] };\n      labelArc.outerRadius = maxRadius + 20;\n      labelArc.innerRadius = maxRadius + 15;\n      arcSt.labels.push(labelArc);\n      for (const v of adatum[t].concat().sort(sortValues)) {\n        const val = state.disabled[v.id % numGroups] ? 0 : v.value;\n        pieEndAngle = G * val + pieStartAngle;\n        arcSt.pie[v.id] = {\n          startAngle: pieStartAngle,\n          endAngle: pieEndAngle,\n          innerRadius: maxRadius * mini,\n          outerRadius: maxRadius,\n          percent: v.value / sums[i]\n        };\n        arcSt.pieOver[v.id] = {\n          startAngle: pieStartAngle,\n          endAngle: pieEndAngle,\n          innerRadius: maxRadius * mini,\n          outerRadius: maxRadius + gro\n        };\n        pieStartAngle = pieEndAngle;\n      }\n    }\n    arcSt.groupLabels = arcSt.data.slice(0, numGroups);\n\n    return arcSt;\n  }\n\n  let arcSt = computeArcStates(datum);\n\n  function tween(target, resFunc) {\n    return function doTween(d) {\n      const interpolate = d3.interpolate(copyArc(d), copyArc(target));\n\n      return (t) => resFunc(Object.assign(d, interpolate(t)));\n    };\n  }\n\n  function arcTween(target) {\n    return tween(target, (d) => arc(d));\n  }\n\n  function translateTween(target) {\n    return tween(target, (d) => `translate(${arc.centroid(d)})`);\n  }\n\n  // Grab the ID range of segments stand between\n  // this segment and the edge of the circle\n  const segmentsToEdgeCache = {};\n  function getSegmentsToEdge(arcId) {\n    if (segmentsToEdgeCache[arcId]) {\n      return segmentsToEdgeCache[arcId];\n    }\n    const timeIndex = Math.floor(arcId / numGroups);\n    segmentsToEdgeCache[arcId] = [arcId + 1, numGroups * (timeIndex + 1) - 1];\n\n    return segmentsToEdgeCache[arcId];\n  }\n\n  // Get the IDs of all segments in a timeIndex\n  const segmentsInTimeCache = {};\n  function getSegmentsInTime(arcId) {\n    if (segmentsInTimeCache[arcId]) {\n      return segmentsInTimeCache[arcId];\n    }\n    const timeIndex = Math.floor(arcId / numGroups);\n    segmentsInTimeCache[arcId] = [\n    timeIndex * numGroups,\n    (timeIndex + 1) * numGroups - 1];\n\n\n    return segmentsInTimeCache[arcId];\n  }\n\n  let clickId = -1;\n  let inTransition = false;\n  const ae = roseWrap.\n  selectAll('g').\n  data(JSON.parse(JSON.stringify(arcSt.data))) // deep copy data state\n  .enter().\n  append('g').\n  attr('class', 'segment').\n  classed('clickable', true).\n  on('mouseover', mouseover).\n  on('mouseout', mouseout).\n  on('mousemove', mousemove).\n  on('click', click);\n\n  const labels = labelsWrap.\n  selectAll('g').\n  data(JSON.parse(JSON.stringify(arcSt.labels))).\n  enter().\n  append('g').\n  attr('class', 'roseLabel').\n  attr('transform', (d) => `translate(${arc.centroid(d)})`);\n\n  labels.\n  append('text').\n  style('text-anchor', 'middle').\n  style('fill', '#000').\n  text((d) => timeFormat(d.time));\n\n  const groupLabels = groupLabelsWrap.\n  selectAll('g').\n  data(JSON.parse(JSON.stringify(arcSt.groupLabels))).\n  enter().\n  append('g');\n\n  groupLabels.\n  style('opacity', 0).\n  attr('class', 'roseGroupLabels').\n  append('text').\n  style('text-anchor', 'middle').\n  style('fill', '#000').\n  text((d) => d.name);\n\n  const arcs = ae.\n  append('path').\n  attr('class', 'arc').\n  attr('fill', (d) => colorFn(d.name, sliceId)).\n  attr('d', arc);\n\n  function mousemove() {\n    tooltip();\n  }\n\n  function mouseover(b, i) {\n    tooltip.data(tooltipData(b, i, datum)).hidden(false);\n    const $this = d3.select(this);\n    $this.classed('hover', true);\n    if (clickId < 0 && !inTransition) {\n      $this.\n      select('path').\n      interrupt().\n      transition().\n      duration(180).\n      attrTween('d', arcTween(arcSt.extend[i]));\n      const edge = getSegmentsToEdge(i);\n      arcs.\n      filter((d) => edge[0] <= d.arcId && d.arcId <= edge[1]).\n      interrupt().\n      transition().\n      duration(180).\n      attrTween('d', (d) => arcTween(arcSt.push[d.arcId])(d));\n    } else if (!inTransition) {\n      const segments = getSegmentsInTime(clickId);\n      if (segments[0] <= b.arcId && b.arcId <= segments[1]) {\n        $this.\n        select('path').\n        interrupt().\n        transition().\n        duration(180).\n        attrTween('d', arcTween(arcSt.pieOver[i]));\n      }\n    }\n  }\n\n  function mouseout(b, i) {\n    tooltip.hidden(true);\n    const $this = d3.select(this);\n    $this.classed('hover', false);\n    if (clickId < 0 && !inTransition) {\n      $this.\n      select('path').\n      interrupt().\n      transition().\n      duration(180).\n      attrTween('d', arcTween(arcSt.data[i]));\n      const edge = getSegmentsToEdge(i);\n      arcs.\n      filter((d) => edge[0] <= d.arcId && d.arcId <= edge[1]).\n      interrupt().\n      transition().\n      duration(180).\n      attrTween('d', (d) => arcTween(arcSt.data[d.arcId])(d));\n    } else if (!inTransition) {\n      const segments = getSegmentsInTime(clickId);\n      if (segments[0] <= b.arcId && b.arcId <= segments[1]) {\n        $this.\n        select('path').\n        interrupt().\n        transition().\n        duration(180).\n        attrTween('d', arcTween(arcSt.pie[i]));\n      }\n    }\n  }\n\n  function click(b, i) {\n    if (inTransition) {\n      return;\n    }\n    const delay = d3.event.altKey ? 3750 : 375;\n    const segments = getSegmentsInTime(i);\n    if (clickId < 0) {\n      inTransition = true;\n      clickId = i;\n      labels.\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('transform', (d) =>\n      translateTween({\n        outerRadius: 0,\n        innerRadius: 0,\n        startAngle: d.startAngle,\n        endAngle: d.endAngle\n      })(d)\n      ).\n      style('opacity', 0);\n      groupLabels.\n      attr(\n        'transform',\n        `translate(${arc.centroid({\n          outerRadius: maxRadius + 20,\n          innerRadius: maxRadius + 15,\n          startAngle: arcSt.data[i].startAngle,\n          endAngle: arcSt.data[i].endAngle\n        })})`\n      ).\n      interrupt().\n      transition().\n      delay(delay).\n      duration(delay).\n      attrTween('transform', (d) =>\n      translateTween({\n        outerRadius: maxRadius + 20,\n        innerRadius: maxRadius + 15,\n        startAngle: arcSt.pie[segments[0] + d.arcId].startAngle,\n        endAngle: arcSt.pie[segments[0] + d.arcId].endAngle\n      })(d)\n      ).\n      style('opacity', (d) =>\n      state.disabled[d.arcId] ||\n      arcSt.pie[segments[0] + d.arcId].percent < labelThreshold ?\n      0 :\n      1\n      );\n      ae.classed(\n        'clickable',\n        (d) => segments[0] > d.arcId || d.arcId > segments[1]\n      );\n      arcs.\n      filter((d) => segments[0] <= d.arcId && d.arcId <= segments[1]).\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('d', (d) => arcTween(arcSt.pieStart[d.arcId])(d)).\n      transition().\n      duration(delay).\n      attrTween('d', (d) => arcTween(arcSt.pie[d.arcId])(d)).\n      each('end', () => {\n        inTransition = false;\n      });\n      arcs.\n      filter((d) => segments[0] > d.arcId || d.arcId > segments[1]).\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('d', (d) => arcTween(arcSt.mini[d.arcId])(d));\n    } else if (clickId < segments[0] || segments[1] < clickId) {\n      inTransition = true;\n      const clickSegments = getSegmentsInTime(clickId);\n      labels.\n      interrupt().\n      transition().\n      delay(delay).\n      duration(delay).\n      attrTween('transform', (d) =>\n      translateTween(arcSt.labels[d.arcId / numGroups])(d)\n      ).\n      style('opacity', 1);\n      groupLabels.\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween(\n        'transform',\n        translateTween({\n          outerRadius: maxRadius + 20,\n          innerRadius: maxRadius + 15,\n          startAngle: arcSt.data[clickId].startAngle,\n          endAngle: arcSt.data[clickId].endAngle\n        })\n      ).\n      style('opacity', 0);\n      ae.classed('clickable', true);\n      arcs.\n      filter((d) => clickSegments[0] <= d.arcId && d.arcId <= clickSegments[1]).\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('d', (d) => arcTween(arcSt.pieStart[d.arcId])(d)).\n      transition().\n      duration(delay).\n      attrTween('d', (d) => arcTween(arcSt.data[d.arcId])(d)).\n      each('end', () => {\n        clickId = -1;\n        inTransition = false;\n      });\n      arcs.\n      filter((d) => clickSegments[0] > d.arcId || d.arcId > clickSegments[1]).\n      interrupt().\n      transition().\n      delay(delay).\n      duration(delay).\n      attrTween('d', (d) => arcTween(arcSt.data[d.arcId])(d));\n    }\n  }\n\n  function updateActive() {\n    const delay = d3.event.altKey ? 3000 : 300;\n    legendWrap.datum(legendData(datum)).call(legend);\n    const nArcSt = computeArcStates(datum);\n    inTransition = true;\n    if (clickId < 0) {\n      arcs.\n      style('opacity', 1).\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('d', (d) => arcTween(nArcSt.data[d.arcId])(d)).\n      each('end', () => {\n        inTransition = false;\n        arcSt = nArcSt;\n      }).\n      transition().\n      duration(0).\n      style('opacity', (d) => state.disabled[d.arcId % numGroups] ? 0 : 1);\n    } else {\n      const segments = getSegmentsInTime(clickId);\n      arcs.\n      style('opacity', 1).\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('d', (d) =>\n      segments[0] <= d.arcId && d.arcId <= segments[1] ?\n      arcTween(nArcSt.pie[d.arcId])(d) :\n      arcTween(nArcSt.mini[d.arcId])(d)\n      ).\n      each('end', () => {\n        inTransition = false;\n        arcSt = nArcSt;\n      }).\n      transition().\n      duration(0).\n      style('opacity', (d) => state.disabled[d.arcId % numGroups] ? 0 : 1);\n      groupLabels.\n      interrupt().\n      transition().\n      duration(delay).\n      attrTween('transform', (d) =>\n      translateTween({\n        outerRadius: maxRadius + 20,\n        innerRadius: maxRadius + 15,\n        startAngle: nArcSt.pie[segments[0] + d.arcId].startAngle,\n        endAngle: nArcSt.pie[segments[0] + d.arcId].endAngle\n      })(d)\n      ).\n      style('opacity', (d) =>\n      state.disabled[d.arcId] ||\n      arcSt.pie[segments[0] + d.arcId].percent < labelThreshold ?\n      0 :\n      1\n      );\n    }\n  }\n\n  legend.dispatch.on('stateChange', (newState) => {\n    if (state.disabled !== newState.disabled) {\n      state.disabled = newState.disabled;\n      updateActive();\n    }\n  });\n}\n\nRose.displayName = 'Rose';\nRose.propTypes = propTypes;\n\nexport default Rose;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}