{"ast":null,"code":"import _pickBy from \"lodash/pickBy\";import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-env browser */\nimport { Component } from 'react';\nimport AutoSizer from 'react-virtualized-auto-sizer';\nimport { FixedSizeList as List } from 'react-window';\n// @ts-ignore\nimport { createFilter } from 'react-search-input';\nimport { t, styled, css } from '@superset-ui/core';\nimport { Input } from 'src/components/Input';\nimport { Select } from 'src/components';\nimport Loading from 'src/components/Loading';\nimport Button from 'src/components/Button';\nimport Icons from 'src/components/Icons';\nimport { LocalStorageKeys, getItem, setItem } from 'src/utils/localStorageHelpers';\nimport { CHART_TYPE, NEW_COMPONENT_SOURCE_TYPE } from 'src/dashboard/util/componentTypes';\nimport { NEW_CHART_ID, NEW_COMPONENTS_SOURCE_ID } from 'src/dashboard/util/constants';\n\nimport Checkbox from 'src/components/Checkbox';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport { withTheme } from '@emotion/react';\nimport AddSliceCard from './AddSliceCard';\nimport AddSliceDragPreview from './dnd/AddSliceDragPreview';\nimport { DragDroppable } from './dnd/DragDroppable';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst KEYS_TO_FILTERS = ['slice_name', 'viz_type', 'datasource_name'];\nconst KEYS_TO_SORT = {\n  slice_name: t('name'),\n  viz_type: t('viz type'),\n  datasource_name: t('dataset'),\n  changed_on: t('recent')\n};\nexport const DEFAULT_SORT_KEY = 'changed_on';\nconst DEFAULT_CELL_HEIGHT = 128;\nconst Controls = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    flex-direction: row;\n    padding:\n      ${theme.gridUnit * 4}px\n      ${theme.gridUnit * 3}px\n      ${theme.gridUnit * 4}px\n      ${theme.gridUnit * 3}px;\n  `}\n`;\nconst StyledSelect = styled(Select)`\n  margin-left: ${({ theme }) => theme.gridUnit * 2}px;\n  min-width: 150px;\n`;\nconst NewChartButtonContainer = styled.div`\n  ${({ theme }) => css`\n    display: flex;\n    justify-content: flex-end;\n    padding-right: ${theme.gridUnit * 2}px;\n  `}\n`;\nconst NewChartButton = styled(Button)`\n  ${({ theme }) => css`\n    height: auto;\n    & > .anticon > span {\n      margin: auto -${theme.gridUnit}px auto 0;\n    }\n    & > [role='img']:first-of-type {\n      padding-bottom: 1px;\n      line-height: 0;\n    }\n  `}\n`;\nexport const ChartList = styled.div`\n  flex-grow: 1;\n  min-height: 0;\n`;\nexport function sortByComparator(attr) {\n  const desc = attr === 'changed_on' ? -1 : 1;\n  return (a, b) => {var _a$attr, _b$attr;\n    const aValue = (_a$attr = a[attr]) != null ? _a$attr : Number.MIN_SAFE_INTEGER;\n    const bValue = (_b$attr = b[attr]) != null ? _b$attr : Number.MIN_SAFE_INTEGER;\n    if (aValue < bValue) {\n      return -1 * desc;\n    }\n    if (aValue > bValue) {\n      return 1 * desc;\n    }\n    return 0;\n  };\n}\nclass SliceAdder extends Component {\n\n\n\n\n\n\n  constructor(props) {\n    super(props);this.slicesRequest = void 0;this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    handleChange = _debounce((value) => {\n      this.searchUpdated(value);\n      this.slicesRequest = this.props.fetchSlices(this.userIdForFetch(), value, this.state.sortBy);\n    }, 300);this.state = { filteredSlices: [], searchTerm: '', sortBy: DEFAULT_SORT_KEY, selectedSliceIdsSet: new Set(props.selectedSliceIds), showOnlyMyCharts: getItem(LocalStorageKeys.DashboardEditorShowOnlyMyCharts, true) };this.rowRenderer = this.rowRenderer.bind(this);this.searchUpdated = this.searchUpdated.bind(this);this.handleSelect = this.handleSelect.bind(this);this.userIdForFetch = this.userIdForFetch.bind(this);this.onShowOnlyMyCharts = this.onShowOnlyMyCharts.bind(this);}userIdForFetch() {return this.state.showOnlyMyCharts ? this.props.userId : undefined;}componentDidMount() {this.slicesRequest = this.props.fetchSlices(this.userIdForFetch(), '', this.state.sortBy);}UNSAFE_componentWillReceiveProps(nextProps) {const nextState = {};if (nextProps.lastUpdated !== this.props.lastUpdated) {nextState.filteredSlices = this.getFilteredSortedSlices(nextProps.slices, this.state.searchTerm, this.state.sortBy, this.state.showOnlyMyCharts);}if (nextProps.selectedSliceIds !== this.props.selectedSliceIds) {nextState.selectedSliceIdsSet = new Set(nextProps.selectedSliceIds);}if (Object.keys(nextState).length) {this.setState(nextState);}}componentWillUnmount() {// Clears the redux store keeping only selected items\n    const selectedSlices = _pickBy(this.props.slices, (value) => this.state.selectedSliceIdsSet.has(value.slice_id));this.props.updateSlices(selectedSlices);if (this.slicesRequest instanceof AbortController) {this.slicesRequest.abort();}}getFilteredSortedSlices(slices, searchTerm, sortBy, showOnlyMyCharts) {return Object.values(slices).filter((slice) => {var _slice$owners, _slice$created_by;return showOnlyMyCharts ? (slice == null ? void 0 : (_slice$owners = slice.owners) == null ? void 0 : _slice$owners.find((owner) => owner.id === this.props.userId)) || (slice == null ? void 0 : (_slice$created_by = slice.created_by) == null ? void 0 : _slice$created_by.id) === this.props.userId : true;}).filter(createFilter(searchTerm, KEYS_TO_FILTERS)).sort(sortByComparator(sortBy));}searchUpdated(searchTerm) {\n    this.setState((prevState) => ({\n      searchTerm,\n      filteredSlices: this.getFilteredSortedSlices(this.props.slices, searchTerm, prevState.sortBy, prevState.showOnlyMyCharts)\n    }));\n  }\n  handleSelect(sortBy) {\n    this.setState((prevState) => ({\n      sortBy,\n      filteredSlices: this.getFilteredSortedSlices(this.props.slices, prevState.searchTerm, sortBy, prevState.showOnlyMyCharts)\n    }));\n    this.slicesRequest = this.props.fetchSlices(this.userIdForFetch(), this.state.searchTerm, sortBy);\n  }\n  rowRenderer({ index, style }) {\n    const { filteredSlices, selectedSliceIdsSet } = this.state;\n    const cellData = filteredSlices[index];\n    const isSelected = selectedSliceIdsSet.has(cellData.slice_id);\n    const type = CHART_TYPE;\n    const id = NEW_CHART_ID;\n    const meta = {\n      chartId: cellData.slice_id,\n      sliceName: cellData.slice_name\n    };\n    return _jsx(DragDroppable, { component: { type, id, meta }, parentComponent: {\n        id: NEW_COMPONENTS_SOURCE_ID,\n        type: NEW_COMPONENT_SOURCE_TYPE\n      }, index: index, depth: 0, disableDragDrop: isSelected, editMode: this.props.editMode\n      // we must use a custom drag preview within the List because\n      // it does not seem to work within a fixed-position container\n      , useEmptyDragPreview: true\n      // List library expect style props here\n      // actual style should be applied to nested AddSliceCard component\n      , style: {}, children:\n      ({ dragSourceRef }) => _jsx(AddSliceCard, { innerRef: dragSourceRef, style: style, sliceName: cellData.slice_name, lastModified: cellData.changed_on_humanized, visType: cellData.viz_type, datasourceUrl: cellData.datasource_url, datasourceName: cellData.datasource_name, thumbnailUrl: cellData.thumbnail_url, isSelected: isSelected }) }, cellData.slice_id\n    );\n  }\n  onShowOnlyMyCharts(showOnlyMyCharts) {\n    if (!showOnlyMyCharts) {\n      this.slicesRequest = this.props.fetchSlices(undefined, this.state.searchTerm, this.state.sortBy);\n    }\n    this.setState((prevState) => ({\n      showOnlyMyCharts,\n      filteredSlices: this.getFilteredSortedSlices(this.props.slices, prevState.searchTerm, prevState.sortBy, showOnlyMyCharts)\n    }));\n    setItem(LocalStorageKeys.DashboardEditorShowOnlyMyCharts, showOnlyMyCharts);\n  }\n  render() {\n    const { theme } = this.props;\n    return _jsxs(\"div\", { css: css`\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n          button > span > :first-of-type {\n            margin-right: 0;\n          }\n        `, children: [\n      _jsx(NewChartButtonContainer, { children:\n        _jsxs(NewChartButton, { buttonStyle: \"link\", buttonSize: \"xsmall\", onClick: () => window.open(`/chart/add?dashboard_id=${this.props.dashboardId}`, '_blank', 'noopener noreferrer'), children: [\n          _jsx(Icons.PlusOutlined, { iconSize: \"m\", iconColor: theme.colors.primary.dark1 }),\n          t('Create new chart')] }\n        ) }\n      ),\n      _jsxs(Controls, { children: [\n        _jsx(Input, { placeholder: this.state.showOnlyMyCharts ?\n          t('Filter your charts') :\n          t('Filter charts'), className: \"search-input\", onChange: (ev) => this.handleChange(ev.target.value) }),\n        _jsx(StyledSelect, { id: \"slice-adder-sortby\", value: this.state.sortBy, onChange: this.handleSelect, options: Object.entries(KEYS_TO_SORT).map(([key, label]) => ({\n            label: t('Sort by %s', label),\n            value: key\n          })), placeholder: t('Sort by') })] }\n      ),\n      _jsxs(\"div\", { css: (theme) => css`\n            display: flex;\n            flex-direction: row;\n            justify-content: flex-start;\n            align-items: center;\n            gap: ${theme.gridUnit}px;\n            padding: 0 ${theme.gridUnit * 3}px ${theme.gridUnit * 4}px\n              ${theme.gridUnit * 3}px;\n          `, children: [\n        _jsx(Checkbox, { onChange: this.onShowOnlyMyCharts, checked: this.state.showOnlyMyCharts }),\n        t('Show only my charts'),\n        _jsx(InfoTooltipWithTrigger, { placement: \"top\", tooltip: t(`You can choose to display all charts that you have access to or only the ones you own.\n              Your filter selection will be saved and remain active until you choose to change it.`) })] }\n      ),\n      this.props.isLoading && _jsx(Loading, {}),\n      !this.props.isLoading && this.state.filteredSlices.length > 0 && _jsx(ChartList, { children:\n        _jsx(AutoSizer, { children:\n          ({ height, width }) => _jsx(List, { width: width, height: height, itemCount: this.state.filteredSlices.length, itemSize: DEFAULT_CELL_HEIGHT, itemKey: (index) => this.state.filteredSlices[index].slice_id, children:\n            this.rowRenderer }\n          ) }\n        ) }\n      ),\n      this.props.errorMessage && _jsx(\"div\", { css: css`\n              padding: 16px;\n            `, children:\n        this.props.errorMessage }\n      ),\n\n      _jsx(AddSliceDragPreview, { slices: this.state.filteredSlices })] }\n    );\n  }\n}SliceAdder.defaultProps = { selectedSliceIds: [], editMode: false, errorMessage: '' };\nexport default withTheme(SliceAdder);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}