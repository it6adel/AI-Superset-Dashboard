{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _debounce from \"lodash/debounce\";import _sortBy from \"lodash/sortBy\";import _isEqual from \"lodash/isEqual\";import _uniq from \"lodash/uniq\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { memo, useEffect, useCallback, useMemo, useState, useRef } from 'react';\n\nimport { styled, SLOW_DEBOUNCE, t, css, useTheme } from '@superset-ui/core';\nimport { useDispatch } from 'react-redux';\nimport { AntdForm } from 'src/components';\nimport Icons from 'src/components/Icons';\nimport ErrorBoundary from 'src/components/ErrorBoundary';\nimport { StyledModal } from 'src/components/Modal';\nimport { testWithId } from 'src/utils/testUtils';\nimport { updateCascadeParentIds } from 'src/dashboard/actions/nativeFilters';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { useFilterConfigMap, useFilterConfiguration } from '../state';\nimport FilterConfigurePane from './FilterConfigurePane';\nimport FiltersConfigForm, { FilterPanels } from './FiltersConfigForm/FiltersConfigForm';\nimport Footer from './Footer/Footer';\nimport { useOpenModal, useRemoveCurrentFilter } from './state';\nimport { createHandleSave, createHandleRemoveItem, generateFilterId, getFilterIds, validateForm, NATIVE_FILTER_DIVIDER_PREFIX, hasCircularDependency } from './utils';\nimport DividerConfigForm from './DividerConfigForm';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst MODAL_MARGIN = 16;\nconst MIN_WIDTH = 880;\nconst StyledModalWrapper = styled(StyledModal)`\n  min-width: ${MIN_WIDTH}px;\n  width: ${({ expanded }) => expanded ? '100%' : MIN_WIDTH} !important;\n\n  @media (max-width: ${MIN_WIDTH + MODAL_MARGIN * 2}px) {\n    width: 100% !important;\n    min-width: auto;\n  }\n\n  .antd5-modal-body {\n    padding: 0px;\n  }\n\n  ${({ expanded }) => expanded &&\ncss`\n      height: 100%;\n\n      .antd5-modal-body {\n        flex: 1 1 auto;\n      }\n      .antd5-modal-content {\n        height: 100%;\n      }\n    `}\n`;\nexport const StyledModalBody = styled.div`\n  display: flex;\n  height: ${({ expanded }) => expanded ? '100%' : '700px'};\n  flex-direction: row;\n  flex: 1;\n  .filters-list {\n    width: ${({ theme }) => theme.gridUnit * 50}px;\n    overflow: auto;\n  }\n`;\nexport const StyledForm = styled(AntdForm)`\n  width: 100%;\n`;\nexport const StyledExpandButtonWrapper = styled.div`\n  margin-left: ${({ theme }) => theme.gridUnit * 4}px;\n`;\nexport const FILTERS_CONFIG_MODAL_TEST_ID = 'filters-config-modal';\nexport const getFiltersConfigModalTestId = testWithId(FILTERS_CONFIG_MODAL_TEST_ID);\nexport const ALLOW_DEPENDENCIES = [\n'filter_range',\n'filter_select',\n'filter_time'];\n\nconst DEFAULT_EMPTY_FILTERS = [];\nconst DEFAULT_REMOVED_FILTERS = {};\nconst DEFAULT_FORM_VALUES = {\n  filters: {}\n};\nconst DEFAULT_FILTER_CHANGES = {\n  modified: [],\n  deleted: [],\n  reordered: []\n};\n/**\n * This is the modal to configure all the dashboard-native filters.\n * Manages modal-level state, such as what filters are in the list,\n * and which filter is currently being edited.\n *\n * Calls the `save` callback with the new FilterConfiguration object\n * when the user saves the filters.\n */\nfunction FiltersConfigModal({ isOpen, initialFilterId, createNewOnOpen, onSave, onCancel }) {\n  const dispatch = useDispatch();\n  const theme = useTheme();\n  const [form] = AntdForm.useForm();\n  const configFormRef = useRef();\n  // the filter config from redux state, this does not change until modal is closed.\n  const filterConfig = useFilterConfiguration();\n  const filterConfigMap = useFilterConfigMap();\n  // this state contains the changes that we'll be sent through the PATCH endpoint\n  const [filterChanges, setFilterChanges] = useState(DEFAULT_FILTER_CHANGES);\n  const resetFilterChanges = () => {\n    setFilterChanges(DEFAULT_FILTER_CHANGES);\n  };\n  const handleModifyFilter = useCallback((filterId) => {\n    if (!filterChanges.modified.includes(filterId)) {\n      setFilterChanges((prev) => ({\n        ...prev,\n        modified: [...prev.modified, filterId]\n      }));\n    }\n  }, [filterChanges.modified]);\n  // new filter ids belong to filters have been added during\n  // this configuration session, and only exist in the form state until we submit.\n  const [newFilterIds, setNewFilterIds] = useState(DEFAULT_EMPTY_FILTERS);\n  // store ids of filters that have been removed with the time they were removed\n  // so that we can disappear them after a few secs.\n  // filters are still kept in state until form is submitted.\n  const [removedFilters, setRemovedFilters] = useState(DEFAULT_REMOVED_FILTERS);\n  const [saveAlertVisible, setSaveAlertVisible] = useState(false);\n  // The full ordered set of ((original + new) - completely removed) filter ids\n  // Use this as the canonical list of what filters are being configured!\n  // This includes filter ids that are pending removal, so check for that.\n  const filterIds = useMemo(() => _uniq([...getFilterIds(filterConfig), ...newFilterIds]).filter((id) => {var _removedFilters$id;return !removedFilters[id] || ((_removedFilters$id = removedFilters[id]) == null ? void 0 : _removedFilters$id.isPending);}), [filterConfig, newFilterIds, removedFilters]);\n  // open the first filter in the list to start\n  const initialCurrentFilterId = initialFilterId != null ? initialFilterId : filterIds[0];\n  const [currentFilterId, setCurrentFilterId] = useState(initialCurrentFilterId);\n  const [erroredFilters, setErroredFilters] = useState(DEFAULT_EMPTY_FILTERS);\n  // the form values are managed by the antd form, but we copy them to here\n  // so that we can display them (e.g. filter titles in the tab headers)\n  const [formValues, setFormValues] = useState(DEFAULT_FORM_VALUES);\n  const unsavedFiltersIds = newFilterIds.filter((id) => !removedFilters[id]);\n  // brings back a filter that was previously removed (\"Undo\")\n  const restoreFilter = useCallback((id) => {\n    const removal = removedFilters[id];\n    // Clear the removal timeout if the filter is pending deletion\n    if (removal != null && removal.isPending)\n    clearTimeout(removal.timerId);\n    setRemovedFilters((current) => ({ ...current, [id]: null }));\n    setFilterChanges((prev) => ({\n      ...prev,\n      deleted: prev.deleted.filter((deletedId) => deletedId !== id)\n    }));\n  }, [removedFilters, setRemovedFilters]);\n  const initialFilterOrder = useMemo(() => Object.keys(filterConfigMap), [filterConfigMap]);\n  // State for tracking the re-ordering of filters\n  const [orderedFilters, setOrderedFilters] = useState(initialFilterOrder);\n  // State for rendered filter to improve performance\n  const [renderedFilters, setRenderedFilters] = useState([\n  initialCurrentFilterId]\n  );\n  const getActiveFilterPanelKey = (filterId) => [\n  `${filterId}-${FilterPanels.configuration.key}`,\n  `${filterId}-${FilterPanels.settings.key}`];\n\n  const [activeFilterPanelKey, setActiveFilterPanelKey] = useState(getActiveFilterPanelKey(initialCurrentFilterId));\n  const handleTabChange = (filterId) => {\n    setCurrentFilterId(filterId);\n    setActiveFilterPanelKey(getActiveFilterPanelKey(filterId));\n  };\n  // generates a new filter id and appends it to the newFilterIds\n  const addFilter = useCallback((type) => {\n    const newFilterId = generateFilterId(type);\n    setNewFilterIds([...newFilterIds, newFilterId]);\n    handleModifyFilter(newFilterId);\n    setCurrentFilterId(newFilterId);\n    setSaveAlertVisible(false);\n    setOrderedFilters([...orderedFilters, newFilterId]);\n    setActiveFilterPanelKey(getActiveFilterPanelKey(newFilterId));\n  }, [newFilterIds, handleModifyFilter, orderedFilters]);\n  useOpenModal(isOpen, addFilter, createNewOnOpen);\n  useRemoveCurrentFilter(removedFilters, currentFilterId, orderedFilters, setCurrentFilterId);\n  const handleRemoveItem = createHandleRemoveItem(setRemovedFilters, setOrderedFilters, setSaveAlertVisible, (filterId) => {\n    setFilterChanges((prev) => ({\n      ...prev,\n      deleted: [...prev.deleted, filterId]\n    }));\n  });\n  // After this, it should be as if the modal was just opened fresh.\n  // Called when the modal is closed.\n  const resetForm = (isSaving = false) => {\n    setNewFilterIds(DEFAULT_EMPTY_FILTERS);\n    setCurrentFilterId(initialCurrentFilterId);\n    setRemovedFilters(DEFAULT_REMOVED_FILTERS);\n    setSaveAlertVisible(false);\n    setFormValues(DEFAULT_FORM_VALUES);\n    resetFilterChanges();\n    setErroredFilters(DEFAULT_EMPTY_FILTERS);\n    if (filterIds.length > 0) {\n      setActiveFilterPanelKey(getActiveFilterPanelKey(filterIds[0]));\n    }\n    if (!isSaving) {\n      setOrderedFilters(initialFilterOrder);\n    }\n    setRenderedFilters([initialCurrentFilterId]);\n    form.resetFields(['filters']);\n    form.setFieldsValue({ changed: false });\n  };\n  const getFilterTitle = useCallback((id) => {\n    const formValue = formValues.filters[id];\n    const config = filterConfigMap[id];\n    return formValue && 'name' in formValue && formValue.name ||\n    formValue && 'title' in formValue && formValue.title ||\n    config && 'name' in config && config.name ||\n    config && 'title' in config && config.title ||\n    t('[untitled]');\n  }, [filterConfigMap, formValues.filters]);\n  const canBeUsedAsDependency = useCallback((filterId) => {var _form$getFieldValue;\n    if (removedFilters[filterId]) {\n      return false;\n    }\n    const component = ((_form$getFieldValue = form.getFieldValue('filters')) == null ? void 0 : _form$getFieldValue[filterId]) || filterConfigMap[filterId];\n    return component &&\n    'filterType' in component &&\n    ALLOW_DEPENDENCIES.includes(component.filterType);\n  }, [filterConfigMap, form, removedFilters]);\n  const getAvailableFilters = useCallback((filterId) => filterIds.\n  filter((id) => id !== filterId).\n  filter((id) => canBeUsedAsDependency(id)).\n  map((id) => {var _filterConfigMap$id;return {\n      label: getFilterTitle(id),\n      value: id,\n      type: (_filterConfigMap$id = filterConfigMap[id]) == null ? void 0 : _filterConfigMap$id.filterType\n    };}), [canBeUsedAsDependency, filterConfigMap, filterIds, getFilterTitle]);\n  /**\n   * Manages dependencies of filters associated with a deleted filter.\n   *\n   * @param values the native filters form\n   * @returns the updated filterConfigMap\n   */\n  const cleanDeletedParents = (values) => {\n    const modifiedParentFilters = new Set();\n    const updatedFilterConfigMap = Object.keys(filterConfigMap).reduce((acc, key) => {var _filter$cascadeParent;\n      const filter = filterConfigMap[key];\n      const cascadeParentIds = (_filter$cascadeParent = filter.cascadeParentIds) == null ? void 0 : _filter$cascadeParent.filter((id) => canBeUsedAsDependency(id));\n      if (cascadeParentIds &&\n      !_isEqual(cascadeParentIds, filter.cascadeParentIds)) {\n        dispatch(updateCascadeParentIds(key, cascadeParentIds));\n        modifiedParentFilters.add(key);\n      }\n      return {\n        ...acc,\n        [key]: {\n          ...filter,\n          cascadeParentIds\n        }\n      };\n    }, {});\n    const filters = values == null ? void 0 : values.filters;\n    if (filters) {\n      Object.keys(filters).forEach((key) => {\n        const filter = filters[key];\n        if (!('dependencies' in filter)) {\n          return;\n        }\n        const originalDependencies = filter.dependencies || [];\n        const cleanedDependencies = originalDependencies.filter((id) => canBeUsedAsDependency(id));\n        if (!_isEqual(cleanedDependencies, originalDependencies)) {\n          filter.dependencies = cleanedDependencies;\n          modifiedParentFilters.add(key);\n        }\n      });\n    }\n    return [updatedFilterConfigMap, modifiedParentFilters];\n  };\n  const handleErroredFilters = useCallback(() => {\n    // managing left pane errored filters indicators\n    const formValidationFields = form.getFieldsError();\n    const erroredFiltersIds = [];\n    formValidationFields.forEach((field) => {\n      const filterId = field.name[1];\n      if (field.errors.length > 0 && !erroredFiltersIds.includes(filterId)) {\n        erroredFiltersIds.push(filterId);\n      }\n    });\n    // no form validation issues found, resets errored filters\n    if (!erroredFiltersIds.length && erroredFilters.length > 0) {\n      setErroredFilters(DEFAULT_EMPTY_FILTERS);\n      return;\n    }\n    // form validation issues found, sets errored filters\n    if (erroredFiltersIds.length > 0 &&\n    !_isEqual(_sortBy(erroredFilters), _sortBy(erroredFiltersIds))) {\n      setErroredFilters(erroredFiltersIds);\n    }\n  }, [form, erroredFilters]);\n  const handleSave = async () => {\n    const values = await validateForm(form, currentFilterId, setCurrentFilterId);\n    handleErroredFilters();\n    if (values) {\n      const [updatedFilterConfigMap, modifiedParentFilters] = cleanDeletedParents(values);\n      const allModified = [\n      ...new Set([\n      ...modifiedParentFilters,\n      ...filterChanges.modified]\n      )];\n\n      const actualChanges = {\n        ...filterChanges,\n        modified: allModified.length && filterChanges.deleted.length ?\n        allModified.filter((id) => !filterChanges.deleted.includes(id)) :\n        allModified,\n        reordered: filterChanges.reordered.length &&\n        !_isEqual(filterChanges.reordered, initialFilterOrder) ?\n        filterChanges.reordered :\n        []\n      };\n      createHandleSave(onSave, actualChanges, values, updatedFilterConfigMap)();\n      resetForm(true);\n      resetFilterChanges();\n    } else\n    {var _configFormRef$curren;\n      (_configFormRef$curren = configFormRef.current) == null ? void 0 : _configFormRef$curren.changeTab == null ? void 0 : _configFormRef$curren.changeTab('configuration');\n    }\n  };\n  const handleConfirmCancel = () => {\n    resetForm();\n    onCancel();\n  };\n  const handleCancel = () => {\n    const changed = form.getFieldValue('changed');\n    const didChangeOrder = orderedFilters.length !== initialFilterOrder.length ||\n    orderedFilters.some((val, index) => val !== initialFilterOrder[index]);\n    if (unsavedFiltersIds.length > 0 ||\n    form.isFieldsTouched() ||\n    changed ||\n    didChangeOrder ||\n    Object.values(removedFilters).some((f) => f == null ? void 0 : f.isPending)) {\n      setSaveAlertVisible(true);\n    } else\n    {\n      handleConfirmCancel();\n    }\n  };\n  const handleRearrange = (dragIndex, targetIndex) => {\n    const newOrderedFilter = [...orderedFilters];\n    const removed = newOrderedFilter.splice(dragIndex, 1)[0];\n    newOrderedFilter.splice(targetIndex, 0, removed);\n    setOrderedFilters(newOrderedFilter);\n    setFilterChanges((prev) => ({\n      ...prev,\n      reordered: newOrderedFilter\n    }));\n  };\n  const buildDependencyMap = useCallback(() => {\n    const dependencyMap = new Map();\n    const filters = form.getFieldValue('filters');\n    if (filters) {\n      Object.keys(filters).forEach((key) => {\n        const formItem = filters[key];\n        const configItem = filterConfigMap[key];\n        let array = [];\n        if (formItem && 'dependencies' in formItem) {\n          array = [...formItem.dependencies];\n        } else\n        if (configItem != null && configItem.cascadeParentIds) {\n          array = [...configItem.cascadeParentIds];\n        }\n        dependencyMap.set(key, array);\n      });\n    }\n    return dependencyMap;\n  }, [filterConfigMap, form]);\n  const validateDependencies = useCallback(() => {\n    const dependencyMap = buildDependencyMap();\n    filterIds.\n    filter((id) => !removedFilters[id]).\n    forEach((filterId) => {\n      const result = hasCircularDependency(dependencyMap, filterId);\n      const field = {\n        name: ['filters', filterId, 'dependencies'],\n        errors: result ? [t('Cyclic dependency detected')] : []\n      };\n      form.setFields([field]);\n    });\n    handleErroredFilters();\n  }, [\n  buildDependencyMap,\n  filterIds,\n  form,\n  handleErroredFilters,\n  removedFilters]\n  );\n  const getDependencySuggestion = useCallback((filterId) => {\n    const dependencyMap = buildDependencyMap();\n    const possibleDependencies = orderedFilters.filter((key) => key !== filterId && canBeUsedAsDependency(key));\n    const found = possibleDependencies.find((filter) => {\n      const dependencies = dependencyMap.get(filterId) || [];\n      dependencies.push(filter);\n      if (hasCircularDependency(dependencyMap, filterId)) {\n        dependencies.pop();\n        return false;\n      }\n      return true;\n    });\n    return found || possibleDependencies[0];\n  }, [buildDependencyMap, canBeUsedAsDependency, orderedFilters]);\n  const [expanded, setExpanded] = useState(false);\n  const toggleExpand = useEffectEvent(() => {\n    setExpanded(!expanded);\n  });\n  const ToggleIcon = expanded ?\n  Icons.FullscreenExitOutlined :\n  Icons.FullscreenOutlined;\n  const handleValuesChange = useMemo(() => _debounce((changes, values) => {\n    const didChangeFilterName = changes.filters &&\n    Object.values(changes.filters).some((filter) => filter.name && filter.name !== null);\n    const didChangeSectionTitle = changes.filters &&\n    Object.values(changes.filters).some((filter) => filter.title && filter.title !== null);\n    if (didChangeFilterName || didChangeSectionTitle) {\n      // we only need to set this if a name/title changed\n      setFormValues(values);\n    }\n    setSaveAlertVisible(false);\n    handleErroredFilters();\n  }, SLOW_DEBOUNCE), [handleErroredFilters]);\n  useEffect(() => {\n    if (!_isEmpty(removedFilters)) {\n      setErroredFilters((prevErroredFilters) => prevErroredFilters.filter((f) => !removedFilters[f]));\n    }\n  }, [removedFilters]);\n  useEffect(() => {\n    if (!renderedFilters.includes(currentFilterId)) {\n      setRenderedFilters([...renderedFilters, currentFilterId]);\n    }\n  }, [currentFilterId]);\n  const handleActiveFilterPanelChange = useCallback((key) => setActiveFilterPanelKey(key), [setActiveFilterPanelKey]);\n  const formList = useMemo(() => orderedFilters.map((id) => {\n    if (!renderedFilters.includes(id))\n    return null;\n    const isDivider = id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX);\n    const isActive = currentFilterId === id;\n    return _jsx(\"div\", { style: {\n        height: '100%',\n        overflowY: 'auto',\n        display: isActive ? '' : 'none'\n      }, children:\n      isDivider ? _jsx(DividerConfigForm, { componentId: id, divider: filterConfigMap[id] }) : _jsx(FiltersConfigForm, { expanded: expanded, ref: configFormRef, form: form, filterId: id, filterToEdit: filterConfigMap[id], removedFilters: removedFilters, restoreFilter: restoreFilter, getAvailableFilters: getAvailableFilters, activeFilterPanelKeys: activeFilterPanelKey, handleActiveFilterPanelChange: handleActiveFilterPanelChange, isActive: isActive, setErroredFilters: setErroredFilters, validateDependencies: validateDependencies, getDependencySuggestion: getDependencySuggestion, onModifyFilter: handleModifyFilter }, id) }, id\n    );\n  }), [\n  orderedFilters,\n  renderedFilters,\n  currentFilterId,\n  filterConfigMap,\n  expanded,\n  form,\n  removedFilters,\n  restoreFilter,\n  getAvailableFilters,\n  activeFilterPanelKey,\n  handleActiveFilterPanelChange,\n  validateDependencies,\n  getDependencySuggestion,\n  handleModifyFilter]\n  );\n  useEffect(() => {\n    resetFilterChanges();\n  }, []);\n  return _jsx(StyledModalWrapper, { open: isOpen, maskClosable: false, title: t('Add and edit filters'), expanded: expanded, destroyOnClose: true, onCancel: handleCancel, onOk: handleSave, centered: true, footer: _jsxs(\"div\", { css: css`\n            display: flex;\n            justify-content: flex-end;\n            align-items: flex-end;\n          `, children: [\n      _jsx(Footer, { onDismiss: () => setSaveAlertVisible(false), onCancel: handleCancel, handleSave: handleSave, canSave: !erroredFilters.length, saveAlertVisible: saveAlertVisible, onConfirmCancel: handleConfirmCancel }),\n      _jsx(StyledExpandButtonWrapper, { children:\n        _jsx(ToggleIcon, { iconSize: \"l\", iconColor: theme.colors.grayscale.dark2, onClick: toggleExpand }) }\n      )] }\n    ), children:\n    _jsx(ErrorBoundary, { children:\n      _jsx(StyledModalBody, { expanded: expanded, children:\n        _jsx(StyledForm, { form: form, onValuesChange: handleValuesChange, layout: \"vertical\", children:\n          _jsx(FilterConfigurePane, { erroredFilters: erroredFilters, onRemove: handleRemoveItem, onAdd: addFilter, onChange: handleTabChange, getFilterTitle: getFilterTitle, currentFilterId: currentFilterId, removedFilters: removedFilters, restoreFilter: restoreFilter, onRearrange: handleRearrange, filters: orderedFilters, children:\n            formList }\n          ) }\n        ) }\n      ) }\n    ) }\n  );\n}\nexport default /*#__PURE__*/memo(FiltersConfigModal);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}