{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport Layer from 'ol/layer/Layer';\nimport { apply as applyTransform } from 'ol/transform';\nimport ReactDOM from 'react-dom';\nimport { createChartComponent } from '../util/chartUtil';\nimport { getProjectedCoordinateFromPointGeoJson } from '../util/geometryUtil';\nimport Loader from '../images/loading.gif';\n/**\n * Custom OpenLayers layer that displays charts on given locations.\n */\nexport class ChartLayer extends Layer {\n\n\n\n\n\n\n\n\n\n\n\n\n  /**\n   * Create a ChartLayer.\n   *\n   * @param {ChartLayerOptions} options The options to create a ChartLayer\n   * @param {ChartHtmlElement[]} options.charts An array with the chart objects containing the HTML element and the coordinate\n   * @param {ChartConfig} options.chartConfigs The chart configuration for the charts\n   * @param {ChartSizeValues} options.chartSizeValues The values for the chart sizes\n   * @param {String} options.chartVizType The viztype of the charts\n   * @param {String} options.chartBackgroundCssColor The color of the additionally added chart background\n   * @param {Number} options.chartBackgroundBorderRadius The border radius in percent of the additionally added chart background\n   * @param {Function} options.onMouseOver The handler function to execute when the mouse entering a HTML element\n   * @param {Function} options.onMouseOut The handler function to execute when the mouse leaves a HTML element\n   * @param {SupersetTheme} options.theme The superset theme\n   */\n  constructor(options) {\n    super(options);this.charts = [];this.chartConfigs = { type: 'FeatureCollection', features: [] };this.chartSizeValues = {};this.chartVizType = void 0;this.div = void 0;this.loadingMask = void 0;this.chartBackgroundCssColor = '';this.chartBackgroundBorderRadius = 0;this.theme = void 0;\n    this.chartVizType = options.chartVizType;\n    if (options.chartConfigs) {\n      this.chartConfigs = options.chartConfigs;\n    }\n    if (options.chartSizeValues) {\n      this.chartSizeValues = options.chartSizeValues;\n    }\n    if (options.chartBackgroundCssColor) {\n      this.chartBackgroundCssColor = options.chartBackgroundCssColor;\n    }\n    if (options.chartBackgroundBorderRadius) {\n      this.chartBackgroundBorderRadius = options.chartBackgroundBorderRadius;\n    }\n    if (options.theme) {\n      this.theme = options.theme;\n    }\n    const spinner = document.createElement('img');\n    spinner.src = Loader;\n    spinner.style.position = 'relative';\n    spinner.style.width = '50px';\n    spinner.style.top = '50%';\n    spinner.style.left = '50%';\n    spinner.style.transform = 'translate(-50%, -50%)';\n    this.loadingMask = document.createElement('div');\n    this.loadingMask.style.position = 'relative';\n    this.loadingMask.style.height = '100%';\n    this.loadingMask.appendChild(spinner);\n    this.div = document.createElement('div');\n    // TODO: consider creating an OpenLayers event\n    if (options.onMouseOver) {\n      this.div.onmouseover = options.onMouseOver;\n    }\n    // TODO: consider creating an OpenLayers event\n    if (options.onMouseOut) {\n      this.div.onmouseout = options.onMouseOut;\n    }\n  }\n  setChartConfig(chartConfigs, silent = false) {\n    this.chartConfigs = chartConfigs;\n    if (!silent) {\n      this.changed();\n    }\n  }\n  setChartVizType(chartVizType, silent = false) {\n    this.chartVizType = chartVizType;\n    if (!silent) {\n      this.changed();\n    }\n  }\n  setChartSizeValues(chartSizeValues, silent = false) {\n    this.chartSizeValues = chartSizeValues;\n    if (!silent) {\n      this.changed();\n    }\n  }\n  setChartBackgroundCssColor(chartBackgroundCssColor, silent = false) {\n    this.chartBackgroundCssColor = chartBackgroundCssColor;\n    if (!silent) {\n      this.changed();\n    }\n  }\n  setChartBackgroundBorderRadius(chartBackgroundBorderRadius, silent = false) {\n    this.chartBackgroundBorderRadius = chartBackgroundBorderRadius;\n    if (!silent) {\n      this.changed();\n    }\n  }\n  /**\n   * Unmount and remove all created chart elements from the DOM.\n   */\n  removeAllChartElements() {\n    this.charts.forEach((chart) => {\n      ReactDOM.unmountComponentAtNode(chart.htmlElement);\n      chart.htmlElement.remove();\n    });\n    this.charts = [];\n  }\n  createCharts(zoom) {\n    const charts = this.chartConfigs.features.map((feature) => {\n      const container = document.createElement('div');\n      let chartWidth = 0;\n      let chartHeight = 0;\n      if (this.chartSizeValues[zoom]) {\n        chartWidth = this.chartSizeValues[zoom].width;\n        chartHeight = this.chartSizeValues[zoom].height;\n      }\n      const chartComponent = createChartComponent(this.chartVizType, feature, chartWidth, chartHeight, this.theme);\n      ReactDOM.render(chartComponent, container);\n      return {\n        htmlElement: container,\n        coordinate: getProjectedCoordinateFromPointGeoJson(feature.geometry),\n        width: chartWidth,\n        height: chartHeight,\n        feature\n      };\n    });\n    this.charts = charts;\n  }\n  updateCharts(zoom) {\n    const charts = this.charts.map((chart) => {\n      let chartWidth = 0;\n      let chartHeight = 0;\n      if (this.chartSizeValues[zoom]) {\n        chartWidth = this.chartSizeValues[zoom].width;\n        chartHeight = this.chartSizeValues[zoom].height;\n      }\n      // only rerender chart if size changes\n      if (chartWidth === chart.width && chartHeight === chart.height) {\n        return chart;\n      }\n      const chartComponent = createChartComponent(this.chartVizType, chart.feature, chartWidth, chartHeight, this.theme);\n      ReactDOM.render(chartComponent, chart.htmlElement);\n      return {\n        ...chart,\n        width: chartWidth,\n        height: chartHeight\n      };\n    });\n    this.charts = charts;\n  }\n  render(frameState) {\n    if (!frameState) {\n      return this.div;\n    }\n    const { viewState } = frameState;\n    const currentZoom = Math.round(viewState.zoom);\n    // nextResolution is only defined while an animation\n    // is in action. For this time we show a loading mask\n    // to keep the amount of chart rerenderings as low as possible.\n    if (viewState.nextResolution) {\n      return this.loadingMask;\n    }\n    if (this.charts.length === 0) {\n      this.createCharts(currentZoom);\n    } else\n    {\n      this.updateCharts(currentZoom);\n    }\n    this.charts.forEach((chartObject) => {\n      const { htmlElement, coordinate, width, height } = chartObject;\n      // clone, because applyTransform modifies in place\n      const coordCopy = [...coordinate];\n      const [x, y] = applyTransform(frameState.coordinateToPixelTransform, coordCopy);\n      // left and top are corrected to place the center of the chart to its location\n      htmlElement.style.left = `${x - width / 2}px`;\n      htmlElement.style.top = `${y - height / 2}px`;\n      htmlElement.style.position = 'absolute';\n      htmlElement.style['background-color'] =\n      this.chartBackgroundCssColor;\n      htmlElement.style['border-radius'] =\n      `${this.chartBackgroundBorderRadius}%`;\n    });\n    // TODO should we always replace the html elements or is there a better way?\n    const htmlElements = this.charts.map((c) => c.htmlElement);\n    this.div.replaceChildren(...htmlElements);\n    return this.div;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}