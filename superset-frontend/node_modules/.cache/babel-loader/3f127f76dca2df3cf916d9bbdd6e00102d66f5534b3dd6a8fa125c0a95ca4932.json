{"ast":null,"code":"import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\n\nimport { AxisType, buildCustomFormatters, CategoricalColorNamespace, CurrencyFormatter, ensureIsArray, tooltipHtml, GenericDataType, getCustomFormatter, getMetricLabel, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, t, NumberFormats } from '@superset-ui/core';\nimport { extractExtraMetrics, getOriginalSeries, isDerivedSeries } from '@superset-ui/chart-controls';\nimport { OrientationType } from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { calculateLowerLogTick, dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, extractTooltipKeys, getAxisType, getColtypesMapping, getLegendProps, getMinAndMaxFromBounds } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastSeriesContexts, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum, reorderForecastSeries } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getBaselineSeriesForStream, getPadding, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from './transformers';\nimport { OpacityEnum, StackControlsValue, TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getPercentFormatter, getTooltipTimeFormatter, getXAxisFormatter, getYAxisFormatter } from '../utils/formatters';\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, filterState, legendState, formData, hooks, queriesData, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, columnFormats = {}, currencyFormats = {} } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } = queryData;\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n  const { area, annotationLayers, colorScheme, contributionMode, forecastEnabled, groupby, legendOrientation, legendType, legendMargin, logAxis, markerEnabled, markerSize, metrics, minorSplitLine, minorTicks, onlyTotal, opacity, orientation, percentageThreshold, richTooltip, seriesType, showLegend, showValue, sliceId, sortSeriesType, sortSeriesAscending, timeGrainSqla, timeCompare, timeShiftColor, stack, tooltipTimeFormat, tooltipSortByMetric, showTooltipTotal, showTooltipPercentage, truncateXAxis, truncateYAxis, xAxis: xAxisOrig, xAxisBounds, xAxisForceCategorical, xAxisLabelRotation, xAxisSortSeries, xAxisSortSeriesAscending, xAxisTimeFormat, xAxisTitle, xAxisTitleMargin, yAxisBounds, yAxisFormat, currencyFormat, yAxisTitle, yAxisTitleMargin, yAxisTitlePosition, zoomable } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const groupBy = ensureIsArray(groupby);\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (entry[1].length > groupBy.length &&\n    Array.isArray(timeCompare) &&\n    timeCompare.includes(entry[1][0])) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedData, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n    legendState\n  });\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(getMetricLabel);\n  const isMultiSeries = groupBy.length || (metrics == null ? void 0 : metrics.length) > 1;\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(rebasedData, {\n    fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n    xAxis: xAxisLabel,\n    extraMetricLabels,\n    stack,\n    totalStackedValues,\n    isHorizontal,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries: isMultiSeries ? xAxisSortSeries : undefined,\n    xAxisSortSeriesAscending: isMultiSeries ?\n    xAxisSortSeriesAscending :\n    undefined\n  });\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState\n  });\n  const seriesContexts = extractForecastSeriesContexts(rawSeries.map((series) => series.name));\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series = [];\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = forcePercentFormatter ?\n  getPercentFormatter(yAxisFormat) :\n  getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const defaultFormatter = currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat }) :\n  getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(metrics, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  let patternIncrement = 0;\n  rawSeries.forEach((entry) => {var _getCustomFormatter, _labelMap$seriesName;\n    const derivedSeries = isDerivedSeries(entry, chartProps.rawFormData);\n    const lineStyle = {};\n    if (derivedSeries) {\n      patternIncrement += 1;\n      // use a combination of dash and dot for the line style\n      lineStyle.type = [patternIncrement % 5 + 1, patternIncrement % 3 + 1];\n      lineStyle.opacity = OpacityEnum.DerivedSeries;\n    }\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      connectNulls: derivedSeries,\n      filterState,\n      seriesContexts,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      legendState,\n      stack,\n      formatter: forcePercentFormatter ?\n      percentFormatter : (_getCustomFormatter =\n      getCustomFormatter(customFormatters, metrics, labelMap == null ? void 0 : (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0])) != null ? _getCustomFormatter : defaultFormatter,\n      showValue,\n      onlyTotal,\n      totalStackedValues: sortedTotalValues,\n      showValueIndexes,\n      thresholdValues,\n      richTooltip,\n      sliceId,\n      isHorizontal,\n      lineStyle,\n      timeCompare: array,\n      timeShiftColor\n    });\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: transformedSeries.data.map((row) => {var _row$;return [row[0], (_row$ = row[1]) != null ? _row$ : 0];})\n        });\n      } else\n      {\n        series.push(transformedSeries);\n      }\n    }\n  });\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(series.map((entry) => entry.data), seriesType);\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = series.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data, xAxisLabel, xAxisType, colorScale, sliceId, orientation));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId, orientation));\n    }\n  });\n  // axis bounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (yAxisMin === undefined)\n    yAxisMin = 0;\n    if (yAxisMax === undefined)\n    yAxisMax = 1;\n  } else\n  if (logAxis &&\n  yAxisMin === undefined &&\n  minPositiveValue !== undefined) {\n    yAxisMin = calculateLowerLogTick(minPositiveValue);\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const { setDataMask = () => {}, setControlValue = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(showLegend, legendOrientation, addYAxisLabelOffset, zoomable, legendMargin, addXAxisLabelOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin), isHorizontal);\n  const legendData = rawSeries.\n  filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n  ForecastSeriesEnum.Observation).\n  map((entry) => entry.name || '').\n  concat(extractAnnotationLabels(annotationLayers, annotationData));\n  let xAxis = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation\n    },\n    minorTick: { show: minorTicks },\n    minInterval: xAxisType === AxisType.Time && timeGrainSqla ?\n    TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n    0,\n    ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax, seriesType)\n  };\n  let yAxis = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.Log : AxisType.Value,\n    min: yAxisMin,\n    max: yAxisMax,\n    minorTick: { show: minorTicks },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(metrics, forcePercentFormatter, customFormatters, defaultFormatter, yAxisFormat)\n    },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end'\n  };\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n  }\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {var _getCustomFormatter2;\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue = richTooltip ?\n        params[0].value[xIndex] :\n        params.value[xIndex];\n        const forecastValue = richTooltip ? params : [params];\n        const sortedKeys = extractTooltipKeys(forecastValue, yIndex, richTooltip, tooltipSortByMetric);\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n        const isForecast = Object.values(forecastValues).some((value) => value.forecastTrend || value.forecastLower || value.forecastUpper);\n        const formatter = forcePercentFormatter ?\n        percentFormatter : (_getCustomFormatter2 =\n        getCustomFormatter(customFormatters, metrics)) != null ? _getCustomFormatter2 : defaultFormatter;\n        const rows = [];\n        const total = Object.values(forecastValues).reduce((acc, value) => value.observation !== undefined ? acc + value.observation : acc, 0);\n        const allowTotal = Boolean(isMultiSeries) && richTooltip && !isForecast;\n        const showPercentage = allowTotal && !forcePercentFormatter && showTooltipPercentage;\n        const keys = Object.keys(forecastValues);\n        let focusedRow;\n        sortedKeys.\n        filter((key) => keys.includes(key)).\n        forEach((key) => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter\n          });\n          if (showPercentage && value.observation !== undefined) {\n            row.push(percentFormatter.format(value.observation / (total || 1)));\n          }\n          rows.push(row);\n          if (key === focusedSeries) {\n            focusedRow = rows.length - 1;\n          }\n        });\n        if (stack) {\n          rows.reverse();\n          if (focusedRow !== undefined) {\n            focusedRow = rows.length - focusedRow - 1;\n          }\n        }\n        if (allowTotal && showTooltipTotal) {\n          const totalRow = ['Total', formatter.format(total)];\n          if (showPercentage) {\n            totalRow.push(percentFormatter.format(1));\n          }\n          rows.push(totalRow);\n        }\n        return tooltipHtml(rows, tooltipFormatter(xValue), focusedRow);\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable, legendState, padding),\n      data: legendData\n    },\n    series: dedupSeries(reorderForecastSeries(series)),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          ...(stack ? { yAxisIndex: false } : {}),\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom')\n          }\n        }\n      }\n    },\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom,\n      yAxisIndex: isHorizontal ? 0 : undefined\n    },\n    {\n      type: 'inside',\n      yAxisIndex: 0,\n      zoomOnMouseWheel: false,\n      moveOnMouseWheel: true\n    },\n    {\n      type: 'inside',\n      xAxisIndex: 0,\n      zoomOnMouseWheel: false,\n      moveOnMouseWheel: true\n    }] :\n\n    []\n  };\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby: groupBy,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType\n    },\n    refs,\n    coltypeMapping: dataTypes\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}