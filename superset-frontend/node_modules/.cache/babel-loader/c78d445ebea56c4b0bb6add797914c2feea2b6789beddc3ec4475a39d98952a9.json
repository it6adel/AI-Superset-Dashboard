{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo } from 'react';\nimport { MinusSquareOutlined, PlusSquareOutlined } from '@ant-design/icons';\nimport { CurrencyFormatter, FeatureFlag, getColumnLabel, getNumberFormatter, getSelectedText, isAdhocColumn, isFeatureEnabled, isPhysicalColumn, styled, t, useTheme } from '@superset-ui/core';\nimport { aggregatorTemplates, PivotTable, sortAs } from './react-pivottable';\nimport { MetricsLayoutEnum } from './types';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst Styles = styled.div`\n  ${({ height, width, margin }) => `\n      margin: ${margin}px;\n      height: ${height - margin * 2}px;\n      width: ${typeof width === 'string' ? parseInt(width, 10) : width - margin * 2}px;\n      white-space: nowrap;\n `}\n`;\nconst PivotTableWrapper = styled.div`\n  height: 100%;\n  max-width: inherit;\n  overflow: auto;\n`;\nconst METRIC_KEY = t('Metric');\nconst vals = ['value'];\nconst StyledPlusSquareOutlined = styled(PlusSquareOutlined)`\n  stroke: ${({ theme }) => theme.colors.grayscale.light2};\n  stroke-width: 16px;\n`;\nconst StyledMinusSquareOutlined = styled(MinusSquareOutlined)`\n  stroke: ${({ theme }) => theme.colors.grayscale.light2};\n  stroke-width: 16px;\n`;\nconst aggregatorsFactory = (formatter) => ({\n  Count: aggregatorTemplates.count(formatter),\n  'Count Unique Values': aggregatorTemplates.countUnique(formatter),\n  'List Unique Values': aggregatorTemplates.listUnique(', ', formatter),\n  Sum: aggregatorTemplates.sum(formatter),\n  Average: aggregatorTemplates.average(formatter),\n  Median: aggregatorTemplates.median(formatter),\n  'Sample Variance': aggregatorTemplates.var(1, formatter),\n  'Sample Standard Deviation': aggregatorTemplates.stdev(1, formatter),\n  Minimum: aggregatorTemplates.min(formatter),\n  Maximum: aggregatorTemplates.max(formatter),\n  First: aggregatorTemplates.first(formatter),\n  Last: aggregatorTemplates.last(formatter),\n  'Sum as Fraction of Total': aggregatorTemplates.fractionOf(aggregatorTemplates.sum(), 'total', formatter),\n  'Sum as Fraction of Rows': aggregatorTemplates.fractionOf(aggregatorTemplates.sum(), 'row', formatter),\n  'Sum as Fraction of Columns': aggregatorTemplates.fractionOf(aggregatorTemplates.sum(), 'col', formatter),\n  'Count as Fraction of Total': aggregatorTemplates.fractionOf(aggregatorTemplates.count(), 'total', formatter),\n  'Count as Fraction of Rows': aggregatorTemplates.fractionOf(aggregatorTemplates.count(), 'row', formatter),\n  'Count as Fraction of Columns': aggregatorTemplates.fractionOf(aggregatorTemplates.count(), 'col', formatter)\n});\n/* If you change this logic, please update the corresponding Python\n * function (https://github.com/apache/superset/blob/master/superset/charts/post_processing.py),\n * or reach out to @betodealmeida.\n */\nexport default function PivotTableChart(props) {\n  const { data, height, width, groupbyRows: groupbyRowsRaw, groupbyColumns: groupbyColumnsRaw, metrics, colOrder, rowOrder, aggregateFunction, transposePivot, combineMetric, rowSubtotalPosition, colSubtotalPosition, colTotals, colSubTotals, rowTotals, rowSubTotals, valueFormat, currencyFormat, emitCrossFilters, setDataMask, selectedFilters, verboseMap, columnFormats, currencyFormats, metricsLayout, metricColorFormatters, dateFormatters, onContextMenu, timeGrainSqla, allowRenderHtml } = props;\n  const theme = useTheme();\n  const defaultFormatter = useMemo(() => currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({\n    currency: currencyFormat,\n    d3Format: valueFormat\n  }) :\n  getNumberFormatter(valueFormat), [valueFormat, currencyFormat]);\n  const customFormatsArray = useMemo(() => Array.from(new Set([\n  ...Object.keys(columnFormats || {}),\n  ...Object.keys(currencyFormats || {})]\n  )).map((metricName) => [\n  metricName,\n  columnFormats[metricName] || valueFormat,\n  currencyFormats[metricName] || currencyFormat]\n  ), [columnFormats, currencyFormat, currencyFormats, valueFormat]);\n  const hasCustomMetricFormatters = customFormatsArray.length > 0;\n  const metricFormatters = useMemo(() => hasCustomMetricFormatters ?\n  {\n    [METRIC_KEY]: Object.fromEntries(customFormatsArray.map(([metric, d3Format, currency]) => [\n    metric,\n    currency ?\n    new CurrencyFormatter({\n      currency,\n      d3Format\n    }) :\n    getNumberFormatter(d3Format)]\n    ))\n  } :\n  undefined, [customFormatsArray, hasCustomMetricFormatters]);\n  const metricNames = useMemo(() => metrics.map((metric) => typeof metric === 'string' ? metric : metric.label), [metrics]);\n  const unpivotedData = useMemo(() => data.reduce((acc, record) => [\n  ...acc,\n  ...metricNames.\n  map((name) => ({\n    ...record,\n    [METRIC_KEY]: name,\n    value: record[name]\n  })).\n  filter((record) => record.value !== null)],\n  []), [data, metricNames]);\n  const groupbyRows = useMemo(() => groupbyRowsRaw.map(getColumnLabel), [groupbyRowsRaw]);\n  const groupbyColumns = useMemo(() => groupbyColumnsRaw.map(getColumnLabel), [groupbyColumnsRaw]);\n  const sorters = useMemo(() => ({\n    [METRIC_KEY]: sortAs(metricNames)\n  }), [metricNames]);\n  const [rows, cols] = useMemo(() => {\n    let [rows_, cols_] = transposePivot ?\n    [groupbyColumns, groupbyRows] :\n    [groupbyRows, groupbyColumns];\n    if (metricsLayout === MetricsLayoutEnum.ROWS) {\n      rows_ = combineMetric ? [...rows_, METRIC_KEY] : [METRIC_KEY, ...rows_];\n    } else\n    {\n      cols_ = combineMetric ? [...cols_, METRIC_KEY] : [METRIC_KEY, ...cols_];\n    }\n    return [rows_, cols_];\n  }, [\n  combineMetric,\n  groupbyColumns,\n  groupbyRows,\n  metricsLayout,\n  transposePivot]\n  );\n  const handleChange = useCallback((filters) => {\n    const filterKeys = Object.keys(filters);\n    const groupby = [...groupbyRowsRaw, ...groupbyColumnsRaw];\n    setDataMask({\n      extraFormData: {\n        filters: filterKeys.length === 0 ?\n        undefined :\n        filterKeys.map((key) => {var _groupby$find;\n          const val = filters == null ? void 0 : filters[key];\n          const col = (_groupby$find = groupby.find((item) => {\n            if (isPhysicalColumn(item)) {\n              return item === key;\n            }\n            if (isAdhocColumn(item)) {\n              return item.label === key;\n            }\n            return false;\n          })) != null ? _groupby$find : '';\n          if (val === null || val === undefined)\n          return {\n            col,\n            op: 'IS NULL'\n          };\n          return {\n            col,\n            op: 'IN',\n            val: val\n          };\n        })\n      },\n      filterState: {\n        value: filters && Object.keys(filters).length ?\n        Object.values(filters) :\n        null,\n        selectedFilters: filters && Object.keys(filters).length ? filters : null\n      }\n    });\n  }, [groupbyColumnsRaw, groupbyRowsRaw, setDataMask]);\n  const getCrossFilterDataMask = useCallback((value) => {\n    const isActiveFilterValue = (key, val) => {var _selectedFilters$key;return !!selectedFilters && ((_selectedFilters$key = selectedFilters[key]) == null ? void 0 : _selectedFilters$key.includes(val));};\n    if (!value) {\n      return undefined;\n    }\n    const [key, val] = Object.entries(value)[0];\n    let values = { ...selectedFilters };\n    if (isActiveFilterValue(key, val)) {\n      values = {};\n    } else\n    {\n      values = { [key]: [val] };\n    }\n    const filterKeys = Object.keys(values);\n    const groupby = [...groupbyRowsRaw, ...groupbyColumnsRaw];\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: filterKeys.length === 0 ?\n          undefined :\n          filterKeys.map((key) => {var _values, _groupby$find2;\n            const val = (_values = values) == null ? void 0 : _values[key];\n            const col = (_groupby$find2 = groupby.find((item) => {\n              if (isPhysicalColumn(item)) {\n                return item === key;\n              }\n              if (isAdhocColumn(item)) {\n                return item.label === key;\n              }\n              return false;\n            })) != null ? _groupby$find2 : '';\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL'\n            };\n            return {\n              col,\n              op: 'IN',\n              val: val\n            };\n          })\n        },\n        filterState: {\n          value: values && Object.keys(values).length ?\n          Object.values(values) :\n          null,\n          selectedFilters: values && Object.keys(values).length ? values : null\n        }\n      },\n      isCurrentValueSelected: isActiveFilterValue(key, val)\n    };\n  }, [groupbyColumnsRaw, groupbyRowsRaw, selectedFilters]);\n  const toggleFilter = useCallback((e, value, filters, pivotData, isSubtotal, isGrandTotal) => {\n    if (isSubtotal || isGrandTotal || !emitCrossFilters) {\n      return;\n    }\n    // allow selecting text in a cell\n    if (getSelectedText()) {\n      return;\n    }\n    const isActiveFilterValue = (key, val) => {var _selectedFilters$key2;return !!selectedFilters && ((_selectedFilters$key2 = selectedFilters[key]) == null ? void 0 : _selectedFilters$key2.includes(val));};\n    const filtersCopy = { ...filters };\n    delete filtersCopy[METRIC_KEY];\n    const filtersEntries = Object.entries(filtersCopy);\n    if (filtersEntries.length === 0) {\n      return;\n    }\n    const [key, val] = filtersEntries[filtersEntries.length - 1];\n    let updatedFilters = { ...(selectedFilters || {}) };\n    // multi select\n    // if (selectedFilters && isActiveFilterValue(key, val)) {\n    //   updatedFilters[key] = selectedFilters[key].filter((x: DataRecordValue) => x !== val);\n    // } else {\n    //   updatedFilters[key] = [...(selectedFilters?.[key] || []), val];\n    // }\n    // single select\n    if (selectedFilters && isActiveFilterValue(key, val)) {\n      updatedFilters = {};\n    } else\n    {\n      updatedFilters = {\n        [key]: [val]\n      };\n    }\n    if (Array.isArray(updatedFilters[key]) &&\n    updatedFilters[key].length === 0) {\n      delete updatedFilters[key];\n    }\n    handleChange(updatedFilters);\n  }, [emitCrossFilters, selectedFilters, handleChange]);\n  const tableOptions = useMemo(() => ({\n    clickRowHeaderCallback: toggleFilter,\n    clickColumnHeaderCallback: toggleFilter,\n    colTotals,\n    colSubTotals,\n    rowTotals,\n    rowSubTotals,\n    highlightHeaderCellsOnHover: emitCrossFilters ||\n    isFeatureEnabled(FeatureFlag.DrillBy) ||\n    isFeatureEnabled(FeatureFlag.DrillToDetail),\n    highlightedHeaderCells: selectedFilters,\n    omittedHighlightHeaderGroups: [METRIC_KEY],\n    cellColorFormatters: { [METRIC_KEY]: metricColorFormatters },\n    dateFormatters\n  }), [\n  colTotals,\n  colSubTotals,\n  dateFormatters,\n  emitCrossFilters,\n  metricColorFormatters,\n  rowTotals,\n  rowSubTotals,\n  selectedFilters,\n  toggleFilter]\n  );\n  const subtotalOptions = useMemo(() => ({\n    colSubtotalDisplay: { displayOnTop: colSubtotalPosition },\n    rowSubtotalDisplay: { displayOnTop: rowSubtotalPosition },\n    arrowCollapsed: _jsx(StyledPlusSquareOutlined, {}),\n    arrowExpanded: _jsx(StyledMinusSquareOutlined, {})\n  }), [colSubtotalPosition, rowSubtotalPosition]);\n  const handleContextMenu = useCallback((e, colKey, rowKey, dataPoint) => {\n    if (onContextMenu) {\n      e.preventDefault();\n      e.stopPropagation();\n      const drillToDetailFilters = [];\n      if (colKey && colKey.length > 1) {\n        colKey.forEach((val, i) => {\n          const col = cols[i];\n          const formatter = dateFormatters[col];\n          const formattedVal = (formatter == null ? void 0 : formatter(val)) || String(val);\n          if (i > 0) {\n            drillToDetailFilters.push({\n              col,\n              op: '==',\n              val,\n              formattedVal,\n              grain: formatter ? timeGrainSqla : undefined\n            });\n          }\n        });\n      }\n      if (rowKey) {\n        rowKey.forEach((val, i) => {\n          const col = rows[i];\n          const formatter = dateFormatters[col];\n          const formattedVal = (formatter == null ? void 0 : formatter(val)) || String(val);\n          drillToDetailFilters.push({\n            col,\n            op: '==',\n            val,\n            formattedVal,\n            grain: formatter ? timeGrainSqla : undefined\n          });\n        });\n      }\n      onContextMenu(e.clientX, e.clientY, {\n        drillToDetail: drillToDetailFilters,\n        crossFilter: getCrossFilterDataMask(dataPoint),\n        drillBy: dataPoint && {\n          filters: [\n          {\n            col: Object.keys(dataPoint)[0],\n            op: '==',\n            val: Object.values(dataPoint)[0]\n          }],\n\n          groupbyFieldName: rowKey ? 'groupbyRows' : 'groupbyColumns'\n        }\n      });\n    }\n  }, [\n  cols,\n  dateFormatters,\n  getCrossFilterDataMask,\n  onContextMenu,\n  rows,\n  timeGrainSqla]\n  );\n  return _jsx(Styles, { height: height, width: width, margin: theme.gridUnit * 4, children:\n    _jsx(PivotTableWrapper, { children:\n      _jsx(PivotTable, { data: unpivotedData, rows: rows, cols: cols, aggregatorsFactory: aggregatorsFactory, defaultFormatter: defaultFormatter, customFormatters: metricFormatters, aggregatorName: aggregateFunction, vals: vals, colOrder: colOrder, rowOrder: rowOrder, sorters: sorters, tableOptions: tableOptions, subtotalOptions: subtotalOptions, namesMapping: verboseMap, onContextMenu: handleContextMenu, allowRenderHtml: allowRenderHtml }) }\n    ) }\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}