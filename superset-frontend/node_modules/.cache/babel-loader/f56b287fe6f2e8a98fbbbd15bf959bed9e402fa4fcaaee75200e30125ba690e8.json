{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { ComparisonType, CurrencyFormatter, ensureIsArray, extractTimegrain, GenericDataType, getMetricLabel, getNumberFormatter, getTimeFormatter, getTimeFormatterForGranularity, NumberFormats, QueryMode, t, SMART_DATE_ID, TimeFormats } from '@superset-ui/core';\nimport { getColorFormatters } from '@superset-ui/chart-controls';\n\nimport isEqualColumns from './utils/isEqualColumns';\nimport DateWithFormatter from './utils/DateWithFormatter';\nimport { ColorSchemeEnum } from './types';\nconst { PERCENT_3_POINT } = NumberFormats;\nconst { DATABASE_DATETIME } = TimeFormats;\nfunction isNumeric(key, data = []) {\n  return data.every((x) => x[key] === null || x[key] === undefined || typeof x[key] === 'number');\n}\nconst processDataRecords = memoizeOne(function processDataRecords(data, columns) {\n  if (!(data != null && data[0])) {\n    return data || [];\n  }\n  const timeColumns = columns.filter((column) => column.dataType === GenericDataType.Temporal);\n  if (timeColumns.length > 0) {\n    return data.map((x) => {\n      const datum = { ...x };\n      timeColumns.forEach(({ key, formatter }) => {\n        // Convert datetime with a custom date class so we can use `String(...)`\n        // formatted value for global search, and `date.getTime()` for sorting.\n        datum[key] = new DateWithFormatter(x[key], {\n          formatter: formatter\n        });\n      });\n      return datum;\n    });\n  }\n  return data;\n});\nconst calculateDifferences = (originalValue, comparisonValue) => {\n  const valueDifference = originalValue - comparisonValue;\n  let percentDifferenceNum;\n  if (!originalValue && !comparisonValue) {\n    percentDifferenceNum = 0;\n  } else\n  if (!originalValue || !comparisonValue) {\n    percentDifferenceNum = originalValue ? 1 : -1;\n  } else\n  {\n    percentDifferenceNum =\n    (originalValue - comparisonValue) / Math.abs(comparisonValue);\n  }\n  return { valueDifference, percentDifferenceNum };\n};\nconst processComparisonTotals = (comparisonSuffix, totals) => {\n  if (!totals) {\n    return totals;\n  }\n  const transformedTotals = {};\n  totals.map((totalRecord) => Object.keys(totalRecord).forEach((key) => {\n    if (totalRecord[key] !== undefined && !key.includes(comparisonSuffix)) {var _transformedTotals, _totalRecord$key, _transformedTotals2, _totalRecord;\n      transformedTotals[`Main ${key}`] =\n      parseInt(((_transformedTotals = transformedTotals[`Main ${key}`]) == null ? void 0 : _transformedTotals.toString()) || '0', 10) +\n      parseInt(((_totalRecord$key = totalRecord[key]) == null ? void 0 : _totalRecord$key.toString()) || '0', 10);\n      transformedTotals[`# ${key}`] =\n      parseInt(((_transformedTotals2 = transformedTotals[`# ${key}`]) == null ? void 0 : _transformedTotals2.toString()) || '0', 10) +\n      parseInt(((_totalRecord = totalRecord[`${key}__${comparisonSuffix}`]) == null ? void 0 : _totalRecord.toString()) || '0', 10);\n      const { valueDifference, percentDifferenceNum } = calculateDifferences(transformedTotals[`Main ${key}`], transformedTotals[`# ${key}`]);\n      transformedTotals[`△ ${key}`] = valueDifference;\n      transformedTotals[`% ${key}`] = percentDifferenceNum;\n    }\n  }));\n  return transformedTotals;\n};\nconst processComparisonDataRecords = memoizeOne(function processComparisonDataRecords(originalData, originalColumns, comparisonSuffix) {\n  // Transform data\n  return originalData == null ? void 0 : originalData.map((originalItem) => {\n    const transformedItem = {};\n    originalColumns.forEach((origCol) => {\n      if ((origCol.isMetric || origCol.isPercentMetric) &&\n      !origCol.key.includes(comparisonSuffix) &&\n      origCol.isNumeric) {\n        const originalValue = originalItem[origCol.key] || 0;\n        const comparisonValue = origCol.isMetric ?\n        (originalItem == null ? void 0 : originalItem[`${origCol.key}__${comparisonSuffix}`]) || 0 :\n        originalItem[`%${origCol.key.slice(1)}__${comparisonSuffix}`] ||\n        0;\n        const { valueDifference, percentDifferenceNum } = calculateDifferences(originalValue, comparisonValue);\n        transformedItem[`Main ${origCol.key}`] = originalValue;\n        transformedItem[`# ${origCol.key}`] = comparisonValue;\n        transformedItem[`△ ${origCol.key}`] = valueDifference;\n        transformedItem[`% ${origCol.key}`] = percentDifferenceNum;\n      }\n    });\n    Object.keys(originalItem).forEach((key) => {\n      const isMetricOrPercentMetric = originalColumns.some((col) => col.key === key && (col.isMetric || col.isPercentMetric));\n      if (!isMetricOrPercentMetric) {\n        transformedItem[key] = originalItem[key];\n      }\n    });\n    return transformedItem;\n  });\n});\nconst processColumns = memoizeOne(function processColumns(props) {\n  const { datasource: { columnFormats, currencyFormats, verboseMap }, rawFormData: { table_timestamp_format: tableTimestampFormat, metrics: metrics_, percent_metrics: percentMetrics_, column_config: columnConfig = {} }, queriesData } = props;\n  const granularity = extractTimegrain(props.rawFormData);\n  const { data: records, colnames, coltypes } = queriesData[0] || {};\n  // convert `metrics` and `percentMetrics` to the key names in `data.records`\n  const metrics = (metrics_ != null ? metrics_ : []).map(getMetricLabel);\n  const rawPercentMetrics = (percentMetrics_ != null ? percentMetrics_ : []).map(getMetricLabel);\n  // column names for percent metrics always starts with a '%' sign.\n  const percentMetrics = rawPercentMetrics.map((x) => `%${x}`);\n  const metricsSet = new Set(metrics);\n  const percentMetricsSet = new Set(percentMetrics);\n  const rawPercentMetricsSet = new Set(rawPercentMetrics);\n  const columns = (colnames || []).\n  filter((key) =>\n  // if a metric was only added to percent_metrics, they should not show up in the table.\n  !(rawPercentMetricsSet.has(key) && !metricsSet.has(key))).\n  map((key, i) => {var _config$currencyForma;\n    const dataType = coltypes[i];\n    const config = columnConfig[key] || {};\n    // for the purpose of presentation, only numeric values are treated as metrics\n    // because users can also add things like `MAX(str_col)` as a metric.\n    const isMetric = metricsSet.has(key) && isNumeric(key, records);\n    const isPercentMetric = percentMetricsSet.has(key);\n    const label = isPercentMetric && verboseMap != null && verboseMap.hasOwnProperty(key.replace('%', '')) ?\n    `%${verboseMap[key.replace('%', '')]}` :\n    (verboseMap == null ? void 0 : verboseMap[key]) || key;\n    const isTime = dataType === GenericDataType.Temporal;\n    const isNumber = dataType === GenericDataType.Numeric;\n    const savedFormat = columnFormats == null ? void 0 : columnFormats[key];\n    const savedCurrency = currencyFormats == null ? void 0 : currencyFormats[key];\n    const numberFormat = config.d3NumberFormat || savedFormat;\n    const currency = (_config$currencyForma = config.currencyFormat) != null && _config$currencyForma.symbol ?\n    config.currencyFormat :\n    savedCurrency;\n    let formatter;\n    if (isTime || config.d3TimeFormat) {\n      // string types may also apply d3-time format\n      // pick adhoc format first, fallback to column level formats defined in\n      // datasource\n      const customFormat = config.d3TimeFormat || savedFormat;\n      const timeFormat = customFormat || tableTimestampFormat;\n      // When format is \"Adaptive Formatting\" (smart_date)\n      if (timeFormat === SMART_DATE_ID) {\n        if (granularity) {\n          // time column use formats based on granularity\n          formatter = getTimeFormatterForGranularity(granularity);\n        } else\n        if (customFormat) {\n          // other columns respect the column-specific format\n          formatter = getTimeFormatter(customFormat);\n        } else\n        if (isNumeric(key, records)) {\n          // if column is numeric values, it is considered a timestamp64\n          formatter = getTimeFormatter(DATABASE_DATETIME);\n        } else\n        {\n          // if no column-specific format, print cell as is\n          formatter = String;\n        }\n      } else\n      if (timeFormat) {\n        formatter = getTimeFormatter(timeFormat);\n      }\n    } else\n    if (isPercentMetric) {\n      // percent metrics have a default format\n      formatter = getNumberFormatter(numberFormat || PERCENT_3_POINT);\n    } else\n    if (isMetric || isNumber && (numberFormat || currency)) {\n      formatter = currency ?\n      new CurrencyFormatter({\n        d3Format: numberFormat,\n        currency\n      }) :\n      getNumberFormatter(numberFormat);\n    }\n    return {\n      key,\n      label,\n      dataType,\n      isNumeric: dataType === GenericDataType.Numeric,\n      isMetric,\n      isPercentMetric,\n      formatter,\n      config\n    };\n  });\n  return [metrics, percentMetrics, columns];\n}, isEqualColumns);\nconst getComparisonColConfig = (label, parentColKey, columnConfig) => {\n  const comparisonKey = `${label} ${parentColKey}`;\n  const comparisonColConfig = columnConfig[comparisonKey] || {};\n  return comparisonColConfig;\n};\nconst getComparisonColFormatter = (label, parentCol, columnConfig, savedFormat, savedCurrency) => {var _currentColConfig$cur, _parentCol$config;\n  const currentColConfig = getComparisonColConfig(label, parentCol.key, columnConfig);\n  const hasCurrency = (_currentColConfig$cur = currentColConfig.currencyFormat) == null ? void 0 : _currentColConfig$cur.symbol;\n  const currentColNumberFormat =\n  // fallback to parent's number format if not set\n  currentColConfig.d3NumberFormat || ((_parentCol$config = parentCol.config) == null ? void 0 : _parentCol$config.d3NumberFormat);\n  let { formatter } = parentCol;\n  if (label === '%') {\n    formatter = getNumberFormatter(currentColNumberFormat || PERCENT_3_POINT);\n  } else\n  if (currentColNumberFormat || hasCurrency) {\n    const currency = currentColConfig.currencyFormat || savedCurrency;\n    const numberFormat = currentColNumberFormat || savedFormat;\n    formatter = currency ?\n    new CurrencyFormatter({\n      d3Format: numberFormat,\n      currency\n    }) :\n    getNumberFormatter(numberFormat);\n  }\n  return formatter;\n};\nconst processComparisonColumns = (columns, props, comparisonSuffix) => columns.\nmap((col) => {\n  const { datasource: { columnFormats, currencyFormats }, rawFormData: { column_config: columnConfig = {} } } = props;\n  const savedFormat = columnFormats == null ? void 0 : columnFormats[col.key];\n  const savedCurrency = currencyFormats == null ? void 0 : currencyFormats[col.key];\n  if ((col.isMetric || col.isPercentMetric) &&\n  !col.key.includes(comparisonSuffix) &&\n  col.isNumeric) {\n    return [\n    {\n      ...col,\n      label: t('Main'),\n      key: `${t('Main')} ${col.key}`,\n      config: getComparisonColConfig(t('Main'), col.key, columnConfig),\n      formatter: getComparisonColFormatter(t('Main'), col, columnConfig, savedFormat, savedCurrency)\n    },\n    {\n      ...col,\n      label: `#`,\n      key: `# ${col.key}`,\n      config: getComparisonColConfig(`#`, col.key, columnConfig),\n      formatter: getComparisonColFormatter(`#`, col, columnConfig, savedFormat, savedCurrency)\n    },\n    {\n      ...col,\n      label: `△`,\n      key: `△ ${col.key}`,\n      config: getComparisonColConfig(`△`, col.key, columnConfig),\n      formatter: getComparisonColFormatter(`△`, col, columnConfig, savedFormat, savedCurrency)\n    },\n    {\n      ...col,\n      label: `%`,\n      key: `% ${col.key}`,\n      config: getComparisonColConfig(`%`, col.key, columnConfig),\n      formatter: getComparisonColFormatter(`%`, col, columnConfig, savedFormat, savedCurrency)\n    }];\n\n  }\n  if (!col.isMetric &&\n  !col.isPercentMetric &&\n  !col.key.includes(comparisonSuffix)) {\n    return [col];\n  }\n  return [];\n}).\nflat();\n/**\n * Automatically set page size based on number of cells.\n */\nconst getPageSize = (pageSize, numRecords, numColumns) => {\n  if (typeof pageSize === 'number') {\n    // NaN is also has typeof === 'number'\n    return pageSize || 0;\n  }\n  if (typeof pageSize === 'string') {\n    return Number(pageSize) || 0;\n  }\n  // when pageSize not set, automatically add pagination if too many records\n  return numRecords * numColumns > 5000 ? 200 : 0;\n};\nconst defaultServerPaginationData = {};\nconst defaultColorFormatters = [];\nconst transformProps = (chartProps) => {var _baseQuery2, _baseQuery3, _totalQuery, _totalQuery2, _baseQuery4, _getColorFormatters, _baseQuery5, _chartProps$rawFormDa;\n  const { height, width, rawFormData: formData, queriesData = [], filterState, ownState: serverPaginationData, hooks: { onAddFilter: onChangeFilter, setDataMask = () => {}, onContextMenu }, emitCrossFilters } = chartProps;\n  const { align_pn: alignPositiveNegative = true, color_pn: colorPositiveNegative = true, show_cell_bars: showCellBars = true, include_search: includeSearch = false, page_length: pageLength, server_pagination: serverPagination = false, server_page_length: serverPageLength = 10, order_desc: sortDesc = false, query_mode: queryMode, show_totals: showTotals, conditional_formatting: conditionalFormatting, allow_rearrange_columns: allowRearrangeColumns, allow_render_html: allowRenderHtml, time_compare, comparison_color_enabled: comparisonColorEnabled = false, comparison_color_scheme: comparisonColorScheme = ColorSchemeEnum.Green, comparison_type } = formData;\n  const isUsingTimeComparison = !_isEmpty(time_compare) &&\n  queryMode === QueryMode.Aggregate &&\n  comparison_type === ComparisonType.Values;\n  const calculateBasicStyle = (percentDifferenceNum, colorOption) => {\n    if (percentDifferenceNum === 0) {\n      return {\n        arrow: '',\n        arrowColor: '',\n        // eslint-disable-next-line theme-colors/no-literal-colors\n        backgroundColor: 'rgba(0,0,0,0.2)'\n      };\n    }\n    const isPositive = percentDifferenceNum > 0;\n    const arrow = isPositive ? '↑' : '↓';\n    const arrowColor = colorOption === ColorSchemeEnum.Green ?\n    isPositive ?\n    ColorSchemeEnum.Green :\n    ColorSchemeEnum.Red :\n    isPositive ?\n    ColorSchemeEnum.Red :\n    ColorSchemeEnum.Green;\n    const backgroundColor = colorOption === ColorSchemeEnum.Green ?\n    `rgba(${isPositive ? '0,150,0' : '150,0,0'},0.2)` :\n    `rgba(${isPositive ? '150,0,0' : '0,150,0'},0.2)`;\n    return { arrow, arrowColor, backgroundColor };\n  };\n  const getBasicColorFormatter = memoizeOne(function getBasicColorFormatter(originalData, originalColumns, selectedColumns) {\n    // Transform data\n    const relevantColumns = selectedColumns ?\n    originalColumns.filter((col) => selectedColumns.some((scol) => {var _scol$column;return scol == null ? void 0 : (_scol$column = scol.column) == null ? void 0 : _scol$column.includes(col.key);})) :\n    originalColumns;\n    return originalData == null ? void 0 : originalData.map((originalItem) => {\n      const item = {};\n      relevantColumns.forEach((origCol) => {\n        if ((origCol.isMetric || origCol.isPercentMetric) &&\n        !origCol.key.includes(ensureIsArray(timeOffsets)[0]) &&\n        origCol.isNumeric) {\n          const originalValue = originalItem[origCol.key] || 0;\n          const comparisonValue = origCol.isMetric ?\n          (originalItem == null ? void 0 : originalItem[`${origCol.key}__${ensureIsArray(timeOffsets)[0]}`]) || 0 :\n          originalItem[`%${origCol.key.slice(1)}__${ensureIsArray(timeOffsets)[0]}`] || 0;\n          const { percentDifferenceNum } = calculateDifferences(originalValue, comparisonValue);\n          if (selectedColumns) {\n            selectedColumns.forEach((col) => {var _col$column;\n              if (col != null && (_col$column = col.column) != null && _col$column.includes(origCol.key)) {\n                const { arrow, arrowColor, backgroundColor } = calculateBasicStyle(percentDifferenceNum, col.colorScheme || comparisonColorScheme);\n                item[col.column] = {\n                  mainArrow: arrow,\n                  arrowColor,\n                  backgroundColor\n                };\n              }\n            });\n          } else\n          {\n            const { arrow, arrowColor, backgroundColor } = calculateBasicStyle(percentDifferenceNum, comparisonColorScheme);\n            item[`${origCol.key}`] = {\n              mainArrow: arrow,\n              arrowColor,\n              backgroundColor\n            };\n          }\n        }\n      });\n      return item;\n    });\n  });\n  const getBasicColorFormatterForColumn = (originalData, originalColumns, conditionalFormatting) => {\n    const selectedColumns = conditionalFormatting == null ? void 0 : conditionalFormatting.filter((config) => config.column && (\n    config.colorScheme === ColorSchemeEnum.Green ||\n    config.colorScheme === ColorSchemeEnum.Red));\n    return selectedColumns != null && selectedColumns.length ?\n    getBasicColorFormatter(originalData, originalColumns, selectedColumns) :\n    undefined;\n  };\n  const timeGrain = extractTimegrain(formData);\n  const nonCustomNorInheritShifts = ensureIsArray(formData.time_compare).filter((shift) => shift !== 'custom' && shift !== 'inherit');\n  const customOrInheritShifts = ensureIsArray(formData.time_compare).filter((shift) => shift === 'custom' || shift === 'inherit');\n  let timeOffsets = [];\n  if (isUsingTimeComparison && !_isEmpty(nonCustomNorInheritShifts)) {\n    timeOffsets = nonCustomNorInheritShifts;\n  }\n  // Shifts for custom or inherit time comparison\n  if (isUsingTimeComparison && !_isEmpty(customOrInheritShifts)) {\n    if (customOrInheritShifts.includes('custom')) {\n      timeOffsets = timeOffsets.concat([formData.start_date_offset]);\n    }\n    if (customOrInheritShifts.includes('inherit')) {\n      timeOffsets = timeOffsets.concat(['inherit']);\n    }\n  }\n  const comparisonSuffix = isUsingTimeComparison ?\n  ensureIsArray(timeOffsets)[0] :\n  '';\n  const [metrics, percentMetrics, columns] = processColumns(chartProps);\n  let comparisonColumns = [];\n  if (isUsingTimeComparison) {\n    comparisonColumns = processComparisonColumns(columns, chartProps, comparisonSuffix);\n  }\n  let baseQuery;\n  let countQuery;\n  let totalQuery;\n  let rowCount;\n  if (serverPagination) {var _countQuery$data$0$ro, _countQuery, _countQuery$data, _countQuery$data$;\n    [baseQuery, countQuery, totalQuery] = queriesData;\n    rowCount = (_countQuery$data$0$ro = (_countQuery = countQuery) == null ? void 0 : (_countQuery$data = _countQuery.data) == null ? void 0 : (_countQuery$data$ = _countQuery$data[0]) == null ? void 0 : _countQuery$data$.rowcount) != null ? _countQuery$data$0$ro : 0;\n  } else\n  {var _baseQuery$rowcount, _baseQuery;\n    [baseQuery, totalQuery] = queriesData;\n    rowCount = (_baseQuery$rowcount = (_baseQuery = baseQuery) == null ? void 0 : _baseQuery.rowcount) != null ? _baseQuery$rowcount : 0;\n  }\n  const data = processDataRecords((_baseQuery2 = baseQuery) == null ? void 0 : _baseQuery2.data, columns);\n  const comparisonData = processComparisonDataRecords((_baseQuery3 = baseQuery) == null ? void 0 : _baseQuery3.data, columns, comparisonSuffix);\n  const totals = showTotals && queryMode === QueryMode.Aggregate ?\n  isUsingTimeComparison ?\n  processComparisonTotals(comparisonSuffix, (_totalQuery = totalQuery) == null ? void 0 : _totalQuery.data) : (_totalQuery2 =\n  totalQuery) == null ? void 0 : _totalQuery2.data[0] :\n  undefined;\n  const passedData = isUsingTimeComparison ? comparisonData || [] : data;\n  const passedColumns = isUsingTimeComparison ? comparisonColumns : columns;\n  const basicColorFormatters = comparisonColorEnabled && getBasicColorFormatter((_baseQuery4 = baseQuery) == null ? void 0 : _baseQuery4.data, columns);\n  const columnColorFormatters = (_getColorFormatters = getColorFormatters(conditionalFormatting, passedData)) != null ? _getColorFormatters :\n  defaultColorFormatters;\n  const basicColorColumnFormatters = getBasicColorFormatterForColumn((_baseQuery5 = baseQuery) == null ? void 0 : _baseQuery5.data, columns, conditionalFormatting);\n  const startDateOffset = (_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.start_date_offset;\n  return {\n    height,\n    width,\n    isRawRecords: queryMode === QueryMode.Raw,\n    data: passedData,\n    totals,\n    columns: passedColumns,\n    serverPagination,\n    metrics,\n    percentMetrics,\n    serverPaginationData: serverPagination ?\n    serverPaginationData :\n    defaultServerPaginationData,\n    setDataMask,\n    alignPositiveNegative,\n    colorPositiveNegative,\n    showCellBars,\n    sortDesc,\n    includeSearch,\n    rowCount,\n    pageSize: serverPagination ?\n    serverPageLength :\n    getPageSize(pageLength, data.length, columns.length),\n    filters: filterState.filters,\n    emitCrossFilters,\n    onChangeFilter,\n    columnColorFormatters,\n    timeGrain,\n    allowRearrangeColumns,\n    allowRenderHtml,\n    onContextMenu,\n    isUsingTimeComparison,\n    basicColorFormatters,\n    startDateOffset,\n    basicColorColumnFormatters\n  };\n};\nexport default transformProps;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}