{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api } from './queryApi';\nconst schemaApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    schemas: builder.query({\n      providesTags: [{ type: 'Schemas', id: 'LIST' }],\n      query: ({ dbId, catalog, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId}/schemas/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n          ...(catalog !== undefined && { catalog })\n        },\n        transformResponse: ({ json }) => json.result.sort().map((value) => ({\n          value,\n          label: value,\n          title: value\n        }))\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId, catalog } }) => ({\n        dbId,\n        catalog\n      })\n    })\n  })\n});\nexport const { useLazySchemasQuery, useSchemasQuery, endpoints: schemaEndpoints, util: schemaApiUtil } = schemaApi;\nexport const EMPTY_SCHEMAS = [];\nexport function useSchemas(options) {\n  const { dbId, catalog, onSuccess, onError } = options || {};\n  const [trigger] = useLazySchemasQuery();\n  const result = useSchemasQuery({ dbId, catalog: catalog || undefined, forceRefresh: false }, {\n    skip: !dbId\n  });\n  useEffect(() => {\n    if (result.isError) {\n      onError == null ? void 0 : onError(result.error);\n    }\n  }, [result.isError, result.error, onError]);\n  const fetchData = useEffectEvent((dbId, catalog, forceRefresh = false) => {\n    if (dbId && (!result.currentData || forceRefresh)) {\n      trigger({ dbId, catalog, forceRefresh }).then(({ isSuccess, isError, data }) => {\n        if (isSuccess) {\n          onSuccess == null ? void 0 : onSuccess(data || EMPTY_SCHEMAS, forceRefresh);\n        }\n        if (isError) {\n          onError == null ? void 0 : onError(result.error);\n        }\n      });\n    }\n  });\n  useEffect(() => {\n    fetchData(dbId, catalog, false);\n  }, [dbId, catalog, fetchData]);\n  const refetch = useCallback(() => {\n    fetchData(dbId, catalog, true);\n  }, [dbId, catalog, fetchData]);\n  return {\n    ...result,\n    refetch\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}