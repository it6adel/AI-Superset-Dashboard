{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport Mexp from 'math-expression-evaluator';\nconst mexp = new Mexp();\nconst REPLACE_OPERATORS = [\n[new RegExp(/==/g), 'Eq'],\n[new RegExp(/>=/g), 'Gte'],\n[new RegExp(/<=/g), 'Lte'],\n[new RegExp(/>/g), 'Gt'],\n[new RegExp(/</g), 'Lt']];\n\nconst TOKENS = [\n{\n  type: 3,\n  token: 'x',\n  show: 'x',\n  value: 'x'\n},\n{\n  type: 2,\n  token: '&',\n  show: '&',\n  value: (a, b) => a & b\n},\n{\n  type: 2,\n  token: '|',\n  show: '|',\n  value: (a, b) => a | b\n},\n{\n  type: 2,\n  token: 'and',\n  show: 'and',\n  value: (a, b) => a && b\n},\n{\n  type: 2,\n  token: 'xor',\n  show: 'xor',\n  value: (a, b) => a ^ b\n},\n{\n  type: 2,\n  token: 'or',\n  show: 'or',\n  value: (a, b) => Number(a || b)\n},\n{\n  type: 2,\n  token: 'Eq',\n  show: 'Eq',\n  value: (a, b) => Number(a === b)\n},\n{\n  type: 2,\n  token: 'Lt',\n  show: 'Lt',\n  value: (a, b) => Number(a < b)\n},\n{\n  type: 2,\n  token: 'Lte',\n  show: 'Lte',\n  value: (a, b) => Number(a <= b)\n},\n{\n  type: 2,\n  token: 'Gt',\n  show: 'Gt',\n  value: (a, b) => Number(a > b)\n},\n{\n  type: 2,\n  token: 'Gte',\n  show: 'Gte',\n  value: (a, b) => Number(a >= b)\n}];\n\nexport function evalExpression(expression, value) {var _subExpressions$;\n  let parsedExpression = expression;\n  // replace `<` with `Lt` (and others) to avoid clashes with builtin function operators\n  // that are not needed in Superset.\n  REPLACE_OPERATORS.forEach(([key, value]) => {\n    parsedExpression = parsedExpression.replace(key, value);\n  });\n  const subExpressions = String(parsedExpression).split('=');\n  parsedExpression = (_subExpressions$ = subExpressions[1]) != null ? _subExpressions$ : subExpressions[0];\n  // we can ignore the type requirement on `TOKENS`, as value is always `number`\n  // and doesn't need to consider `number | undefined`.\n  // @ts-ignore\n  return Number(mexp.eval(parsedExpression, TOKENS, { x: value }));\n}\nexport function isValidExpression(expression) {\n  try {\n    evalExpression(expression, 0);\n  }\n  catch (err) {\n    return false;\n  }\n  return true;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}