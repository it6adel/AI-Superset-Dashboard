{"ast":null,"code":"import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useEffect, useState } from 'react';\nimport Point from 'ol/geom/Point';\nimport { unByKey } from 'ol/Observable';\nimport { toLonLat } from 'ol/proj';\n\nimport { fitMapToCharts } from '../util/mapUtil';\nimport { ChartLayer } from './ChartLayer';\nimport { createLayer } from '../util/layerUtil';\nimport { isChartConfigEqual } from '../util/chartUtil';\n/** The name to reference the chart layer */import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst CHART_LAYER_NAME = 'openlayers-chart-layer';\nexport const OlChartMap = (props) => {\n  const { height, width, mapId, olMap, chartConfigs, chartSize, chartVizType, layerConfigs, mapView, chartBackgroundColor, chartBackgroundBorderRadius, setControlValue, theme } = props;\n  const [currentChartConfigs, setCurrentChartConfigs] = useState(chartConfigs);\n  const [currentMapView, setCurrentMapView] = useState(mapView);\n  /**\n   * Add map to correct DOM element.\n   */\n  useEffect(() => {\n    olMap.setTarget(mapId);\n  }, [olMap, mapId]);\n  /**\n   * Update map size if size of parent container changes.\n   */\n  useEffect(() => {\n    olMap.updateSize();\n  }, [olMap, width, height]);\n  /**\n   * The prop chartConfigs will always be created on the fly,\n   * therefore the shallow comparison of the effect hooks will\n   * always trigger. In this hook, we make a 'deep comparison'\n   * between the incoming prop and the state. Only if the objects\n   * differ will we set the state to the new object. All other\n   * effect hooks that depend on chartConfigs should now depend\n   * on currentChartConfigs instead.\n   */\n  useEffect(() => {\n    setCurrentChartConfigs((oldCurrentChartConfigs) => {\n      if (isChartConfigEqual(chartConfigs, oldCurrentChartConfigs)) {\n        return oldCurrentChartConfigs;\n      }\n      return chartConfigs;\n    });\n  }, [chartConfigs]);\n  /**\n   * The prop mapView will always be created on the fly,\n   * therefore the shallow comparison of the effect hooks will\n   * always trigger. In this hook, we compare only those props\n   * that might be changed from outside of the component, i.e the\n   * fixed properties and the mode. Only if these values differ will\n   * we set the state to the new object. All other effect hooks that\n   * depend on mapView should now depend on currentMapView instead.\n   */\n  useEffect(() => {\n    setCurrentMapView((oldCurrentMapView) => {\n      const sameFixedZoom = oldCurrentMapView.fixedZoom === mapView.fixedZoom;\n      const sameFixedLon = oldCurrentMapView.fixedLongitude === mapView.fixedLongitude;\n      const sameFixedLat = oldCurrentMapView.fixedLatitude === mapView.fixedLatitude;\n      const sameMode = oldCurrentMapView.mode === mapView.mode;\n      if (sameFixedZoom && sameFixedLon && sameFixedLat && sameMode) {\n        return oldCurrentMapView;\n      }\n      return mapView;\n    });\n  }, [mapView]);\n  /**\n   * Set initial map extent.\n   */\n  useEffect(() => {\n    const view = olMap.getView();\n    const { mode, fixedLatitude, fixedLongitude, fixedZoom } = mapView;\n    switch (mode) {\n      case 'CUSTOM':{\n          const fixedCenter = new Point([fixedLongitude, fixedLatitude]);\n          fixedCenter.transform('EPSG:4326', 'EPSG:3857'); // in-place\n          view.setZoom(fixedZoom);\n          view.setCenter(fixedCenter.getCoordinates());\n          break;\n        }\n      default:{\n          fitMapToCharts(olMap, chartConfigs);\n          const zoom = view.getZoom();\n          const centerCoord = view.getCenter();\n          if (!centerCoord)\n          return;\n          const centerPoint = new Point(centerCoord);\n          centerPoint.transform('EPSG:3857', 'EPSG:4326'); // in-place\n          const [longitude, latitude] = centerPoint.getCoordinates();\n          setControlValue('map_view', {\n            ...mapView,\n            zoom,\n            longitude,\n            latitude,\n            fixedLatitude: latitude,\n            fixedLongitude: longitude,\n            fixedZoom: zoom\n          });\n          break;\n        }\n    }\n  }, []);\n  /**\n   * Update non-chart layers\n   */\n  useEffect(() => {\n    // clear existing layers\n    // We first filter the layers we want to remove,\n    // because removing items from an array during a loop can be erroneous.\n    const layersToRemove = olMap.\n    getLayers().\n    getArray().\n    filter((layer) => !(layer instanceof ChartLayer));\n    layersToRemove.forEach((layer) => {\n      olMap.removeLayer(layer);\n    });\n    const addLayers = async (configs) => {\n      // Loop through layer configs, create layers and add them to map.\n      // The first layer in the list will be the upmost layer on the map.\n      // With insertAt(0) we ensure that the chart layer will always\n      // stay on top, though.\n      const createdLayersPromises = configs.map(createLayer);\n      const createdLayers = await Promise.allSettled(createdLayersPromises);\n      createdLayers.forEach((createdLayer, idx) => {\n        if (createdLayer.status === 'fulfilled' && createdLayer.value) {\n          olMap.getLayers().insertAt(0, createdLayer.value);\n        } else\n        {\n          console.warn(`Layer could not be created: ${configs[idx]}`);\n        }\n      });\n    };\n    addLayers(layerConfigs);\n  }, [olMap, layerConfigs]);\n  /**\n   * Create listener on map movement\n   */\n  useEffect(() => {\n    const { fixedLatitude, fixedLongitude, fixedZoom } = currentMapView;\n    const view = olMap.getView();\n    const onViewChange = (event) => {\n      const targetView = event.target;\n      const center = targetView.getCenter();\n      const zoom = targetView.getZoom();\n      if (!center) {\n        return;\n      }\n      const [longitude, latitude] = toLonLat(center);\n      setControlValue('map_view', {\n        ...currentMapView,\n        zoom,\n        longitude,\n        latitude,\n        fixedLatitude,\n        fixedLongitude,\n        fixedZoom\n      });\n    };\n    // TODO: maybe replace with debounce from lodash\n    // timeout=100ms seems to work well, 1000ms has other side-effects\n    function debounce(func, timeout = 100) {\n      let timer;\n      return function (...args) {\n        clearTimeout(timer);\n        timer = window.setTimeout(() => func.apply(this, args), timeout);\n      };\n    }\n    const debouncedOnViewChange = debounce((event) => {\n      onViewChange(event);\n    });\n    const listenerKey = view.on('change', debouncedOnViewChange);\n    // this is executed before the next render,\n    // here we cleanup the listener\n    return () => {\n      unByKey(listenerKey);\n    };\n  }, [olMap, setControlValue, currentMapView, currentChartConfigs]);\n  useEffect(() => {\n    if (currentMapView.mode === 'FIT_DATA') {\n      const layers = olMap.getLayers();\n      const chartLayer = layers.\n      getArray().\n      find((layer) => layer instanceof ChartLayer);\n      if (!chartLayer) {\n        return;\n      }\n      const extent = chartLayer.getExtent();\n      if (!extent) {\n        return;\n      }\n      const view = olMap.getView();\n      view.fit(extent, {\n        size: [250, 250]\n      });\n    }\n  }, [olMap, currentMapView.mode]);\n  /**\n   * Send updated zoom to chart config control.\n   */\n  useEffect(() => {\n    const view = olMap.getView();\n    const onViewChange = (event) => {\n      const targetView = event.target;\n      // ensure only zoom has changed\n      const zoom = targetView.getZoom();\n      // needed for TypeScript\n      if (!zoom)\n      return;\n      // round zoom to full integer\n      const previousZoom = Math.round(chartSize.configs.zoom);\n      const newZoom = Math.round(zoom);\n      // if zoom has not changed, we return and do not update the controls\n      if (previousZoom === newZoom)\n      return;\n      const updatedChartSizeConf = {\n        ...chartSize,\n        configs: {\n          ...chartSize.configs,\n          zoom: newZoom\n        }\n      };\n      setControlValue('chart_size', updatedChartSizeConf);\n    };\n    const debouncedOnZoomChange = _debounce((event) => {\n      onViewChange(event);\n    }, 100);\n    const listenerKey = view.on('change:resolution', debouncedOnZoomChange);\n    // This is executed before the next render,\n    // here we cleanup our listener.\n    return () => {\n      unByKey(listenerKey);\n    };\n  }, [olMap, setControlValue, chartSize]);\n  /**\n   * Handle changes that trigger changes of charts. Also instantiate\n   * the chart layer, if it does not exist yet.\n   */\n  useEffect(() => {\n    const layers = olMap.getLayers();\n    const chartLayer = layers.\n    getArray().\n    find((layer) => layer instanceof ChartLayer);\n    const { r, g, b, a } = chartBackgroundColor;\n    const cssColor = `rgba(${r}, ${g}, ${b}, ${a})`;\n    if (!chartLayer) {\n      layers.forEach((layer) => {\n        if (!(layer instanceof ChartLayer)) {\n          return;\n        }\n        // remove all chart elements from dom.\n        layer.removeAllChartElements();\n        // delete previous chart layers\n        olMap.removeLayer(layer);\n      });\n      // prevent map interactions when mouse is over chart element\n      // inspired by https://gis.stackexchange.com/questions/303331\n      const deactivateInteractions = () => {\n        olMap.getInteractions().forEach((interaction) => {\n          interaction.setActive(false);\n        });\n      };\n      const activateInteractions = () => {\n        olMap.getInteractions().forEach((interaction) => {\n          interaction.setActive(true);\n        });\n      };\n      const newChartLayer = new ChartLayer({\n        name: CHART_LAYER_NAME,\n        chartConfigs: currentChartConfigs,\n        chartVizType,\n        chartSizeValues: chartSize.values,\n        chartBackgroundCssColor: cssColor,\n        chartBackgroundBorderRadius,\n        onMouseOver: deactivateInteractions,\n        onMouseOut: activateInteractions,\n        theme\n      });\n      olMap.addLayer(newChartLayer);\n    } else\n    {\n      let recreateCharts = false;\n      if (chartVizType !== chartLayer.chartVizType) {\n        chartLayer.setChartVizType(chartVizType, true);\n        recreateCharts = true;\n      }\n      if (!isChartConfigEqual(currentChartConfigs, chartLayer.chartConfigs)) {\n        chartLayer.setChartConfig(currentChartConfigs, true);\n        recreateCharts = true;\n      }\n      // Only the last setter triggers rerendering of charts\n      chartLayer.setChartBackgroundBorderRadius(chartBackgroundBorderRadius, true);\n      chartLayer.setChartBackgroundCssColor(cssColor, true);\n      chartLayer.setChartSizeValues(chartSize.values, true);\n      if (recreateCharts) {\n        chartLayer.removeAllChartElements();\n      }\n      chartLayer.changed();\n    }\n  }, [\n  olMap,\n  theme,\n  currentChartConfigs,\n  chartVizType,\n  chartSize.values,\n  chartBackgroundColor,\n  chartBackgroundBorderRadius]\n  );\n  return _jsx(\"div\", { id: mapId, style: {\n      height: `${height}px`,\n      width: `${width}px`\n    } });\n};\nexport default OlChartMap;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}