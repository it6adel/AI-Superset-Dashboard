{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  css,\n  t,\n  logging,\n  SupersetClient,\n  withTheme,\n  ensureIsArray } from\n'@superset-ui/core';\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport adhocMetricType from 'src/explore/components/controls/MetricControl/adhocMetricType';\nimport savedMetricType from 'src/explore/components/controls/MetricControl/savedMetricType';\nimport AdhocMetric from 'src/explore/components/controls/MetricControl/AdhocMetric';\nimport {\n  Operators,\n  OPERATOR_ENUM_TO_OPERATOR_TYPE } from\n'src/explore/constants';\nimport FilterDefinitionOption from 'src/explore/components/controls/MetricControl/FilterDefinitionOption';\nimport {\n  AddControlLabel,\n  AddIconButton,\n  HeaderContainer,\n  LabelsContainer } from\n'src/explore/components/controls/OptionControls';\nimport Icons from 'src/components/Icons';\nimport Modal from 'src/components/Modal';\nimport AdhocFilterPopoverTrigger from 'src/explore/components/controls/FilterControl/AdhocFilterPopoverTrigger';\nimport AdhocFilterOption from 'src/explore/components/controls/FilterControl/AdhocFilterOption';\nimport AdhocFilter from 'src/explore/components/controls/FilterControl/AdhocFilter';\nimport adhocFilterType from 'src/explore/components/controls/FilterControl/adhocFilterType';\nimport columnType from 'src/explore/components/controls/FilterControl/columnType';\nimport { toQueryString } from 'src/utils/urlUtils';\nimport { Clauses, ExpressionTypes } from '../types';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nconst { warning } = Modal;\n\nconst selectedMetricType = PropTypes.oneOfType([\nPropTypes.string,\nadhocMetricType]\n);\n\nconst propTypes = {\n  label: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),\n  name: PropTypes.string,\n  sections: PropTypes.arrayOf(PropTypes.string),\n  operators: PropTypes.arrayOf(PropTypes.string),\n  onChange: PropTypes.func,\n  value: PropTypes.arrayOf(adhocFilterType),\n  datasource: PropTypes.object,\n  columns: PropTypes.arrayOf(columnType),\n  savedMetrics: PropTypes.arrayOf(savedMetricType),\n  selectedMetrics: PropTypes.oneOfType([\n  selectedMetricType,\n  PropTypes.arrayOf(selectedMetricType)]\n  ),\n  isLoading: PropTypes.bool,\n  canDelete: PropTypes.func\n};\n\nconst defaultProps = {\n  name: '',\n  onChange: () => {},\n  columns: [],\n  savedMetrics: [],\n  selectedMetrics: []\n};\n\nfunction isDictionaryForAdhocFilter(value) {\n  return value && !(value instanceof AdhocFilter) && value.expressionType;\n}\n\nclass AdhocFilterControl extends Component {\n  constructor(props) {\n    super(props);\n    this.optionsForSelect = this.optionsForSelect.bind(this);\n    this.onRemoveFilter = this.onRemoveFilter.bind(this);\n    this.onNewFilter = this.onNewFilter.bind(this);\n    this.onFilterEdit = this.onFilterEdit.bind(this);\n    this.moveLabel = this.moveLabel.bind(this);\n    this.onChange = this.onChange.bind(this);\n    this.mapOption = this.mapOption.bind(this);\n    this.getMetricExpression = this.getMetricExpression.bind(this);\n    this.removeFilter = this.removeFilter.bind(this);\n\n    const filters = (this.props.value || []).map((filter) =>\n    isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter\n    );\n\n    this.optionRenderer = (option) => _jsx(FilterDefinitionOption, { option: option });\n    this.valueRenderer = (adhocFilter, index) =>\n    _jsx(AdhocFilterOption, {\n\n      index: index,\n      adhocFilter: adhocFilter,\n      onFilterEdit: this.onFilterEdit,\n      options: this.state.options,\n      sections: this.props.sections,\n      operators: this.props.operators,\n      datasource: this.props.datasource,\n      onRemoveFilter: (e) => {\n        e.stopPropagation();\n        this.onRemoveFilter(index);\n      },\n      onMoveLabel: this.moveLabel,\n      onDropLabel: () => this.props.onChange(this.state.values),\n      partitionColumn: this.state.partitionColumn }, index\n    );\n\n    this.state = {\n      values: filters,\n      options: this.optionsForSelect(this.props),\n      partitionColumn: null\n    };\n  }\n\n  componentDidMount() {\n    const { datasource } = this.props;\n    if (datasource && datasource.type === 'table') {var _datasource$database;\n      const dbId = (_datasource$database = datasource.database) == null ? void 0 : _datasource$database.id;\n      const {\n        datasource_name: name,\n        catalog,\n        schema,\n        is_sqllab_view: isSqllabView\n      } = datasource;\n\n      if (!isSqllabView && dbId && name && schema) {\n        SupersetClient.get({\n          endpoint: `/api/v1/database/${dbId}/table_metadata/extra/${toQueryString(\n            {\n              name,\n              catalog,\n              schema\n            }\n          )}`\n        }).\n        then(({ json }) => {\n          if (json && json.partitions) {\n            const { partitions } = json;\n            // for now only show latest_partition option\n            // when table datasource has only 1 partition key.\n            if (\n            partitions &&\n            partitions.cols &&\n            Object.keys(partitions.cols).length === 1)\n            {\n              this.setState({ partitionColumn: partitions.cols[0] });\n            }\n          }\n        }).\n        catch((error) => {\n          logging.error('fetch extra_table_metadata:', error.statusText);\n        });\n      }\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (this.props.columns !== nextProps.columns) {\n      this.setState({ options: this.optionsForSelect(nextProps) });\n    }\n    if (this.props.value !== nextProps.value) {\n      this.setState({\n        values: (nextProps.value || []).map((filter) =>\n        isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter\n        )\n      });\n    }\n  }\n\n  removeFilter(index) {\n    const valuesCopy = [...this.state.values];\n    valuesCopy.splice(index, 1);\n    this.setState((prevState) => ({\n      ...prevState,\n      values: valuesCopy\n    }));\n    this.props.onChange(valuesCopy);\n  }\n\n  onRemoveFilter(index) {\n    const { canDelete } = this.props;\n    const { values } = this.state;\n    const result = canDelete == null ? void 0 : canDelete(values[index], values);\n    if (typeof result === 'string') {\n      warning({ title: t('Warning'), content: result });\n      return;\n    }\n    this.removeFilter(index);\n  }\n\n  onNewFilter(newFilter) {\n    const mappedOption = this.mapOption(newFilter);\n    if (mappedOption) {\n      this.setState(\n        (prevState) => ({\n          ...prevState,\n          values: [...prevState.values, mappedOption]\n        }),\n        () => {\n          this.props.onChange(this.state.values);\n        }\n      );\n    }\n  }\n\n  onFilterEdit(changedFilter) {\n    this.props.onChange(\n      this.state.values.map((value) => {\n        if (value.filterOptionName === changedFilter.filterOptionName) {\n          return changedFilter;\n        }\n        return value;\n      })\n    );\n  }\n\n  onChange(opts) {\n    const options = (opts || []).\n    map((option) => this.mapOption(option)).\n    filter((option) => option);\n    this.props.onChange(options);\n  }\n\n  getMetricExpression(savedMetricName) {\n    return this.props.savedMetrics.find(\n      (savedMetric) => savedMetric.metric_name === savedMetricName\n    ).expression;\n  }\n\n  moveLabel(dragIndex, hoverIndex) {\n    const { values } = this.state;\n\n    const newValues = [...values];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    this.setState({ values: newValues });\n  }\n\n  mapOption(option) {\n    // already a AdhocFilter, skip\n    if (option instanceof AdhocFilter) {\n      return option;\n    }\n    // via datasource saved metric\n    if (option.saved_metric_name) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Sql,\n        subject: this.getMetricExpression(option.saved_metric_name),\n        operator:\n        OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GreaterThan].operation,\n        comparator: 0,\n        clause: Clauses.Having\n      });\n    }\n    // has a custom label, meaning it's custom column\n    if (option.label) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Sql,\n        subject: new AdhocMetric(option).translateToSql(),\n        operator:\n        OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GreaterThan].operation,\n        comparator: 0,\n        clause: Clauses.Having\n      });\n    }\n    // add a new filter item\n    if (option.column_name) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Simple,\n        subject: option.column_name,\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.Equals].operation,\n        comparator: '',\n        clause: Clauses.Where,\n        isNew: true\n      });\n    }\n    return null;\n  }\n\n  optionsForSelect(props) {\n    const options = [\n    ...props.columns,\n    ...ensureIsArray(props.selectedMetrics).map(\n      (metric) =>\n      metric && (\n      typeof metric === 'string' ?\n      { saved_metric_name: metric } :\n      new AdhocMetric(metric))\n    )].\n    filter((option) => option);\n\n    return options.\n    reduce((results, option) => {\n      if (option.saved_metric_name) {\n        results.push({\n          ...option,\n          filterOptionName: option.saved_metric_name\n        });\n      } else if (option.column_name) {\n        results.push({\n          ...option,\n          filterOptionName: `_col_${option.column_name}`\n        });\n      } else if (option instanceof AdhocMetric) {\n        results.push({\n          ...option,\n          filterOptionName: `_adhocmetric_${option.label}`\n        });\n      }\n      return results;\n    }, []).\n    sort((a, b) =>\n    (a.saved_metric_name || a.column_name || a.label).localeCompare(\n      b.saved_metric_name || b.column_name || b.label\n    )\n    );\n  }\n\n  addNewFilterPopoverTrigger(trigger) {\n    return (\n      _jsx(AdhocFilterPopoverTrigger, {\n        operators: this.props.operators,\n        sections: this.props.sections,\n        adhocFilter: new AdhocFilter({}),\n        datasource: this.props.datasource,\n        options: this.state.options,\n        onFilterEdit: this.onNewFilter,\n        partitionColumn: this.state.partitionColumn, children:\n\n        trigger }\n      ));\n\n  }\n\n  render() {\n    const { theme } = this.props;\n    return (\n      _jsxs(\"div\", { className: \"metrics-select\", children: [\n        _jsxs(HeaderContainer, { children: [\n          _jsx(ControlHeader, { ...this.props }),\n          this.addNewFilterPopoverTrigger(\n            _jsx(AddIconButton, { children:\n              _jsx(Icons.PlusOutlined, {\n                iconSize: \"m\",\n                iconColor: theme.colors.grayscale.light5 }\n              ) }\n            )\n          )] }\n        ),\n        _jsx(LabelsContainer, { children:\n          this.state.values.length > 0 ?\n          this.state.values.map((value, index) =>\n          this.valueRenderer(value, index)\n          ) :\n          this.addNewFilterPopoverTrigger(\n            _jsxs(AddControlLabel, { children: [\n              _jsx(Icons.PlusOutlined, {\n                css: css`\n                      margin: auto ${theme.gridUnit}px auto 0;\n                    `,\n                iconSize: \"m\",\n                iconColor: theme.colors.grayscale.light1 }\n              ),\n              t('Add filter')] }\n            )\n          ) }\n        )] }\n      ));\n\n  }\n}\n\nAdhocFilterControl.propTypes = propTypes;\nAdhocFilterControl.defaultProps = defaultProps;\n\nexport default withTheme(AdhocFilterControl);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}