{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport { styled, t, useTheme, keyframes, css } from '@superset-ui/core';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport { Tooltip } from 'src/components/Tooltip';\nimport Icons from 'src/components/Icons';\nimport { StyledMetricOption } from '../../optionRenderers';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nexport const DragContainer = styled.div`\n  margin-bottom: ${({ theme }) => theme.gridUnit}px;\n  :last-child {\n    margin-bottom: 0;\n  }\n`;\nexport const OptionControlContainer = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  height: ${({ theme }) => theme.gridUnit * 6}px;\n  background-color: ${({ theme }) => theme.colors.grayscale.light3};\n  border-radius: 3px;\n  cursor: ${({ withCaret }) => withCaret ? 'pointer' : 'default'};\n`;\nexport const Label = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    align-items: center;\n    white-space: nowrap;\n    padding-left: ${theme.gridUnit}px;\n    svg {\n      margin-right: ${theme.gridUnit}px;\n    }\n    .type-label {\n      margin-right: ${theme.gridUnit * 2}px;\n      margin-left: ${theme.gridUnit}px;\n      font-weight: ${theme.typography.weights.normal};\n      width: auto;\n    }\n    .option-label {\n      display: inline;\n    }\n  `}\n`;\nconst LabelText = styled.span`\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\nexport const CaretContainer = styled.div`\n  height: 100%;\n  border-left: solid 1px ${({ theme }) => theme.colors.grayscale.dark2}0C;\n  margin-left: auto;\n`;\nexport const CloseContainer = styled.div`\n  height: auto;\n  width: ${({ theme }) => theme.gridUnit * 6}px;\n  border-right: solid 1px ${({ theme }) => theme.colors.grayscale.dark2}0C;\n  cursor: pointer;\n`;\nconst StyledInfoTooltipWithTrigger = styled(InfoTooltipWithTrigger)`\n  margin: 0 ${({ theme }) => theme.gridUnit}px;\n`;\nexport const HeaderContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`;\nexport const LabelsContainer = styled.div`\n  padding: ${({ theme }) => theme.gridUnit}px;\n  border: solid 1px ${({ theme }) => theme.colors.grayscale.light2};\n  border-radius: ${({ theme }) => theme.gridUnit}px;\n`;\nconst borderPulse = keyframes`\n  0% {\n    right: 100%;\n  }\n  50% {\n    left: 4px;\n  }\n  90% {\n    right: 4px;\n  }\n  100% {\n    left: 100%;\n  }\n`;\nexport const DndLabelsContainer = styled.div`\n  ${({ theme, isLoading, canDrop, isDragging, isOver }) => `\n  position: relative;\n  padding: ${theme.gridUnit}px;\n  border: ${!isLoading && isDragging ?\n`dashed 1px ${canDrop ? theme.colors.info.dark1 : theme.colors.error.dark1}` :\n`solid 1px ${isLoading && isDragging ?\ntheme.colors.warning.light1 :\ntheme.colors.grayscale.light2}`};\n  border-radius: ${theme.gridUnit}px;\n  &:before,\n  &:after {\n    content: ' ';\n    position: absolute;\n    border-radius: ${theme.gridUnit}px;\n  }\n  &:before {\n    display: ${isDragging || isLoading ? 'block' : 'none'};\n    background-color: ${canDrop ? theme.colors.primary.base : theme.colors.error.light1};\n    z-index: ${theme.zIndex.aboveDashboardCharts};\n    opacity: ${theme.opacity.light};\n    top: 1px;\n    right: 1px;\n    bottom: 1px;\n    left: 1px;\n  }\n  &:after {\n    display: ${isLoading || canDrop && isOver ? 'block' : 'none'};\n    background-color: ${isLoading ? theme.colors.grayscale.light3 : theme.colors.primary.base};\n    z-index: ${theme.zIndex.dropdown};\n    opacity: ${theme.opacity.mediumLight};\n    top: ${-theme.gridUnit}px;\n    right: ${-theme.gridUnit}px;\n    bottom: ${-theme.gridUnit}px;\n    left: ${-theme.gridUnit}px;\n    cursor: ${isLoading ? 'wait' : 'auto'};\n  }\n  `}\n\n  &:before {\n    ${({ theme, isLoading }) => isLoading &&\ncss`\n        animation: ${borderPulse} 2s ease-in infinite;\n        background: linear-gradient(currentColor 0 0) 0 100%/0% 3px no-repeat;\n        background-size: 100% ${theme.gridUnit / 2}px;\n        top: auto;\n        right: ${theme.gridUnit}px;\n        left: ${theme.gridUnit}px;\n        bottom: -${theme.gridUnit / 2}px;\n        height: ${theme.gridUnit / 2}px;\n      `};\n  }\n`;\nexport const AddControlLabel = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: ${({ theme }) => theme.gridUnit * 6}px;\n  padding-left: ${({ theme }) => theme.gridUnit}px;\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  color: ${({ theme }) => theme.colors.grayscale.light1};\n  border: dashed 1px ${({ theme }) => theme.colors.grayscale.light2};\n  border-radius: ${({ theme }) => theme.gridUnit}px;\n  cursor: ${({ cancelHover }) => cancelHover ? 'inherit' : 'pointer'};\n\n  :hover {\n    background-color: ${({ cancelHover, theme }) => cancelHover ? 'inherit' : theme.colors.grayscale.light4};\n  }\n\n  :active {\n    background-color: ${({ cancelHover, theme }) => cancelHover ? 'inherit' : theme.colors.grayscale.light3};\n  }\n`;\nexport const AddIconButton = styled.button`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: ${({ theme }) => theme.gridUnit * 4}px;\n  width: ${({ theme }) => theme.gridUnit * 4}px;\n  padding: 0;\n  background-color: ${({ theme }) => theme.colors.primary.dark1};\n  border: none;\n  border-radius: 2px;\n\n  :disabled {\n    cursor: not-allowed;\n    background-color: ${({ theme }) => theme.colors.grayscale.light1};\n  }\n`;\nexport const OptionControlLabel = ({ label, savedMetric, adhocMetric, onRemove, onMoveLabel, onDropLabel, withCaret, isFunction, type, index, isExtra, datasourceWarningMessage, tooltipTitle, multi = true, ...props }) => {\n  const theme = useTheme();\n  const ref = useRef(null);\n  const labelRef = useRef(null);\n  const hasMetricName = savedMetric == null ? void 0 : savedMetric.metric_name;\n  const [, drop] = useDrop({\n    accept: type,\n    drop() {\n      if (!multi) {\n        return;\n      }\n      onDropLabel == null ? void 0 : onDropLabel();\n    },\n    hover(item, monitor) {var _ref$current;\n      if (!multi) {\n        return;\n      }\n      if (!ref.current) {\n        return;\n      }\n      const { dragIndex } = item;\n      const hoverIndex = index;\n      // Don't replace items with themselves\n      if (dragIndex === hoverIndex) {\n        return;\n      }\n      // Determine rectangle on screen\n      const hoverBoundingRect = (_ref$current = ref.current) == null ? void 0 : _ref$current.getBoundingClientRect();\n      // Get vertical middle\n      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n      // Determine mouse position\n      const clientOffset = monitor.getClientOffset();\n      // Get pixels to the top\n      const hoverClientY = clientOffset != null && clientOffset.y ?\n      (clientOffset == null ? void 0 : clientOffset.y) - hoverBoundingRect.top :\n      0;\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n      // Dragging downwards\n      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n        return;\n      }\n      // Dragging upwards\n      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n        return;\n      }\n      // Time to actually perform the action\n      onMoveLabel == null ? void 0 : onMoveLabel(dragIndex, hoverIndex);\n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      // eslint-disable-next-line no-param-reassign\n      item.dragIndex = hoverIndex;\n    }\n  });\n  const [{ isDragging }, drag] = useDrag({\n    item: {\n      type,\n      dragIndex: index,\n      value: savedMetric != null && savedMetric.metric_name ? savedMetric : adhocMetric\n    },\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging()\n    })\n  });\n  const getLabelContent = () => {\n    const shouldShowTooltip = !isDragging &&\n    typeof label === 'string' &&\n    tooltipTitle &&\n    label &&\n    tooltipTitle !== label ||\n    !isDragging &&\n    labelRef &&\n    labelRef.current &&\n    labelRef.current.scrollWidth > labelRef.current.clientWidth;\n    if (savedMetric && hasMetricName) {\n      return _jsx(StyledMetricOption, { metric: savedMetric, labelRef: labelRef, shouldShowTooltip: !isDragging });\n    }\n    if (!shouldShowTooltip) {\n      return _jsx(LabelText, { ref: labelRef, children: label });\n    }\n    return _jsx(Tooltip, { title: tooltipTitle || label, children:\n      _jsx(LabelText, { ref: labelRef, children: label }) }\n    );\n  };\n  const getOptionControlContent = () => _jsxs(OptionControlContainer, { withCaret: withCaret, ...props, css: css`\n        text-align: center;\n      `, children: [\n    _jsx(CloseContainer, { role: \"button\", onClick: onRemove, children:\n      _jsx(Icons.CloseOutlined, { iconSize: \"m\", iconColor: theme.colors.grayscale.light1, css: css`\n            vertical-align: sub;\n          ` }) }\n    ),\n    _jsxs(Label, { children: [\n      isFunction && _jsx(Icons.FunctionOutlined, { iconSize: \"m\" }),\n      getLabelContent()] }\n    ),\n    (!!datasourceWarningMessage || isExtra) && _jsx(StyledInfoTooltipWithTrigger, { icon: \"exclamation-triangle\", placement: \"top\", bsStyle: \"warning\", tooltip: datasourceWarningMessage ||\n      t(`\n                This filter was inherited from the dashboard's context.\n                It won't be saved when saving the chart.\n              `) }),\n    withCaret && _jsx(CaretContainer, { children:\n      _jsx(Icons.RightOutlined, { iconSize: \"m\", css: css`\n              margin-top: ${theme.gridUnit}px;\n            `, iconColor: theme.colors.grayscale.light1 }) }\n    )] }\n  );\n  drag(drop(ref));\n  return _jsx(DragContainer, { ref: ref, children: getOptionControlContent() });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}