{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t } from '@superset-ui/core';\nimport { LatestQueryEditorVersion, QueryEditorVersion } from 'src/SqlLab/types';\nexport function dedupeTabHistory(tabHistory) {\n  return tabHistory.reduce((result, tabId) => result.slice(-1)[0] === tabId ? result : result.concat(tabId), []);\n}\nexport default function getInitialState({ common, active_tab: activeTab, tab_state_ids: tabStateIds = [], databases, queries: queries_, ...otherBootstrapData }) {\n  /**\n   * Before YYYY-MM-DD, the state for SQL Lab was stored exclusively in the\n   * browser's localStorage. The feature flag `SQLLAB_BACKEND_PERSISTENCE`\n   * moves the state to the backend instead, migrating it from local storage.\n   *\n   * To allow for a transparent migration, the initial state is a combination\n   * of the backend state (if any) with the browser state (if any).\n   */\n  let queryEditors = {};\n  const defaultQueryEditor = {\n    version: LatestQueryEditorVersion,\n    loaded: true,\n    name: t('Untitled query'),\n    sql: '',\n    latestQueryId: null,\n    autorun: false,\n    dbId: common.conf.SQLLAB_DEFAULT_DBID,\n    queryLimit: common.conf.DEFAULT_SQLLAB_LIMIT,\n    hideLeftBar: false,\n    remoteId: null,\n    cursorPosition: { row: 0, column: 0 }\n  };\n  let unsavedQueryEditor = {};\n  /**\n   * Load state from the backend. This will be empty if the feature flag\n   * `SQLLAB_BACKEND_PERSISTENCE` is off.\n   */\n  tabStateIds.forEach(({ id, label }) => {\n    let queryEditor;\n    if (activeTab && activeTab.id === id) {var _activeTab$extra_json, _activeTab$extra_json2, _activeTab$saved_quer, _activeTab$extra_json3;\n      queryEditor = {\n        version: (_activeTab$extra_json = (_activeTab$extra_json2 = activeTab.extra_json) == null ? void 0 : _activeTab$extra_json2.version) != null ? _activeTab$extra_json : QueryEditorVersion.V1,\n        id: id.toString(),\n        loaded: true,\n        name: activeTab.label,\n        sql: activeTab.sql || '',\n        selectedText: undefined,\n        latestQueryId: activeTab.latest_query ?\n        activeTab.latest_query.id :\n        null,\n        remoteId: ((_activeTab$saved_quer = activeTab.saved_query) == null ? void 0 : _activeTab$saved_quer.id) || null,\n        autorun: Boolean(activeTab.autorun),\n        templateParams: activeTab.template_params || undefined,\n        dbId: activeTab.database_id,\n        catalog: activeTab.catalog,\n        schema: activeTab.schema,\n        queryLimit: activeTab.query_limit,\n        hideLeftBar: activeTab.hide_left_bar,\n        updatedAt: (_activeTab$extra_json3 = activeTab.extra_json) == null ? void 0 : _activeTab$extra_json3.updatedAt\n      };\n    } else\n    {\n      // dummy state, actual state will be loaded on tab switch\n      queryEditor = {\n        ...defaultQueryEditor,\n        id: id.toString(),\n        loaded: false,\n        name: label,\n        dbId: undefined\n      };\n    }\n    queryEditors = {\n      ...queryEditors,\n      [queryEditor.id]: queryEditor\n    };\n  });\n  const tabHistory = activeTab ? [activeTab.id.toString()] : [];\n  let lastUpdatedActiveTab = activeTab ? activeTab.id.toString() : '';\n  let tables = {};\n  let editorTabLastUpdatedAt = Date.now();\n  if (activeTab) {var _activeTab$extra_json4;\n    editorTabLastUpdatedAt =\n    ((_activeTab$extra_json4 = activeTab.extra_json) == null ? void 0 : _activeTab$extra_json4.updatedAt) || editorTabLastUpdatedAt;\n    activeTab.table_schemas.\n    filter((tableSchema) => tableSchema.description !== null).\n    forEach((tableSchema) => {var _tableSchema$database;\n      const { dataPreviewQueryId, ...persistData } = tableSchema.description;\n      const table = {\n        dbId: (_tableSchema$database = tableSchema.database_id) != null ? _tableSchema$database : 0,\n        queryEditorId: tableSchema.tab_state_id.toString(),\n        catalog: tableSchema.catalog,\n        schema: tableSchema.schema,\n        name: tableSchema.table,\n        expanded: Boolean(tableSchema.expanded),\n        id: tableSchema.id,\n        dataPreviewQueryId,\n        persistData,\n        initialized: true\n      };\n      tables = {\n        ...tables,\n        [table.id]: table\n      };\n    });\n  }\n  const queries = {\n    ...queries_,\n    ...((activeTab == null ? void 0 : activeTab.latest_query) && {\n      [activeTab.latest_query.id]: activeTab.latest_query\n    })\n  };\n  const destroyedQueryEditors = {};\n  /**\n   * If the `SQLLAB_BACKEND_PERSISTENCE` feature flag is off, or if the user\n   * hasn't used SQL Lab after it has been turned on, the state will be stored\n   * in the browser's local storage.\n   */\n  try {\n    const localStorageData = localStorage.getItem('redux');\n    const sqlLabCacheData = localStorageData ?\n    JSON.parse(localStorageData) :\n    undefined;\n    if (localStorageData && sqlLabCacheData != null && sqlLabCacheData.sqlLab) {\n      const { sqlLab } = sqlLabCacheData;\n      if (sqlLab.queryEditors.length === 0) {\n        // migration was successful\n        localStorage.removeItem('redux');\n      } else\n      {\n        unsavedQueryEditor = sqlLab.unsavedQueryEditor || unsavedQueryEditor;\n        // add query editors and tables to state with a special flag so they can\n        // be migrated if the `SQLLAB_BACKEND_PERSISTENCE` feature flag is on\n        sqlLab.queryEditors.forEach((qe) => {var _queryEditors$qe$id, _queryEditors$qe$id2;\n          const hasConflictFromBackend = Boolean(queryEditors[qe.id]);\n          const unsavedUpdatedAt = (_queryEditors$qe$id = queryEditors[qe.id]) == null ? void 0 : _queryEditors$qe$id.updatedAt;\n          const hasUnsavedUpdateSinceLastSave = qe.updatedAt && (\n          !unsavedUpdatedAt || qe.updatedAt > unsavedUpdatedAt);\n          const cachedQueryEditor = !hasConflictFromBackend || hasUnsavedUpdateSinceLastSave ? qe : {};\n          queryEditors = {\n            ...queryEditors,\n            [qe.id]: {\n              ...queryEditors[qe.id],\n              ...cachedQueryEditor,\n              name: cachedQueryEditor.title ||\n              cachedQueryEditor.name || ((_queryEditors$qe$id2 =\n              queryEditors[qe.id]) == null ? void 0 : _queryEditors$qe$id2.name),\n              ...(cachedQueryEditor.id &&\n              unsavedQueryEditor.id === qe.id &&\n              unsavedQueryEditor),\n              inLocalStorage: !hasConflictFromBackend,\n              loaded: true\n            }\n          };\n        });\n        const expandedTables = new Set();\n        if (sqlLab.tables) {\n          tables = sqlLab.tables.reduce((merged, table) => {\n            const expanded = !expandedTables.has(table.queryEditorId);\n            if (expanded) {\n              expandedTables.add(table.queryEditorId);\n            }\n            return {\n              ...merged,\n              [table.id]: {\n                ...tables[table.id],\n                ...table,\n                expanded,\n                inLocalStorage: true\n              }\n            };\n          }, tables);\n        }\n        if (sqlLab.queries) {\n          Object.values(sqlLab.queries).forEach((query) => {\n            queries[query.id] = { ...query, inLocalStorage: true };\n          });\n        }\n        if (sqlLab.tabHistory) {\n          tabHistory.push(...sqlLab.tabHistory);\n        }\n        lastUpdatedActiveTab = tabHistory.slice(tabHistory.length - 1)[0] || '';\n        if (sqlLab.destroyedQueryEditors) {\n          Object.entries(sqlLab.destroyedQueryEditors).forEach(([id, ts]) => {\n            if (queryEditors[id]) {\n              destroyedQueryEditors[id] = ts;\n              delete queryEditors[id];\n            }\n          });\n        }\n      }\n    }\n  }\n  catch (error) {\n\n    // continue regardless of error\n  }return {\n    sqlLab: {\n      activeSouthPaneTab: 'Results',\n      alerts: [],\n      databases,\n      offline: false,\n      queries: Object.fromEntries(Object.entries(queries).map(([queryId, query]) => [\n      queryId,\n      {\n        ...query,\n        ...(query.startDttm && {\n          startDttm: Number(query.startDttm)\n        }),\n        ...(query.endDttm && {\n          endDttm: Number(query.endDttm)\n        })\n      }]\n      )),\n      queryEditors: Object.values(queryEditors),\n      tabHistory: dedupeTabHistory(tabHistory),\n      tables: Object.values(tables),\n      queriesLastUpdate: Date.now(),\n      editorTabLastUpdatedAt,\n      queryCostEstimates: {},\n      unsavedQueryEditor,\n      lastUpdatedActiveTab,\n      destroyedQueryEditors\n    },\n    localStorageUsageInKilobytes: 0,\n    common,\n    ...otherBootstrapData\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}