{"ast":null,"code":"import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { forwardRef, useEffect, useMemo, useState, useRef, useCallback, useImperativeHandle } from 'react';\nimport { ensureIsArray, t, usePrevious, getClientErrorObject } from '@superset-ui/core';\n\nimport Icons from 'src/components/Icons';\nimport { FAST_DEBOUNCE, SLOW_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, hasCustomLabels, sortSelectedFirstHelper, sortComparatorWithSearchHelper, sortComparatorForNoSearchHelper, getSuffixIcon, dropDownRenderHelper, handleFilterOptionHelper, mapOptions, getOption, isObject, isEqual as utilsIsEqual } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledError, StyledErrorMessage, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { DEFAULT_PAGE_SIZE, EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst Error = ({ error }) => _jsxs(StyledError, { children: [\n  _jsx(Icons.ExclamationCircleOutlined, {}), ' ',\n  _jsx(StyledErrorMessage, { children: error })] }\n);\nconst getQueryCacheKey = (value, page, pageSize) => `${value};${page};${pageSize}`;\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst AsyncSelect = /*#__PURE__*/forwardRef(({ allowClear, allowNewOptions = false, ariaLabel, autoClearSearchValue = false, fetchOnlyOnSearch, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, lazyLoading = true, loading, mode = 'single', name, notFoundContent, onBlur, onError, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, pageSize = DEFAULT_PAGE_SIZE, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props }, ref) => {\n  const isSingleMode = mode === 'single';\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const selectValueRef = useRef(selectValue);\n  const fetchedQueries = useRef(new Map());\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const allowFetch = !fetchOnlyOnSearch || inputValue;\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  useEffect(() => {\n    selectValueRef.current = selectValue;\n  }, [selectValue]);\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValueRef.current), []);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const sortComparatorForNoSearch = useCallback((a, b) => sortComparatorForNoSearchHelper(a, b, sortSelectedFirst, sortComparator), [sortComparator, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(EMPTY_OPTIONS);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    return missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n  }, [selectOptions, selectValue]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      // on select is fired in single value mode if the same value is selected\n      const valueChanged = !utilsIsEqual(selectedItem, selectValue, 'value');\n      setSelectValue(selectedItem);\n      if (valueChanged) {\n        fireOnChange();\n      }\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          return isLabeledValue(selectedItem) ?\n          result :\n          result;\n        }\n        return previousState;\n      });\n      fireOnChange();\n    }\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      if (isLabeledValue(value)) {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element.value !== value.value));\n      } else\n      {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element !== value));\n      }\n      // removes new option\n      if (option.isNewOption) {\n        setSelectOptions(fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value)));\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const internalOnError = useCallback((response) => getClientErrorObject(response).then((e) => {\n    const { error } = e;\n    setError(error);\n    if (onError) {\n      onError(error);\n    }\n  }), [onError]);\n  const mergeData = useCallback((data) => {\n    let mergedData = [];\n    if (data && Array.isArray(data) && data.length) {\n      // unique option values should always be case sensitive so don't lowercase\n      const dataValues = new Set(data.map((opt) => opt.value));\n      // merges with existing and creates unique options\n      setSelectOptions((prevOptions) => {\n        mergedData = prevOptions.\n        filter((previousOption) => !dataValues.has(previousOption.value)).\n        concat(data).\n        sort(sortComparatorForNoSearch);\n        return mergedData;\n      });\n    }\n    return mergedData;\n  }, [sortComparatorForNoSearch]);\n  const fetchPage = useMemo(() => (search, page) => {\n    setPage(page);\n    if (allValuesLoaded) {\n      setIsLoading(false);\n      return;\n    }\n    const key = getQueryCacheKey(search, page, pageSize);\n    const cachedCount = fetchedQueries.current.get(key);\n    if (cachedCount !== undefined) {\n      setTotalCount(cachedCount);\n      setIsLoading(false);\n      return;\n    }\n    setIsLoading(true);\n    const fetchOptions = options;\n    fetchOptions(search, page, pageSize).\n    then(({ data, totalCount }) => {\n      const mergedData = mergeData(data);\n      fetchedQueries.current.set(key, totalCount);\n      setTotalCount(totalCount);\n      if (!fetchOnlyOnSearch &&\n      search === '' &&\n      mergedData.length >= totalCount) {\n        setAllValuesLoaded(true);\n      }\n    }).\n    catch(internalOnError).\n    finally(() => {\n      setIsLoading(false);\n    });\n  }, [\n  allValuesLoaded,\n  fetchOnlyOnSearch,\n  mergeData,\n  internalOnError,\n  options,\n  pageSize]\n  );\n  const debouncedFetchPage = useMemo(() => _debounce(fetchPage, SLOW_DEBOUNCE), [fetchPage]);\n  const handleOnSearch = _debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true\n      };\n      const cleanSelectOptions = fullSelectOptions.filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    if (!allValuesLoaded &&\n    loadingEnabled &&\n    !fetchedQueries.current.has(getQueryCacheKey(searchValue, 0, pageSize))) {\n      // if fetch only on search but search value is empty, then should not be\n      // in loading state\n      setIsLoading(!(fetchOnlyOnSearch && !searchValue));\n    }\n    setInputValue(search);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handlePagination = (e) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached = vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n    if (!isLoading && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      fetchPage(inputValue, newPage);\n    }\n  };\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // loading is enabled when dropdown is open,\n    // disabled when dropdown is closed\n    if (loadingEnabled !== isDropdownVisible) {\n      setLoadingEnabled(isDropdownVisible);\n    }\n    // when closing dropdown, always reset loading state\n    if (!isDropdownVisible && isLoading) {\n      // delay is for the animation of closing the dropdown\n      // so the dropdown doesn't flash between \"Loading...\" and \"No data\"\n      // before closing.\n      setTimeout(() => {\n        setIsLoading(false);\n      }, 250);\n    }\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      const sortedOptions = selectOptions.\n      slice().\n      sort(sortComparatorForNoSearch);\n      if (!_isEqual(sortedOptions, selectOptions)) {\n        setSelectOptions(sortedOptions);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText, error ? _jsx(Error, { error: error }) : undefined);\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n    fireOnChange();\n  };\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        // @ts-ignore\n        onChange == null ? void 0 : onChange(selectValue, options[0]);\n      } else\n      {\n        // @ts-ignore\n        onChange == null ? void 0 : onChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]\n  );\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    fetchedQueries.current.clear();\n    setAllValuesLoaded(false);\n    setSelectOptions(EMPTY_OPTIONS);\n  }, [options]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => {\n    debouncedFetchPage.cancel();\n  }, [debouncedFetchPage]);\n  useEffect(() => {\n    if (loadingEnabled && allowFetch) {\n      // trigger fetch every time inputValue changes\n      if (inputValue) {\n        debouncedFetchPage(inputValue, 0);\n      } else\n      {\n        fetchPage('', 0);\n      }\n    }\n  }, [loadingEnabled, fetchPage, allowFetch, inputValue, debouncedFetchPage]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  const clearCache = () => fetchedQueries.current.clear();\n  useImperativeHandle(ref, () => ({\n    ...ref.current,\n    clearCache\n  }), [ref]);\n  const getPastedTextValue = useCallback(async (text) => {\n    let option = getOption(text, fullSelectOptions, true);\n    if (!option && !allValuesLoaded) {\n      const fetchOptions = options;\n      option = await fetchOptions(text, 0, pageSize).then(({ data }) => data.find((item) => item.label === text));\n    }\n    if (!option && !allowNewOptions) {\n      return undefined;\n    }\n    const value = {\n      label: text,\n      value: text\n    };\n    if (option) {\n      value.label = isObject(option) ? option.label : option;\n      value.value = isObject(option) ? option.value : option;\n    }\n    return value;\n  }, [allValuesLoaded, allowNewOptions, fullSelectOptions, options, pageSize]);\n  const onPaste = async (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      const value = await getPastedTextValue(pastedText);\n      if (value) {\n        setSelectValue(value);\n      }\n    } else\n    {\n      const token = tokenSeparators.find((token) => pastedText.includes(token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      const values = (await Promise.all(array.map((item) => getPastedTextValue(item)))).filter((item) => item !== undefined);\n      setSelectValue((previous) => [\n      ...(previous || []),\n      ...values.filter((value) => !hasOption(value.value, previous))]\n      );\n    }\n    fireOnChange();\n  };\n  const shouldRenderChildrenOptions = useMemo(() => hasCustomLabels(fullSelectOptions), [fullSelectOptions]);\n  return _jsxs(StyledContainer, { headerPosition: headerPosition, children: [\n    header && _jsx(StyledHeader, { headerPosition: headerPosition, children: header }),\n    _jsx(StyledSelect, { allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel || name, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: true, maxTagCount: maxTagCount, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n      // @ts-ignore\n      , onPaste: onPaste, onPopupScroll: handlePagination, onSearch: showSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, options: shouldRenderChildrenOptions ? undefined : fullSelectOptions, placeholder: placeholder, showSearch: showSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, showSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? _jsx(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : _jsx(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), oneLine: oneLine, tagRender: customTagRender, ...props, ref: ref, children:\n      hasCustomLabels(fullSelectOptions) &&\n      renderSelectOptions(fullSelectOptions) }\n    )] }\n  );\n});\nexport default AsyncSelect;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}