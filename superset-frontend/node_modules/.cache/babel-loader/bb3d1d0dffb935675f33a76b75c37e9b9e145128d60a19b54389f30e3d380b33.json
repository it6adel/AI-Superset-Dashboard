{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useMemo, useRef, useCallback } from 'react';\nimport { styled } from '@superset-ui/core';\nimport { useCellContentParser } from './useCellContentParser';\nimport { renderResultCell } from './utils';\nimport GridTable, { GridSize } from '../GridTable';\n// This regex handles all possible number formats in javascript, including ints, floats,\n// exponential notation, NaN, and Infinity.\n// See https://stackoverflow.com/a/30987109 for more details\nimport { jsx as _jsx } from \"@emotion/react/jsx-runtime\";const ONLY_NUMBER_REGEX = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))$/;\nconst StyledFilterableTable = styled.div`\n  height: 100%;\n  overflow: hidden;\n`;\nconst parseNumberFromString = (value) => {\n  if (typeof value === 'string' && ONLY_NUMBER_REGEX.test(value)) {\n    return parseFloat(value);\n  }\n  return value;\n};\nconst sortResults = (valueA, valueB) => {\n  const aValue = parseNumberFromString(valueA);\n  const bValue = parseNumberFromString(valueB);\n  // equal items sort equally\n  if (aValue === bValue) {\n    return 0;\n  }\n  // nulls sort after anything else\n  if (aValue === null) {\n    return 1;\n  }\n  if (bValue === null) {\n    return -1;\n  }\n  return aValue < bValue ? -1 : 1;\n};\nconst FilterableTable = ({ orderedColumnKeys, data, height, filterText = '', expandedColumns = [], allowHTML = true, striped }) => {\n  const getCellContent = useCellContentParser({\n    columnKeys: orderedColumnKeys,\n    expandedColumns\n  });\n  const hasMatch = (text, row) => {\n    const values = [];\n    Object.keys(row).forEach((key) => {\n      if (row.hasOwnProperty(key)) {\n        const cellValue = row[key];\n        if (typeof cellValue === 'string') {\n          values.push(cellValue.toLowerCase());\n        } else\n        if (cellValue !== null &&\n        typeof cellValue.toString === 'function') {\n          values.push(cellValue.toString());\n        }\n      }\n    });\n    const lowerCaseText = text.toLowerCase();\n    return values.some((v) => v.includes(lowerCaseText));\n  };\n  const columns = useMemo(() => orderedColumnKeys.map((key) => ({\n    key,\n    label: key,\n    fieldName: key,\n    headerName: key,\n    comparator: sortResults,\n    render: ({ value, colDef }) => renderResultCell({\n      cellData: value,\n      columnKey: colDef.field,\n      allowHTML,\n      getCellContent\n    })\n  })), [orderedColumnKeys, allowHTML, getCellContent]);\n  const keyword = useRef(filterText);\n  keyword.current = filterText;\n  const keywordFilter = useCallback((node) => {\n    if (keyword.current && node.data) {\n      return hasMatch(keyword.current, node.data);\n    }\n    return true;\n  }, []);\n  return _jsx(StyledFilterableTable, { className: \"filterable-table-container\", children:\n    _jsx(GridTable, { size: GridSize.Small, height: height, usePagination: false, columns: columns, data: data, externalFilter: keywordFilter, showRowNumber: true, striped: striped, enableActions: true, columnReorderable: true }) }\n  );\n};\nexport default FilterableTable;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}