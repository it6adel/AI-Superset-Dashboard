{"ast":null,"code":"import _pick from \"lodash/pick\";import _omit from \"lodash/omit\";import _isObjectLike from \"lodash/isObjectLike\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { memo, useCallback, useEffect, useMemo, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport {\n  styled,\n  t,\n  css,\n  useTheme,\n  logging,\n  useChangeEffect,\n  useComponentDidMount,\n  usePrevious } from\n'@superset-ui/core';\n\nimport { Resizable } from 're-resizable';\nimport { usePluginContext } from 'src/components/DynamicPlugins';\nimport { Global } from '@emotion/react';\nimport { Tooltip } from 'src/components/Tooltip';\nimport Icons from 'src/components/Icons';\nimport {\n  getItem,\n  setItem,\n  LocalStorageKeys } from\n'src/utils/localStorageHelpers';\nimport { RESERVED_CHART_URL_PARAMS, URL_PARAMS } from 'src/constants';\nimport { QUERY_MODE_REQUISITES } from 'src/explore/constants';\nimport { areObjectsEqual } from 'src/reduxUtils';\nimport * as logActions from 'src/logger/actions';\nimport {\n  LOG_ACTIONS_MOUNT_EXPLORER,\n  LOG_ACTIONS_CHANGE_EXPLORE_CONTROLS } from\n'src/logger/LogUtils';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport cx from 'classnames';\nimport * as chartActions from 'src/components/Chart/chartAction';\nimport { fetchDatasourceMetadata } from 'src/dashboard/actions/datasources';\nimport { chartPropShape } from 'src/dashboard/util/propShapes';\nimport { mergeExtraFormData } from 'src/dashboard/components/nativeFilters/utils';\nimport { postFormData, putFormData } from 'src/explore/exploreUtils/formData';\nimport { datasourcesActions } from 'src/explore/actions/datasourcesActions';\nimport { mountExploreUrl } from 'src/explore/exploreUtils';\nimport { getFormDataFromControls } from 'src/explore/controlUtils';\nimport * as exploreActions from 'src/explore/actions/exploreActions';\nimport * as saveModalActions from 'src/explore/actions/saveModalActions';\nimport { useTabId } from 'src/hooks/useTabId';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport ExploreChartPanel from '../ExploreChartPanel';\nimport ConnectedControlPanelsContainer from '../ControlPanelsContainer';\nimport SaveModal from '../SaveModal';\nimport DataSourcePanel from '../DatasourcePanel';\nimport ConnectedExploreChartHeader from '../ExploreChartHeader';\nimport ExploreContainer from '../ExploreContainer';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nconst propTypes = {\n  ...ExploreChartPanel.propTypes,\n  actions: PropTypes.object.isRequired,\n  datasource_type: PropTypes.string.isRequired,\n  dashboardId: PropTypes.number,\n  colorScheme: PropTypes.string,\n  ownColorScheme: PropTypes.string,\n  dashboardColorScheme: PropTypes.string,\n  isDatasourceMetaLoading: PropTypes.bool.isRequired,\n  chart: chartPropShape.isRequired,\n  slice: PropTypes.object,\n  sliceName: PropTypes.string,\n  controls: PropTypes.object.isRequired,\n  forcedHeight: PropTypes.string,\n  form_data: PropTypes.object.isRequired,\n  standalone: PropTypes.bool.isRequired,\n  force: PropTypes.bool,\n  timeout: PropTypes.number,\n  impressionId: PropTypes.string,\n  vizType: PropTypes.string,\n  saveAction: PropTypes.string,\n  isSaveModalVisible: PropTypes.bool\n};\n\nconst ExplorePanelContainer = styled.div`\n  ${({ theme }) => css`\n    background: ${theme.colors.grayscale.light5};\n    text-align: left;\n    position: relative;\n    width: 100%;\n    max-height: 100%;\n    min-height: 0;\n    display: flex;\n    flex: 1;\n    flex-wrap: nowrap;\n    border-top: 1px solid ${theme.colors.grayscale.light2};\n    .explore-column {\n      display: flex;\n      flex-direction: column;\n      padding: ${theme.gridUnit * 2}px 0;\n      max-height: 100%;\n    }\n    .data-source-selection {\n      background-color: ${theme.colors.grayscale.light5};\n      padding: ${theme.gridUnit * 2}px 0;\n      border-right: 1px solid ${theme.colors.grayscale.light2};\n    }\n    .main-explore-content {\n      flex: 1;\n      min-width: ${theme.gridUnit * 128}px;\n      border-left: 1px solid ${theme.colors.grayscale.light2};\n      padding: 0 ${theme.gridUnit * 4}px;\n      .panel {\n        margin-bottom: 0;\n      }\n    }\n    .controls-column {\n      align-self: flex-start;\n      padding: 0;\n    }\n    .title-container {\n      position: relative;\n      display: flex;\n      flex-direction: row;\n      padding: 0 ${theme.gridUnit * 2}px 0 ${theme.gridUnit * 4}px;\n      justify-content: space-between;\n      .horizontal-text {\n        font-size: ${theme.typography.sizes.m}px;\n      }\n    }\n    .no-show {\n      display: none;\n    }\n    .vertical-text {\n      writing-mode: vertical-rl;\n      text-orientation: mixed;\n    }\n    .sidebar {\n      height: 100%;\n      background-color: ${theme.colors.grayscale.light4};\n      padding: ${theme.gridUnit * 2}px;\n      width: ${theme.gridUnit * 8}px;\n    }\n    .collapse-icon > svg {\n      color: ${theme.colors.primary.base};\n    }\n  `};\n`;\n\nconst updateHistory = _debounce(\n  async (\n  formData,\n  datasourceId,\n  datasourceType,\n  isReplace,\n  standalone,\n  force,\n  title,\n  tabId) =>\n  {\n    const payload = { ...formData };\n    const chartId = formData.slice_id;\n    const params = new URLSearchParams(window.location.search);\n    const additionalParam = Object.fromEntries(params);\n\n    if (chartId) {\n      additionalParam[URL_PARAMS.sliceId.name] = chartId;\n    } else {\n      additionalParam[URL_PARAMS.datasourceId.name] = datasourceId;\n      additionalParam[URL_PARAMS.datasourceType.name] = datasourceType;\n    }\n\n    const urlParams = (payload == null ? void 0 : payload.url_params) || {};\n    Object.entries(urlParams).forEach(([key, value]) => {\n      if (!RESERVED_CHART_URL_PARAMS.includes(key)) {\n        additionalParam[key] = value;\n      }\n    });\n\n    try {\n      let key;\n      let stateModifier;\n      if (isReplace) {\n        key = await postFormData(\n          datasourceId,\n          datasourceType,\n          formData,\n          chartId,\n          tabId\n        );\n        stateModifier = 'replaceState';\n      } else {\n        key = getUrlParam(URL_PARAMS.formDataKey);\n        await putFormData(\n          datasourceId,\n          datasourceType,\n          key,\n          formData,\n          chartId,\n          tabId\n        );\n        stateModifier = 'pushState';\n      }\n      // avoid race condition in case user changes route before explore updates the url\n      if (window.location.pathname.startsWith('/explore')) {\n        const url = mountExploreUrl(\n          standalone ? URL_PARAMS.standalone.name : null,\n          {\n            [URL_PARAMS.formDataKey.name]: key,\n            ...additionalParam\n          },\n          force\n        );\n        window.history[stateModifier](payload, title, url);\n      }\n    } catch (e) {\n      logging.warn('Failed at altering browser history', e);\n    }\n  },\n  1000\n);\n\nconst defaultSidebarsWidth = {\n  controls_width: 320,\n  datasource_width: 300\n};\n\nfunction getSidebarWidths(key) {\n  return getItem(key, defaultSidebarsWidth[key]);\n}\n\nfunction setSidebarWidths(key, dimension) {\n  const newDimension = Number(getSidebarWidths(key)) + dimension.width;\n  setItem(key, newDimension);\n}\n\nfunction ExploreViewContainer(props) {\n  const dynamicPluginContext = usePluginContext();\n  const dynamicPlugin = dynamicPluginContext.dynamicPlugins[props.vizType];\n  const isDynamicPluginLoading = dynamicPlugin && dynamicPlugin.mounting;\n  const wasDynamicPluginLoading = usePrevious(isDynamicPluginLoading);\n\n  /** the state of controls in the previous render */\n  const previousControls = usePrevious(props.controls);\n  /** the state of controls last time a query was triggered */\n  const [lastQueriedControls, setLastQueriedControls] = useState(\n    props.controls\n  );\n\n  const [isCollapsed, setIsCollapsed] = useState(false);\n  const [width, setWidth] = useState(\n    getSidebarWidths(LocalStorageKeys.DatasourceWidth)\n  );\n  const tabId = useTabId();\n\n  const theme = useTheme();\n\n  const addHistory = useCallback(\n    async ({ isReplace = false, title } = {}) => {\n      const formData = props.dashboardId ?\n      {\n        ...props.form_data,\n        dashboardId: props.dashboardId\n      } :\n      props.form_data;\n      const { id: datasourceId, type: datasourceType } = props.datasource;\n\n      updateHistory(\n        formData,\n        datasourceId,\n        datasourceType,\n        isReplace,\n        props.standalone,\n        props.force,\n        title,\n        tabId\n      );\n    },\n    [\n    props.dashboardId,\n    props.form_data,\n    props.datasource.id,\n    props.datasource.type,\n    props.standalone,\n    props.force,\n    tabId]\n\n  );\n\n  const handlePopstate = useCallback(() => {\n    const formData = window.history.state;\n    if (formData && Object.keys(formData).length) {\n      props.actions.setExploreControls(formData);\n      props.actions.postChartFormData(\n        formData,\n        props.force,\n        props.timeout,\n        props.chart.id\n      );\n    }\n  }, [props.actions, props.chart.id, props.timeout]);\n\n  const onQuery = useCallback(() => {\n    props.actions.setForceQuery(false);\n    props.actions.triggerQuery(true, props.chart.id);\n    addHistory();\n    setLastQueriedControls(props.controls);\n  }, [props.controls, addHistory, props.actions, props.chart.id]);\n\n  const handleKeydown = useCallback(\n    (event) => {\n      const controlOrCommand = event.ctrlKey || event.metaKey;\n      if (controlOrCommand) {\n        const isEnter = event.key === 'Enter' || event.keyCode === 13;\n        const isS = event.key === 's' || event.keyCode === 83;\n        if (isEnter) {\n          onQuery();\n        } else if (isS) {\n          if (props.slice) {\n            props.actions.\n            saveSlice(props.form_data, {\n              action: 'overwrite',\n              slice_id: props.slice.slice_id,\n              slice_name: props.slice.slice_name,\n              add_to_dash: 'noSave',\n              goto_dash: false\n            }).\n            then(({ data }) => {\n              window.location = data.slice.slice_url;\n            });\n          }\n        }\n      }\n    },\n    [onQuery, props.actions, props.form_data, props.slice]\n  );\n\n  function onStop() {\n    if (props.chart && props.chart.queryController) {\n      props.chart.queryController.abort();\n    }\n  }\n\n  function toggleCollapse() {\n    setIsCollapsed(!isCollapsed);\n  }\n\n  useComponentDidMount(() => {var _props$slice;\n    props.actions.logEvent(\n      LOG_ACTIONS_MOUNT_EXPLORER,\n      (_props$slice = props.slice) != null && _props$slice.slice_id ?\n      {\n        slice_id: props.slice.slice_id\n      } :\n      undefined\n    );\n  });\n\n  useChangeEffect(tabId, (previous, current) => {\n    if (current) {\n      addHistory({ isReplace: true });\n    }\n  });\n\n  const previousHandlePopstate = usePrevious(handlePopstate);\n  useEffect(() => {\n    if (previousHandlePopstate) {\n      window.removeEventListener('popstate', previousHandlePopstate);\n    }\n    window.addEventListener('popstate', handlePopstate);\n    return () => {\n      window.removeEventListener('popstate', handlePopstate);\n    };\n  }, [handlePopstate, previousHandlePopstate]);\n\n  const previousHandleKeyDown = usePrevious(handleKeydown);\n  useEffect(() => {\n    if (previousHandleKeyDown) {\n      window.removeEventListener('keydown', previousHandleKeyDown);\n    }\n    document.addEventListener('keydown', handleKeydown);\n    return () => {\n      document.removeEventListener('keydown', handleKeydown);\n    };\n  }, [handleKeydown, previousHandleKeyDown]);\n\n  useEffect(() => {\n    if (wasDynamicPluginLoading && !isDynamicPluginLoading) {\n      // reload the controls now that we actually have the control config\n      props.actions.dynamicPluginControlsReady();\n    }\n  }, [isDynamicPluginLoading]);\n\n  useEffect(() => {\n    const hasError = Object.values(props.controls).some(\n      (control) =>\n      control.validationErrors && control.validationErrors.length > 0\n    );\n    if (!hasError) {\n      props.actions.triggerQuery(true, props.chart.id);\n    }\n  }, []);\n\n  const reRenderChart = useCallback(\n    (controlsChanged) => {\n      const newQueryFormData = controlsChanged ?\n      {\n        ...props.chart.latestQueryFormData,\n        ...getFormDataFromControls(_pick(props.controls, controlsChanged))\n      } :\n      getFormDataFromControls(props.controls);\n      props.actions.updateQueryFormData(newQueryFormData, props.chart.id);\n      props.actions.renderTriggered(new Date().getTime(), props.chart.id);\n      addHistory();\n    },\n    [\n    addHistory,\n    props.actions,\n    props.chart.id,\n    props.chart.latestQueryFormData,\n    props.controls]\n\n  );\n\n  // effect to run when controls change\n  useEffect(() => {\n    if (\n    previousControls &&\n    props.chart.latestQueryFormData.viz_type === props.controls.viz_type.value)\n    {\n      if (\n      props.controls.datasource && (\n      previousControls.datasource == null ||\n      props.controls.datasource.value !== previousControls.datasource.value))\n      {\n        // this should really be handled by actions\n        fetchDatasourceMetadata(props.form_data.datasource, true);\n      }\n\n      const changedControlKeys = Object.keys(props.controls).filter(\n        (key) =>\n        typeof previousControls[key] !== 'undefined' &&\n        !areObjectsEqual(\n          props.controls[key].value,\n          previousControls[key].value\n        )\n      );\n\n      // this should also be handled by the actions that are actually changing the controls\n      const displayControlsChanged = changedControlKeys.filter(\n        (key) => props.controls[key].renderTrigger\n      );\n      if (displayControlsChanged.length > 0) {\n        reRenderChart(displayControlsChanged);\n      }\n    }\n  }, [props.controls, props.ownState]);\n\n  const chartIsStale = useMemo(() => {\n    if (lastQueriedControls) {\n      const { controls } = props;\n      const changedControlKeys = Object.keys(controls).filter((key) => {\n        const lastControl = lastQueriedControls[key];\n        if (typeof lastControl === 'undefined') {\n          return false;\n        }\n        const { value: value1 } = controls[key];\n        const { value: value2 } = lastControl;\n        if (_isObjectLike(value1) && _isObjectLike(value2)) {\n          return !areObjectsEqual(value1, value2, {\n            ignoreFields: ['datasourceWarning']\n          });\n        }\n        return !_isEqual(value1, value2);\n      });\n\n      return changedControlKeys.some(\n        (key) =>\n        !props.controls[key].renderTrigger &&\n        !props.controls[key].dontRefreshOnChange\n      );\n    }\n    return false;\n  }, [lastQueriedControls, props.controls]);\n\n  useChangeEffect(props.saveAction, () => {\n    if (['saveas', 'overwrite'].includes(props.saveAction)) {\n      onQuery();\n      addHistory({ isReplace: true });\n      props.actions.setSaveAction(null);\n    }\n  });\n\n  useEffect(() => {\n    if (props.ownState !== undefined) {\n      onQuery();\n      reRenderChart();\n    }\n  }, [props.ownState]);\n\n  if (chartIsStale) {\n    props.actions.logEvent(LOG_ACTIONS_CHANGE_EXPLORE_CONTROLS);\n  }\n\n  const errorMessage = useMemo(() => {\n    const controlsWithErrors = Object.values(props.controls).filter(\n      (control) =>\n      control.validationErrors && control.validationErrors.length > 0\n    );\n    if (controlsWithErrors.length === 0) {\n      return null;\n    }\n\n    const errorMessages = controlsWithErrors.map(\n      (control) => control.validationErrors\n    );\n    const uniqueErrorMessages = [...new Set(errorMessages.flat())];\n\n    const errors = uniqueErrorMessages.\n    map((message) => {\n      const matchingLabels = controlsWithErrors.\n      filter((control) => {var _control$validationEr;return (_control$validationEr = control.validationErrors) == null ? void 0 : _control$validationEr.includes(message);}).\n      map((control) => control.label);\n      return [matchingLabels, message];\n    }).\n    map(([labels, message]) =>\n    _jsxs(\"div\", { children: [\n      labels.length > 1 ? t('Controls labeled ') : t('Control labeled '),\n      _jsx(\"strong\", { children: ` ${labels.join(', ')}` }),\n      _jsxs(\"span\", { children: [\": \", message] })] }, message\n    )\n    );\n\n    let errorMessage;\n    if (errors.length > 0) {\n      errorMessage = _jsx(\"div\", { style: { textAlign: 'left' }, children: errors });\n    }\n    return errorMessage;\n  }, [props.controls]);\n\n  function renderChartContainer() {\n    return (\n      _jsx(ExploreChartPanel, { ...\n        props,\n        errorMessage: errorMessage,\n        chartIsStale: chartIsStale,\n        onQuery: onQuery }\n      ));\n\n  }\n\n  if (props.standalone) {\n    return renderChartContainer();\n  }\n\n  return (\n    _jsxs(ExploreContainer, { children: [\n      _jsx(ConnectedExploreChartHeader, {\n        actions: props.actions,\n        canOverwrite: props.can_overwrite,\n        canDownload: props.can_download,\n        dashboardId: props.dashboardId,\n        colorScheme: props.dashboardColorScheme,\n        isStarred: props.isStarred,\n        slice: props.slice,\n        sliceName: props.sliceName,\n        table_name: props.table_name,\n        formData: props.form_data,\n        chart: props.chart,\n        ownState: props.ownState,\n        user: props.user,\n        reports: props.reports,\n        saveDisabled: errorMessage || props.chart.chartStatus === 'loading',\n        metadata: props.metadata }\n      ),\n      _jsxs(ExplorePanelContainer, { id: \"explore-container\", children: [\n        _jsx(Global, {\n          styles: css`\n            .navbar {\n              margin-bottom: 0;\n            }\n            body {\n              height: 100vh;\n              max-height: 100vh;\n              overflow: hidden;\n            }\n            #app-menu,\n            #app {\n              flex: 1 1 auto;\n            }\n            #app {\n              flex-basis: 100%;\n              overflow: hidden;\n              height: 100%;\n            }\n            #app-menu {\n              flex-shrink: 0;\n            }\n          ` }\n        ),\n        _jsxs(Resizable, {\n          onResizeStop: (evt, direction, ref, d) => {\n            setWidth(ref.getBoundingClientRect().width);\n            setSidebarWidths(LocalStorageKeys.DatasourceWidth, d);\n          },\n          defaultSize: {\n            width: getSidebarWidths(LocalStorageKeys.DatasourceWidth),\n            height: '100%'\n          },\n          minWidth: defaultSidebarsWidth[LocalStorageKeys.DatasourceWidth],\n          maxWidth: \"33%\",\n          enable: { right: true },\n          className:\n          isCollapsed ? 'no-show' : 'explore-column data-source-selection', children: [\n\n\n          _jsxs(\"div\", { className: \"title-container\", children: [\n            _jsx(\"span\", { className: \"horizontal-text\", children: t('Chart Source') }),\n            _jsx(\"span\", {\n              role: \"button\",\n              tabIndex: 0,\n              className: \"action-button\",\n              onClick: toggleCollapse, children:\n\n              _jsx(Icons.VerticalAlignTopOutlined, {\n                iconSize: \"xl\",\n                css: css`\n                  transform: rotate(-90deg);\n                `,\n                className: \"collapse-icon\",\n                iconColor: theme.colors.primary.base }\n              ) }\n            )] }\n          ),\n          _jsx(DataSourcePanel, {\n            formData: props.form_data,\n            datasource: props.datasource,\n            controls: props.controls,\n            actions: props.actions,\n            width: width,\n            user: props.user }\n          )] }\n        ),\n        isCollapsed ?\n        _jsx(\"div\", {\n          className: \"sidebar\",\n          onClick: toggleCollapse,\n\n          role: \"button\",\n          tabIndex: 0, children:\n\n          _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", children:\n            _jsx(Tooltip, { title: t('Open Datasource tab'), children:\n              _jsx(Icons.VerticalAlignTopOutlined, {\n                iconSize: \"xl\",\n                css: css`\n                    transform: rotate(90deg);\n                  `,\n                className: \"collapse-icon\",\n                iconColor: theme.colors.primary.base }\n              ) }\n            ) }\n          ) }\n        ) :\n        null,\n        _jsx(Resizable, {\n          onResizeStop: (evt, direction, ref, d) =>\n          setSidebarWidths(LocalStorageKeys.ControlsWidth, d),\n\n          defaultSize: {\n            width: getSidebarWidths(LocalStorageKeys.ControlsWidth),\n            height: '100%'\n          },\n          minWidth: defaultSidebarsWidth[LocalStorageKeys.ControlsWidth],\n          maxWidth: \"33%\",\n          enable: { right: true },\n          className: \"col-sm-3 explore-column controls-column\", children:\n\n          _jsx(ConnectedControlPanelsContainer, {\n            exploreState: props.exploreState,\n            actions: props.actions,\n            form_data: props.form_data,\n            controls: props.controls,\n            chart: props.chart,\n            datasource_type: props.datasource_type,\n            isDatasourceMetaLoading: props.isDatasourceMetaLoading,\n            onQuery: onQuery,\n            onStop: onStop,\n            canStopQuery: props.can_add || props.can_overwrite,\n            errorMessage: errorMessage,\n            chartIsStale: chartIsStale }\n          ) }\n        ),\n        _jsx(\"div\", {\n          className: cx(\n            'main-explore-content',\n            isCollapsed ? 'col-sm-9' : 'col-sm-7'\n          ), children:\n\n          renderChartContainer() }\n        )] }\n      ),\n      props.isSaveModalVisible &&\n      _jsx(SaveModal, {\n        addDangerToast: props.addDangerToast,\n        actions: props.actions,\n        form_data: props.form_data,\n        sliceName: props.sliceName,\n        dashboardId: props.dashboardId }\n      )] }\n\n    ));\n\n}\n\nExploreViewContainer.propTypes = propTypes;\n\nconst retainQueryModeRequirements = (hiddenFormData) =>\nObject.keys(hiddenFormData != null ? hiddenFormData : {}).filter(\n  (key) => !QUERY_MODE_REQUISITES.has(key)\n);\n\nfunction mapStateToProps(state) {var _controls$query_mode, _ref, _form_data$slice_id, _dataMask$slice_id, _explore$form_data, _explore$form_data2, _explore$form_data3, _explore$form_data4, _datasource$column_fo, _ref2, _explore$sliceName, _dataMask$slice_id2;\n  const {\n    explore,\n    charts,\n    common,\n    impressionId,\n    dataMask,\n    reports,\n    user,\n    saveModal\n  } = state;\n  const { controls, slice, datasource, metadata, hiddenFormData } = explore;\n  const hasQueryMode = !!((_controls$query_mode = controls.query_mode) != null && _controls$query_mode.value);\n  const fieldsToOmit = hasQueryMode ?\n  retainQueryModeRequirements(hiddenFormData) :\n  Object.keys(hiddenFormData != null ? hiddenFormData : {});\n  const form_data = _omit(getFormDataFromControls(controls), fieldsToOmit);\n  const slice_id = (_ref = (_form_data$slice_id = form_data.slice_id) != null ? _form_data$slice_id : slice == null ? void 0 : slice.slice_id) != null ? _ref : 0; // 0 - unsaved chart\n  form_data.extra_form_data = mergeExtraFormData(\n    { ...form_data.extra_form_data },\n    {\n      ...((_dataMask$slice_id = dataMask[slice_id]) == null ? void 0 : _dataMask$slice_id.ownState)\n    }\n  );\n  const chart = charts[slice_id];\n  const colorScheme = (_explore$form_data = explore.form_data) == null ? void 0 : _explore$form_data.color_scheme;\n  const ownColorScheme = (_explore$form_data2 = explore.form_data) == null ? void 0 : _explore$form_data2.own_color_scheme;\n  const dashboardColorScheme = (_explore$form_data3 = explore.form_data) == null ? void 0 : _explore$form_data3.dashboard_color_scheme;\n\n  let dashboardId = Number((_explore$form_data4 = explore.form_data) == null ? void 0 : _explore$form_data4.dashboardId);\n  if (Number.isNaN(dashboardId)) {\n    dashboardId = undefined;\n  }\n\n  return {\n    isDatasourceMetaLoading: explore.isDatasourceMetaLoading,\n    datasource,\n    datasource_type: datasource.type,\n    datasourceId: datasource.datasource_id,\n    dashboardId,\n    colorScheme,\n    ownColorScheme,\n    dashboardColorScheme,\n    controls: explore.controls,\n    can_add: !!explore.can_add,\n    can_download: !!explore.can_download,\n    can_overwrite: !!explore.can_overwrite,\n    column_formats: (_datasource$column_fo = datasource == null ? void 0 : datasource.column_formats) != null ? _datasource$column_fo : null,\n    containerId: slice ?\n    `slice-container-${slice.slice_id}` :\n    'slice-container',\n    isStarred: explore.isStarred,\n    slice,\n    sliceName: (_ref2 = (_explore$sliceName = explore.sliceName) != null ? _explore$sliceName : slice == null ? void 0 : slice.slice_name) != null ? _ref2 : null,\n    triggerRender: explore.triggerRender,\n    form_data,\n    table_name: datasource.table_name,\n    vizType: form_data.viz_type,\n    standalone: !!explore.standalone,\n    force: !!explore.force,\n    chart,\n    timeout: common.conf.SUPERSET_WEBSERVER_TIMEOUT,\n    ownState: (_dataMask$slice_id2 = dataMask[slice_id]) == null ? void 0 : _dataMask$slice_id2.ownState,\n    impressionId,\n    user,\n    exploreState: explore,\n    reports,\n    metadata,\n    saveAction: explore.saveAction,\n    isSaveModalVisible: saveModal.isVisible\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  const actions = {\n    ...exploreActions,\n    ...datasourcesActions,\n    ...saveModalActions,\n    ...chartActions,\n    ...logActions\n  };\n  return {\n    actions: bindActionCreators(actions, dispatch)\n  };\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(withToasts(/*#__PURE__*/memo(ExploreViewContainer)));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}