{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { t } from '@superset-ui/core';\nimport { sanitizeFormData } from 'src/explore/exploreUtils/formData';\nimport getControlsForVizType from 'src/utils/getControlsForVizType';\nimport Label from 'src/components/Label';\nimport Icons from 'src/components/Icons';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { Tooltip } from 'src/components/Tooltip';\nimport ModalTrigger from '../ModalTrigger';\nimport TableView from '../TableView';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport const alterForComparison = (value) => {\n  // Treat `null`, `undefined`, and empty strings as equivalent\n  if (value === undefined || value === null || value === '') {\n    return null;\n  }\n  // Treat empty arrays and objects as equivalent to null\n  if (Array.isArray(value) && value.length === 0) {\n    return null;\n  }\n  if (typeof value === 'object' && Object.keys(value).length === 0) {\n    return null;\n  }\n  return value;\n};\nexport const formatValueHandler = (value, key, controlsMap) => {var _controlsMap$key, _controlsMap$key2, _controlsMap$key3, _controlsMap$key4;\n  if (value === undefined) {\n    return 'N/A';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n  if (((_controlsMap$key = controlsMap[key]) == null ? void 0 : _controlsMap$key.type) === 'AdhocFilterControl' && Array.isArray(value)) {\n    if (!value.length) {\n      return '[]';\n    }\n    return value.\n    map((v) => {\n      const filterVal = v.comparator && v.comparator.constructor === Array ?\n      `[${v.comparator.join(', ')}]` :\n      v.comparator;\n      return `${v.subject} ${v.operator} ${filterVal}`;\n    }).\n    join(', ');\n  }\n  if (((_controlsMap$key2 = controlsMap[key]) == null ? void 0 : _controlsMap$key2.type) === 'BoundsControl' && Array.isArray(value)) {\n    return `Min: ${value[0]}, Max: ${value[1]}`;\n  }\n  if (((_controlsMap$key3 = controlsMap[key]) == null ? void 0 : _controlsMap$key3.type) === 'CollectionControl' && Array.isArray(value)) {\n    return value.map((v) => safeStringify(v)).join(', ');\n  }\n  if (((_controlsMap$key4 = controlsMap[key]) == null ? void 0 : _controlsMap$key4.type) === 'MetricsControl' &&\n  value.constructor === Array) {\n    const formattedValue = value.map((v) => {var _v$label;return (_v$label = v == null ? void 0 : v.label) != null ? _v$label : v;});\n    return formattedValue.length ? formattedValue.join(', ') : '[]';\n  }\n  if (Array.isArray(value)) {\n    const formattedValue = value.map((v) => {var _v$label2;return (_v$label2 = v == null ? void 0 : v.label) != null ? _v$label2 : v;});\n    return formattedValue.length ? formattedValue.join(', ') : '[]';\n  }\n  if (typeof value === 'string' || typeof value === 'number') {\n    return value;\n  }\n  return safeStringify(value);\n};\nexport const getRowsFromDiffs = (diffs, controlsMap) => Object.entries(diffs).map(([key, diff]) => {var _controlsMap$key5;return {\n    control: ((_controlsMap$key5 = controlsMap[key]) == null ? void 0 : _controlsMap$key5.label) || key,\n    before: formatValueHandler(diff.before, key, controlsMap),\n    after: formatValueHandler(diff.after, key, controlsMap)\n  };});\nexport const isEqualish = (val1, val2) => _isEqual(alterForComparison(val1), alterForComparison(val2));\nconst AlteredSliceTag = (props) => {var _props$origFormData2;\n  const [rows, setRows] = useState([]);\n  const [hasDiffs, setHasDiffs] = useState(false);\n  const getDiffs = useCallback(() => {\n    // Returns all properties that differ in the\n    // current form data and the saved form data\n    const ofd = sanitizeFormData(props.origFormData);\n    const cfd = sanitizeFormData(props.currentFormData);\n    const fdKeys = Object.keys(cfd);\n    const diffs = {};\n    fdKeys.forEach((fdKey) => {\n      if (!ofd[fdKey] && !cfd[fdKey]) {\n        return;\n      }\n      if (['filters', 'having', 'where'].includes(fdKey)) {\n        return;\n      }\n      if (!isEqualish(ofd[fdKey], cfd[fdKey])) {\n        diffs[fdKey] = { before: ofd[fdKey], after: cfd[fdKey] };\n      }\n    });\n    return diffs;\n  }, [props.currentFormData, props.origFormData]);\n  useEffect(() => {var _props$origFormData;\n    const diffs = getDiffs();\n    const controlsMap = getControlsForVizType((_props$origFormData = props.origFormData) == null ? void 0 : _props$origFormData.viz_type);\n    setRows(getRowsFromDiffs(diffs, controlsMap));\n    setHasDiffs(!_isEmpty(diffs));\n  }, [getDiffs, (_props$origFormData2 = props.origFormData) == null ? void 0 : _props$origFormData2.viz_type]);\n  const modalBody = useMemo(() => {\n    const columns = [\n    {\n      accessor: 'control',\n      Header: t('Control')\n    },\n    {\n      accessor: 'before',\n      Header: t('Before')\n    },\n    {\n      accessor: 'after',\n      Header: t('After')\n    }];\n\n    // set the wrap text in the specific columns.\n    const columnsForWrapText = ['Control', 'Before', 'After'];\n    return _jsx(TableView, { columns: columns, data: rows, pageSize: 50, className: \"table-condensed\", columnsForWrapText: columnsForWrapText });\n  }, [rows]);\n  const triggerNode = useMemo(() => _jsx(Tooltip, { id: \"difference-tooltip\", title: t('Click to see difference'), children:\n    _jsx(Label, { icon: _jsx(Icons.ExclamationCircleOutlined, { iconSize: \"m\" }), className: \"label\", type: \"warning\", onClick: () => {}, children:\n      t('Altered') }\n    ) }\n  ), []);\n  if (!hasDiffs) {\n    return null;\n  }\n  return _jsx(ModalTrigger, { triggerNode: triggerNode, modalTitle: t('Chart changes'), modalBody: modalBody, responsive: true });\n};\nexport default AlteredSliceTag;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}