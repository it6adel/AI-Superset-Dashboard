{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, isFeatureEnabled, FeatureFlag, makeApi, SupersetClient, logging, getClientErrorObject, parseErrorJson } from '@superset-ui/core';\nimport getBootstrapData from 'src/utils/getBootstrapData';\nconst TRANSPORT_POLLING = 'polling';\nconst TRANSPORT_WS = 'ws';\nconst JOB_STATUS = {\n  PENDING: 'pending',\n  RUNNING: 'running',\n  ERROR: 'error',\n  DONE: 'done'\n};\nconst LOCALSTORAGE_KEY = 'last_async_event_id';\nconst POLLING_URL = '/api/v1/async_event/';\nconst MAX_RETRIES = 6;\nconst RETRY_DELAY = 100;\nlet config;\nlet transport;\nlet pollingDelayMs;\nlet pollingTimeoutId;\nlet listenersByJobId;\nlet retriesByJobId;\nlet lastReceivedEventId;\nconst addListener = (id, fn) => {\n  listenersByJobId[id] = fn;\n};\nconst removeListener = (id) => {\n  if (!listenersByJobId[id])\n  return;\n  delete listenersByJobId[id];\n};\nconst fetchCachedData = async (asyncEvent) => {\n  let status = 'success';\n  let data;\n  try {\n    const { json } = await SupersetClient.get({\n      endpoint: String(asyncEvent.result_url)\n    });\n    data = 'result' in json ? json.result : json;\n  }\n  catch (response) {\n    status = 'error';\n    data = await getClientErrorObject(response);\n  }\n  return { status, data };\n};\nexport const waitForAsyncData = async (asyncResponse) => new Promise((resolve, reject) => {\n  const jobId = asyncResponse.job_id;\n  const listener = async (asyncEvent) => {\n    switch (asyncEvent.status) {\n      case JOB_STATUS.DONE:{\n          let { data, status } = await fetchCachedData(asyncEvent); // eslint-disable-line prefer-const\n          data = ensureIsArray(data);\n          if (status === 'success') {\n            resolve(data);\n          } else\n          {\n            reject(data);\n          }\n          break;\n        }\n      case JOB_STATUS.ERROR:{\n          const err = parseErrorJson(asyncEvent);\n          reject(err);\n          break;\n        }\n      default:{\n          logging.warn('received event with status', asyncEvent.status);\n        }\n    }\n    removeListener(jobId);\n  };\n  addListener(jobId, listener);\n});\nconst fetchEvents = makeApi({\n  method: 'GET',\n  endpoint: POLLING_URL\n});\nconst setLastId = (asyncEvent) => {\n  lastReceivedEventId = asyncEvent.id;\n  try {\n    localStorage.setItem(LOCALSTORAGE_KEY, lastReceivedEventId);\n  }\n  catch (err) {\n    logging.warn('Error saving event Id to localStorage', err);\n  }\n};\nexport const processEvents = async (events) => {\n  events.forEach((asyncEvent) => {\n    const jobId = asyncEvent.job_id;\n    const listener = listenersByJobId[jobId];\n    if (listener) {\n      listener(asyncEvent);\n      delete retriesByJobId[jobId];\n    } else\n    {\n      // handle race condition where event is received\n      // before listener is registered\n      if (!retriesByJobId[jobId])\n      retriesByJobId[jobId] = 0;\n      retriesByJobId[jobId] += 1;\n      if (retriesByJobId[jobId] <= MAX_RETRIES) {\n        setTimeout(() => {\n          processEvents([asyncEvent]);\n        }, RETRY_DELAY * retriesByJobId[jobId]);\n      } else\n      {\n        delete retriesByJobId[jobId];\n        logging.warn('listener not found for job_id', asyncEvent.job_id);\n      }\n    }\n    setLastId(asyncEvent);\n  });\n};\nconst loadEventsFromApi = async () => {\n  const eventArgs = lastReceivedEventId ? { last_id: lastReceivedEventId } : {};\n  if (Object.keys(listenersByJobId).length) {\n    try {\n      const { result: events } = await fetchEvents(eventArgs);\n      if (events != null && events.length)\n      await processEvents(events);\n    }\n    catch (err) {\n      logging.warn(err);\n    }\n  }\n  if (transport === TRANSPORT_POLLING) {\n    pollingTimeoutId = window.setTimeout(loadEventsFromApi, pollingDelayMs);\n  }\n};\nconst wsConnectMaxRetries = 6;\nconst wsConnectErrorDelay = 2500;\nlet wsConnectRetries = 0;\nlet wsConnectTimeout;\nlet ws;\nconst wsConnect = () => {\n  let url = config.GLOBAL_ASYNC_QUERIES_WEBSOCKET_URL;\n  if (lastReceivedEventId)\n  url += `?last_id=${lastReceivedEventId}`;\n  ws = new WebSocket(url);\n  ws.addEventListener('open', () => {\n    logging.log('WebSocket connected');\n    clearTimeout(wsConnectTimeout);\n    wsConnectRetries = 0;\n  });\n  ws.addEventListener('close', () => {\n    wsConnectTimeout = setTimeout(() => {\n      wsConnectRetries += 1;\n      if (wsConnectRetries <= wsConnectMaxRetries) {\n        wsConnect();\n      } else\n      {\n        logging.warn('WebSocket not available, falling back to async polling');\n        loadEventsFromApi();\n      }\n    }, wsConnectErrorDelay);\n  });\n  ws.addEventListener('error', () => {\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/readyState\n    if (ws.readyState < 2)\n    ws.close();\n  });\n  ws.addEventListener('message', async (event) => {\n    let events = [];\n    try {\n      events = [JSON.parse(event.data)];\n      await processEvents(events);\n    }\n    catch (err) {\n      logging.warn(err);\n    }\n  });\n};\nexport const init = (appConfig) => {\n  if (!isFeatureEnabled(FeatureFlag.GlobalAsyncQueries))\n  return;\n  if (pollingTimeoutId)\n  clearTimeout(pollingTimeoutId);\n  listenersByJobId = {};\n  retriesByJobId = {};\n  lastReceivedEventId = null;\n  config = appConfig || getBootstrapData().common.conf;\n  transport = config.GLOBAL_ASYNC_QUERIES_TRANSPORT || TRANSPORT_POLLING;\n  pollingDelayMs = config.GLOBAL_ASYNC_QUERIES_POLLING_DELAY || 500;\n  try {\n    lastReceivedEventId = localStorage.getItem(LOCALSTORAGE_KEY);\n  }\n  catch (err) {\n    logging.warn('Failed to fetch last event Id from localStorage');\n  }\n  if (transport === TRANSPORT_POLLING) {\n    loadEventsFromApi();\n  }\n  if (transport === TRANSPORT_WS) {\n    wsConnect();\n  }\n};\ninit();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}