{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { makeSingleton } from '../utils';\nexport var LabelsColorMapSource;\n(function (LabelsColorMapSource) {\n  LabelsColorMapSource[LabelsColorMapSource[\"Dashboard\"] = 0] = \"Dashboard\";\n  LabelsColorMapSource[LabelsColorMapSource[\"Explore\"] = 1] = \"Explore\";\n})(LabelsColorMapSource || (LabelsColorMapSource = {}));\nexport class LabelsColorMap {\n\n\n\n  constructor() {this.chartsLabelsMap = void 0;this.colorMap = void 0;this.source = void 0;\n    // holds labels and original color schemes for each chart in context\n    this.chartsLabelsMap = new Map();\n    this.colorMap = new Map();\n    this.source = LabelsColorMapSource.Dashboard;\n  }\n  /**\n   * Wipes out the color map and updates it with the new color scheme.\n   *\n   * @param categoricalNamespace - the namespace to use for color mapping\n   * @param colorScheme - color scheme\n   */\n  updateColorMap(categoricalNamespace, colorScheme, merge = false) {\n    const newColorMap = this.colorMap;\n    if (!merge) {\n      newColorMap.clear();\n    }\n    this.chartsLabelsMap.forEach((chartConfig, sliceId) => {\n      const { labels, ownScheme } = chartConfig;\n      const appliedColorScheme = colorScheme || ownScheme;\n      const colorScale = categoricalNamespace.getScale(appliedColorScheme);\n      labels.forEach((label) => {\n        // if merge, apply the scheme only to new labels in the map\n        if (!merge || !this.colorMap.has(label)) {\n          const newColor = colorScale.getColor(label, sliceId, appliedColorScheme);\n          newColorMap.set(label, newColor);\n        }\n      });\n    });\n    this.colorMap = newColorMap;\n  }\n  getColorMap() {\n    return this.colorMap;\n  }\n  /**\n   *\n   * Called individually by each plugin via getColor fn.\n   *\n   * @param label - the label name\n   * @param color - the color\n   * @param sliceId - the chart id\n   * @param colorScheme - the color scheme\n   *\n   */\n  addSlice(label, color, sliceId, colorScheme) {\n    const chartConfig = this.chartsLabelsMap.get(sliceId) || {\n      labels: [],\n      scheme: undefined,\n      ownScheme: undefined\n    };\n    const { labels } = chartConfig;\n    if (!labels.includes(label)) {\n      labels.push(label);\n      this.chartsLabelsMap.set(sliceId, {\n        labels,\n        scheme: colorScheme,\n        ownScheme: chartConfig.ownScheme\n      });\n    }\n    if (this.source === LabelsColorMapSource.Dashboard) {\n      this.colorMap.set(label, color);\n    }\n  }\n  /**\n   * Used to make sure all slices respect their original scheme.\n   *\n   * @param sliceId - the chart id\n   * @param ownScheme - the color scheme\n   */\n  setOwnColorScheme(sliceId, ownScheme) {\n    const chartConfig = this.chartsLabelsMap.get(sliceId);\n    if (chartConfig) {\n      this.chartsLabelsMap.set(sliceId, {\n        ...chartConfig,\n        ownScheme\n      });\n    }\n  }\n  /**\n   * Remove a slice from the color map.\n   *\n   * @param sliceId - the chart\n   */\n  removeSlice(sliceId) {\n    if (this.source !== LabelsColorMapSource.Dashboard)\n    return;\n    this.chartsLabelsMap.delete(sliceId);\n    const newColorMap = new Map();\n    this.chartsLabelsMap.forEach((chartConfig) => {\n      const { labels } = chartConfig;\n      labels.forEach((label) => {\n        newColorMap.set(label, this.colorMap.get(label));\n      });\n    });\n    this.colorMap = newColorMap;\n  }\n  /**\n   * Clear the shared labels color map.\n   */\n  clear() {\n    this.colorMap.clear();\n  }\n  /**\n   * Clears all maps\n   */\n  reset() {\n    this.clear();\n    this.chartsLabelsMap.clear();\n  }\n}\nconst getInstance = makeSingleton(LabelsColorMap);\nexport default getInstance;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}