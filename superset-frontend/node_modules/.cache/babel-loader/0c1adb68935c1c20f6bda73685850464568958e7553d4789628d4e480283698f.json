{"ast":null,"code":"import { css as _css } from \"@emotion/react\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react-hooks/rules-of-hooks */\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport { Behavior, isFeatureEnabled, FeatureFlag, GenericDataType, getChartMetadataRegistry, NativeFilterType, styled, t, getClientErrorObject, SLOW_DEBOUNCE, useTheme, css } from '@superset-ui/core';\n\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState, memo } from 'react';\nimport rison from 'rison';\nimport { useSelector } from 'react-redux';\nimport { getChartDataRequest } from 'src/components/Chart/chartAction';\nimport { Input, TextArea } from 'src/components/Input';\nimport { Select } from 'src/components';\nimport Collapse from 'src/components/Collapse';\nimport BasicErrorAlert from 'src/components/ErrorMessage/BasicErrorAlert';\nimport ErrorMessageWithStackTrace from 'src/components/ErrorMessage/ErrorMessageWithStackTrace';\nimport { FormItem } from 'src/components/Form';\nimport Icons from 'src/components/Icons';\nimport Loading from 'src/components/Loading';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport { Radio } from 'src/components/Radio';\nimport Tabs from 'src/components/Tabs';\nimport { Tooltip } from 'src/components/Tooltip';\nimport { cachedSupersetGet } from 'src/utils/cachedSupersetGet';\nimport DateFilterControl from 'src/explore/components/controls/DateFilterControl';\nimport AdhocFilterControl from 'src/explore/components/controls/FilterControl/AdhocFilterControl';\nimport { waitForAsyncData } from 'src/middleware/asyncEvent';\nimport { SingleValueType } from 'src/filters/components/Range/SingleValueType';\nimport { getFormData, mergeExtraFormData } from 'src/dashboard/components/nativeFilters/utils';\nimport { DatasetSelectLabel } from 'src/features/datasets/DatasetSelectLabel';\nimport { ALLOW_DEPENDENCIES as TYPES_SUPPORT_DEPENDENCIES, getFiltersConfigModalTestId } from '../FiltersConfigModal';\nimport { CollapsibleControl } from './CollapsibleControl';\nimport { ColumnSelect } from './ColumnSelect';\nimport DatasetSelect from './DatasetSelect';\nimport DefaultValue from './DefaultValue';\nimport FilterScope from './FilterScope/FilterScope';\nimport getControlItemsMap from './getControlItemsMap';\nimport RemovedFilter from './RemovedFilter';\nimport { useBackendFormUpdate, useDefaultValue } from './state';\nimport { hasTemporalColumns, mostUsedDataset, setNativeFilterFieldValues, useForceUpdate } from './utils';\nimport { FILTER_SUPPORTED_TYPES, INPUT_WIDTH } from './constants';\nimport DependencyList from './DependencyList';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst FORM_ITEM_WIDTH = 260;\nconst TabPane = styled(Tabs.TabPane)`\n  padding: ${({ theme }) => theme.gridUnit * 4}px 0px;\n`;\nconst StyledContainer = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    flex-direction: row-reverse;\n    justify-content: space-between;\n    padding: 0px ${theme.gridUnit * 4}px;\n  `}\n`;\nconst StyledRowContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  width: 100%;\n  padding: 0px ${({ theme }) => theme.gridUnit * 4}px;\n`;\nconst controlsOrder = [\n'enableEmptyFilter',\n'defaultToFirstItem',\n'multiSelect',\n'searchAllOptions',\n'inverseSelection'];\n\nexport const StyledFormItem = styled(FormItem)`\n  width: ${({ expanded }) => expanded ? '49%' : `${FORM_ITEM_WIDTH}px`};\n  margin-bottom: ${({ theme }) => theme.gridUnit * 4}px;\n\n  & .ant-form-item-label {\n    padding-bottom: 0;\n  }\n\n  & .ant-form-item-control-input {\n    min-height: ${({ theme }) => theme.gridUnit * 10}px;\n  }\n`;\nexport const StyledRowFormItem = styled(FormItem)`\n  margin-bottom: 0;\n  padding-bottom: 0;\n  min-width: ${({ expanded }) => expanded ? '50%' : `${FORM_ITEM_WIDTH}px`};\n\n  & .ant-form-item-label {\n    padding-bottom: 0;\n  }\n\n  .ant-form-item-control-input-content > div > div {\n    height: auto;\n  }\n\n  & .ant-form-item-control-input {\n    min-height: ${({ theme }) => theme.gridUnit * 10}px;\n  }\n`;\nexport const StyledRowSubFormItem = styled(FormItem)`\n  min-width: ${({ expanded }) => expanded ? '50%' : `${FORM_ITEM_WIDTH}px`};\n\n  & .ant-form-item-label {\n    padding-bottom: 0;\n  }\n\n  .ant-form-item {\n    margin-bottom: 0;\n  }\n\n  .ant-form-item-control-input-content > div > div {\n    height: auto;\n  }\n\n  .ant-form-item-extra {\n    display: none;\n  }\n\n  & .ant-form-item-control-input {\n    height: auto;\n  }\n`;\nexport const StyledLabel = styled.span`\n  color: ${({ theme }) => theme.colors.grayscale.base};\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n`;\nconst CleanFormItem = styled(FormItem)`\n  margin-bottom: 0;\n`;\nconst DefaultValueContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n`;\nconst StyledCollapse = styled(Collapse)`\n  border-left: 0;\n  border-top: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n  border-radius: 0;\n\n  .ant-collapse-header {\n    border-bottom: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n    border-top: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n    margin-top: -1px;\n    border-radius: 0;\n  }\n\n  .ant-collapse-content {\n    border: 0;\n  }\n\n  .ant-collapse-content-box {\n    padding-top: ${({ theme }) => theme.gridUnit * 2}px;\n  }\n\n  &.ant-collapse > .ant-collapse-item {\n    border: 0;\n    border-radius: 0;\n  }\n`;\nconst StyledTabs = styled(Tabs)`\n  .ant-tabs-nav {\n    position: sticky;\n    top: 0;\n    background: ${({ theme }) => theme.colors.grayscale.light5};\n    z-index: 1;\n  }\n\n  .ant-tabs-nav-list {\n    padding: 0;\n  }\n\n  .ant-form-item-label {\n    padding-bottom: 0;\n  }\n`;\nconst StyledAsterisk = styled.span`\n  color: ${({ theme }) => theme.colors.error.base};\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  margin-left: ${({ theme }) => theme.gridUnit - 1}px;\n  &:before {\n    content: '*';\n  }\n`;\nconst FilterTypeInfo = styled.div`\n  ${({ theme, expanded }) => `\n    width: ${expanded ? '49%' : `${FORM_ITEM_WIDTH}px`};\n    font-size: ${theme.typography.sizes.s}px;\n    color: ${theme.colors.grayscale.light1};\n    margin:\n      ${-theme.gridUnit * 2}px\n      0px\n      ${theme.gridUnit * 4}px\n      ${theme.gridUnit * 4}px;\n  `}\n`;\nconst FilterTabs = {\n  configuration: {\n    key: 'configuration',\n    name: t('Settings')\n  },\n  scoping: {\n    key: 'scoping',\n    name: t('Scoping')\n  }\n};\nexport const FilterPanels = {\n  configuration: {\n    key: 'configuration',\n    name: t('Filter Configuration')\n  },\n  settings: {\n    key: 'settings',\n    name: t('Filter Settings')\n  }\n};\nconst FILTERS_WITH_ADHOC_FILTERS = ['filter_select', 'filter_range'];\n// TODO: Rename the filter plugins and remove this mapping\nconst FILTER_TYPE_NAME_MAPPING = {\n  [t('Select filter')]: t('Value'),\n  [t('Range filter')]: t('Numerical range'),\n  [t('Time filter')]: t('Time range'),\n  [t('Time column')]: t('Time column'),\n  [t('Time grain')]: t('Time grain'),\n  [t('Group By')]: t('Group by')\n};\n/**\n * The configuration form for a specific filter.\n * Assigns field values to `filters[filterId]` in the form.\n */\nconst FiltersConfigForm = ({ expanded, filterId, filterToEdit, removedFilters, form, getAvailableFilters, activeFilterPanelKeys, restoreFilter, handleActiveFilterPanelChange, setErroredFilters, onModifyFilter, validateDependencies, getDependencySuggestion, isActive }, ref) => {var _formFilter$dataset2, _nativeFilterItems$fo, _nativeFilterItems$fo2, _ref, _formFilter$dataset$v, _formFilter$dataset3, _filterToEdit$targets, _nativeFilterItems$fo3, _nativeFilterItem$val, _formFilter$isDataDir, _formFilter$dataset6, _filterToEdit$adhoc_f, _formFilter$controlVa, _filterToEdit$control, _filterToEdit$control2, _formFilter$controlVa2, _formFilter$controlVa3, _filterToEdit$control3, _filterToEdit$control4, _formFilter$controlVa4, _formFilter$adhoc_fil, _formFilter$controlVa5, _formFilter$dataset9, _datasetDetails$colum, _error$errors;\n  const theme = useTheme();\n  const isRemoved = !!removedFilters[filterId];\n  const [error, setError] = useState();\n  const [metrics, setMetrics] = useState([]);\n  const [activeTabKey, setActiveTabKey] = useState(FilterTabs.configuration.key);\n  const dashboardId = useSelector((state) => state.dashboardInfo.id);\n  const [undoFormValues, setUndoFormValues] = useState(null);\n  const forceUpdate = useForceUpdate(isActive);\n  const [datasetDetails, setDatasetDetails] = useState();\n  const defaultFormFilter = useMemo(() => ({}), []);\n  const filters = form.getFieldValue('filters');\n  const formValues = filters == null ? void 0 : filters[filterId];\n  const formFilter = formValues || undoFormValues || defaultFormFilter;\n  const handleModifyFilter = useCallback(() => {\n    if (onModifyFilter) {\n      onModifyFilter(filterId);\n    }\n  }, [onModifyFilter, filterId]);\n  const dependencies = (formFilter == null ? void 0 : formFilter.dependencies) || (filterToEdit == null ? void 0 : filterToEdit.cascadeParentIds) || [];\n  const nativeFilterItems = getChartMetadataRegistry().items;\n  const nativeFilterVizTypes = Object.entries(nativeFilterItems)\n  // @ts-ignore\n  .filter(([, { value }]) => {var _value$behaviors;return (_value$behaviors = value.behaviors) == null ? void 0 : _value$behaviors.includes(Behavior.NativeFilter);}).\n  map(([key]) => key);\n  const loadedDatasets = useSelector(({ datasources }) => datasources);\n  const charts = useSelector(({ charts }) => charts);\n  const doLoadedDatasetsHaveTemporalColumns = useMemo(() => Object.values(loadedDatasets).some((dataset) => hasTemporalColumns(dataset)), [loadedDatasets]);\n  const showTimeRangePicker = useMemo(() => {\n    const currentDataset = Object.values(loadedDatasets).find((dataset) => {var _formFilter$dataset;return dataset.id === (formFilter == null ? void 0 : (_formFilter$dataset = formFilter.dataset) == null ? void 0 : _formFilter$dataset.value);});\n    return currentDataset ? hasTemporalColumns(currentDataset) : true;\n  }, [formFilter == null ? void 0 : (_formFilter$dataset2 = formFilter.dataset) == null ? void 0 : _formFilter$dataset2.value, loadedDatasets]);\n  const hasDataset =\n  // @ts-ignore\n  !!((_nativeFilterItems$fo = nativeFilterItems[formFilter == null ? void 0 : formFilter.filterType]) != null && (_nativeFilterItems$fo2 = _nativeFilterItems$fo.value) != null && _nativeFilterItems$fo2.datasourceCount);\n  const datasetId = (_ref = (_formFilter$dataset$v = formFilter == null ? void 0 : (_formFilter$dataset3 = formFilter.dataset) == null ? void 0 : _formFilter$dataset3.value) != null ? _formFilter$dataset$v :\n  filterToEdit == null ? void 0 : (_filterToEdit$targets = filterToEdit.targets[0]) == null ? void 0 : _filterToEdit$targets.datasetId) != null ? _ref :\n  mostUsedDataset(loadedDatasets, charts);\n  const formChanged = useCallback(() => {\n    form.setFields([\n    {\n      name: 'changed',\n      value: true\n    }]\n    );\n    handleModifyFilter();\n  }, [form, handleModifyFilter]);\n  const debouncedFormChanged = useCallback(_debounce(formChanged, SLOW_DEBOUNCE), []);\n  const { controlItems = {}, mainControlItems = {} } = formFilter ?\n  getControlItemsMap({\n    expanded,\n    datasetId,\n    disabled: false,\n    forceUpdate,\n    formChanged,\n    form,\n    filterId,\n    filterType: formFilter == null ? void 0 : formFilter.filterType,\n    filterToEdit,\n    formFilter,\n    removed: isRemoved\n  }) :\n  {};\n  const hasColumn = !!mainControlItems.groupby;\n  const nativeFilterItem = (_nativeFilterItems$fo3 = nativeFilterItems[formFilter == null ? void 0 : formFilter.filterType]) != null ? _nativeFilterItems$fo3 : {};\n  // @ts-ignore\n  const enableNoResults = !!((_nativeFilterItem$val = nativeFilterItem.value) != null && _nativeFilterItem$val.enableNoResults);\n  const hasMetrics = hasColumn && !!metrics.length;\n  const hasFilledDataset = !hasDataset || datasetId && ((formFilter == null ? void 0 : formFilter.column) || !hasColumn);\n  const hasAdditionalFilters = FILTERS_WITH_ADHOC_FILTERS.includes(formFilter == null ? void 0 : formFilter.filterType);\n  const canDependOnOtherFilters = TYPES_SUPPORT_DEPENDENCIES.includes(formFilter == null ? void 0 : formFilter.filterType);\n  const isDataDirty = (_formFilter$isDataDir = formFilter == null ? void 0 : formFilter.isDataDirty) != null ? _formFilter$isDataDir : true;\n  const setNativeFilterFieldValuesWrapper = (values) => {\n    setNativeFilterFieldValues(form, filterId, values);\n    setError(undefined);\n    forceUpdate();\n  };\n  const setErrorWrapper = (error) => {\n    setNativeFilterFieldValues(form, filterId, {\n      defaultValueQueriesData: null\n    });\n    setError(error);\n    forceUpdate();\n  };\n  // Calculates the dependencies default values to be used\n  // to extract the available values to the filter\n  let dependenciesDefaultValues = {};\n  if (dependencies && dependencies.length > 0 && filters) {\n    dependencies.forEach((dependency) => {var _filters$dependency, _filters$dependency$d;\n      const extraFormData = (_filters$dependency = filters[dependency]) == null ? void 0 : (_filters$dependency$d = _filters$dependency.defaultDataMask) == null ? void 0 : _filters$dependency$d.extraFormData;\n      dependenciesDefaultValues = mergeExtraFormData(dependenciesDefaultValues, extraFormData);\n    });\n  }\n  const dependenciesText = JSON.stringify(dependenciesDefaultValues);\n  const refreshHandler = useCallback((force = false) => {var _formFilter$dataset4, _formFilter$dataset5;\n    if (!hasDataset || !(formFilter != null && (_formFilter$dataset4 = formFilter.dataset) != null && _formFilter$dataset4.value)) {\n      forceUpdate();\n      return;\n    }\n    const formData = getFormData({\n      datasetId: formFilter == null ? void 0 : (_formFilter$dataset5 = formFilter.dataset) == null ? void 0 : _formFilter$dataset5.value,\n      dashboardId,\n      groupby: formFilter == null ? void 0 : formFilter.column,\n      ...formFilter\n    });\n    formData.extra_form_data = dependenciesDefaultValues;\n    setNativeFilterFieldValuesWrapper({\n      defaultValueQueriesData: null,\n      isDataDirty: false\n    });\n    getChartDataRequest({\n      formData,\n      force\n    }).\n    then(({ response, json }) => {\n      if (isFeatureEnabled(FeatureFlag.GlobalAsyncQueries)) {\n        // deal with getChartDataRequest transforming the response data\n        const result = 'result' in json ? json.result[0] : json;\n        if (response.status === 200) {\n          setNativeFilterFieldValuesWrapper({\n            defaultValueQueriesData: [result]\n          });\n        } else\n        if (response.status === 202) {\n          waitForAsyncData(result).\n          then((asyncResult) => {\n            setNativeFilterFieldValuesWrapper({\n              defaultValueQueriesData: asyncResult\n            });\n          }).\n          catch((error) => {\n            getClientErrorObject(error).then((clientErrorObject) => {\n              setErrorWrapper(clientErrorObject);\n            });\n          });\n        } else\n        {\n          throw new Error(`Received unexpected response status (${response.status}) while fetching chart data`);\n        }\n      } else\n      {\n        setNativeFilterFieldValuesWrapper({\n          defaultValueQueriesData: json.result\n        });\n      }\n    }).\n    catch((error) => {\n      getClientErrorObject(error).then((clientErrorObject) => {\n        setError(clientErrorObject);\n      });\n    });\n  }, [filterId, forceUpdate, form, formFilter, hasDataset, dependenciesText]);\n  // TODO: refreshHandler changes itself because of the dependencies. Needs refactor.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(() => refreshHandler(), [dependenciesText]);\n  const newFormData = getFormData({\n    datasetId,\n    groupby: hasColumn ? formFilter == null ? void 0 : formFilter.column : undefined,\n    ...formFilter\n  });\n  newFormData.extra_form_data = dependenciesDefaultValues;\n  const [hasDefaultValue, isRequired, defaultValueTooltip, setHasDefaultValue] = useDefaultValue(formFilter, filterToEdit);\n  const showDataset = !datasetId || datasetDetails || (formFilter == null ? void 0 : (_formFilter$dataset6 = formFilter.dataset) == null ? void 0 : _formFilter$dataset6.label);\n  const updateFormValues = useCallback((values, triggerFormChange = true) => {\n    setNativeFilterFieldValues(form, filterId, values);\n    if (triggerFormChange)\n    formChanged();\n  }, [filterId, form, formChanged]);\n  const hasPreFilter = !!(formFilter != null && formFilter.adhoc_filters) ||\n  !!(formFilter != null && formFilter.time_range) ||\n  !!(filterToEdit != null && (_filterToEdit$adhoc_f = filterToEdit.adhoc_filters) != null && _filterToEdit$adhoc_f.length) ||\n  !!(filterToEdit != null && filterToEdit.time_range);\n  const hasEnableSingleValue = (formFilter == null ? void 0 : (_formFilter$controlVa = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa.enableSingleValue) !== undefined ||\n  (filterToEdit == null ? void 0 : (_filterToEdit$control = filterToEdit.controlValues) == null ? void 0 : _filterToEdit$control.enableSingleValue) !== undefined;\n  let enableSingleValue = filterToEdit == null ? void 0 : (_filterToEdit$control2 = filterToEdit.controlValues) == null ? void 0 : _filterToEdit$control2.enableSingleValue;\n  if ((formFilter == null ? void 0 : (_formFilter$controlVa2 = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa2.enableSingleMaxValue) !== undefined) {\n    ({ enableSingleValue } = formFilter.controlValues);\n  }\n  const hasSorting = typeof (formFilter == null ? void 0 : (_formFilter$controlVa3 = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa3.sortAscending) === 'boolean' ||\n  typeof (filterToEdit == null ? void 0 : (_filterToEdit$control3 = filterToEdit.controlValues) == null ? void 0 : _filterToEdit$control3.sortAscending) === 'boolean';\n  let sort = filterToEdit == null ? void 0 : (_filterToEdit$control4 = filterToEdit.controlValues) == null ? void 0 : _filterToEdit$control4.sortAscending;\n  if (typeof (formFilter == null ? void 0 : (_formFilter$controlVa4 = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa4.sortAscending) === 'boolean') {\n    sort = formFilter.controlValues.sortAscending;\n  }\n  const showDefaultValue = !hasDataset ||\n  !isDataDirty && hasFilledDataset ||\n  !mainControlItems.groupby;\n  const onSortChanged = (value) => {var _form$getFieldValue;\n    const previous = (_form$getFieldValue = form.getFieldValue('filters')) == null ? void 0 : _form$getFieldValue[filterId].controlValues;\n    setNativeFilterFieldValues(form, filterId, {\n      controlValues: {\n        ...previous,\n        sortAscending: value\n      }\n    });\n    forceUpdate();\n  };\n  const onEnableSingleValueChanged = (value) => {var _form$getFieldValue2;\n    const previous = (_form$getFieldValue2 = form.getFieldValue('filters')) == null ? void 0 : _form$getFieldValue2[filterId].controlValues;\n    setNativeFilterFieldValues(form, filterId, {\n      controlValues: {\n        ...previous,\n        enableSingleValue: value\n      }\n    });\n    forceUpdate();\n  };\n  const validatePreFilter = () => setTimeout(() => form.validateFields([\n  ['filters', filterId, 'adhoc_filters'],\n  ['filters', filterId, 'time_range']]\n  ), 0);\n  const hasTimeRange = (formFilter == null ? void 0 : formFilter.time_range) && formFilter.time_range !== 'No filter';\n  const hasAdhoc = (formFilter == null ? void 0 : (_formFilter$adhoc_fil = formFilter.adhoc_filters) == null ? void 0 : _formFilter$adhoc_fil.length) > 0;\n  const defaultToFirstItem = formFilter == null ? void 0 : (_formFilter$controlVa5 = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa5.defaultToFirstItem;\n  const initialDefaultValue = (formFilter == null ? void 0 : formFilter.filterType) === (filterToEdit == null ? void 0 : filterToEdit.filterType) ?\n  filterToEdit == null ? void 0 : filterToEdit.defaultDataMask :\n  null;\n  const preFilterValidator = () => {\n    if (hasTimeRange || hasAdhoc) {\n      return Promise.resolve();\n    }\n    return Promise.reject(new Error(t('Pre-filter is required')));\n  };\n  const availableFilters = getAvailableFilters(filterId);\n  const hasAvailableFilters = availableFilters.length > 0;\n  const hasTimeDependency = availableFilters.\n  filter((filter) => filter.type === 'filter_time').\n  some((filter) => dependencies == null ? void 0 : dependencies.includes(filter.value));\n  useEffect(() => {\n    if (datasetId) {\n      cachedSupersetGet({\n        endpoint: `/api/v1/dataset/${datasetId}?q=${rison.encode({\n          columns: [\n          'columns.column_name',\n          'columns.expression',\n          'columns.filterable',\n          'columns.is_dttm',\n          'columns.type',\n          'columns.verbose_name',\n          'database.id',\n          'database.database_name',\n          'datasource_type',\n          'filter_select_enabled',\n          'id',\n          'is_sqllab_view',\n          'main_dttm_col',\n          'metrics.metric_name',\n          'metrics.verbose_name',\n          'schema',\n          'sql',\n          'table_name']\n\n        })}`\n      }).\n      then((response) => {var _response$json, _response$json$result, _response$json2;\n        setMetrics((_response$json = response.json) == null ? void 0 : (_response$json$result = _response$json.result) == null ? void 0 : _response$json$result.metrics);\n        const dataset = (_response$json2 = response.json) == null ? void 0 : _response$json2.result;\n        // modify the response to fit structure expected by AdhocFilterControl\n        dataset.type = dataset.datasource_type;\n        dataset.filter_select = true;\n        setDatasetDetails(dataset);\n      }).\n      catch((response) => {\n        addDangerToast(response.message);\n      });\n    }\n  }, [datasetId]);\n  useImperativeHandle(ref, () => ({\n    changeTab(tab) {\n      setActiveTabKey(tab);\n    }\n  }));\n  useBackendFormUpdate(form, filterId);\n  useEffect(() => {\n    if (hasDataset && hasFilledDataset && hasDefaultValue && isDataDirty) {\n      refreshHandler();\n    }\n  }, [\n  hasDataset,\n  hasFilledDataset,\n  hasDefaultValue,\n  isDataDirty,\n  refreshHandler,\n  showDataset]\n  );\n  const initiallyExcludedCharts = useMemo(() => {var _formFilter$dataset7;\n    const excluded = [];\n    if ((formFilter == null ? void 0 : (_formFilter$dataset7 = formFilter.dataset) == null ? void 0 : _formFilter$dataset7.value) === undefined) {\n      return [];\n    }\n    Object.values(charts).forEach((chart) => {var _chart$form_data, _loadedDatasets$chart, _formFilter$dataset8;\n      const chartDatasetUid = (_chart$form_data = chart.form_data) == null ? void 0 : _chart$form_data.datasource;\n      if (chartDatasetUid === undefined) {\n        return;\n      }\n      if (((_loadedDatasets$chart = loadedDatasets[chartDatasetUid]) == null ? void 0 : _loadedDatasets$chart.id) !== (formFilter == null ? void 0 : (_formFilter$dataset8 = formFilter.dataset) == null ? void 0 : _formFilter$dataset8.value)) {\n        excluded.push(chart.id);\n      }\n    });\n    return excluded;\n  }, [\n  JSON.stringify(charts),\n  formFilter == null ? void 0 : (_formFilter$dataset9 = formFilter.dataset) == null ? void 0 : _formFilter$dataset9.value,\n  JSON.stringify(loadedDatasets)]\n  );\n  useEffect(() => {\n    // just removed, saving current form items for eventual undo\n    if (isRemoved) {\n      setUndoFormValues(formValues);\n    }\n  }, [isRemoved]);\n  useEffect(() => {\n    // the filter was just restored after undo\n    if (undoFormValues && !isRemoved) {\n      setNativeFilterFieldValues(form, filterId, undoFormValues);\n      setUndoFormValues(null);\n    }\n  }, [formValues, filterId, form, isRemoved, undoFormValues]);\n  if (isRemoved) {\n    return _jsx(RemovedFilter, { onClick: () => restoreFilter(filterId) });\n  }\n  const timeColumn = _jsx(StyledRowFormItem, { expanded: expanded, name: ['filters', filterId, 'granularity_sqla'], label: _jsxs(_Fragment, { children: [\n      _jsx(StyledLabel, { children: t('Time column') }), \"\\xA0\",\n      _jsx(InfoTooltipWithTrigger, { placement: \"top\", tooltip: hasTimeDependency ?\n        t('Time column to apply dependent temporal filter to') :\n        t('Time column to apply time range to') })] }\n    ), initialValue: filterToEdit == null ? void 0 : filterToEdit.granularity_sqla, children:\n    _jsx(ColumnSelect, { allowClear: true, form: form, formField: \"granularity_sqla\", filterId: filterId, filterValues: (column) => !!column.is_dttm, datasetId: datasetId, onChange: (column) => {\n        // We need reset default value when column changed\n        setNativeFilterFieldValues(form, filterId, {\n          granularity_sqla: column\n        });\n        forceUpdate();\n        formChanged();\n      } }) }\n  );\n  return _jsxs(StyledTabs, { activeKey: activeTabKey, onChange: (activeKey) => setActiveTabKey(activeKey), centered: true, children: [\n    _jsxs(TabPane, { tab: FilterTabs.configuration.name, forceRender: true, children: [\n      _jsxs(StyledContainer, { children: [\n        _jsx(StyledFormItem, { expanded: expanded, name: ['filters', filterId, 'type'], hidden: true, initialValue: NativeFilterType.NativeFilter, children:\n          _jsx(Input, { onChange: formChanged }) }\n        ),\n        _jsx(StyledFormItem, { expanded: expanded, name: ['filters', filterId, 'name'], label: _jsx(StyledLabel, { children: t('Filter name') }), initialValue: filterToEdit == null ? void 0 : filterToEdit.name, rules: [{ required: !isRemoved, message: t('Name is required') }], children:\n          _jsx(Input, { ...getFiltersConfigModalTestId('name-input'), onChange: debouncedFormChanged }) }\n        ),\n        _jsx(StyledFormItem, { expanded: expanded, name: ['filters', filterId, 'filterType'], rules: [{ required: !isRemoved, message: t('Name is required') }], initialValue: (filterToEdit == null ? void 0 : filterToEdit.filterType) || 'filter_select', label: _jsx(StyledLabel, { children: t('Filter Type') }), ...getFiltersConfigModalTestId('filter-type'), children:\n          _jsx(Select, { ariaLabel: t('Filter type'), options: nativeFilterVizTypes.map((filterType) => {var _nativeFilterItems$fi, _FILTER_SUPPORTED_TYP, _FILTER_SUPPORTED_TYP2;\n              // @ts-ignore\n              const name = (_nativeFilterItems$fi = nativeFilterItems[filterType]) == null ? void 0 : _nativeFilterItems$fi.value.name;\n              const mappedName = name ?\n              FILTER_TYPE_NAME_MAPPING[name] :\n              undefined;\n              const isDisabled = ((_FILTER_SUPPORTED_TYP = FILTER_SUPPORTED_TYPES[filterType]) == null ? void 0 : _FILTER_SUPPORTED_TYP.length) === 1 && ((_FILTER_SUPPORTED_TYP2 =\n              FILTER_SUPPORTED_TYPES[filterType]) == null ? void 0 : _FILTER_SUPPORTED_TYP2.includes(GenericDataType.Temporal)) &&\n              !doLoadedDatasetsHaveTemporalColumns;\n              return {\n                value: filterType,\n                label: mappedName || name,\n                customLabel: isDisabled ? _jsx(Tooltip, { title: t('Datasets do not contain a temporal column'), children:\n                  mappedName || name }\n                ) : undefined,\n                disabled: isDisabled\n              };\n            }), onChange: (value) => {\n              setNativeFilterFieldValues(form, filterId, {\n                filterType: value,\n                defaultDataMask: null,\n                column: null\n              });\n              forceUpdate();\n              formChanged();\n            } }) }\n        )] }\n      ),\n      (formFilter == null ? void 0 : formFilter.filterType) === 'filter_time' && _jsx(FilterTypeInfo, { expanded: expanded, children:\n        t(`Dashboard time range filters apply to temporal columns defined in\n          the filter section of each chart. Add temporal columns to the chart\n          filters to have this dashboard filter impact those charts.`) }\n      ),\n      hasDataset && _jsxs(StyledRowContainer, { children: [\n        showDataset ? _jsx(StyledFormItem, { expanded: expanded, name: ['filters', filterId, 'dataset'], label: _jsx(StyledLabel, { children: t('Dataset') }), initialValue: datasetDetails ?\n          {\n            label: DatasetSelectLabel({\n              id: datasetDetails.id,\n              table_name: datasetDetails.table_name,\n              schema: datasetDetails.schema,\n              database: {\n                database_name: datasetDetails.database.database_name\n              }\n            }),\n            value: datasetDetails.id\n          } :\n          undefined, rules: [\n          { required: !isRemoved, message: t('Dataset is required') }], ...\n          getFiltersConfigModalTestId('datasource-input'), children:\n          _jsx(DatasetSelect, { onChange: (value) => {\n              // We need to reset the column when the dataset has changed\n              if (value.value !== datasetId) {\n                setNativeFilterFieldValues(form, filterId, {\n                  dataset: value,\n                  defaultDataMask: null,\n                  column: null\n                });\n              }\n              forceUpdate();\n              formChanged();\n            } }) }\n        ) : _jsx(StyledFormItem, { expanded: expanded, label: _jsx(StyledLabel, { children: t('Dataset') }), children:\n          _jsx(Loading, { position: \"inline-centered\" }) }\n        ),\n        hasDataset &&\n        Object.keys(mainControlItems).map((key) => mainControlItems[key].element)] }\n      ),\n      _jsxs(StyledCollapse, { defaultActiveKey: activeFilterPanelKeys, onChange: (key) => {\n          handleActiveFilterPanelChange(key);\n        }, expandIconPosition: \"right\", children: [\n        (formFilter == null ? void 0 : formFilter.filterType) !== 'filter_time' && _jsxs(Collapse.Panel, { forceRender: true, header: FilterPanels.configuration.name, children: [\n          canDependOnOtherFilters && hasAvailableFilters && _jsx(StyledRowFormItem, { expanded: expanded, name: ['filters', filterId, 'dependencies'], initialValue: dependencies, children:\n            _jsx(DependencyList, { availableFilters: availableFilters, dependencies: dependencies, onDependenciesChange: (dependencies) => {\n                setNativeFilterFieldValues(form, filterId, {\n                  dependencies\n                });\n                forceUpdate();\n                validateDependencies();\n                formChanged();\n              }, getDependencySuggestion: () => getDependencySuggestion(filterId), children:\n              hasTimeDependency ? timeColumn : undefined }\n            ) }\n          ),\n          hasDataset && hasAdditionalFilters && _jsx(CleanFormItem, { name: ['filters', filterId, 'preFilter'], children:\n            _jsxs(CollapsibleControl, { initialValue: hasPreFilter, title: t('Pre-filter available values'), tooltip: t(`Add filter clauses to control the filter's source query,\n                    though only in the context of the autocomplete i.e., these conditions\n                    do not impact how the filter is applied to the dashboard. This is useful\n                    when you want to improve the query's performance by only scanning a subset\n                    of the underlying data or limit the available values displayed in the filter.`), onChange: (checked) => {\n                formChanged();\n                if (checked) {\n                  validatePreFilter();\n                }\n              }, children: [\n              _jsx(StyledRowSubFormItem, { expanded: expanded, name: ['filters', filterId, 'adhoc_filters'], css: /*#__PURE__*/_css({ width: INPUT_WIDTH }, process.env.NODE_ENV === \"production\" ? \"\" : \";label:FiltersConfigForm;\", process.env.NODE_ENV === \"production\" ? \"\" : \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL2Rhc2hib2FyZC9jb21wb25lbnRzL25hdGl2ZUZpbHRlcnMvRmlsdGVyc0NvbmZpZ01vZGFsL0ZpbHRlcnNDb25maWdGb3JtL0ZpbHRlcnNDb25maWdGb3JtLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEwcUI0RyIsImZpbGUiOiIvaG9tZS9hZGVsL3N1cGVyc2V0L3N1cGVyc2V0LWZyb250ZW5kL3NyYy9kYXNoYm9hcmQvY29tcG9uZW50cy9uYXRpdmVGaWx0ZXJzL0ZpbHRlcnNDb25maWdNb2RhbC9GaWx0ZXJzQ29uZmlnRm9ybS9GaWx0ZXJzQ29uZmlnRm9ybS50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcyAqL1xuaW1wb3J0IHsgSW5mb1Rvb2x0aXBXaXRoVHJpZ2dlciwgfSBmcm9tICdAc3VwZXJzZXQtdWkvY2hhcnQtY29udHJvbHMnO1xuaW1wb3J0IHsgQmVoYXZpb3IsIGlzRmVhdHVyZUVuYWJsZWQsIEZlYXR1cmVGbGFnLCBHZW5lcmljRGF0YVR5cGUsIGdldENoYXJ0TWV0YWRhdGFSZWdpc3RyeSwgTmF0aXZlRmlsdGVyVHlwZSwgc3R5bGVkLCB0LCBnZXRDbGllbnRFcnJvck9iamVjdCwgU0xPV19ERUJPVU5DRSwgdXNlVGhlbWUsIGNzcywgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBkZWJvdW5jZSwgaXNFcXVhbCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vLCB1c2VTdGF0ZSwgbWVtbywgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgcmlzb24gZnJvbSAncmlzb24nO1xuaW1wb3J0IHsgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBnZXRDaGFydERhdGFSZXF1ZXN0IH0gZnJvbSAnc3JjL2NvbXBvbmVudHMvQ2hhcnQvY2hhcnRBY3Rpb24nO1xuaW1wb3J0IHsgSW5wdXQsIFRleHRBcmVhIH0gZnJvbSAnc3JjL2NvbXBvbmVudHMvSW5wdXQnO1xuaW1wb3J0IHsgU2VsZWN0IH0gZnJvbSAnc3JjL2NvbXBvbmVudHMnO1xuaW1wb3J0IENvbGxhcHNlIGZyb20gJ3NyYy9jb21wb25lbnRzL0NvbGxhcHNlJztcbmltcG9ydCBCYXNpY0Vycm9yQWxlcnQgZnJvbSAnc3JjL2NvbXBvbmVudHMvRXJyb3JNZXNzYWdlL0Jhc2ljRXJyb3JBbGVydCc7XG5pbXBvcnQgRXJyb3JNZXNzYWdlV2l0aFN0YWNrVHJhY2UgZnJvbSAnc3JjL2NvbXBvbmVudHMvRXJyb3JNZXNzYWdlL0Vycm9yTWVzc2FnZVdpdGhTdGFja1RyYWNlJztcbmltcG9ydCB7IEZvcm1JdGVtIH0gZnJvbSAnc3JjL2NvbXBvbmVudHMvRm9ybSc7XG5pbXBvcnQgSWNvbnMgZnJvbSAnc3JjL2NvbXBvbmVudHMvSWNvbnMnO1xuaW1wb3J0IExvYWRpbmcgZnJvbSAnc3JjL2NvbXBvbmVudHMvTG9hZGluZyc7XG5pbXBvcnQgeyBhZGREYW5nZXJUb2FzdCB9IGZyb20gJ3NyYy9jb21wb25lbnRzL01lc3NhZ2VUb2FzdHMvYWN0aW9ucyc7XG5pbXBvcnQgeyBSYWRpbyB9IGZyb20gJ3NyYy9jb21wb25lbnRzL1JhZGlvJztcbmltcG9ydCBUYWJzIGZyb20gJ3NyYy9jb21wb25lbnRzL1RhYnMnO1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJ3NyYy9jb21wb25lbnRzL1Rvb2x0aXAnO1xuaW1wb3J0IHsgY2FjaGVkU3VwZXJzZXRHZXQgfSBmcm9tICdzcmMvdXRpbHMvY2FjaGVkU3VwZXJzZXRHZXQnO1xuaW1wb3J0IERhdGVGaWx0ZXJDb250cm9sIGZyb20gJ3NyYy9leHBsb3JlL2NvbXBvbmVudHMvY29udHJvbHMvRGF0ZUZpbHRlckNvbnRyb2wnO1xuaW1wb3J0IEFkaG9jRmlsdGVyQ29udHJvbCBmcm9tICdzcmMvZXhwbG9yZS9jb21wb25lbnRzL2NvbnRyb2xzL0ZpbHRlckNvbnRyb2wvQWRob2NGaWx0ZXJDb250cm9sJztcbmltcG9ydCB7IHdhaXRGb3JBc3luY0RhdGEgfSBmcm9tICdzcmMvbWlkZGxld2FyZS9hc3luY0V2ZW50JztcbmltcG9ydCB7IFNpbmdsZVZhbHVlVHlwZSB9IGZyb20gJ3NyYy9maWx0ZXJzL2NvbXBvbmVudHMvUmFuZ2UvU2luZ2xlVmFsdWVUeXBlJztcbmltcG9ydCB7IGdldEZvcm1EYXRhLCBtZXJnZUV4dHJhRm9ybURhdGEsIH0gZnJvbSAnc3JjL2Rhc2hib2FyZC9jb21wb25lbnRzL25hdGl2ZUZpbHRlcnMvdXRpbHMnO1xuaW1wb3J0IHsgRGF0YXNldFNlbGVjdExhYmVsIH0gZnJvbSAnc3JjL2ZlYXR1cmVzL2RhdGFzZXRzL0RhdGFzZXRTZWxlY3RMYWJlbCc7XG5pbXBvcnQgeyBBTExPV19ERVBFTkRFTkNJRVMgYXMgVFlQRVNfU1VQUE9SVF9ERVBFTkRFTkNJRVMsIGdldEZpbHRlcnNDb25maWdNb2RhbFRlc3RJZCwgfSBmcm9tICcuLi9GaWx0ZXJzQ29uZmlnTW9kYWwnO1xuaW1wb3J0IHsgQ29sbGFwc2libGVDb250cm9sIH0gZnJvbSAnLi9Db2xsYXBzaWJsZUNvbnRyb2wnO1xuaW1wb3J0IHsgQ29sdW1uU2VsZWN0IH0gZnJvbSAnLi9Db2x1bW5TZWxlY3QnO1xuaW1wb3J0IERhdGFzZXRTZWxlY3QgZnJvbSAnLi9EYXRhc2V0U2VsZWN0JztcbmltcG9ydCBEZWZhdWx0VmFsdWUgZnJvbSAnLi9EZWZhdWx0VmFsdWUnO1xuaW1wb3J0IEZpbHRlclNjb3BlIGZyb20gJy4vRmlsdGVyU2NvcGUvRmlsdGVyU2NvcGUnO1xuaW1wb3J0IGdldENvbnRyb2xJdGVtc01hcCBmcm9tICcuL2dldENvbnRyb2xJdGVtc01hcCc7XG5pbXBvcnQgUmVtb3ZlZEZpbHRlciBmcm9tICcuL1JlbW92ZWRGaWx0ZXInO1xuaW1wb3J0IHsgdXNlQmFja2VuZEZvcm1VcGRhdGUsIHVzZURlZmF1bHRWYWx1ZSB9IGZyb20gJy4vc3RhdGUnO1xuaW1wb3J0IHsgaGFzVGVtcG9yYWxDb2x1bW5zLCBtb3N0VXNlZERhdGFzZXQsIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzLCB1c2VGb3JjZVVwZGF0ZSwgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IEZJTFRFUl9TVVBQT1JURURfVFlQRVMsIElOUFVUX1dJRFRIIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IERlcGVuZGVuY3lMaXN0IGZyb20gJy4vRGVwZW5kZW5jeUxpc3QnO1xuY29uc3QgRk9STV9JVEVNX1dJRFRIID0gMjYwO1xuY29uc3QgVGFiUGFuZSA9IHN0eWxlZChUYWJzLlRhYlBhbmUpIGBcbiAgcGFkZGluZzogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdCAqIDR9cHggMHB4O1xuYDtcbmNvbnN0IFN0eWxlZENvbnRhaW5lciA9IHN0eWxlZC5kaXYgYFxuICAkeyh7IHRoZW1lIH0pID0+IGBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcGFkZGluZzogMHB4ICR7dGhlbWUuZ3JpZFVuaXQgKiA0fXB4O1xuICBgfVxuYDtcbmNvbnN0IFN0eWxlZFJvd0NvbnRhaW5lciA9IHN0eWxlZC5kaXYgYFxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIHdpZHRoOiAxMDAlO1xuICBwYWRkaW5nOiAwcHggJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdCAqIDR9cHg7XG5gO1xuY29uc3QgY29udHJvbHNPcmRlciA9IFtcbiAgICAnZW5hYmxlRW1wdHlGaWx0ZXInLFxuICAgICdkZWZhdWx0VG9GaXJzdEl0ZW0nLFxuICAgICdtdWx0aVNlbGVjdCcsXG4gICAgJ3NlYXJjaEFsbE9wdGlvbnMnLFxuICAgICdpbnZlcnNlU2VsZWN0aW9uJyxcbl07XG5leHBvcnQgY29uc3QgU3R5bGVkRm9ybUl0ZW0gPSBzdHlsZWQoRm9ybUl0ZW0pIGBcbiAgd2lkdGg6ICR7KHsgZXhwYW5kZWQgfSkgPT4gKGV4cGFuZGVkID8gJzQ5JScgOiBgJHtGT1JNX0lURU1fV0lEVEh9cHhgKX07XG4gIG1hcmdpbi1ib3R0b206ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiA0fXB4O1xuXG4gICYgLmFudC1mb3JtLWl0ZW0tbGFiZWwge1xuICAgIHBhZGRpbmctYm90dG9tOiAwO1xuICB9XG5cbiAgJiAuYW50LWZvcm0taXRlbS1jb250cm9sLWlucHV0IHtcbiAgICBtaW4taGVpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMTB9cHg7XG4gIH1cbmA7XG5leHBvcnQgY29uc3QgU3R5bGVkUm93Rm9ybUl0ZW0gPSBzdHlsZWQoRm9ybUl0ZW0pIGBcbiAgbWFyZ2luLWJvdHRvbTogMDtcbiAgcGFkZGluZy1ib3R0b206IDA7XG4gIG1pbi13aWR0aDogJHsoeyBleHBhbmRlZCB9KSA9PiAoZXhwYW5kZWQgPyAnNTAlJyA6IGAke0ZPUk1fSVRFTV9XSURUSH1weGApfTtcblxuICAmIC5hbnQtZm9ybS1pdGVtLWxhYmVsIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcbiAgfVxuXG4gIC5hbnQtZm9ybS1pdGVtLWNvbnRyb2wtaW5wdXQtY29udGVudCA+IGRpdiA+IGRpdiB7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICB9XG5cbiAgJiAuYW50LWZvcm0taXRlbS1jb250cm9sLWlucHV0IHtcbiAgICBtaW4taGVpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMTB9cHg7XG4gIH1cbmA7XG5leHBvcnQgY29uc3QgU3R5bGVkUm93U3ViRm9ybUl0ZW0gPSBzdHlsZWQoRm9ybUl0ZW0pIGBcbiAgbWluLXdpZHRoOiAkeyh7IGV4cGFuZGVkIH0pID0+IChleHBhbmRlZCA/ICc1MCUnIDogYCR7Rk9STV9JVEVNX1dJRFRIfXB4YCl9O1xuXG4gICYgLmFudC1mb3JtLWl0ZW0tbGFiZWwge1xuICAgIHBhZGRpbmctYm90dG9tOiAwO1xuICB9XG5cbiAgLmFudC1mb3JtLWl0ZW0ge1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cblxuICAuYW50LWZvcm0taXRlbS1jb250cm9sLWlucHV0LWNvbnRlbnQgPiBkaXYgPiBkaXYge1xuICAgIGhlaWdodDogYXV0bztcbiAgfVxuXG4gIC5hbnQtZm9ybS1pdGVtLWV4dHJhIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgJiAuYW50LWZvcm0taXRlbS1jb250cm9sLWlucHV0IHtcbiAgICBoZWlnaHQ6IGF1dG87XG4gIH1cbmA7XG5leHBvcnQgY29uc3QgU3R5bGVkTGFiZWwgPSBzdHlsZWQuc3BhbiBgXG4gIGNvbG9yOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUuYmFzZX07XG4gIGZvbnQtc2l6ZTogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XG5gO1xuY29uc3QgQ2xlYW5Gb3JtSXRlbSA9IHN0eWxlZChGb3JtSXRlbSkgYFxuICBtYXJnaW4tYm90dG9tOiAwO1xuYDtcbmNvbnN0IERlZmF1bHRWYWx1ZUNvbnRhaW5lciA9IHN0eWxlZC5kaXYgYFxuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcbmNvbnN0IFN0eWxlZENvbGxhcHNlID0gc3R5bGVkKENvbGxhcHNlKSBgXG4gIGJvcmRlci1sZWZ0OiAwO1xuICBib3JkZXItdG9wOiAxcHggc29saWQgJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XG4gIGJvcmRlci1yYWRpdXM6IDA7XG5cbiAgLmFudC1jb2xsYXBzZS1oZWFkZXIge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQyfTtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XG4gICAgbWFyZ2luLXRvcDogLTFweDtcbiAgICBib3JkZXItcmFkaXVzOiAwO1xuICB9XG5cbiAgLmFudC1jb2xsYXBzZS1jb250ZW50IHtcbiAgICBib3JkZXI6IDA7XG4gIH1cblxuICAuYW50LWNvbGxhcHNlLWNvbnRlbnQtYm94IHtcbiAgICBwYWRkaW5nLXRvcDogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdCAqIDJ9cHg7XG4gIH1cblxuICAmLmFudC1jb2xsYXBzZSA+IC5hbnQtY29sbGFwc2UtaXRlbSB7XG4gICAgYm9yZGVyOiAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gIH1cbmA7XG5jb25zdCBTdHlsZWRUYWJzID0gc3R5bGVkKFRhYnMpIGBcbiAgLmFudC10YWJzLW5hdiB7XG4gICAgcG9zaXRpb246IHN0aWNreTtcbiAgICB0b3A6IDA7XG4gICAgYmFja2dyb3VuZDogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NX07XG4gICAgei1pbmRleDogMTtcbiAgfVxuXG4gIC5hbnQtdGFicy1uYXYtbGlzdCB7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuXG4gIC5hbnQtZm9ybS1pdGVtLWxhYmVsIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcbiAgfVxuYDtcbmNvbnN0IFN0eWxlZEFzdGVyaXNrID0gc3R5bGVkLnNwYW4gYFxuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZXJyb3IuYmFzZX07XG4gIGZvbnQtc2l6ZTogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XG4gIG1hcmdpbi1sZWZ0OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0IC0gMX1weDtcbiAgJjpiZWZvcmUge1xuICAgIGNvbnRlbnQ6ICcqJztcbiAgfVxuYDtcbmNvbnN0IEZpbHRlclR5cGVJbmZvID0gc3R5bGVkLmRpdiBgXG4gICR7KHsgdGhlbWUsIGV4cGFuZGVkIH0pID0+IGBcbiAgICB3aWR0aDogJHtleHBhbmRlZCA/ICc0OSUnIDogYCR7Rk9STV9JVEVNX1dJRFRIfXB4YH07XG4gICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0MX07XG4gICAgbWFyZ2luOlxuICAgICAgJHstdGhlbWUuZ3JpZFVuaXQgKiAyfXB4XG4gICAgICAwcHhcbiAgICAgICR7dGhlbWUuZ3JpZFVuaXQgKiA0fXB4XG4gICAgICAke3RoZW1lLmdyaWRVbml0ICogNH1weDtcbiAgYH1cbmA7XG5jb25zdCBGaWx0ZXJUYWJzID0ge1xuICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAga2V5OiAnY29uZmlndXJhdGlvbicsXG4gICAgICAgIG5hbWU6IHQoJ1NldHRpbmdzJyksXG4gICAgfSxcbiAgICBzY29waW5nOiB7XG4gICAgICAgIGtleTogJ3Njb3BpbmcnLFxuICAgICAgICBuYW1lOiB0KCdTY29waW5nJyksXG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgRmlsdGVyUGFuZWxzID0ge1xuICAgIGNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAga2V5OiAnY29uZmlndXJhdGlvbicsXG4gICAgICAgIG5hbWU6IHQoJ0ZpbHRlciBDb25maWd1cmF0aW9uJyksXG4gICAgfSxcbiAgICBzZXR0aW5nczoge1xuICAgICAgICBrZXk6ICdzZXR0aW5ncycsXG4gICAgICAgIG5hbWU6IHQoJ0ZpbHRlciBTZXR0aW5ncycpLFxuICAgIH0sXG59O1xuY29uc3QgRklMVEVSU19XSVRIX0FESE9DX0ZJTFRFUlMgPSBbJ2ZpbHRlcl9zZWxlY3QnLCAnZmlsdGVyX3JhbmdlJ107XG4vLyBUT0RPOiBSZW5hbWUgdGhlIGZpbHRlciBwbHVnaW5zIGFuZCByZW1vdmUgdGhpcyBtYXBwaW5nXG5jb25zdCBGSUxURVJfVFlQRV9OQU1FX01BUFBJTkcgPSB7XG4gICAgW3QoJ1NlbGVjdCBmaWx0ZXInKV06IHQoJ1ZhbHVlJyksXG4gICAgW3QoJ1JhbmdlIGZpbHRlcicpXTogdCgnTnVtZXJpY2FsIHJhbmdlJyksXG4gICAgW3QoJ1RpbWUgZmlsdGVyJyldOiB0KCdUaW1lIHJhbmdlJyksXG4gICAgW3QoJ1RpbWUgY29sdW1uJyldOiB0KCdUaW1lIGNvbHVtbicpLFxuICAgIFt0KCdUaW1lIGdyYWluJyldOiB0KCdUaW1lIGdyYWluJyksXG4gICAgW3QoJ0dyb3VwIEJ5JyldOiB0KCdHcm91cCBieScpLFxufTtcbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gZm9ybSBmb3IgYSBzcGVjaWZpYyBmaWx0ZXIuXG4gKiBBc3NpZ25zIGZpZWxkIHZhbHVlcyB0byBgZmlsdGVyc1tmaWx0ZXJJZF1gIGluIHRoZSBmb3JtLlxuICovXG5jb25zdCBGaWx0ZXJzQ29uZmlnRm9ybSA9ICh7IGV4cGFuZGVkLCBmaWx0ZXJJZCwgZmlsdGVyVG9FZGl0LCByZW1vdmVkRmlsdGVycywgZm9ybSwgZ2V0QXZhaWxhYmxlRmlsdGVycywgYWN0aXZlRmlsdGVyUGFuZWxLZXlzLCByZXN0b3JlRmlsdGVyLCBoYW5kbGVBY3RpdmVGaWx0ZXJQYW5lbENoYW5nZSwgc2V0RXJyb3JlZEZpbHRlcnMsIG9uTW9kaWZ5RmlsdGVyLCB2YWxpZGF0ZURlcGVuZGVuY2llcywgZ2V0RGVwZW5kZW5jeVN1Z2dlc3Rpb24sIGlzQWN0aXZlLCB9LCByZWYpID0+IHtcbiAgICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gICAgY29uc3QgaXNSZW1vdmVkID0gISFyZW1vdmVkRmlsdGVyc1tmaWx0ZXJJZF07XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFttZXRyaWNzLCBzZXRNZXRyaWNzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBbYWN0aXZlVGFiS2V5LCBzZXRBY3RpdmVUYWJLZXldID0gdXNlU3RhdGUoRmlsdGVyVGFicy5jb25maWd1cmF0aW9uLmtleSk7XG4gICAgY29uc3QgZGFzaGJvYXJkSWQgPSB1c2VTZWxlY3RvcihzdGF0ZSA9PiBzdGF0ZS5kYXNoYm9hcmRJbmZvLmlkKTtcbiAgICBjb25zdCBbdW5kb0Zvcm1WYWx1ZXMsIHNldFVuZG9Gb3JtVmFsdWVzXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoaXNBY3RpdmUpO1xuICAgIGNvbnN0IFtkYXRhc2V0RGV0YWlscywgc2V0RGF0YXNldERldGFpbHNdID0gdXNlU3RhdGUoKTtcbiAgICBjb25zdCBkZWZhdWx0Rm9ybUZpbHRlciA9IHVzZU1lbW8oKCkgPT4gKHt9KSwgW10pO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBmb3JtLmdldEZpZWxkVmFsdWUoJ2ZpbHRlcnMnKTtcbiAgICBjb25zdCBmb3JtVmFsdWVzID0gZmlsdGVycz8uW2ZpbHRlcklkXTtcbiAgICBjb25zdCBmb3JtRmlsdGVyID0gZm9ybVZhbHVlcyB8fCB1bmRvRm9ybVZhbHVlcyB8fCBkZWZhdWx0Rm9ybUZpbHRlcjtcbiAgICBjb25zdCBoYW5kbGVNb2RpZnlGaWx0ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChvbk1vZGlmeUZpbHRlcikge1xuICAgICAgICAgICAgb25Nb2RpZnlGaWx0ZXIoZmlsdGVySWQpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW9kaWZ5RmlsdGVyLCBmaWx0ZXJJZF0pO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGZvcm1GaWx0ZXI/LmRlcGVuZGVuY2llcyB8fCBmaWx0ZXJUb0VkaXQ/LmNhc2NhZGVQYXJlbnRJZHMgfHwgW107XG4gICAgY29uc3QgbmF0aXZlRmlsdGVySXRlbXMgPSBnZXRDaGFydE1ldGFkYXRhUmVnaXN0cnkoKS5pdGVtcztcbiAgICBjb25zdCBuYXRpdmVGaWx0ZXJWaXpUeXBlcyA9IE9iamVjdC5lbnRyaWVzKG5hdGl2ZUZpbHRlckl0ZW1zKVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC5maWx0ZXIoKFssIHsgdmFsdWUgfV0pID0+IHZhbHVlLmJlaGF2aW9ycz8uaW5jbHVkZXMoQmVoYXZpb3IuTmF0aXZlRmlsdGVyKSlcbiAgICAgICAgLm1hcCgoW2tleV0pID0+IGtleSk7XG4gICAgY29uc3QgbG9hZGVkRGF0YXNldHMgPSB1c2VTZWxlY3RvcigoeyBkYXRhc291cmNlcyB9KSA9PiBkYXRhc291cmNlcyk7XG4gICAgY29uc3QgY2hhcnRzID0gdXNlU2VsZWN0b3IoKHsgY2hhcnRzIH0pID0+IGNoYXJ0cyk7XG4gICAgY29uc3QgZG9Mb2FkZWREYXRhc2V0c0hhdmVUZW1wb3JhbENvbHVtbnMgPSB1c2VNZW1vKCgpID0+IE9iamVjdC52YWx1ZXMobG9hZGVkRGF0YXNldHMpLnNvbWUoZGF0YXNldCA9PiBoYXNUZW1wb3JhbENvbHVtbnMoZGF0YXNldCkpLCBbbG9hZGVkRGF0YXNldHNdKTtcbiAgICBjb25zdCBzaG93VGltZVJhbmdlUGlja2VyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRhc2V0ID0gT2JqZWN0LnZhbHVlcyhsb2FkZWREYXRhc2V0cykuZmluZChkYXRhc2V0ID0+IGRhdGFzZXQuaWQgPT09IGZvcm1GaWx0ZXI/LmRhdGFzZXQ/LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRhc2V0ID8gaGFzVGVtcG9yYWxDb2x1bW5zKGN1cnJlbnREYXRhc2V0KSA6IHRydWU7XG4gICAgfSwgW2Zvcm1GaWx0ZXI/LmRhdGFzZXQ/LnZhbHVlLCBsb2FkZWREYXRhc2V0c10pO1xuICAgIGNvbnN0IGhhc0RhdGFzZXQgPSBcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgISFuYXRpdmVGaWx0ZXJJdGVtc1tmb3JtRmlsdGVyPy5maWx0ZXJUeXBlXT8udmFsdWU/LmRhdGFzb3VyY2VDb3VudDtcbiAgICBjb25zdCBkYXRhc2V0SWQgPSBmb3JtRmlsdGVyPy5kYXRhc2V0Py52YWx1ZSA/P1xuICAgICAgICBmaWx0ZXJUb0VkaXQ/LnRhcmdldHNbMF0/LmRhdGFzZXRJZCA/P1xuICAgICAgICBtb3N0VXNlZERhdGFzZXQobG9hZGVkRGF0YXNldHMsIGNoYXJ0cyk7XG4gICAgY29uc3QgZm9ybUNoYW5nZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGZvcm0uc2V0RmllbGRzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICAgICAgaGFuZGxlTW9kaWZ5RmlsdGVyKCk7XG4gICAgfSwgW2Zvcm0sIGhhbmRsZU1vZGlmeUZpbHRlcl0pO1xuICAgIGNvbnN0IGRlYm91bmNlZEZvcm1DaGFuZ2VkID0gdXNlQ2FsbGJhY2soZGVib3VuY2UoZm9ybUNoYW5nZWQsIFNMT1dfREVCT1VOQ0UpLCBbXSk7XG4gICAgY29uc3QgeyBjb250cm9sSXRlbXMgPSB7fSwgbWFpbkNvbnRyb2xJdGVtcyA9IHt9IH0gPSBmb3JtRmlsdGVyXG4gICAgICAgID8gZ2V0Q29udHJvbEl0ZW1zTWFwKHtcbiAgICAgICAgICAgIGV4cGFuZGVkLFxuICAgICAgICAgICAgZGF0YXNldElkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VVcGRhdGUsXG4gICAgICAgICAgICBmb3JtQ2hhbmdlZCxcbiAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICBmaWx0ZXJJZCxcbiAgICAgICAgICAgIGZpbHRlclR5cGU6IGZvcm1GaWx0ZXI/LmZpbHRlclR5cGUsXG4gICAgICAgICAgICBmaWx0ZXJUb0VkaXQsXG4gICAgICAgICAgICBmb3JtRmlsdGVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogaXNSZW1vdmVkLFxuICAgICAgICB9KVxuICAgICAgICA6IHt9O1xuICAgIGNvbnN0IGhhc0NvbHVtbiA9ICEhbWFpbkNvbnRyb2xJdGVtcy5ncm91cGJ5O1xuICAgIGNvbnN0IG5hdGl2ZUZpbHRlckl0ZW0gPSBuYXRpdmVGaWx0ZXJJdGVtc1tmb3JtRmlsdGVyPy5maWx0ZXJUeXBlXSA/PyB7fTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZW5hYmxlTm9SZXN1bHRzID0gISFuYXRpdmVGaWx0ZXJJdGVtLnZhbHVlPy5lbmFibGVOb1Jlc3VsdHM7XG4gICAgY29uc3QgaGFzTWV0cmljcyA9IGhhc0NvbHVtbiAmJiAhIW1ldHJpY3MubGVuZ3RoO1xuICAgIGNvbnN0IGhhc0ZpbGxlZERhdGFzZXQgPSAhaGFzRGF0YXNldCB8fCAoZGF0YXNldElkICYmIChmb3JtRmlsdGVyPy5jb2x1bW4gfHwgIWhhc0NvbHVtbikpO1xuICAgIGNvbnN0IGhhc0FkZGl0aW9uYWxGaWx0ZXJzID0gRklMVEVSU19XSVRIX0FESE9DX0ZJTFRFUlMuaW5jbHVkZXMoZm9ybUZpbHRlcj8uZmlsdGVyVHlwZSk7XG4gICAgY29uc3QgY2FuRGVwZW5kT25PdGhlckZpbHRlcnMgPSBUWVBFU19TVVBQT1JUX0RFUEVOREVOQ0lFUy5pbmNsdWRlcyhmb3JtRmlsdGVyPy5maWx0ZXJUeXBlKTtcbiAgICBjb25zdCBpc0RhdGFEaXJ0eSA9IGZvcm1GaWx0ZXI/LmlzRGF0YURpcnR5ID8/IHRydWU7XG4gICAgY29uc3Qgc2V0TmF0aXZlRmlsdGVyRmllbGRWYWx1ZXNXcmFwcGVyID0gKHZhbHVlcykgPT4ge1xuICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwgdmFsdWVzKTtcbiAgICAgICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcbiAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEVycm9yV3JhcHBlciA9IChlcnJvcikgPT4ge1xuICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlUXVlcmllc0RhdGE6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRFcnJvcihlcnJvcik7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgfTtcbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBkZXBlbmRlbmNpZXMgZGVmYXVsdCB2YWx1ZXMgdG8gYmUgdXNlZFxuICAgIC8vIHRvIGV4dHJhY3QgdGhlIGF2YWlsYWJsZSB2YWx1ZXMgdG8gdGhlIGZpbHRlclxuICAgIGxldCBkZXBlbmRlbmNpZXNEZWZhdWx0VmFsdWVzID0ge307XG4gICAgaWYgKGRlcGVuZGVuY2llcyAmJiBkZXBlbmRlbmNpZXMubGVuZ3RoID4gMCAmJiBmaWx0ZXJzKSB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcGVuZGVuY3kgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0cmFGb3JtRGF0YSA9IGZpbHRlcnNbZGVwZW5kZW5jeV0/LmRlZmF1bHREYXRhTWFzaz8uZXh0cmFGb3JtRGF0YTtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llc0RlZmF1bHRWYWx1ZXMgPSBtZXJnZUV4dHJhRm9ybURhdGEoZGVwZW5kZW5jaWVzRGVmYXVsdFZhbHVlcywgZXh0cmFGb3JtRGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkZXBlbmRlbmNpZXNUZXh0ID0gSlNPTi5zdHJpbmdpZnkoZGVwZW5kZW5jaWVzRGVmYXVsdFZhbHVlcyk7XG4gICAgY29uc3QgcmVmcmVzaEhhbmRsZXIgPSB1c2VDYWxsYmFjaygoZm9yY2UgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoIWhhc0RhdGFzZXQgfHwgIWZvcm1GaWx0ZXI/LmRhdGFzZXQ/LnZhbHVlKSB7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gZ2V0Rm9ybURhdGEoe1xuICAgICAgICAgICAgZGF0YXNldElkOiBmb3JtRmlsdGVyPy5kYXRhc2V0Py52YWx1ZSxcbiAgICAgICAgICAgIGRhc2hib2FyZElkLFxuICAgICAgICAgICAgZ3JvdXBieTogZm9ybUZpbHRlcj8uY29sdW1uLFxuICAgICAgICAgICAgLi4uZm9ybUZpbHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1EYXRhLmV4dHJhX2Zvcm1fZGF0YSA9IGRlcGVuZGVuY2llc0RlZmF1bHRWYWx1ZXM7XG4gICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzV3JhcHBlcih7XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVRdWVyaWVzRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGlzRGF0YURpcnR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGdldENoYXJ0RGF0YVJlcXVlc3Qoe1xuICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICBmb3JjZSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCh7IHJlc3BvbnNlLCBqc29uIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc0ZlYXR1cmVFbmFibGVkKEZlYXR1cmVGbGFnLkdsb2JhbEFzeW5jUXVlcmllcykpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggZ2V0Q2hhcnREYXRhUmVxdWVzdCB0cmFuc2Zvcm1pbmcgdGhlIHJlc3BvbnNlIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAncmVzdWx0JyBpbiBqc29uID8ganNvbi5yZXN1bHRbMF0gOiBqc29uO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlc1dyYXBwZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlUXVlcmllc0RhdGE6IFtyZXN1bHRdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvckFzeW5jRGF0YShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoYXN5bmNSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlUXVlcmllc0RhdGE6IGFzeW5jUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDbGllbnRFcnJvck9iamVjdChlcnJvcikudGhlbihjbGllbnRFcnJvck9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3JXcmFwcGVyKGNsaWVudEVycm9yT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgdW5leHBlY3RlZCByZXNwb25zZSBzdGF0dXMgKCR7cmVzcG9uc2Uuc3RhdHVzfSkgd2hpbGUgZmV0Y2hpbmcgY2hhcnQgZGF0YWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVF1ZXJpZXNEYXRhOiBqc29uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGdldENsaWVudEVycm9yT2JqZWN0KGVycm9yKS50aGVuKGNsaWVudEVycm9yT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihjbGllbnRFcnJvck9iamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2ZpbHRlcklkLCBmb3JjZVVwZGF0ZSwgZm9ybSwgZm9ybUZpbHRlciwgaGFzRGF0YXNldCwgZGVwZW5kZW5jaWVzVGV4dF0pO1xuICAgIC8vIFRPRE86IHJlZnJlc2hIYW5kbGVyIGNoYW5nZXMgaXRzZWxmIGJlY2F1c2Ugb2YgdGhlIGRlcGVuZGVuY2llcy4gTmVlZHMgcmVmYWN0b3IuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIHVzZUVmZmVjdCgoKSA9PiByZWZyZXNoSGFuZGxlcigpLCBbZGVwZW5kZW5jaWVzVGV4dF0pO1xuICAgIGNvbnN0IG5ld0Zvcm1EYXRhID0gZ2V0Rm9ybURhdGEoe1xuICAgICAgICBkYXRhc2V0SWQsXG4gICAgICAgIGdyb3VwYnk6IGhhc0NvbHVtbiA/IGZvcm1GaWx0ZXI/LmNvbHVtbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4uZm9ybUZpbHRlcixcbiAgICB9KTtcbiAgICBuZXdGb3JtRGF0YS5leHRyYV9mb3JtX2RhdGEgPSBkZXBlbmRlbmNpZXNEZWZhdWx0VmFsdWVzO1xuICAgIGNvbnN0IFtoYXNEZWZhdWx0VmFsdWUsIGlzUmVxdWlyZWQsIGRlZmF1bHRWYWx1ZVRvb2x0aXAsIHNldEhhc0RlZmF1bHRWYWx1ZV0gPSB1c2VEZWZhdWx0VmFsdWUoZm9ybUZpbHRlciwgZmlsdGVyVG9FZGl0KTtcbiAgICBjb25zdCBzaG93RGF0YXNldCA9ICFkYXRhc2V0SWQgfHwgZGF0YXNldERldGFpbHMgfHwgZm9ybUZpbHRlcj8uZGF0YXNldD8ubGFiZWw7XG4gICAgY29uc3QgdXBkYXRlRm9ybVZhbHVlcyA9IHVzZUNhbGxiYWNrKCh2YWx1ZXMsIHRyaWdnZXJGb3JtQ2hhbmdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwgdmFsdWVzKTtcbiAgICAgICAgaWYgKHRyaWdnZXJGb3JtQ2hhbmdlKVxuICAgICAgICAgICAgZm9ybUNoYW5nZWQoKTtcbiAgICB9LCBbZmlsdGVySWQsIGZvcm0sIGZvcm1DaGFuZ2VkXSk7XG4gICAgY29uc3QgaGFzUHJlRmlsdGVyID0gISFmb3JtRmlsdGVyPy5hZGhvY19maWx0ZXJzIHx8XG4gICAgICAgICEhZm9ybUZpbHRlcj8udGltZV9yYW5nZSB8fFxuICAgICAgICAhIWZpbHRlclRvRWRpdD8uYWRob2NfZmlsdGVycz8ubGVuZ3RoIHx8XG4gICAgICAgICEhZmlsdGVyVG9FZGl0Py50aW1lX3JhbmdlO1xuICAgIGNvbnN0IGhhc0VuYWJsZVNpbmdsZVZhbHVlID0gZm9ybUZpbHRlcj8uY29udHJvbFZhbHVlcz8uZW5hYmxlU2luZ2xlVmFsdWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBmaWx0ZXJUb0VkaXQ/LmNvbnRyb2xWYWx1ZXM/LmVuYWJsZVNpbmdsZVZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgbGV0IGVuYWJsZVNpbmdsZVZhbHVlID0gZmlsdGVyVG9FZGl0Py5jb250cm9sVmFsdWVzPy5lbmFibGVTaW5nbGVWYWx1ZTtcbiAgICBpZiAoZm9ybUZpbHRlcj8uY29udHJvbFZhbHVlcz8uZW5hYmxlU2luZ2xlTWF4VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAoeyBlbmFibGVTaW5nbGVWYWx1ZSB9ID0gZm9ybUZpbHRlci5jb250cm9sVmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgaGFzU29ydGluZyA9IHR5cGVvZiBmb3JtRmlsdGVyPy5jb250cm9sVmFsdWVzPy5zb3J0QXNjZW5kaW5nID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdHlwZW9mIGZpbHRlclRvRWRpdD8uY29udHJvbFZhbHVlcz8uc29ydEFzY2VuZGluZyA9PT0gJ2Jvb2xlYW4nO1xuICAgIGxldCBzb3J0ID0gZmlsdGVyVG9FZGl0Py5jb250cm9sVmFsdWVzPy5zb3J0QXNjZW5kaW5nO1xuICAgIGlmICh0eXBlb2YgZm9ybUZpbHRlcj8uY29udHJvbFZhbHVlcz8uc29ydEFzY2VuZGluZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHNvcnQgPSBmb3JtRmlsdGVyLmNvbnRyb2xWYWx1ZXMuc29ydEFzY2VuZGluZztcbiAgICB9XG4gICAgY29uc3Qgc2hvd0RlZmF1bHRWYWx1ZSA9ICFoYXNEYXRhc2V0IHx8XG4gICAgICAgICghaXNEYXRhRGlydHkgJiYgaGFzRmlsbGVkRGF0YXNldCkgfHxcbiAgICAgICAgIW1haW5Db250cm9sSXRlbXMuZ3JvdXBieTtcbiAgICBjb25zdCBvblNvcnRDaGFuZ2VkID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gZm9ybS5nZXRGaWVsZFZhbHVlKCdmaWx0ZXJzJyk/LltmaWx0ZXJJZF0uY29udHJvbFZhbHVlcztcbiAgICAgICAgc2V0TmF0aXZlRmlsdGVyRmllbGRWYWx1ZXMoZm9ybSwgZmlsdGVySWQsIHtcbiAgICAgICAgICAgIGNvbnRyb2xWYWx1ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgICAgICAgICBzb3J0QXNjZW5kaW5nOiB2YWx1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmFibGVTaW5nbGVWYWx1ZUNoYW5nZWQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSBmb3JtLmdldEZpZWxkVmFsdWUoJ2ZpbHRlcnMnKT8uW2ZpbHRlcklkXS5jb250cm9sVmFsdWVzO1xuICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwge1xuICAgICAgICAgICAgY29udHJvbFZhbHVlczoge1xuICAgICAgICAgICAgICAgIC4uLnByZXZpb3VzLFxuICAgICAgICAgICAgICAgIGVuYWJsZVNpbmdsZVZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgIH07XG4gICAgY29uc3QgdmFsaWRhdGVQcmVGaWx0ZXIgPSAoKSA9PiBzZXRUaW1lb3V0KCgpID0+IGZvcm0udmFsaWRhdGVGaWVsZHMoW1xuICAgICAgICBbJ2ZpbHRlcnMnLCBmaWx0ZXJJZCwgJ2FkaG9jX2ZpbHRlcnMnXSxcbiAgICAgICAgWydmaWx0ZXJzJywgZmlsdGVySWQsICd0aW1lX3JhbmdlJ10sXG4gICAgXSksIDApO1xuICAgIGNvbnN0IGhhc1RpbWVSYW5nZSA9IGZvcm1GaWx0ZXI/LnRpbWVfcmFuZ2UgJiYgZm9ybUZpbHRlci50aW1lX3JhbmdlICE9PSAnTm8gZmlsdGVyJztcbiAgICBjb25zdCBoYXNBZGhvYyA9IGZvcm1GaWx0ZXI/LmFkaG9jX2ZpbHRlcnM/Lmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZGVmYXVsdFRvRmlyc3RJdGVtID0gZm9ybUZpbHRlcj8uY29udHJvbFZhbHVlcz8uZGVmYXVsdFRvRmlyc3RJdGVtO1xuICAgIGNvbnN0IGluaXRpYWxEZWZhdWx0VmFsdWUgPSBmb3JtRmlsdGVyPy5maWx0ZXJUeXBlID09PSBmaWx0ZXJUb0VkaXQ/LmZpbHRlclR5cGVcbiAgICAgICAgPyBmaWx0ZXJUb0VkaXQ/LmRlZmF1bHREYXRhTWFza1xuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgcHJlRmlsdGVyVmFsaWRhdG9yID0gKCkgPT4ge1xuICAgICAgICBpZiAoaGFzVGltZVJhbmdlIHx8IGhhc0FkaG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcih0KCdQcmUtZmlsdGVyIGlzIHJlcXVpcmVkJykpKTtcbiAgICB9O1xuICAgIGNvbnN0IGF2YWlsYWJsZUZpbHRlcnMgPSBnZXRBdmFpbGFibGVGaWx0ZXJzKGZpbHRlcklkKTtcbiAgICBjb25zdCBoYXNBdmFpbGFibGVGaWx0ZXJzID0gYXZhaWxhYmxlRmlsdGVycy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGhhc1RpbWVEZXBlbmRlbmN5ID0gYXZhaWxhYmxlRmlsdGVyc1xuICAgICAgICAuZmlsdGVyKGZpbHRlciA9PiBmaWx0ZXIudHlwZSA9PT0gJ2ZpbHRlcl90aW1lJylcbiAgICAgICAgLnNvbWUoZmlsdGVyID0+IGRlcGVuZGVuY2llcz8uaW5jbHVkZXMoZmlsdGVyLnZhbHVlKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY2FjaGVkU3VwZXJzZXRHZXQoe1xuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBgL2FwaS92MS9kYXRhc2V0LyR7ZGF0YXNldElkfT9xPSR7cmlzb24uZW5jb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMuY29sdW1uX25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMuZXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sdW1ucy5maWx0ZXJhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2x1bW5zLmlzX2R0dG0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMudHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sdW1ucy52ZXJib3NlX25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGFiYXNlLmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhYmFzZS5kYXRhYmFzZV9uYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhc291cmNlX3R5cGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbHRlcl9zZWxlY3RfZW5hYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lzX3NxbGxhYl92aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYWluX2R0dG1fY29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZXRyaWNzLm1ldHJpY19uYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZXRyaWNzLnZlcmJvc2VfbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2NoZW1hJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzcWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RhYmxlX25hbWUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pfWAsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNldE1ldHJpY3MocmVzcG9uc2UuanNvbj8ucmVzdWx0Py5tZXRyaWNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gcmVzcG9uc2UuanNvbj8ucmVzdWx0O1xuICAgICAgICAgICAgICAgIC8vIG1vZGlmeSB0aGUgcmVzcG9uc2UgdG8gZml0IHN0cnVjdHVyZSBleHBlY3RlZCBieSBBZGhvY0ZpbHRlckNvbnRyb2xcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGUgPSBkYXRhc2V0LmRhdGFzb3VyY2VfdHlwZTtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LmZpbHRlcl9zZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldERhdGFzZXREZXRhaWxzKGRhdGFzZXQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkRGFuZ2VyVG9hc3QocmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkYXRhc2V0SWRdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICAgICAgY2hhbmdlVGFiKHRhYikge1xuICAgICAgICAgICAgc2V0QWN0aXZlVGFiS2V5KHRhYik7XG4gICAgICAgIH0sXG4gICAgfSkpO1xuICAgIHVzZUJhY2tlbmRGb3JtVXBkYXRlKGZvcm0sIGZpbHRlcklkKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaGFzRGF0YXNldCAmJiBoYXNGaWxsZWREYXRhc2V0ICYmIGhhc0RlZmF1bHRWYWx1ZSAmJiBpc0RhdGFEaXJ0eSkge1xuICAgICAgICAgICAgcmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaGFzRGF0YXNldCxcbiAgICAgICAgaGFzRmlsbGVkRGF0YXNldCxcbiAgICAgICAgaGFzRGVmYXVsdFZhbHVlLFxuICAgICAgICBpc0RhdGFEaXJ0eSxcbiAgICAgICAgcmVmcmVzaEhhbmRsZXIsXG4gICAgICAgIHNob3dEYXRhc2V0LFxuICAgIF0pO1xuICAgIGNvbnN0IGluaXRpYWxseUV4Y2x1ZGVkQ2hhcnRzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gW107XG4gICAgICAgIGlmIChmb3JtRmlsdGVyPy5kYXRhc2V0Py52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnZhbHVlcyhjaGFydHMpLmZvckVhY2goKGNoYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGFydERhdGFzZXRVaWQgPSBjaGFydC5mb3JtX2RhdGE/LmRhdGFzb3VyY2U7XG4gICAgICAgICAgICBpZiAoY2hhcnREYXRhc2V0VWlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9hZGVkRGF0YXNldHNbY2hhcnREYXRhc2V0VWlkXT8uaWQgIT09IGZvcm1GaWx0ZXI/LmRhdGFzZXQ/LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZWQucHVzaChjaGFydC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXhjbHVkZWQ7XG4gICAgfSwgW1xuICAgICAgICBKU09OLnN0cmluZ2lmeShjaGFydHMpLFxuICAgICAgICBmb3JtRmlsdGVyPy5kYXRhc2V0Py52YWx1ZSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobG9hZGVkRGF0YXNldHMpLFxuICAgIF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIGp1c3QgcmVtb3ZlZCwgc2F2aW5nIGN1cnJlbnQgZm9ybSBpdGVtcyBmb3IgZXZlbnR1YWwgdW5kb1xuICAgICAgICBpZiAoaXNSZW1vdmVkKSB7XG4gICAgICAgICAgICBzZXRVbmRvRm9ybVZhbHVlcyhmb3JtVmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc1JlbW92ZWRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyB0aGUgZmlsdGVyIHdhcyBqdXN0IHJlc3RvcmVkIGFmdGVyIHVuZG9cbiAgICAgICAgaWYgKHVuZG9Gb3JtVmFsdWVzICYmICFpc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzKGZvcm0sIGZpbHRlcklkLCB1bmRvRm9ybVZhbHVlcyk7XG4gICAgICAgICAgICBzZXRVbmRvRm9ybVZhbHVlcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFtmb3JtVmFsdWVzLCBmaWx0ZXJJZCwgZm9ybSwgaXNSZW1vdmVkLCB1bmRvRm9ybVZhbHVlc10pO1xuICAgIGlmIChpc1JlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIDxSZW1vdmVkRmlsdGVyIG9uQ2xpY2s9eygpID0+IHJlc3RvcmVGaWx0ZXIoZmlsdGVySWQpfS8+O1xuICAgIH1cbiAgICBjb25zdCB0aW1lQ29sdW1uID0gKDxTdHlsZWRSb3dGb3JtSXRlbSBleHBhbmRlZD17ZXhwYW5kZWR9IG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAnZ3JhbnVsYXJpdHlfc3FsYSddfSBsYWJlbD17PD5cbiAgICAgICAgICA8U3R5bGVkTGFiZWw+e3QoJ1RpbWUgY29sdW1uJyl9PC9TdHlsZWRMYWJlbD4mbmJzcDtcbiAgICAgICAgICA8SW5mb1Rvb2x0aXBXaXRoVHJpZ2dlciBwbGFjZW1lbnQ9XCJ0b3BcIiB0b29sdGlwPXtoYXNUaW1lRGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgID8gdCgnVGltZSBjb2x1bW4gdG8gYXBwbHkgZGVwZW5kZW50IHRlbXBvcmFsIGZpbHRlciB0bycpXG4gICAgICAgICAgICAgICAgOiB0KCdUaW1lIGNvbHVtbiB0byBhcHBseSB0aW1lIHJhbmdlIHRvJyl9Lz5cbiAgICAgICAgPC8+fSBpbml0aWFsVmFsdWU9e2ZpbHRlclRvRWRpdD8uZ3JhbnVsYXJpdHlfc3FsYX0+XG4gICAgICA8Q29sdW1uU2VsZWN0IGFsbG93Q2xlYXIgZm9ybT17Zm9ybX0gZm9ybUZpZWxkPVwiZ3JhbnVsYXJpdHlfc3FsYVwiIGZpbHRlcklkPXtmaWx0ZXJJZH0gZmlsdGVyVmFsdWVzPXsoY29sdW1uKSA9PiAhIWNvbHVtbi5pc19kdHRtfSBkYXRhc2V0SWQ9e2RhdGFzZXRJZH0gb25DaGFuZ2U9e2NvbHVtbiA9PiB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHJlc2V0IGRlZmF1bHQgdmFsdWUgd2hlbiBjb2x1bW4gY2hhbmdlZFxuICAgICAgICAgICAgc2V0TmF0aXZlRmlsdGVyRmllbGRWYWx1ZXMoZm9ybSwgZmlsdGVySWQsIHtcbiAgICAgICAgICAgICAgICBncmFudWxhcml0eV9zcWxhOiBjb2x1bW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICBmb3JtQ2hhbmdlZCgpO1xuICAgICAgICB9fS8+XG4gICAgPC9TdHlsZWRSb3dGb3JtSXRlbT4pO1xuICAgIHJldHVybiAoPFN0eWxlZFRhYnMgYWN0aXZlS2V5PXthY3RpdmVUYWJLZXl9IG9uQ2hhbmdlPXthY3RpdmVLZXkgPT4gc2V0QWN0aXZlVGFiS2V5KGFjdGl2ZUtleSl9IGNlbnRlcmVkPlxuICAgICAgPFRhYlBhbmUgdGFiPXtGaWx0ZXJUYWJzLmNvbmZpZ3VyYXRpb24ubmFtZX0ga2V5PXtGaWx0ZXJUYWJzLmNvbmZpZ3VyYXRpb24ua2V5fSBmb3JjZVJlbmRlcj5cbiAgICAgICAgPFN0eWxlZENvbnRhaW5lcj5cbiAgICAgICAgICA8U3R5bGVkRm9ybUl0ZW0gZXhwYW5kZWQ9e2V4cGFuZGVkfSBuYW1lPXtbJ2ZpbHRlcnMnLCBmaWx0ZXJJZCwgJ3R5cGUnXX0gaGlkZGVuIGluaXRpYWxWYWx1ZT17TmF0aXZlRmlsdGVyVHlwZS5OYXRpdmVGaWx0ZXJ9PlxuICAgICAgICAgICAgPElucHV0IG9uQ2hhbmdlPXtmb3JtQ2hhbmdlZH0vPlxuICAgICAgICAgIDwvU3R5bGVkRm9ybUl0ZW0+XG4gICAgICAgICAgPFN0eWxlZEZvcm1JdGVtIGV4cGFuZGVkPXtleHBhbmRlZH0gbmFtZT17WydmaWx0ZXJzJywgZmlsdGVySWQsICduYW1lJ119IGxhYmVsPXs8U3R5bGVkTGFiZWw+e3QoJ0ZpbHRlciBuYW1lJyl9PC9TdHlsZWRMYWJlbD59IGluaXRpYWxWYWx1ZT17ZmlsdGVyVG9FZGl0Py5uYW1lfSBydWxlcz17W3sgcmVxdWlyZWQ6ICFpc1JlbW92ZWQsIG1lc3NhZ2U6IHQoJ05hbWUgaXMgcmVxdWlyZWQnKSB9XX0+XG4gICAgICAgICAgICA8SW5wdXQgey4uLmdldEZpbHRlcnNDb25maWdNb2RhbFRlc3RJZCgnbmFtZS1pbnB1dCcpfSBvbkNoYW5nZT17ZGVib3VuY2VkRm9ybUNoYW5nZWR9Lz5cbiAgICAgICAgICA8L1N0eWxlZEZvcm1JdGVtPlxuICAgICAgICAgIDxTdHlsZWRGb3JtSXRlbSBleHBhbmRlZD17ZXhwYW5kZWR9IG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAnZmlsdGVyVHlwZSddfSBydWxlcz17W3sgcmVxdWlyZWQ6ICFpc1JlbW92ZWQsIG1lc3NhZ2U6IHQoJ05hbWUgaXMgcmVxdWlyZWQnKSB9XX0gaW5pdGlhbFZhbHVlPXtmaWx0ZXJUb0VkaXQ/LmZpbHRlclR5cGUgfHwgJ2ZpbHRlcl9zZWxlY3QnfSBsYWJlbD17PFN0eWxlZExhYmVsPnt0KCdGaWx0ZXIgVHlwZScpfTwvU3R5bGVkTGFiZWw+fSB7Li4uZ2V0RmlsdGVyc0NvbmZpZ01vZGFsVGVzdElkKCdmaWx0ZXItdHlwZScpfT5cbiAgICAgICAgICAgIDxTZWxlY3QgYXJpYUxhYmVsPXt0KCdGaWx0ZXIgdHlwZScpfSBvcHRpb25zPXtuYXRpdmVGaWx0ZXJWaXpUeXBlcy5tYXAoZmlsdGVyVHlwZSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmF0aXZlRmlsdGVySXRlbXNbZmlsdGVyVHlwZV0/LnZhbHVlLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWROYW1lID0gbmFtZVxuICAgICAgICAgICAgICAgID8gRklMVEVSX1RZUEVfTkFNRV9NQVBQSU5HW25hbWVdXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc0Rpc2FibGVkID0gRklMVEVSX1NVUFBPUlRFRF9UWVBFU1tmaWx0ZXJUeXBlXT8ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgRklMVEVSX1NVUFBPUlRFRF9UWVBFU1tmaWx0ZXJUeXBlXT8uaW5jbHVkZXMoR2VuZXJpY0RhdGFUeXBlLlRlbXBvcmFsKSAmJlxuICAgICAgICAgICAgICAgICFkb0xvYWRlZERhdGFzZXRzSGF2ZVRlbXBvcmFsQ29sdW1ucztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZpbHRlclR5cGUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG1hcHBlZE5hbWUgfHwgbmFtZSxcbiAgICAgICAgICAgICAgICBjdXN0b21MYWJlbDogaXNEaXNhYmxlZCA/ICg8VG9vbHRpcCB0aXRsZT17dCgnRGF0YXNldHMgZG8gbm90IGNvbnRhaW4gYSB0ZW1wb3JhbCBjb2x1bW4nKX0+XG4gICAgICAgICAgICAgICAgICAgICAge21hcHBlZE5hbWUgfHwgbmFtZX1cbiAgICAgICAgICAgICAgICAgICAgPC9Ub29sdGlwPikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KX0gb25DaGFuZ2U9e3ZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzKGZvcm0sIGZpbHRlcklkLCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVHlwZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdERhdGFNYXNrOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgIH19Lz5cbiAgICAgICAgICA8L1N0eWxlZEZvcm1JdGVtPlxuICAgICAgICA8L1N0eWxlZENvbnRhaW5lcj5cbiAgICAgICAge2Zvcm1GaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdmaWx0ZXJfdGltZScgJiYgKDxGaWx0ZXJUeXBlSW5mbyBleHBhbmRlZD17ZXhwYW5kZWR9PlxuICAgICAgICAgICAge3QoYERhc2hib2FyZCB0aW1lIHJhbmdlIGZpbHRlcnMgYXBwbHkgdG8gdGVtcG9yYWwgY29sdW1ucyBkZWZpbmVkIGluXG4gICAgICAgICAgdGhlIGZpbHRlciBzZWN0aW9uIG9mIGVhY2ggY2hhcnQuIEFkZCB0ZW1wb3JhbCBjb2x1bW5zIHRvIHRoZSBjaGFydFxuICAgICAgICAgIGZpbHRlcnMgdG8gaGF2ZSB0aGlzIGRhc2hib2FyZCBmaWx0ZXIgaW1wYWN0IHRob3NlIGNoYXJ0cy5gKX1cbiAgICAgICAgICA8L0ZpbHRlclR5cGVJbmZvPil9XG4gICAgICAgIHtoYXNEYXRhc2V0ICYmICg8U3R5bGVkUm93Q29udGFpbmVyPlxuICAgICAgICAgICAge3Nob3dEYXRhc2V0ID8gKDxTdHlsZWRGb3JtSXRlbSBleHBhbmRlZD17ZXhwYW5kZWR9IG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAnZGF0YXNldCddfSBsYWJlbD17PFN0eWxlZExhYmVsPnt0KCdEYXRhc2V0Jyl9PC9TdHlsZWRMYWJlbD59IGluaXRpYWxWYWx1ZT17ZGF0YXNldERldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogRGF0YXNldFNlbGVjdExhYmVsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZGF0YXNldERldGFpbHMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVfbmFtZTogZGF0YXNldERldGFpbHMudGFibGVfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGRhdGFzZXREZXRhaWxzLnNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZV9uYW1lOiBkYXRhc2V0RGV0YWlscy5kYXRhYmFzZS5kYXRhYmFzZV9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhc2V0RGV0YWlscy5pZCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZH0gcnVsZXM9e1tcbiAgICAgICAgICAgICAgICAgICAgeyByZXF1aXJlZDogIWlzUmVtb3ZlZCwgbWVzc2FnZTogdCgnRGF0YXNldCBpcyByZXF1aXJlZCcpIH0sXG4gICAgICAgICAgICAgICAgXX0gey4uLmdldEZpbHRlcnNDb25maWdNb2RhbFRlc3RJZCgnZGF0YXNvdXJjZS1pbnB1dCcpfT5cbiAgICAgICAgICAgICAgICA8RGF0YXNldFNlbGVjdCBvbkNoYW5nZT17KHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVzZXQgdGhlIGNvbHVtbiB3aGVuIHRoZSBkYXRhc2V0IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS52YWx1ZSAhPT0gZGF0YXNldElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHREYXRhTWFzazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH19Lz5cbiAgICAgICAgICAgICAgPC9TdHlsZWRGb3JtSXRlbT4pIDogKDxTdHlsZWRGb3JtSXRlbSBleHBhbmRlZD17ZXhwYW5kZWR9IGxhYmVsPXs8U3R5bGVkTGFiZWw+e3QoJ0RhdGFzZXQnKX08L1N0eWxlZExhYmVsPn0+XG4gICAgICAgICAgICAgICAgPExvYWRpbmcgcG9zaXRpb249XCJpbmxpbmUtY2VudGVyZWRcIi8+XG4gICAgICAgICAgICAgIDwvU3R5bGVkRm9ybUl0ZW0+KX1cbiAgICAgICAgICAgIHtoYXNEYXRhc2V0ICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWFpbkNvbnRyb2xJdGVtcykubWFwKGtleSA9PiBtYWluQ29udHJvbEl0ZW1zW2tleV0uZWxlbWVudCl9XG4gICAgICAgICAgPC9TdHlsZWRSb3dDb250YWluZXI+KX1cbiAgICAgICAgPFN0eWxlZENvbGxhcHNlIGRlZmF1bHRBY3RpdmVLZXk9e2FjdGl2ZUZpbHRlclBhbmVsS2V5c30gb25DaGFuZ2U9e2tleSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVBY3RpdmVGaWx0ZXJQYW5lbENoYW5nZShrZXkpO1xuICAgICAgICB9fSBleHBhbmRJY29uUG9zaXRpb249XCJyaWdodFwiIGtleT17YG5hdGl2ZS1maWx0ZXItY29uZmlnLSR7ZmlsdGVySWR9YH0+XG4gICAgICAgICAge2Zvcm1GaWx0ZXI/LmZpbHRlclR5cGUgIT09ICdmaWx0ZXJfdGltZScgJiYgKDxDb2xsYXBzZS5QYW5lbCBmb3JjZVJlbmRlciBoZWFkZXI9e0ZpbHRlclBhbmVscy5jb25maWd1cmF0aW9uLm5hbWV9IGtleT17YCR7ZmlsdGVySWR9LSR7RmlsdGVyUGFuZWxzLmNvbmZpZ3VyYXRpb24ua2V5fWB9PlxuICAgICAgICAgICAgICB7Y2FuRGVwZW5kT25PdGhlckZpbHRlcnMgJiYgaGFzQXZhaWxhYmxlRmlsdGVycyAmJiAoPFN0eWxlZFJvd0Zvcm1JdGVtIGV4cGFuZGVkPXtleHBhbmRlZH0gbmFtZT17WydmaWx0ZXJzJywgZmlsdGVySWQsICdkZXBlbmRlbmNpZXMnXX0gaW5pdGlhbFZhbHVlPXtkZXBlbmRlbmNpZXN9PlxuICAgICAgICAgICAgICAgICAgPERlcGVuZGVuY3lMaXN0IGF2YWlsYWJsZUZpbHRlcnM9e2F2YWlsYWJsZUZpbHRlcnN9IGRlcGVuZGVuY2llcz17ZGVwZW5kZW5jaWVzfSBvbkRlcGVuZGVuY2llc0NoYW5nZT17ZGVwZW5kZW5jaWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TmF0aXZlRmlsdGVyRmllbGRWYWx1ZXMoZm9ybSwgZmlsdGVySWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfX0gZ2V0RGVwZW5kZW5jeVN1Z2dlc3Rpb249eygpID0+IGdldERlcGVuZGVuY3lTdWdnZXN0aW9uKGZpbHRlcklkKX0+XG4gICAgICAgICAgICAgICAgICAgIHtoYXNUaW1lRGVwZW5kZW5jeSA/IHRpbWVDb2x1bW4gOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgICA8L0RlcGVuZGVuY3lMaXN0PlxuICAgICAgICAgICAgICAgIDwvU3R5bGVkUm93Rm9ybUl0ZW0+KX1cbiAgICAgICAgICAgICAge2hhc0RhdGFzZXQgJiYgaGFzQWRkaXRpb25hbEZpbHRlcnMgJiYgKDxDbGVhbkZvcm1JdGVtIG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAncHJlRmlsdGVyJ119PlxuICAgICAgICAgICAgICAgICAgPENvbGxhcHNpYmxlQ29udHJvbCBpbml0aWFsVmFsdWU9e2hhc1ByZUZpbHRlcn0gdGl0bGU9e3QoJ1ByZS1maWx0ZXIgYXZhaWxhYmxlIHZhbHVlcycpfSB0b29sdGlwPXt0KGBBZGQgZmlsdGVyIGNsYXVzZXMgdG8gY29udHJvbCB0aGUgZmlsdGVyJ3Mgc291cmNlIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB0aG91Z2ggb25seSBpbiB0aGUgY29udGV4dCBvZiB0aGUgYXV0b2NvbXBsZXRlIGkuZS4sIHRoZXNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZG8gbm90IGltcGFjdCBob3cgdGhlIGZpbHRlciBpcyBhcHBsaWVkIHRvIHRoZSBkYXNoYm9hcmQuIFRoaXMgaXMgdXNlZnVsXG4gICAgICAgICAgICAgICAgICAgIHdoZW4geW91IHdhbnQgdG8gaW1wcm92ZSB0aGUgcXVlcnkncyBwZXJmb3JtYW5jZSBieSBvbmx5IHNjYW5uaW5nIGEgc3Vic2V0XG4gICAgICAgICAgICAgICAgICAgIG9mIHRoZSB1bmRlcmx5aW5nIGRhdGEgb3IgbGltaXQgdGhlIGF2YWlsYWJsZSB2YWx1ZXMgZGlzcGxheWVkIGluIHRoZSBmaWx0ZXIuYCl9IG9uQ2hhbmdlPXtjaGVja2VkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJlRmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgPFN0eWxlZFJvd1N1YkZvcm1JdGVtIGV4cGFuZGVkPXtleHBhbmRlZH0gbmFtZT17WydmaWx0ZXJzJywgZmlsdGVySWQsICdhZGhvY19maWx0ZXJzJ119IGNzcz17eyB3aWR0aDogSU5QVVRfV0lEVEggfX0gaW5pdGlhbFZhbHVlPXtmaWx0ZXJUb0VkaXQ/LmFkaG9jX2ZpbHRlcnN9IHJlcXVpcmVkIHJ1bGVzPXtbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogcHJlRmlsdGVyVmFsaWRhdG9yLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF19PlxuICAgICAgICAgICAgICAgICAgICAgIDxBZGhvY0ZpbHRlckNvbnRyb2wgY29sdW1ucz17ZGF0YXNldERldGFpbHM/LmNvbHVtbnM/LmZpbHRlcigoYykgPT4gYy5maWx0ZXJhYmxlKSB8fCBbXX0gc2F2ZWRNZXRyaWNzPXtkYXRhc2V0RGV0YWlscz8ubWV0cmljcyB8fCBbXX0gZGF0YXNvdXJjZT17ZGF0YXNldERldGFpbHN9IG9uQ2hhbmdlPXsoZmlsdGVycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRob2NfZmlsdGVyczogZmlsdGVycyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJlRmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgfX0gbGFiZWw9ezxzcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTdHlsZWRMYWJlbD57dCgnUHJlLWZpbHRlcicpfTwvU3R5bGVkTGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFoYXNUaW1lUmFuZ2UgJiYgPFN0eWxlZEFzdGVyaXNrIC8+fVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+fS8+XG4gICAgICAgICAgICAgICAgICAgIDwvU3R5bGVkUm93U3ViRm9ybUl0ZW0+XG4gICAgICAgICAgICAgICAgICAgIHtzaG93VGltZVJhbmdlUGlja2VyICYmICg8U3R5bGVkUm93Rm9ybUl0ZW0gZXhwYW5kZWQ9e2V4cGFuZGVkfSBuYW1lPXtbJ2ZpbHRlcnMnLCBmaWx0ZXJJZCwgJ3RpbWVfcmFuZ2UnXX0gbGFiZWw9ezxTdHlsZWRMYWJlbD57dCgnVGltZSByYW5nZScpfTwvU3R5bGVkTGFiZWw+fSBpbml0aWFsVmFsdWU9e2ZpbHRlclRvRWRpdD8udGltZV9yYW5nZSB8fCB0KCdObyBmaWx0ZXInKX0gcmVxdWlyZWQ9eyFoYXNBZGhvY30gcnVsZXM9e1tcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHByZUZpbHRlclZhbGlkYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPERhdGVGaWx0ZXJDb250cm9sIG5hbWU9XCJ0aW1lX3JhbmdlXCIgb25DaGFuZ2U9e3RpbWVSYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROYXRpdmVGaWx0ZXJGaWVsZFZhbHVlcyhmb3JtLCBmaWx0ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVfcmFuZ2U6IHRpbWVSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZVByZUZpbHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9fS8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9TdHlsZWRSb3dGb3JtSXRlbT4pfVxuICAgICAgICAgICAgICAgICAgICB7aGFzVGltZVJhbmdlICYmICFoYXNUaW1lRGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgICAgICA/IHRpbWVDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICAgICAgICA8L0NvbGxhcHNpYmxlQ29udHJvbD5cbiAgICAgICAgICAgICAgICA8L0NsZWFuRm9ybUl0ZW0+KX1cbiAgICAgICAgICAgICAge2Zvcm1GaWx0ZXI/LmZpbHRlclR5cGUgIT09ICdmaWx0ZXJfcmFuZ2UnID8gKDxDbGVhbkZvcm1JdGVtIG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAnc29ydEZpbHRlciddfT5cbiAgICAgICAgICAgICAgICAgIDxDb2xsYXBzaWJsZUNvbnRyb2wgaW5pdGlhbFZhbHVlPXtoYXNTb3J0aW5nfSB0aXRsZT17dCgnU29ydCBmaWx0ZXIgdmFsdWVzJyl9IG9uQ2hhbmdlPXtjaGVja2VkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25Tb3J0Q2hhbmdlZChjaGVja2VkIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIDxTdHlsZWRSb3dGb3JtSXRlbSBleHBhbmRlZD17ZXhwYW5kZWR9IG5hbWU9e1tcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbHRlcnMnLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRyb2xWYWx1ZXMnLFxuICAgICAgICAgICAgICAgICAgICAnc29ydEFzY2VuZGluZycsXG4gICAgICAgICAgICAgICAgXX0gaW5pdGlhbFZhbHVlPXtzb3J0fSBsYWJlbD17PFN0eWxlZExhYmVsPnt0KCdTb3J0IHR5cGUnKX08L1N0eWxlZExhYmVsPn0+XG4gICAgICAgICAgICAgICAgICAgICAgPFJhZGlvLkdyb3VwV3JhcHBlciBvcHRpb25zPXtbXG4gICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IHRydWUsIGxhYmVsOiB0KCdTb3J0IGFzY2VuZGluZycpIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdmFsdWU6IGZhbHNlLCBsYWJlbDogdCgnU29ydCBkZXNjZW5kaW5nJykgfSxcbiAgICAgICAgICAgICAgICBdfSBvbkNoYW5nZT17dmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvblNvcnRDaGFuZ2VkKHZhbHVlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfX0vPlxuICAgICAgICAgICAgICAgICAgICA8L1N0eWxlZFJvd0Zvcm1JdGVtPlxuICAgICAgICAgICAgICAgICAgICB7aGFzTWV0cmljcyAmJiAoPFN0eWxlZFJvd1N1YkZvcm1JdGVtIGV4cGFuZGVkPXtleHBhbmRlZH0gbmFtZT17WydmaWx0ZXJzJywgZmlsdGVySWQsICdzb3J0TWV0cmljJ119IGluaXRpYWxWYWx1ZT17ZmlsdGVyVG9FZGl0Py5zb3J0TWV0cmljfSBsYWJlbD17PD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U3R5bGVkTGFiZWw+e3QoJ1NvcnQgTWV0cmljJyl9PC9TdHlsZWRMYWJlbD4mbmJzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SW5mb1Rvb2x0aXBXaXRoVHJpZ2dlciBwbGFjZW1lbnQ9XCJ0b3BcIiB0b29sdGlwPXt0KCdJZiBhIG1ldHJpYyBpcyBzcGVjaWZpZWQsIHNvcnRpbmcgd2lsbCBiZSBkb25lIGJhc2VkIG9uIHRoZSBtZXRyaWMgdmFsdWUnKX0vPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz59IGRhdGEtdGVzdD1cImZpZWxkLWlucHV0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U2VsZWN0IGFsbG93Q2xlYXIgYXJpYUxhYmVsPXt0KCdTb3J0IG1ldHJpYycpfSBuYW1lPVwic29ydE1ldHJpY1wiIG9wdGlvbnM9e21ldHJpY3MubWFwKChtZXRyaWMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0cmljLm1ldHJpY19uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG1ldHJpYy52ZXJib3NlX25hbWUgPz8gbWV0cmljLm1ldHJpY19uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSl9IG9uQ2hhbmdlPXt2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzKGZvcm0sIGZpbHRlcklkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRNZXRyaWM6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9fS8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9TdHlsZWRSb3dTdWJGb3JtSXRlbT4pfVxuICAgICAgICAgICAgICAgICAgPC9Db2xsYXBzaWJsZUNvbnRyb2w+XG4gICAgICAgICAgICAgICAgPC9DbGVhbkZvcm1JdGVtPikgOiAoPENsZWFuRm9ybUl0ZW0gbmFtZT17WydmaWx0ZXJzJywgZmlsdGVySWQsICdyYW5nZUZpbHRlciddfT5cbiAgICAgICAgICAgICAgICAgIDxDb2xsYXBzaWJsZUNvbnRyb2wgaW5pdGlhbFZhbHVlPXtoYXNFbmFibGVTaW5nbGVWYWx1ZX0gdGl0bGU9e3QoJ1NpbmdsZSBWYWx1ZScpfSBvbkNoYW5nZT17Y2hlY2tlZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uRW5hYmxlU2luZ2xlVmFsdWVDaGFuZ2VkKGNoZWNrZWQgPyBTaW5nbGVWYWx1ZVR5cGUuRXhhY3QgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICA8U3R5bGVkUm93Rm9ybUl0ZW0gZXhwYW5kZWQ9e2V4cGFuZGVkfSBuYW1lPXtbXG4gICAgICAgICAgICAgICAgICAgICdmaWx0ZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVySWQsXG4gICAgICAgICAgICAgICAgICAgICdjb250cm9sVmFsdWVzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2VuYWJsZVNpbmdsZVZhbHVlJyxcbiAgICAgICAgICAgICAgICBdfSBpbml0aWFsVmFsdWU9e2VuYWJsZVNpbmdsZVZhbHVlfSBsYWJlbD17PFN0eWxlZExhYmVsPnt0KCdTaW5nbGUgdmFsdWUgdHlwZScpfTwvU3R5bGVkTGFiZWw+fT5cbiAgICAgICAgICAgICAgICAgICAgICA8UmFkaW8uR3JvdXBXcmFwcGVyIG9uQ2hhbmdlPXt2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uRW5hYmxlU2luZ2xlVmFsdWVDaGFuZ2VkKHZhbHVlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfX0gb3B0aW9ucz17W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdCgnTWluaW11bScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFNpbmdsZVZhbHVlVHlwZS5NaW5pbXVtLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGxhYmVsOiB0KCdFeGFjdCcpLCB2YWx1ZTogU2luZ2xlVmFsdWVUeXBlLkV4YWN0IH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0KCdNYXhpbXVtJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU2luZ2xlVmFsdWVUeXBlLk1heGltdW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXX0vPlxuICAgICAgICAgICAgICAgICAgICA8L1N0eWxlZFJvd0Zvcm1JdGVtPlxuICAgICAgICAgICAgICAgICAgPC9Db2xsYXBzaWJsZUNvbnRyb2w+XG4gICAgICAgICAgICAgICAgPC9DbGVhbkZvcm1JdGVtPil9XG4gICAgICAgICAgICA8L0NvbGxhcHNlLlBhbmVsPil9XG4gICAgICAgICAgPENvbGxhcHNlLlBhbmVsIGZvcmNlUmVuZGVyIGhlYWRlcj17RmlsdGVyUGFuZWxzLnNldHRpbmdzLm5hbWV9IGtleT17YCR7ZmlsdGVySWR9LSR7RmlsdGVyUGFuZWxzLnNldHRpbmdzLmtleX1gfT5cbiAgICAgICAgICAgIDxTdHlsZWRGb3JtSXRlbSBleHBhbmRlZD17ZXhwYW5kZWR9IG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAnZGVzY3JpcHRpb24nXX0gaW5pdGlhbFZhbHVlPXtmaWx0ZXJUb0VkaXQ/LmRlc2NyaXB0aW9ufSBsYWJlbD17PFN0eWxlZExhYmVsPnt0KCdEZXNjcmlwdGlvbicpfTwvU3R5bGVkTGFiZWw+fT5cbiAgICAgICAgICAgICAgPFRleHRBcmVhIG9uQ2hhbmdlPXtkZWJvdW5jZWRGb3JtQ2hhbmdlZH0vPlxuICAgICAgICAgICAgPC9TdHlsZWRGb3JtSXRlbT5cbiAgICAgICAgICAgIDxDbGVhbkZvcm1JdGVtIG5hbWU9e1snZmlsdGVycycsIGZpbHRlcklkLCAnZGVmYXVsdFZhbHVlUXVlcmllc0RhdGEnXX0gaGlkZGVuIGluaXRpYWxWYWx1ZT17bnVsbH0vPlxuICAgICAgICAgICAgPENsZWFuRm9ybUl0ZW0gbmFtZT17WydmaWx0ZXJzJywgZmlsdGVySWQsICdkZWZhdWx0VmFsdWUnXX0+XG4gICAgICAgICAgICAgIDxDb2xsYXBzaWJsZUNvbnRyb2wgY2hlY2tlZD17aGFzRGVmYXVsdFZhbHVlfSBkaXNhYmxlZD17aXNSZXF1aXJlZCB8fCBkZWZhdWx0VG9GaXJzdEl0ZW19IGluaXRpYWxWYWx1ZT17aGFzRGVmYXVsdFZhbHVlfSB0aXRsZT17dCgnRmlsdGVyIGhhcyBkZWZhdWx0IHZhbHVlJyl9IHRvb2x0aXA9e2RlZmF1bHRWYWx1ZVRvb2x0aXB9IG9uQ2hhbmdlPXt2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRIYXNEZWZhdWx0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzKGZvcm0sIGZpbHRlcklkLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHREYXRhTWFzazogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm1DaGFuZ2VkKCk7XG4gICAgICAgIH19PlxuICAgICAgICAgICAgICAgIHshaXNSZW1vdmVkICYmICg8U3R5bGVkUm93U3ViRm9ybUl0ZW0gZXhwYW5kZWQ9e2V4cGFuZGVkfSBuYW1lPXtbJ2ZpbHRlcnMnLCBmaWx0ZXJJZCwgJ2RlZmF1bHREYXRhTWFzayddfSBpbml0aWFsVmFsdWU9e2luaXRpYWxEZWZhdWx0VmFsdWV9IGRhdGEtdGVzdD1cImRlZmF1bHQtaW5wdXRcIiBsYWJlbD17PFN0eWxlZExhYmVsPnt0KCdEZWZhdWx0IFZhbHVlJyl9PC9TdHlsZWRMYWJlbD59IHJlcXVpcmVkPXtoYXNEZWZhdWx0VmFsdWV9IHJ1bGVzPXtbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtRmlsdGVyPy5kZWZhdWx0RGF0YU1hc2s/LmZpbHRlclN0YXRlPy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVzIG1hbmFnaW5nIHRoZSBlcnJvciBhcyB0aGUgRGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IGRvZXMgbm90IHVzZSBhbiBBbnRkZXNpZ24gY29tcGF0aWJsZSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1WYWxpZGF0aW9uRmllbGRzID0gZm9ybS5nZXRGaWVsZHNFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yZWRGaWx0ZXJzKHByZXZFcnJvcmVkRmlsdGVycyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2RXJyb3JlZEZpbHRlcnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZm9ybVZhbGlkYXRpb25GaWVsZHMuZmluZChmID0+IGYuZXJyb3JzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZFcnJvcmVkRmlsdGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcmVkRmlsdGVycyhwcmV2RXJyb3JlZEZpbHRlcnMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2RXJyb3JlZEZpbHRlcnMuaW5jbHVkZXMoZmlsdGVySWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2RXJyb3JlZEZpbHRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucHJldkVycm9yZWRGaWx0ZXJzLCBmaWx0ZXJJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IodCgnUGxlYXNlIGNob29zZSBhIHZhbGlkIHZhbHVlJykpKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXX0+XG4gICAgICAgICAgICAgICAgICAgIHtlcnJvciB8fCBzaG93RGVmYXVsdFZhbHVlID8gKDxEZWZhdWx0VmFsdWVDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZXJyb3IgPyAoPEVycm9yTWVzc2FnZVdpdGhTdGFja1RyYWNlIGVycm9yPXtlcnJvci5lcnJvcnM/LlswXX0gZmFsbGJhY2s9ezxCYXNpY0Vycm9yQWxlcnQgdGl0bGU9e3QoJ0Nhbm5vdCBsb2FkIGZpbHRlcicpfSBib2R5PXtlcnJvci5lcnJvcn0gbGV2ZWw9XCJlcnJvclwiLz59Lz4pIDogKDxEZWZhdWx0VmFsdWUgc2V0RGF0YU1hc2s9e2RhdGFNYXNrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbChpbml0aWFsRGVmYXVsdFZhbHVlPy5maWx0ZXJTdGF0ZT8udmFsdWUsIGRhdGFNYXNrPy5maWx0ZXJTdGF0ZT8udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybUNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE5hdGl2ZUZpbHRlckZpZWxkVmFsdWVzKGZvcm0sIGZpbHRlcklkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdERhdGFNYXNrOiBkYXRhTWFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS52YWxpZGF0ZUZpZWxkcyhbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWydmaWx0ZXJzJywgZmlsdGVySWQsICdkZWZhdWx0RGF0YU1hc2snXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfX0gaGFzRGVmYXVsdFZhbHVlPXtoYXNEZWZhdWx0VmFsdWV9IGZpbHRlcklkPXtmaWx0ZXJJZH0gaGFzRGF0YXNldD17aGFzRGF0YXNldH0gZm9ybT17Zm9ybX0gZm9ybURhdGE9e25ld0Zvcm1EYXRhfSBlbmFibGVOb1Jlc3VsdHM9e2VuYWJsZU5vUmVzdWx0c30vPil9XG4gICAgICAgICAgICAgICAgICAgICAgICB7aGFzRGF0YXNldCAmJiBkYXRhc2V0SWQgJiYgKDxUb29sdGlwIHRpdGxlPXt0KCdSZWZyZXNoIHRoZSBkZWZhdWx0IHZhbHVlcycpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbnMuU3luY091dGxpbmVkIGljb25TaXplPVwieGxcIiBpY29uQ29sb3I9e3RoZW1lLmNvbG9ycy5wcmltYXJ5LmJhc2V9IGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLWxlZnQ6ICR7dGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYH0gb25DbGljaz17KCkgPT4gcmVmcmVzaEhhbmRsZXIodHJ1ZSl9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Ub29sdGlwPil9XG4gICAgICAgICAgICAgICAgICAgICAgPC9EZWZhdWx0VmFsdWVDb250YWluZXI+KSA6ICh0KCdGaWxsIGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZW5hYmxlIFwiRGVmYXVsdCBWYWx1ZVwiJykpfVxuICAgICAgICAgICAgICAgICAgPC9TdHlsZWRSb3dTdWJGb3JtSXRlbT4pfVxuICAgICAgICAgICAgICA8L0NvbGxhcHNpYmxlQ29udHJvbD5cbiAgICAgICAgICAgIDwvQ2xlYW5Gb3JtSXRlbT5cbiAgICAgICAgICAgIHtPYmplY3Qua2V5cyhjb250cm9sSXRlbXMpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gY29udHJvbHNPcmRlci5pbmRleE9mKGEpIC1cbiAgICAgICAgICAgIGNvbnRyb2xzT3JkZXIuaW5kZXhPZihiKSlcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+IGNvbnRyb2xJdGVtc1trZXldLmVsZW1lbnQpfVxuICAgICAgICAgIDwvQ29sbGFwc2UuUGFuZWw+XG4gICAgICAgIDwvU3R5bGVkQ29sbGFwc2U+XG4gICAgICA8L1RhYlBhbmU+XG4gICAgICA8VGFiUGFuZSB0YWI9e0ZpbHRlclRhYnMuc2NvcGluZy5uYW1lfSBrZXk9e0ZpbHRlclRhYnMuc2NvcGluZy5rZXl9IGZvcmNlUmVuZGVyPlxuICAgICAgICA8RmlsdGVyU2NvcGUgdXBkYXRlRm9ybVZhbHVlcz17dXBkYXRlRm9ybVZhbHVlc30gcGF0aFRvRm9ybVZhbHVlPXtbJ2ZpbHRlcnMnLCBmaWx0ZXJJZF19IGZvcmNlVXBkYXRlPXtmb3JjZVVwZGF0ZX0gZmlsdGVyU2NvcGU9e2ZpbHRlclRvRWRpdD8uc2NvcGV9IGZvcm1GaWx0ZXJTY29wZT17Zm9ybUZpbHRlcj8uc2NvcGV9IGluaXRpYWxseUV4Y2x1ZGVkQ2hhcnRzPXtpbml0aWFsbHlFeGNsdWRlZENoYXJ0c30vPlxuICAgICAgPC9UYWJQYW5lPlxuICAgIDwvU3R5bGVkVGFicz4pO1xufTtcbmV4cG9ydCBkZWZhdWx0IG1lbW8oZm9yd2FyZFJlZihGaWx0ZXJzQ29uZmlnRm9ybSkpO1xuIl19 */\"), initialValue: filterToEdit == null ? void 0 : filterToEdit.adhoc_filters, required: true, rules: [\n                {\n                  validator: preFilterValidator\n                }], children:\n\n                _jsx(AdhocFilterControl, { columns: (datasetDetails == null ? void 0 : (_datasetDetails$colum = datasetDetails.columns) == null ? void 0 : _datasetDetails$colum.filter((c) => c.filterable)) || [], savedMetrics: (datasetDetails == null ? void 0 : datasetDetails.metrics) || [], datasource: datasetDetails, onChange: (filters) => {\n                    setNativeFilterFieldValues(form, filterId, {\n                      adhoc_filters: filters\n                    });\n                    forceUpdate();\n                    formChanged();\n                    validatePreFilter();\n                  }, label: _jsxs(\"span\", { children: [\n                    _jsx(StyledLabel, { children: t('Pre-filter') }),\n                    !hasTimeRange && _jsx(StyledAsterisk, {})] }\n                  ) }) }\n              ),\n              showTimeRangePicker && _jsx(StyledRowFormItem, { expanded: expanded, name: ['filters', filterId, 'time_range'], label: _jsx(StyledLabel, { children: t('Time range') }), initialValue: (filterToEdit == null ? void 0 : filterToEdit.time_range) || t('No filter'), required: !hasAdhoc, rules: [\n                {\n                  validator: preFilterValidator\n                }], children:\n\n                _jsx(DateFilterControl, { name: \"time_range\", onChange: (timeRange) => {\n                    setNativeFilterFieldValues(form, filterId, {\n                      time_range: timeRange\n                    });\n                    forceUpdate();\n                    formChanged();\n                    validatePreFilter();\n                  } }) }\n              ),\n              hasTimeRange && !hasTimeDependency ?\n              timeColumn :\n              undefined] }\n            ) }\n          ),\n          (formFilter == null ? void 0 : formFilter.filterType) !== 'filter_range' ? _jsx(CleanFormItem, { name: ['filters', filterId, 'sortFilter'], children:\n            _jsxs(CollapsibleControl, { initialValue: hasSorting, title: t('Sort filter values'), onChange: (checked) => {\n                onSortChanged(checked || undefined);\n                formChanged();\n              }, children: [\n              _jsx(StyledRowFormItem, { expanded: expanded, name: [\n                'filters',\n                filterId,\n                'controlValues',\n                'sortAscending'],\n                initialValue: sort, label: _jsx(StyledLabel, { children: t('Sort type') }), children:\n                _jsx(Radio.GroupWrapper, { options: [\n                  { value: true, label: t('Sort ascending') },\n                  { value: false, label: t('Sort descending') }],\n                  onChange: (value) => {\n                    onSortChanged(value.target.value);\n                    formChanged();\n                  } }) }\n              ),\n              hasMetrics && _jsx(StyledRowSubFormItem, { expanded: expanded, name: ['filters', filterId, 'sortMetric'], initialValue: filterToEdit == null ? void 0 : filterToEdit.sortMetric, label: _jsxs(_Fragment, { children: [\n                  _jsx(StyledLabel, { children: t('Sort Metric') }), \"\\xA0\",\n                  _jsx(InfoTooltipWithTrigger, { placement: \"top\", tooltip: t('If a metric is specified, sorting will be done based on the metric value') })] }\n                ), children:\n                _jsx(Select, { allowClear: true, ariaLabel: t('Sort metric'), name: \"sortMetric\", options: metrics.map((metric) => {var _metric$verbose_name;return {\n                      value: metric.metric_name,\n                      label: (_metric$verbose_name = metric.verbose_name) != null ? _metric$verbose_name : metric.metric_name\n                    };}), onChange: (value) => {\n                    if (value !== undefined) {\n                      setNativeFilterFieldValues(form, filterId, {\n                        sortMetric: value\n                      });\n                      forceUpdate();\n                    }\n                    formChanged();\n                  } }) }\n              )] }\n            ) }\n          ) : _jsx(CleanFormItem, { name: ['filters', filterId, 'rangeFilter'], children:\n            _jsx(CollapsibleControl, { initialValue: hasEnableSingleValue, title: t('Single Value'), onChange: (checked) => {\n                onEnableSingleValueChanged(checked ? SingleValueType.Exact : undefined);\n                formChanged();\n              }, children:\n              _jsx(StyledRowFormItem, { expanded: expanded, name: [\n                'filters',\n                filterId,\n                'controlValues',\n                'enableSingleValue'],\n                initialValue: enableSingleValue, label: _jsx(StyledLabel, { children: t('Single value type') }), children:\n                _jsx(Radio.GroupWrapper, { onChange: (value) => {\n                    onEnableSingleValueChanged(value.target.value);\n                    formChanged();\n                  }, options: [\n                  {\n                    label: t('Minimum'),\n                    value: SingleValueType.Minimum\n                  },\n                  { label: t('Exact'), value: SingleValueType.Exact },\n                  {\n                    label: t('Maximum'),\n                    value: SingleValueType.Maximum\n                  }] }\n                ) }\n              ) }\n            ) }\n          )] }, `${filterId}-${FilterPanels.configuration.key}`\n        ),\n        _jsxs(Collapse.Panel, { forceRender: true, header: FilterPanels.settings.name, children: [\n          _jsx(StyledFormItem, { expanded: expanded, name: ['filters', filterId, 'description'], initialValue: filterToEdit == null ? void 0 : filterToEdit.description, label: _jsx(StyledLabel, { children: t('Description') }), children:\n            _jsx(TextArea, { onChange: debouncedFormChanged }) }\n          ),\n          _jsx(CleanFormItem, { name: ['filters', filterId, 'defaultValueQueriesData'], hidden: true, initialValue: null }),\n          _jsx(CleanFormItem, { name: ['filters', filterId, 'defaultValue'], children:\n            _jsx(CollapsibleControl, { checked: hasDefaultValue, disabled: isRequired || defaultToFirstItem, initialValue: hasDefaultValue, title: t('Filter has default value'), tooltip: defaultValueTooltip, onChange: (value) => {\n                setHasDefaultValue(value);\n                if (!value) {\n                  setNativeFilterFieldValues(form, filterId, {\n                    defaultDataMask: null\n                  });\n                }\n                formChanged();\n              }, children:\n              !isRemoved && _jsx(StyledRowSubFormItem, { expanded: expanded, name: ['filters', filterId, 'defaultDataMask'], initialValue: initialDefaultValue, label: _jsx(StyledLabel, { children: t('Default Value') }), required: hasDefaultValue, rules: [\n                {\n                  validator: () => {var _formFilter$defaultDa, _formFilter$defaultDa2;\n                    if (formFilter != null && (_formFilter$defaultDa = formFilter.defaultDataMask) != null && (_formFilter$defaultDa2 = _formFilter$defaultDa.filterState) != null && _formFilter$defaultDa2.value) {\n                      // requires managing the error as the DefaultValue\n                      // component does not use an Antdesign compatible input\n                      const formValidationFields = form.getFieldsError();\n                      setErroredFilters((prevErroredFilters) => {\n                        if (prevErroredFilters.length &&\n                        !formValidationFields.find((f) => f.errors.length > 0)) {\n                          return [];\n                        }\n                        return prevErroredFilters;\n                      });\n                      return Promise.resolve();\n                    }\n                    setErroredFilters((prevErroredFilters) => {\n                      if (prevErroredFilters.includes(filterId)) {\n                        return prevErroredFilters;\n                      }\n                      return [...prevErroredFilters, filterId];\n                    });\n                    return Promise.reject(new Error(t('Please choose a valid value')));\n                  }\n                }], children:\n\n                error || showDefaultValue ? _jsxs(DefaultValueContainer, { children: [\n                  error ? _jsx(ErrorMessageWithStackTrace, { error: (_error$errors = error.errors) == null ? void 0 : _error$errors[0], fallback: _jsx(BasicErrorAlert, { title: t('Cannot load filter'), body: error.error, level: \"error\" }) }) : _jsx(DefaultValue, { setDataMask: (dataMask) => {var _initialDefaultValue$, _dataMask$filterState;\n                      if (!_isEqual(initialDefaultValue == null ? void 0 : (_initialDefaultValue$ = initialDefaultValue.filterState) == null ? void 0 : _initialDefaultValue$.value, dataMask == null ? void 0 : (_dataMask$filterState = dataMask.filterState) == null ? void 0 : _dataMask$filterState.value)) {\n                        formChanged();\n                      }\n                      setNativeFilterFieldValues(form, filterId, {\n                        defaultDataMask: dataMask\n                      });\n                      form.validateFields([\n                      ['filters', filterId, 'defaultDataMask']]\n                      );\n                      forceUpdate();\n                    }, hasDefaultValue: hasDefaultValue, filterId: filterId, hasDataset: hasDataset, form: form, formData: newFormData, enableNoResults: enableNoResults }),\n                  hasDataset && datasetId && _jsx(Tooltip, { title: t('Refresh the default values'), children:\n                    _jsx(Icons.SyncOutlined, { iconSize: \"xl\", iconColor: theme.colors.primary.base, css: css`\n                                margin-left: ${theme.gridUnit * 2}px;\n                              `, onClick: () => refreshHandler(true) }) }\n                  )] }\n                ) : t('Fill all required fields to enable \"Default Value\"') }\n              ) }\n            ) }\n          ),\n          Object.keys(controlItems).\n          sort((a, b) => controlsOrder.indexOf(a) -\n          controlsOrder.indexOf(b)).\n          map((key) => controlItems[key].element)] }, `${filterId}-${FilterPanels.settings.key}`\n        )] }, `native-filter-config-${filterId}`\n      )] }, FilterTabs.configuration.key\n    ),\n    _jsx(TabPane, { tab: FilterTabs.scoping.name, forceRender: true, children:\n      _jsx(FilterScope, { updateFormValues: updateFormValues, pathToFormValue: ['filters', filterId], forceUpdate: forceUpdate, filterScope: filterToEdit == null ? void 0 : filterToEdit.scope, formFilterScope: formFilter == null ? void 0 : formFilter.scope, initiallyExcludedCharts: initiallyExcludedCharts }) }, FilterTabs.scoping.key\n    )] }\n  );\n};\nexport default /*#__PURE__*/memo(/*#__PURE__*/forwardRef(FiltersConfigForm));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}