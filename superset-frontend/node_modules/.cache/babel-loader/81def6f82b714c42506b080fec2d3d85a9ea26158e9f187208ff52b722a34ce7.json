{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with work for additional information\n * regarding copyright ownership.  The ASF licenses file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { logging, SupersetClient, t } from '@superset-ui/core';\nimport { isColumnMeta, isTemporalColumn } from '@superset-ui/chart-controls';\nimport Modal from 'src/components/Modal';\nimport { OPERATOR_ENUM_TO_OPERATOR_TYPE, Operators } from 'src/explore/constants';\nimport AdhocFilterPopoverTrigger from 'src/explore/components/controls/FilterControl/AdhocFilterPopoverTrigger';\nimport DndSelectLabel from 'src/explore/components/controls/DndColumnSelectControl/DndSelectLabel';\nimport AdhocFilter from 'src/explore/components/controls/FilterControl/AdhocFilter';\nimport AdhocMetric from 'src/explore/components/controls/MetricControl/AdhocMetric';\nimport { isSavedMetric } from 'src/explore/components/DatasourcePanel/types';\nimport { DndItemType } from 'src/explore/components/DndItemType';\nimport { toQueryString } from 'src/utils/urlUtils';\nimport DndAdhocFilterOption from './DndAdhocFilterOption';\nimport { useDefaultTimeFilter } from '../DateFilterControl/utils';\nimport { Clauses, ExpressionTypes } from '../FilterControl/types';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst { warning } = Modal;\nconst EMPTY_OBJECT = {};\nconst DND_ACCEPTED_TYPES = [\nDndItemType.Column,\nDndItemType.Metric,\nDndItemType.MetricOption,\nDndItemType.AdhocMetricOption];\n\nconst isDictionaryForAdhocFilter = (value) => !(value instanceof AdhocFilter) && (value == null ? void 0 : value.expressionType);\nconst DndFilterSelect = (props) => {var _props$value;\n  const { datasource, onChange = () => {}, name: controlName, canDelete } = props;\n  const extra = useMemo(() => {\n    let extra = {};\n    if (datasource != null && datasource.extra) {\n      try {\n        extra = JSON.parse(datasource.extra);\n      }\n      catch {} // eslint-disable-line no-empty\n    }\n    return extra;\n  }, [datasource == null ? void 0 : datasource.extra]);\n  const propsValues = Array.from((_props$value = props.value) != null ? _props$value : []);\n  const [values, setValues] = useState(propsValues.map((filter) => isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter));\n  const [partitionColumn, setPartitionColumn] = useState(undefined);\n  const [newFilterPopoverVisible, setNewFilterPopoverVisible] = useState(false);\n  const [droppedItem, setDroppedItem] = useState({});\n  const optionsForSelect = (columns, formData) => {\n    const options = [\n    ...columns,\n    ...[...((formData == null ? void 0 : formData.metrics) || []), formData == null ? void 0 : formData.metric].map((metric) => metric && (\n    typeof metric === 'string' ?\n    { saved_metric_name: metric } :\n    new AdhocMetric(metric)))].\n    filter((option) => option);\n    return options.\n    reduce((results, option) => {\n      if ('saved_metric_name' in option && option.saved_metric_name) {\n        results.push({\n          ...option,\n          filterOptionName: option.saved_metric_name\n        });\n      } else\n      if ('column_name' in option && option.column_name) {\n        results.push({\n          ...option,\n          filterOptionName: `_col_${option.column_name}`\n        });\n      } else\n      if (option instanceof AdhocMetric) {\n        results.push({\n          ...option,\n          filterOptionName: `_adhocmetric_${option.label}`\n        });\n      }\n      return results;\n    }, []).\n    sort((a, b) => {var _localeCompare, _ref;return (_localeCompare = (_ref = a.saved_metric_name || a.column_name || a.label) == null ? void 0 : _ref.localeCompare(b.saved_metric_name || b.column_name || b.label || '')) != null ? _localeCompare : 0;});\n  };\n  const [options, setOptions] = useState(optionsForSelect(props.columns, props.formData));\n  const availableColumnSet = useMemo(() => new Set(options.map(({ column_name, filterOptionName }) => column_name != null ? column_name : filterOptionName)), [options]);\n  useEffect(() => {\n    if (datasource && datasource.type === 'table') {var _datasource$database;\n      const dbId = (_datasource$database = datasource.database) == null ? void 0 : _datasource$database.id;\n      const { datasource_name: name, catalog, schema, is_sqllab_view: isSqllabView } = datasource;\n      if (!isSqllabView && dbId && name && schema) {\n        SupersetClient.get({\n          endpoint: `/api/v1/database/${dbId}/table_metadata/extra/${toQueryString({\n            name,\n            catalog,\n            schema\n          })}`\n        }).\n        then(({ json }) => {\n          if (json != null && json.partitions) {\n            const { partitions } = json;\n            // for now only show latest_partition option\n            // when table datasource has only 1 partition key.\n            if (partitions != null && partitions.cols &&\n            Object.keys(partitions.cols).length === 1) {\n              setPartitionColumn(partitions.cols[0]);\n            }\n          }\n        }).\n        catch((error) => {\n          logging.error('fetch extra_table_metadata:', error.statusText);\n        });\n      }\n    }\n  }, [datasource]);\n  useEffect(() => {\n    setOptions(optionsForSelect(props.columns, props.formData));\n  }, [props.columns, props.formData]);\n  useEffect(() => {\n    setValues((props.value || []).map((filter) => isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter));\n  }, [props.value]);\n  const removeValue = useCallback((index) => {\n    const valuesCopy = [...values];\n    valuesCopy.splice(index, 1);\n    setValues(valuesCopy);\n    onChange(valuesCopy);\n  }, [onChange, values]);\n  const onClickClose = useCallback((index) => {\n    const result = canDelete == null ? void 0 : canDelete(values[index], values);\n    if (typeof result === 'string') {\n      warning({ title: t('Warning'), content: result });\n      return;\n    }\n    if (result === true) {\n      removeValue(index);\n    }\n  }, [canDelete, removeValue, values]);\n  const onShiftOptions = useCallback((dragIndex, hoverIndex) => {\n    const newValues = [...values];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    setValues(newValues);\n  }, [values]);\n  const getMetricExpression = useCallback((savedMetricName) => {var _props$savedMetrics$f;return (_props$savedMetrics$f = props.savedMetrics.find((savedMetric) => savedMetric.metric_name === savedMetricName)) == null ? void 0 : _props$savedMetrics$f.expression;}, [props.savedMetrics]);\n  const mapOption = useCallback((option) => {\n    // already a AdhocFilter, skip\n    if (option instanceof AdhocFilter) {\n      return option;\n    }\n    const filterOptions = option;\n    // via datasource saved metric\n    if (filterOptions.saved_metric_name) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Sql,\n        subject: getMetricExpression(filterOptions.saved_metric_name),\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GreaterThan].operation,\n        operatorId: Operators.GreaterThan,\n        comparator: 0,\n        clause: Clauses.Having\n      });\n    }\n    // has a custom label, meaning it's custom column\n    if (filterOptions.label) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Sql,\n        subject: new AdhocMetric(option).translateToSql(),\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GreaterThan].operation,\n        operatorId: Operators.GreaterThan,\n        comparator: 0,\n        clause: Clauses.Having\n      });\n    }\n    // add a new filter item\n    if (filterOptions.column_name) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Simple,\n        subject: filterOptions.column_name,\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.Equals].operation,\n        operatorId: Operators.Equals,\n        comparator: '',\n        clause: Clauses.Where,\n        isNew: true\n      });\n    }\n    return null;\n  }, [datasource.type, getMetricExpression]);\n  const onFilterEdit = useCallback((changedFilter) => {\n    onChange(values.map((value) => {\n      if (value.filterOptionName === changedFilter.filterOptionName) {\n        return changedFilter;\n      }\n      return value;\n    }));\n  }, [onChange, values]);\n  const onNewFilter = useCallback((newFilter) => {\n    const mappedOption = mapOption(newFilter);\n    if (mappedOption) {\n      const newValues = [...values, mappedOption];\n      setValues(newValues);\n      onChange(newValues);\n    }\n  }, [mapOption, onChange, values]);\n  const togglePopover = useCallback((visible) => {\n    setNewFilterPopoverVisible(visible);\n  }, []);\n  const closePopover = useCallback(() => {\n    togglePopover(false);\n  }, [togglePopover]);\n  const valuesRenderer = useCallback(() => values.map((adhocFilter, index) => _jsx(DndAdhocFilterOption, { index: index, adhocFilter: adhocFilter, options: options, datasource: datasource, onFilterEdit: onFilterEdit, partitionColumn: partitionColumn, onClickClose: onClickClose, onShiftOptions: onShiftOptions })), [\n  onClickClose,\n  onFilterEdit,\n  onShiftOptions,\n  options,\n  partitionColumn,\n  datasource,\n  values]\n  );\n  const handleClickGhostButton = useCallback(() => {\n    setDroppedItem({});\n    togglePopover(true);\n  }, [togglePopover]);\n  const defaultTimeFilter = useDefaultTimeFilter();\n  const adhocFilter = useMemo(() => {\n    if (isSavedMetric(droppedItem)) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Sql,\n        clause: Clauses.Having,\n        sqlExpression: droppedItem == null ? void 0 : droppedItem.expression\n      });\n    }\n    if (droppedItem instanceof AdhocMetric) {\n      return new AdhocFilter({\n        expressionType: ExpressionTypes.Sql,\n        clause: Clauses.Having,\n        sqlExpression: droppedItem == null ? void 0 : droppedItem.translateToSql()\n      });\n    }\n    const config = {\n      subject: droppedItem == null ? void 0 : droppedItem.column_name\n    };\n    if (config.subject) {\n      config.operator = OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.In].operation;\n      config.operatorId = Operators.In;\n    }\n    if (isColumnMeta(droppedItem) &&\n    isTemporalColumn(droppedItem == null ? void 0 : droppedItem.column_name, props.datasource)) {\n      config.operator = Operators.TemporalRange;\n      config.operatorId = Operators.TemporalRange;\n      config.comparator = defaultTimeFilter;\n    }\n    return new AdhocFilter(config);\n  }, [droppedItem]);\n  const canDrop = useCallback((item) => {\n    if (extra.disallow_adhoc_metrics && (\n    item.type !== DndItemType.Column ||\n    !availableColumnSet.has(item.value.column_name))) {\n      return false;\n    }\n    if (item.type === DndItemType.Column) {\n      const columnName = item.value.column_name;\n      return availableColumnSet.has(columnName);\n    }\n    return true;\n  }, [availableColumnSet, extra]);\n  const handleDrop = useCallback((item) => {\n    setDroppedItem(item.value);\n    togglePopover(true);\n  }, [controlName, togglePopover]);\n  return _jsxs(_Fragment, { children: [\n    _jsx(DndSelectLabel, { onDrop: handleDrop, canDrop: canDrop, valuesRenderer: valuesRenderer, accept: DND_ACCEPTED_TYPES, ghostButtonText: t('Drop columns/metrics here or click'), onClickGhostButton: handleClickGhostButton, ...props }),\n    _jsx(AdhocFilterPopoverTrigger, { adhocFilter: adhocFilter, options: options, datasource: datasource, onFilterEdit: onNewFilter, partitionColumn: partitionColumn, isControlledComponent: true, visible: newFilterPopoverVisible, togglePopover: togglePopover, closePopover: closePopover, requireSave: !!droppedItem })] }\n  );\n};\nexport { DndFilterSelect };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}