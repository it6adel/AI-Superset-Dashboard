{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { useState, useEffect, useCallback } from 'react';\nimport { makeApi, SupersetClient, t, getClientErrorObject } from '@superset-ui/core';\nimport { createErrorHandler, getAlreadyExists, getPasswordsNeeded, hasTerminalValidation, getSSHPasswordsNeeded, getSSHPrivateKeysNeeded, getSSHPrivateKeyPasswordsNeeded } from 'src/views/CRUD/utils';\nimport copyTextToClipboard from 'src/utils/copy';\nimport SupersetText from 'src/utils/textUtils';\nconst parsedErrorMessage = (errorMessage) => {\n  if (typeof errorMessage === 'string') {\n    return errorMessage;\n  }\n  return Object.entries(errorMessage).\n  map(([key, value]) => {\n    if (Array.isArray(value)) {\n      return `(${key}) ${value.join(', ')}`;\n    }\n    return `(${key}) ${value}`;\n  }).\n  join('\\n');\n};\nexport function useListViewResource(resource, resourceLabel, // resourceLabel for translations\nhandleErrorMsg, infoEnable = true, defaultCollectionValue = [], baseFilters, // must be memoized\ninitialLoadingState = true, selectColumns) {\n  const [state, setState] = useState({\n    count: 0,\n    collection: defaultCollectionValue,\n    loading: initialLoadingState,\n    lastFetchDataConfig: null,\n    permissions: [],\n    bulkSelectEnabled: false\n  });\n  function updateState(update) {\n    setState((currentState) => ({ ...currentState, ...update }));\n  }\n  function toggleBulkSelect() {\n    updateState({ bulkSelectEnabled: !state.bulkSelectEnabled });\n  }\n  useEffect(() => {\n    if (!infoEnable)\n    return;\n    SupersetClient.get({\n      endpoint: `/api/v1/${resource}/_info?q=${rison.encode({\n        keys: ['permissions']\n      })}`\n    }).then(({ json: infoJson = {} }) => {\n      updateState({\n        permissions: infoJson.permissions\n      });\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('An error occurred while fetching %s info: %s', resourceLabel, errMsg))));\n  }, []);\n  function hasPerm(perm) {\n    if (!state.permissions.length) {\n      return false;\n    }\n    return Boolean(state.permissions.find((p) => p === perm));\n  }\n  const fetchData = useCallback(({ pageIndex, pageSize, sortBy, filters: filterValues }) => {\n    // set loading state, cache the last config for refreshing data.\n    updateState({\n      lastFetchDataConfig: {\n        filters: filterValues,\n        pageIndex,\n        pageSize,\n        sortBy\n      },\n      loading: true\n    });\n    const filterExps = (baseFilters || []).\n    concat(filterValues).\n    map(({ id, operator: opr, value }) => ({\n      col: id,\n      opr,\n      value: value && typeof value === 'object' && 'value' in value ?\n      value.value :\n      value\n    }));\n    const queryParams = rison.encode_uri({\n      order_column: sortBy[0].id,\n      order_direction: sortBy[0].desc ? 'desc' : 'asc',\n      page: pageIndex,\n      page_size: pageSize,\n      ...(filterExps.length ? { filters: filterExps } : {}),\n      ...(selectColumns != null && selectColumns.length ? { select_columns: selectColumns } : {})\n    });\n    return SupersetClient.get({\n      endpoint: `/api/v1/${resource}/?q=${queryParams}`\n    }).\n    then(({ json = {} }) => {\n      updateState({\n        collection: json.result,\n        count: json.count,\n        lastFetched: new Date().toISOString()\n      });\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('An error occurred while fetching %ss: %s', resourceLabel, errMsg)))).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [baseFilters]);\n  return {\n    state: {\n      loading: state.loading,\n      resourceCount: state.count,\n      resourceCollection: state.collection,\n      bulkSelectEnabled: state.bulkSelectEnabled,\n      lastFetched: state.lastFetched\n    },\n    setResourceCollection: (update) => updateState({\n      collection: update\n    }),\n    hasPerm,\n    fetchData,\n    toggleBulkSelect,\n    refreshData: (provideConfig) => {\n      if (state.lastFetchDataConfig) {\n        return fetchData(state.lastFetchDataConfig);\n      }\n      if (provideConfig) {\n        return fetchData(provideConfig);\n      }\n      return null;\n    }\n  };\n}\nexport function useSingleViewResource(resourceName, resourceLabel, // resourceLabel for translations\nhandleErrorMsg, path_suffix = '') {\n  const [state, setState] = useState({\n    loading: false,\n    resource: null,\n    error: null\n  });\n  function updateState(update) {\n    setState((currentState) => ({ ...currentState, ...update }));\n  }\n  const fetchResource = useCallback((resourceID) => {\n    // Set loading state\n    updateState({\n      loading: true\n    });\n    const baseEndpoint = `/api/v1/${resourceName}/${resourceID}`;\n    const endpoint = path_suffix !== '' ? `${baseEndpoint}/${path_suffix}` : baseEndpoint;\n    return SupersetClient.get({\n      endpoint\n    }).\n    then(({ json = {} }) => {\n      updateState({\n        resource: json.result,\n        error: null\n      });\n      return json.result;\n    }, createErrorHandler((errMsg) => {\n      handleErrorMsg(t('An error occurred while fetching %ss: %s', resourceLabel, parsedErrorMessage(errMsg)));\n      updateState({\n        error: errMsg\n      });\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [handleErrorMsg, resourceName, resourceLabel]);\n  const createResource = useCallback((resource, hideToast = false) => {\n    // Set loading state\n    updateState({\n      loading: true\n    });\n    return SupersetClient.post({\n      endpoint: `/api/v1/${resourceName}/`,\n      body: JSON.stringify(resource),\n      headers: { 'Content-Type': 'application/json' }\n    }).\n    then(({ json = {} }) => {\n      updateState({\n        resource: { id: json.id, ...json.result },\n        error: null\n      });\n      return json.id;\n    }, createErrorHandler((errMsg) => {\n      // we did not want toasts for db-connection-ui but did not want to disable it everywhere\n      if (!hideToast) {\n        handleErrorMsg(t('An error occurred while creating %ss: %s', resourceLabel, parsedErrorMessage(errMsg)));\n      }\n      updateState({\n        error: errMsg\n      });\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [handleErrorMsg, resourceName, resourceLabel]);\n  const updateResource = useCallback((resourceID, resource, hideToast = false, setLoading = true) => {\n    // Set loading state\n    if (setLoading) {\n      updateState({\n        loading: true\n      });\n    }\n    return SupersetClient.put({\n      endpoint: `/api/v1/${resourceName}/${resourceID}`,\n      body: JSON.stringify(resource),\n      headers: { 'Content-Type': 'application/json' }\n    }).\n    then(({ json = {} }) => {\n      updateState({\n        resource: { ...json.result, id: json.id },\n        error: null\n      });\n      return json.result;\n    }, createErrorHandler((errMsg) => {\n      if (!hideToast) {\n        handleErrorMsg(t('An error occurred while fetching %ss: %s', resourceLabel, JSON.stringify(errMsg)));\n      }\n      updateState({\n        error: errMsg\n      });\n      return errMsg;\n    })).\n    finally(() => {\n      if (setLoading) {\n        updateState({ loading: false });\n      }\n    });\n  }, [handleErrorMsg, resourceName, resourceLabel]);\n  const clearError = () => updateState({\n    error: null\n  });\n  return {\n    state,\n    setResource: (update) => updateState({\n      resource: update\n    }),\n    fetchResource,\n    createResource,\n    updateResource,\n    clearError\n  };\n}\nexport function useImportResource(resourceName, resourceLabel, // resourceLabel for translations\nhandleErrorMsg) {\n  const [state, setState] = useState({\n    loading: false,\n    passwordsNeeded: [],\n    alreadyExists: [],\n    sshPasswordNeeded: [],\n    sshPrivateKeyNeeded: [],\n    sshPrivateKeyPasswordNeeded: [],\n    failed: false\n  });\n  function updateState(update) {\n    setState((currentState) => ({ ...currentState, ...update }));\n  }\n  const importResource = useCallback((bundle, databasePasswords = {}, sshTunnelPasswords = {}, sshTunnelPrivateKey = {}, sshTunnelPrivateKeyPasswords = {}, overwrite = false) => {\n    // Set loading state\n    updateState({\n      loading: true,\n      failed: false\n    });\n    const formData = new FormData();\n    formData.append('formData', bundle);\n    const RE_EXPORT_TEXT = t('Please re-export your file and try importing again');\n    /* The import bundle never contains database passwords; if required\n     * they should be provided by the user during import.\n     */\n    if (databasePasswords) {\n      formData.append('passwords', JSON.stringify(databasePasswords));\n    }\n    /* If the imported model already exists the user needs to confirm\n     * that they want to overwrite it.\n     */\n    if (overwrite) {\n      formData.append('overwrite', 'true');\n    }\n    /* The import bundle may contain ssh tunnel passwords; if required\n     * they should be provided by the user during import.\n     */\n    if (sshTunnelPasswords) {\n      formData.append('ssh_tunnel_passwords', JSON.stringify(sshTunnelPasswords));\n    }\n    /* The import bundle may contain ssh tunnel private_key; if required\n     * they should be provided by the user during import.\n     */\n    if (sshTunnelPrivateKey) {\n      formData.append('ssh_tunnel_private_keys', JSON.stringify(sshTunnelPrivateKey));\n    }\n    /* The import bundle may contain ssh tunnel private_key_password; if required\n     * they should be provided by the user during import.\n     */\n    if (sshTunnelPrivateKeyPasswords) {\n      formData.append('ssh_tunnel_private_key_passwords', JSON.stringify(sshTunnelPrivateKeyPasswords));\n    }\n    return SupersetClient.post({\n      endpoint: `/api/v1/${resourceName}/import/`,\n      body: formData,\n      headers: { Accept: 'application/json' }\n    }).\n    then(() => {\n      updateState({\n        passwordsNeeded: [],\n        alreadyExists: [],\n        sshPasswordNeeded: [],\n        sshPrivateKeyNeeded: [],\n        sshPrivateKeyPasswordNeeded: [],\n        failed: false\n      });\n      return true;\n    }).\n    catch((response) => getClientErrorObject(response).then((error) => {\n      updateState({\n        failed: true\n      });\n      if (!error.errors) {\n        handleErrorMsg(t('An error occurred while importing %s: %s', resourceLabel, error.message || error.error));\n        return false;\n      }\n      if (hasTerminalValidation(error.errors)) {\n        handleErrorMsg(t('An error occurred while importing %s: %s', resourceLabel, [\n        ...error.errors.map((payload) => payload.message),\n        RE_EXPORT_TEXT].\n        join('.\\n')));\n      } else\n      {\n        updateState({\n          passwordsNeeded: getPasswordsNeeded(error.errors),\n          sshPasswordNeeded: getSSHPasswordsNeeded(error.errors),\n          sshPrivateKeyNeeded: getSSHPrivateKeysNeeded(error.errors),\n          sshPrivateKeyPasswordNeeded: getSSHPrivateKeyPasswordsNeeded(error.errors),\n          alreadyExists: getAlreadyExists(error.errors)\n        });\n      }\n      return false;\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, []);\n  return { state, importResource };\n}\nconst favoriteApis = {\n  chart: makeApi({\n    requestType: 'rison',\n    method: 'GET',\n    endpoint: '/api/v1/chart/favorite_status/'\n  }),\n  dashboard: makeApi({\n    requestType: 'rison',\n    method: 'GET',\n    endpoint: '/api/v1/dashboard/favorite_status/'\n  }),\n  tag: makeApi({\n    requestType: 'rison',\n    method: 'GET',\n    endpoint: '/api/v1/tag/favorite_status/'\n  })\n};\nexport function useFavoriteStatus(type, ids, handleErrorMsg) {\n  const [favoriteStatus, setFavoriteStatus] = useState({});\n  const updateFavoriteStatus = (update) => setFavoriteStatus((currentState) => ({ ...currentState, ...update }));\n  useEffect(() => {\n    if (!ids.length) {\n      return;\n    }\n    favoriteApis[type](ids).then(({ result }) => {\n      const update = result.reduce((acc, element) => {\n        acc[element.id] = element.value;\n        return acc;\n      }, {});\n      updateFavoriteStatus(update);\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('There was an error fetching the favorite status: %s', errMsg))));\n  }, [ids, type, handleErrorMsg]);\n  const saveFaveStar = useCallback((id, isStarred) => {\n    const endpoint = `/api/v1/${type}/${id}/favorites/`;\n    const apiCall = isStarred ?\n    SupersetClient.delete({\n      endpoint\n    }) :\n    SupersetClient.post({ endpoint });\n    apiCall.then(() => {\n      updateFavoriteStatus({\n        [id]: !isStarred\n      });\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('There was an error saving the favorite status: %s', errMsg))));\n  }, [type]);\n  return [saveFaveStar, favoriteStatus];\n}\nexport const useChartEditModal = (setCharts, charts) => {\n  const [sliceCurrentlyEditing, setSliceCurrentlyEditing] = useState(null);\n  function openChartEditModal(chart) {\n    setSliceCurrentlyEditing({\n      slice_id: chart.id,\n      slice_name: chart.slice_name,\n      description: chart.description,\n      cache_timeout: chart.cache_timeout,\n      certified_by: chart.certified_by,\n      certification_details: chart.certification_details,\n      is_managed_externally: chart.is_managed_externally\n    });\n  }\n  function closeChartEditModal() {\n    setSliceCurrentlyEditing(null);\n  }\n  function handleChartUpdated(edits) {\n    // update the chart in our state with the edited info\n    const newCharts = charts.map((chart) => chart.id === edits.id ? { ...chart, ...edits } : chart);\n    setCharts(newCharts);\n  }\n  return {\n    sliceCurrentlyEditing,\n    handleChartUpdated,\n    openChartEditModal,\n    closeChartEditModal\n  };\n};\nexport const copyQueryLink = (id, addDangerToast, addSuccessToast) => {\n  copyTextToClipboard(() => Promise.resolve(`${window.location.origin}/sqllab?savedQueryId=${id}`)).\n  then(() => {\n    addSuccessToast(t('Link Copied!'));\n  }).\n  catch(() => {\n    addDangerToast(t('Sorry, your browser does not support copying.'));\n  });\n};\nexport const getDatabaseImages = () => SupersetText.DB_IMAGES;\nexport const getConnectionAlert = () => SupersetText.DB_CONNECTION_ALERTS;\nexport const getDatabaseDocumentationLinks = () => SupersetText.DB_CONNECTION_DOC_LINKS;\nexport const testDatabaseConnection = (connection, handleErrorMsg, addSuccessToast) => {\n  SupersetClient.post({\n    endpoint: 'api/v1/database/test_connection/',\n    body: JSON.stringify(connection),\n    headers: { 'Content-Type': 'application/json' }\n  }).then(() => {\n    addSuccessToast(t('Connection looks good!'));\n  }, createErrorHandler((errMsg) => {\n    handleErrorMsg(t('ERROR: %s', parsedErrorMessage(errMsg)));\n  }));\n};\nexport function useAvailableDatabases() {\n  const [availableDbs, setAvailableDbs] = useState(null);\n  const getAvailable = useCallback(() => {\n    SupersetClient.get({\n      endpoint: `/api/v1/database/available/`\n    }).then(({ json }) => {\n      setAvailableDbs(json);\n    });\n  }, [setAvailableDbs]);\n  return [availableDbs, getAvailable];\n}\nconst transformDB = (db) => {\n  if (db && Array.isArray(db == null ? void 0 : db.catalog)) {\n    return {\n      ...db,\n      catalog: Object.assign({}, ...db.catalog.map((x) => ({\n        [x.name]: x.value\n      })))\n    };\n  }\n  return db;\n};\nexport function useDatabaseValidation() {\n  const [validationErrors, setValidationErrors] = useState(null);\n  const getValidation = useCallback((database, onCreate = false) => {var _database$parameters;\n    if (database != null && (_database$parameters = database.parameters) != null && _database$parameters.ssh) {\n      // TODO: /validate_parameters/ and related utils should support ssh tunnel\n      setValidationErrors(null);\n      return [];\n    }\n    return SupersetClient.post({\n      endpoint: '/api/v1/database/validate_parameters/',\n      body: JSON.stringify(transformDB(database)),\n      headers: { 'Content-Type': 'application/json' }\n    }).\n    then(() => {\n      setValidationErrors(null);\n    })\n    // eslint-disable-next-line consistent-return\n    .catch((e) => {\n      if (typeof e.json === 'function') {\n        return e.json().then(({ errors = [] }) => {\n          const parsedErrors = errors.\n          filter((error) => {\n            const skipValidationError = ![\n            'CONNECTION_MISSING_PARAMETERS_ERROR',\n            'CONNECTION_ACCESS_DENIED_ERROR'].\n            includes(error.error_type);\n            return skipValidationError || onCreate;\n          }).\n          reduce((obj, { error_type, extra, message }) => {var _extra$issue_codes;\n            if (extra.catalog) {\n              if (extra.catalog.name) {\n                return {\n                  ...obj,\n                  error_type,\n                  [extra.catalog.idx]: {\n                    name: message\n                  }\n                };\n              }\n              if (extra.catalog.url) {\n                return {\n                  ...obj,\n                  error_type,\n                  [extra.catalog.idx]: {\n                    url: message\n                  }\n                };\n              }\n              return {\n                ...obj,\n                error_type,\n                [extra.catalog.idx]: {\n                  name: message,\n                  url: message\n                }\n              };\n            }\n            // if extra.invalid doesn't exist then the\n            // error can't be mapped to a parameter\n            // so leave it alone\n            if (extra.invalid) {\n              return {\n                ...obj,\n                [extra.invalid[0]]: message,\n                error_type\n              };\n            }\n            if (extra.missing) {\n              return {\n                ...obj,\n                error_type,\n                ...Object.assign({}, ...extra.missing.map((field) => ({\n                  [field]: 'This is a required field'\n                })))\n              };\n            }\n            if ((_extra$issue_codes = extra.issue_codes) != null && _extra$issue_codes.length) {var _extra$issue_codes$;\n              return {\n                ...obj,\n                error_type,\n                description: message || ((_extra$issue_codes$ = extra.issue_codes[0]) == null ? void 0 : _extra$issue_codes$.message)\n              };\n            }\n            return obj;\n          }, {});\n          setValidationErrors(parsedErrors);\n          return parsedErrors;\n        });\n      }\n      // eslint-disable-next-line no-console\n      console.error(e);\n    });\n  }, [setValidationErrors]);\n  return [validationErrors, getValidation, setValidationErrors];\n}\nexport const reportSelector = (state, resourceType, resourceId) => {\n  if (resourceId) {var _state$reports$resour;\n    return (_state$reports$resour = state.reports[resourceType]) == null ? void 0 : _state$reports$resour[resourceId];\n  }\n  return null;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}