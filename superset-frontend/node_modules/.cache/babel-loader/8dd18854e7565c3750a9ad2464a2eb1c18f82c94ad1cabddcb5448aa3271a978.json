{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, t } from '@superset-ui/core';\n// eslint-disable-next-line no-restricted-imports\nimport AntdSelect from 'antd/lib/select'; // TODO: Remove antd\nimport Icons from 'src/components/Icons';\nimport { StyledHelperText, StyledLoadingText, StyledSpin } from './styles';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";import { createElement as _createElement } from \"@emotion/react\";\nconst { Option } = AntdSelect;\nexport const SELECT_ALL_VALUE = 'Select All';\nexport const selectAllOption = {\n  value: SELECT_ALL_VALUE,\n  label: String(SELECT_ALL_VALUE)\n};\nexport function isObject(value) {\n  return value !== null &&\n  typeof value === 'object' &&\n  Array.isArray(value) === false;\n}\nexport function isLabeledValue(value) {\n  return isObject(value) && 'value' in value && 'label' in value;\n}\nexport function getValue(option) {\n  return isLabeledValue(option) ? option.value : option;\n}\nexport function isEqual(a, b, key) {\n  const actualA = isObject(a) && key in a ? a[key] : a;\n  const actualB = isObject(b) && key in b ? b[key] : b;\n  // When comparing the values we use the equality\n  // operator to automatically convert different types\n  // eslint-disable-next-line eqeqeq\n  return actualA == actualB;\n}\nexport function getOption(value, options, checkLabel = false) {\n  const optionsArray = ensureIsArray(options);\n  return optionsArray.find((x) => isEqual(x, value, 'value') || checkLabel && isEqual(x, value, 'label'));\n}\nexport function hasOption(value, options, checkLabel = false) {\n  return getOption(value, options, checkLabel) !== undefined;\n}\n/**\n * It creates a comparator to check for a specific property.\n * Can be used with string and number property values.\n * */\nexport const propertyComparator = (property) => (a, b) => {\n  const propertyA = a[property];\n  const propertyB = b[property];\n  if (typeof propertyA === 'string' && typeof propertyB === 'string') {\n    return propertyA.localeCompare(propertyB);\n  }\n  if (typeof propertyA === 'number' && typeof propertyB === 'number') {\n    return propertyA - propertyB;\n  }\n  return String(propertyA).localeCompare(String(propertyB)); // fallback to string comparison\n};\nexport const sortSelectedFirstHelper = (a, b, selectValue) => selectValue && a.value !== undefined && b.value !== undefined ?\nNumber(hasOption(b.value, selectValue)) -\nNumber(hasOption(a.value, selectValue)) :\n0;\nexport const sortComparatorWithSearchHelper = (a, b, inputValue, sortCallback, sortComparator) => sortCallback(a, b) || sortComparator(a, b, inputValue);\nexport const sortComparatorForNoSearchHelper = (a, b, sortCallback, sortComparator) => sortCallback(a, b) || sortComparator(a, b, '');\n// use a function instead of component since every rerender of the\n// Select component will create a new component\nexport const getSuffixIcon = (isLoading, showSearch, isDropdownVisible) => {\n  if (isLoading) {\n    return _jsx(StyledSpin, { size: \"small\" });\n  }\n  if (showSearch && isDropdownVisible) {\n    return _jsx(Icons.SearchOutlined, { iconSize: \"s\" });\n  }\n  return _jsx(Icons.DownOutlined, { iconSize: \"s\" });\n};\nexport const dropDownRenderHelper = (originNode, isDropdownVisible, isLoading, optionsLength, helperText, errorComponent) => {\n  if (!isDropdownVisible) {var _originNode$ref, _originNode$ref$curre;\n    (_originNode$ref = originNode.ref) == null ? void 0 : (_originNode$ref$curre = _originNode$ref.current) == null ? void 0 : _originNode$ref$curre.scrollTo({ top: 0 });\n  }\n  if (isLoading && optionsLength === 0) {\n    return _jsx(StyledLoadingText, { children: t('Loading...') });\n  }\n  if (errorComponent) {\n    return errorComponent;\n  }\n  return _jsxs(_Fragment, { children: [\n    helperText && _jsx(StyledHelperText, { role: \"note\", children: helperText }),\n    originNode] }\n  );\n};\nexport const handleFilterOptionHelper = (search, option, optionFilterProps, filterOption) => {\n  if (typeof filterOption === 'function') {\n    return filterOption(search, option);\n  }\n  if (filterOption) {\n    const searchValue = search.trim().toLowerCase();\n    if (optionFilterProps != null && optionFilterProps.length) {\n      return optionFilterProps.some((prop) => {\n        const optionProp = option != null && option[prop] ?\n        String(option[prop]).\n        trim().\n        toLowerCase() :\n        '';\n        return optionProp.includes(searchValue);\n      });\n    }\n  }\n  return false;\n};\nexport const hasCustomLabels = (options) => options == null ? void 0 : options.some((opt) => !!(opt != null && opt.customLabel));\nexport const renderSelectOptions = (options) => options.map((opt) => {\n  const isOptObject = typeof opt === 'object';\n  const label = isOptObject ? (opt == null ? void 0 : opt.label) || opt.value : opt;\n  const value = isOptObject ? opt.value : opt;\n  const { customLabel, ...optProps } = opt;\n  return _createElement(Option, { ...optProps, key: value, label: label, value: value },\n  isOptObject && customLabel ? customLabel : label\n  );\n});\nexport const mapValues = (values, labelInValue) => labelInValue ?\nvalues.map((opt) => ({\n  key: opt.value,\n  value: opt.value,\n  label: opt.label\n})) :\nvalues.map((opt) => opt.value);\nexport const mapOptions = (values) => values.map((opt) => ({\n  children: opt.label,\n  key: opt.value,\n  ...opt\n}));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}