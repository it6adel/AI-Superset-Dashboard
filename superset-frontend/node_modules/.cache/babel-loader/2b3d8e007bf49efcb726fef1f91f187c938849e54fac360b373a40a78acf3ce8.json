{"ast":null,"code":"import _cloneDeep from \"lodash/cloneDeep\";import _isEqual from \"lodash/isEqual\";import _snakeCase from \"lodash/snakeCase\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport PropTypes from 'prop-types';\nimport { createRef, Component } from 'react';\nimport {\n  SuperChart,\n  logging,\n  Behavior,\n  t,\n  getChartMetadataRegistry,\n  VizType,\n  isFeatureEnabled,\n  FeatureFlag } from\n'@superset-ui/core';\nimport { Logger, LOG_ACTIONS_RENDER_CHART } from 'src/logger/LogUtils';\nimport { EmptyState } from 'src/components/EmptyState';\nimport { ChartSource } from 'src/types/ChartSource';\nimport ChartContextMenu from './ChartContextMenu/ChartContextMenu';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nconst propTypes = {\n  annotationData: PropTypes.object,\n  actions: PropTypes.object,\n  chartId: PropTypes.number.isRequired,\n  datasource: PropTypes.object,\n  initialValues: PropTypes.object,\n  formData: PropTypes.object.isRequired,\n  latestQueryFormData: PropTypes.object,\n  labelsColor: PropTypes.object,\n  labelsColorMap: PropTypes.object,\n  height: PropTypes.number,\n  width: PropTypes.number,\n  setControlValue: PropTypes.func,\n  vizType: PropTypes.string.isRequired,\n  triggerRender: PropTypes.bool,\n  // state\n  chartAlert: PropTypes.string,\n  chartStatus: PropTypes.string,\n  queriesResponse: PropTypes.arrayOf(PropTypes.object),\n  triggerQuery: PropTypes.bool,\n  chartIsStale: PropTypes.bool,\n  // dashboard callbacks\n  addFilter: PropTypes.func,\n  setDataMask: PropTypes.func,\n  onFilterMenuOpen: PropTypes.func,\n  onFilterMenuClose: PropTypes.func,\n  ownState: PropTypes.object,\n  postTransformProps: PropTypes.func,\n  source: PropTypes.oneOf([ChartSource.Dashboard, ChartSource.Explore]),\n  emitCrossFilters: PropTypes.bool\n};\n\nconst BLANK = {};\n\nconst BIG_NO_RESULT_MIN_WIDTH = 300;\nconst BIG_NO_RESULT_MIN_HEIGHT = 220;\n\nconst behaviors = [Behavior.InteractiveChart];\n\nconst defaultProps = {\n  addFilter: () => BLANK,\n  onFilterMenuOpen: () => BLANK,\n  onFilterMenuClose: () => BLANK,\n  initialValues: BLANK,\n  setControlValue() {},\n  triggerRender: false\n};\n\nclass ChartRenderer extends Component {\n  constructor(props) {var _getChartMetadataRegi, _props$formData$viz_t;\n    super(props);\n    const suppressContextMenu = (_getChartMetadataRegi = getChartMetadataRegistry().get((_props$formData$viz_t =\n    props.formData.viz_type) != null ? _props$formData$viz_t : props.vizType\n    )) == null ? void 0 : _getChartMetadataRegi.suppressContextMenu;\n    this.state = {\n      showContextMenu:\n      props.source === ChartSource.Dashboard &&\n      !suppressContextMenu &&\n      isFeatureEnabled(FeatureFlag.DrillToDetail),\n      inContextMenu: false,\n      legendState: undefined\n    };\n    this.hasQueryResponseChange = false;\n\n    this.contextMenuRef = /*#__PURE__*/createRef();\n\n    this.handleAddFilter = this.handleAddFilter.bind(this);\n    this.handleRenderSuccess = this.handleRenderSuccess.bind(this);\n    this.handleRenderFailure = this.handleRenderFailure.bind(this);\n    this.handleSetControlValue = this.handleSetControlValue.bind(this);\n    this.handleOnContextMenu = this.handleOnContextMenu.bind(this);\n    this.handleContextMenuSelected = this.handleContextMenuSelected.bind(this);\n    this.handleContextMenuClosed = this.handleContextMenuClosed.bind(this);\n    this.handleLegendStateChanged = this.handleLegendStateChanged.bind(this);\n    this.onContextMenuFallback = this.onContextMenuFallback.bind(this);\n\n    this.hooks = {\n      onAddFilter: this.handleAddFilter,\n      onContextMenu: this.state.showContextMenu ?\n      this.handleOnContextMenu :\n      undefined,\n      onError: this.handleRenderFailure,\n      setControlValue: this.handleSetControlValue,\n      onFilterMenuOpen: this.props.onFilterMenuOpen,\n      onFilterMenuClose: this.props.onFilterMenuClose,\n      onLegendStateChanged: this.handleLegendStateChanged,\n      setDataMask: (dataMask) => {var _this$props$actions;\n        (_this$props$actions = this.props.actions) == null ? void 0 : _this$props$actions.updateDataMask(this.props.chartId, dataMask);\n      }\n    };\n\n    // TODO: queriesResponse comes from Redux store but it's being edited by\n    // the plugins, hence we need to clone it to avoid state mutation\n    // until we change the reducers to use Redux Toolkit with Immer\n    this.mutableQueriesResponse = _cloneDeep(this.props.queriesResponse);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {var _nextProps$queriesRes, _nextProps$queriesRes2;\n    const resultsReady =\n    nextProps.queriesResponse &&\n    ['success', 'rendered'].indexOf(nextProps.chartStatus) > -1 &&\n    !((_nextProps$queriesRes = nextProps.queriesResponse) != null && (_nextProps$queriesRes2 = _nextProps$queriesRes[0]) != null && _nextProps$queriesRes2.error);\n\n    if (resultsReady) {\n      if (!_isEqual(this.state, nextState)) {\n        return true;\n      }\n      this.hasQueryResponseChange =\n      nextProps.queriesResponse !== this.props.queriesResponse;\n\n      if (this.hasQueryResponseChange) {\n        this.mutableQueriesResponse = _cloneDeep(nextProps.queriesResponse);\n      }\n\n      return (\n        this.hasQueryResponseChange ||\n        !_isEqual(nextProps.datasource, this.props.datasource) ||\n        nextProps.annotationData !== this.props.annotationData ||\n        nextProps.ownState !== this.props.ownState ||\n        nextProps.filterState !== this.props.filterState ||\n        nextProps.height !== this.props.height ||\n        nextProps.width !== this.props.width ||\n        nextProps.triggerRender ||\n        nextProps.labelsColor !== this.props.labelsColor ||\n        nextProps.labelsColorMap !== this.props.labelsColorMap ||\n        nextProps.formData.color_scheme !== this.props.formData.color_scheme ||\n        nextProps.formData.stack !== this.props.formData.stack ||\n        nextProps.cacheBusterProp !== this.props.cacheBusterProp ||\n        nextProps.emitCrossFilters !== this.props.emitCrossFilters);\n\n    }\n    return false;\n  }\n\n  handleAddFilter(col, vals, merge = true, refresh = true) {\n    this.props.addFilter(col, vals, merge, refresh);\n  }\n\n  handleRenderSuccess() {\n    const { actions, chartStatus, chartId, vizType } = this.props;\n    if (['loading', 'rendered'].indexOf(chartStatus) < 0) {\n      actions.chartRenderingSucceeded(chartId);\n    }\n\n    // only log chart render time which is triggered by query results change\n    // currently we don't log chart re-render time, like window resize etc\n    if (this.hasQueryResponseChange) {\n      actions.logEvent(LOG_ACTIONS_RENDER_CHART, {\n        slice_id: chartId,\n        viz_type: vizType,\n        start_offset: this.renderStartTime,\n        ts: new Date().getTime(),\n        duration: Logger.getTimestamp() - this.renderStartTime\n      });\n    }\n  }\n\n  handleRenderFailure(error, info) {\n    const { actions, chartId } = this.props;\n    logging.warn(error);\n    actions.chartRenderingFailed(\n      error.toString(),\n      chartId,\n      info ? info.componentStack : null\n    );\n\n    // only trigger render log when query is changed\n    if (this.hasQueryResponseChange) {\n      actions.logEvent(LOG_ACTIONS_RENDER_CHART, {\n        slice_id: chartId,\n        has_err: true,\n        error_details: error.toString(),\n        start_offset: this.renderStartTime,\n        ts: new Date().getTime(),\n        duration: Logger.getTimestamp() - this.renderStartTime\n      });\n    }\n  }\n\n  handleSetControlValue(...args) {\n    const { setControlValue } = this.props;\n    if (setControlValue) {\n      setControlValue(...args);\n    }\n  }\n\n  handleOnContextMenu(offsetX, offsetY, filters) {\n    this.contextMenuRef.current.open(offsetX, offsetY, filters);\n    this.setState({ inContextMenu: true });\n  }\n\n  handleContextMenuSelected() {\n    this.setState({ inContextMenu: false });\n  }\n\n  handleContextMenuClosed() {\n    this.setState({ inContextMenu: false });\n  }\n\n  handleLegendStateChanged(legendState) {\n    this.setState({ legendState });\n  }\n\n  // When viz plugins don't handle `contextmenu` event, fallback handler\n  // calls `handleOnContextMenu` with no `filters` param.\n  onContextMenuFallback(event) {\n    if (!this.state.inContextMenu) {\n      event.preventDefault();\n      this.handleOnContextMenu(event.clientX, event.clientY);\n    }\n  }\n\n  render() {var _getChartMetadataRegi2;\n    const { chartAlert, chartStatus, chartId, emitCrossFilters } = this.props;\n\n    // Skip chart rendering\n    if (chartStatus === 'loading' || !!chartAlert || chartStatus === null) {\n      return null;\n    }\n\n    this.renderStartTime = Logger.getTimestamp();\n\n    const {\n      width,\n      height,\n      datasource,\n      annotationData,\n      initialValues,\n      ownState,\n      filterState,\n      chartIsStale,\n      formData,\n      latestQueryFormData,\n      postTransformProps\n    } = this.props;\n\n    const currentFormData =\n    chartIsStale && latestQueryFormData ? latestQueryFormData : formData;\n    const vizType = currentFormData.viz_type || this.props.vizType;\n\n    // It's bad practice to use unprefixed `vizType` as classnames for chart\n    // container. It may cause css conflicts as in the case of legacy table chart.\n    // When migrating charts, we should gradually add a `superset-chart-` prefix\n    // to each one of them.\n    const snakeCaseVizType = _snakeCase(vizType);\n    const chartClassName =\n    vizType === VizType.Table ?\n    `superset-chart-${snakeCaseVizType}` :\n    snakeCaseVizType;\n\n    const webpackHash =\n    process.env.WEBPACK_MODE === 'development' ?\n    `-${\n    // eslint-disable-next-line camelcase\n    typeof __webpack_require__ !== 'undefined' &&\n    // eslint-disable-next-line camelcase, no-undef\n    typeof __webpack_require__.h === 'function' &&\n    // eslint-disable-next-line no-undef, camelcase\n    __webpack_require__.h()}` :\n\n    '';\n\n    let noResultsComponent;\n    const noResultTitle = t('No results were returned for this query');\n    const noResultDescription =\n    this.props.source === ChartSource.Explore ?\n    t(\n      'Make sure that the controls are configured properly and the datasource contains data for the selected time range'\n    ) :\n    undefined;\n    const noResultImage = 'chart.svg';\n    if (width > BIG_NO_RESULT_MIN_WIDTH && height > BIG_NO_RESULT_MIN_HEIGHT) {\n      noResultsComponent =\n      _jsx(EmptyState, {\n        size: \"large\",\n        title: noResultTitle,\n        description: noResultDescription,\n        image: noResultImage }\n      );\n\n    } else {\n      noResultsComponent =\n      _jsx(EmptyState, { size: \"small\", title: noResultTitle, image: noResultImage });\n\n    }\n\n    // Check for Behavior.DRILL_TO_DETAIL to tell if chart can receive Drill to\n    // Detail props or if it'll cause side-effects (e.g. excessive re-renders).\n    const drillToDetailProps = (_getChartMetadataRegi2 = getChartMetadataRegistry().\n    get(formData.viz_type)) != null && _getChartMetadataRegi2.\n    behaviors.find((behavior) => behavior === Behavior.DrillToDetail) ?\n    { inContextMenu: this.state.inContextMenu } :\n    {};\n\n    return (\n      _jsxs(_Fragment, { children: [\n        this.state.showContextMenu &&\n        _jsx(ChartContextMenu, {\n          ref: this.contextMenuRef,\n          id: chartId,\n          formData: currentFormData,\n          onSelection: this.handleContextMenuSelected,\n          onClose: this.handleContextMenuClosed }\n        ),\n\n        _jsx(\"div\", {\n          onContextMenu:\n          this.state.showContextMenu ? this.onContextMenuFallback : undefined, children:\n\n\n          _jsx(SuperChart, {\n            disableErrorBoundary: true,\n\n            id: `chart-id-${chartId}`,\n            className: chartClassName,\n            chartType: vizType,\n            width: width,\n            height: height,\n            annotationData: annotationData,\n            datasource: datasource,\n            initialValues: initialValues,\n            formData: currentFormData,\n            ownState: ownState,\n            filterState: filterState,\n            hooks: this.hooks,\n            behaviors: behaviors,\n            queriesData: this.mutableQueriesResponse,\n            onRenderSuccess: this.handleRenderSuccess,\n            onRenderFailure: this.handleRenderFailure,\n            noResults: noResultsComponent,\n            postTransformProps: postTransformProps,\n            emitCrossFilters: emitCrossFilters,\n            legendState: this.state.legendState, ...\n            drillToDetailProps }, `${chartId}${webpackHash}`\n          ) }\n        )] }\n      ));\n\n  }\n}\n\nChartRenderer.propTypes = propTypes;\nChartRenderer.defaultProps = defaultProps;\n\nexport default ChartRenderer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}