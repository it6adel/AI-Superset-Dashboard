{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AnnotationOpacity, isTimeseriesAnnotationResult } from '@superset-ui/core';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum, LegendOrientation, OrientationType } from '../types';\nimport { evalFormula, extractRecordAnnotations, formatAnnotationLabel, parseAnnotationOpacity } from '../utils/annotation';\nimport { getChartPadding, getTimeCompareStackId } from '../utils/series';\nimport { OpacityEnum, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (series, seriesType) => {\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value) => value != null ? value : 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta = i > 0 ?\n      getVal(series[j][i][1]) - getVal(series[j][i - 1][1]) :\n      getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n        i > 0 ?\n        getVal(series[k][i][1]) - getVal(series[k][i - 1][1]) :\n        getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else\n    {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all',\n    type: 'line',\n    lineStyle: {\n      opacity: 0\n    },\n    tooltip: {\n      show: false\n    },\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0\n    },\n    step: [\n    EchartsTimeseriesSeriesType.Start,\n    EchartsTimeseriesSeriesType.Middle,\n    EchartsTimeseriesSeriesType.End].\n    includes(seriesType) ?\n    seriesType :\n    undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth\n  };\n};\nexport function transformSeries(series, colorScale, colorScaleKey, opts) {var _opts$lineStyle;\n  const { name } = series;\n  const { area, connectNulls, filterState, seriesContexts = {}, markerEnabled, markerSize, areaOpacity = 1, seriesType, stack, stackIdSuffix, yAxisIndex = 0, showValue, onlyTotal, formatter, legendState, totalStackedValues = [], showValueIndexes = [], thresholdValues = [], richTooltip, seriesKey, sliceId, isHorizontal = false, queryIndex = 0, timeCompare = [], timeShiftColor } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast = contexts.includes(ForecastSeriesEnum.ForecastTrend) ||\n  contexts.includes(ForecastSeriesEnum.ForecastLower) ||\n  contexts.includes(ForecastSeriesEnum.ForecastUpper);\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand = forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n  forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered = (filterState == null ? void 0 : filterState.selectedValues) && !(filterState != null && filterState.selectedValues.includes(name));\n  const opacity = isFiltered ?\n  OpacityEnum.SemiTransparent :\n  ((_opts$lineStyle = opts.lineStyle) == null ? void 0 : _opts$lineStyle.opacity) || OpacityEnum.NonTransparent;\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand)\n  return undefined;\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else\n  if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore, we need to set something that is truthy.\n    stackId = getTimeCompareStackId('obs', timeCompare, name);\n  } else\n  if (stack && isTrend) {\n    stackId = getTimeCompareStackId(forecastSeries.type, timeCompare, name);\n  }\n  if (stackId && stackIdSuffix) {\n    stackId += stackIdSuffix;\n  }\n  let plotType;\n  if (!isConfidenceBand && (\n  seriesType === 'scatter' || hasForecast && isObservation)) {\n    plotType = 'scatter';\n  } else\n  if (isConfidenceBand) {\n    plotType = 'line';\n  } else\n  {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  /**\n   * if timeShiftColor is enabled the colorScaleKey forces the color to be the\n   * same as the original series, otherwise uses separate colors\n   * */\n  const itemStyle = {\n    color: timeShiftColor ?\n    colorScale(colorScaleKey, sliceId) :\n    colorScale(seriesKey || forecastSeries.name, sliceId),\n    opacity,\n    borderWidth: 0\n  };\n  if (seriesType === 'bar' && connectNulls) {\n    itemStyle.borderWidth = 1.5;\n    itemStyle.borderType = 'dotted';\n    itemStyle.borderColor = itemStyle.color;\n  }\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else\n    if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1\n        }\n      };\n    } else\n    if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle = isConfidenceBand || stack === StackControlsValue.Stream && area ?\n  { ...opts.lineStyle, opacity: OpacityEnum.Transparent } :\n  { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    connectNulls,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: ['start', 'middle', 'end'].includes(seriesType) ?\n    seriesType :\n    undefined,\n    stack: stackId,\n    stackStrategy: isConfidenceBand || stack === StackControlsValue.Stream ?\n    'all' :\n    'samesign',\n    lineStyle,\n    areaStyle: area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper ?\n    {\n      opacity: opacity * areaOpacity\n    } :\n    undefined,\n    emphasis,\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params) => {\n        // don't show confidence band value labels, as they're already visible on the tooltip\n        if ([\n        ForecastSeriesEnum.ForecastUpper,\n        ForecastSeriesEnum.ForecastLower].\n        includes(forecastSeries.type)) {\n          return '';\n        }\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (numericValue >= (\n          thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      }\n    }\n  };\n}\nexport function transformFormulaAnnotation(layer, data, xAxisCol, xAxisType, colorScale, sliceId, orientation) {\n  const { name, color, opacity, width, style } = layer;\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId)\n    },\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style,\n      width\n    },\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType).map(([x, y]) => isHorizontal ? [y, x] : [x, y]),\n    symbolSize: 0\n  };\n}\nexport function transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const isHorizontal = orientation === OrientationType.Horizontal;\n    const intervalData = [\n    [\n    {\n      name: label,\n      ...(isHorizontal ? { yAxis: time } : { xAxis: time })\n    },\n    isHorizontal ? { yAxis: intervalEnd } : { xAxis: intervalEnd }]];\n\n\n    const intervalLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideTop',\n      verticalAlign: 'top',\n      fontWeight: 'bold',\n      // @ts-ignore\n      emphasis: {\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    } :\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      // @ts-ignore\n      emphasis: {\n        fontWeight: 'bold',\n        show: true,\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    };\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8\n          }\n        },\n        label: intervalLabel,\n        data: intervalData\n      }\n    });\n  });\n  return series;\n}\nexport function transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const isHorizontal = orientation === OrientationType.Horizontal;\n    const eventData = [\n    {\n      name: label,\n      ...(isHorizontal ? { yAxis: time } : { xAxis: time })\n    }];\n\n    const lineStyle = {\n      width,\n      type: style,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1\n      }\n    };\n    const eventLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      fontWeight: 'bold',\n      formatter: (params) => params.name,\n      // @ts-ignore\n      emphasis: {\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    } :\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      // @ts-ignore\n      emphasis: {\n        formatter: (params) => params.name,\n        fontWeight: 'bold',\n        show: true,\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    };\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData\n      }\n    });\n  });\n  return series;\n}\nexport function transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId, orientation) {\n  const series = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach((annotation) => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map(({ x, y }) => isHorizontal ?\n        [y, x] :\n        [x, y]),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId)\n        }\n      });\n    });\n  }\n  return series;\n}\nexport function getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, margin, addXAxisTitleOffset, yAxisTitlePosition, yAxisTitleMargin, xAxisTitleMargin, isHorizontal) {\n  const yAxisOffset = addYAxisTitleOffset ?\n  TIMESERIES_CONSTANTS.yAxisLabelTopOffset :\n  0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n  return getChartPadding(showLegend, legendOrientation, margin, {\n    top: yAxisTitlePosition && yAxisTitlePosition === 'Top' ?\n    TIMESERIES_CONSTANTS.gridOffsetTop + (Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetTop + yAxisOffset,\n    bottom: zoomable && !isHorizontal ?\n    TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset :\n    TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n    left: yAxisTitlePosition === 'Left' ?\n    TIMESERIES_CONSTANTS.gridOffsetLeft + (\n    Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetLeft,\n    right: showLegend && legendOrientation === LegendOrientation.Right ?\n    0 :\n    TIMESERIES_CONSTANTS.gridOffsetRight\n  }, isHorizontal);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}