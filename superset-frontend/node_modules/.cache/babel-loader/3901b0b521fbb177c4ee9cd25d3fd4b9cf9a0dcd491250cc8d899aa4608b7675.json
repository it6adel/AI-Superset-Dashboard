{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useSelector, useDispatch, shallowEqual, useStore } from 'react-redux';\nimport { getExtensionsRegistry, t } from '@superset-ui/core';\nimport sqlKeywords from 'src/SqlLab/utils/sqlKeywords';\nimport { addTable, addDangerToast } from 'src/SqlLab/actions/sqlLab';\nimport { SCHEMA_AUTOCOMPLETE_SCORE, TABLE_AUTOCOMPLETE_SCORE, COLUMN_AUTOCOMPLETE_SCORE, SQL_FUNCTIONS_AUTOCOMPLETE_SCORE } from 'src/SqlLab/constants';\nimport { schemaEndpoints, tableEndpoints, skipToken } from 'src/hooks/apiResources';\nimport { api } from 'src/hooks/apiResources/queryApi';\nimport { useDatabaseFunctionsQuery } from 'src/hooks/apiResources/databaseFunctions';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nconst EMPTY_LIST = [];\nconst { useQueryState: useSchemasQueryState } = schemaEndpoints.schemas;\nconst { useQueryState: useTablesQueryState } = tableEndpoints.tables;\nconst getHelperText = (value) => value.length > 30 && {\n  docText: value\n};\nconst extensionsRegistry = getExtensionsRegistry();\nexport function useKeywords({ queryEditorId, dbId, catalog, schema }, skip = false) {\n  const useCustomKeywords = extensionsRegistry.get('sqleditor.extension.customAutocomplete');\n  const customKeywords = useCustomKeywords == null ? void 0 : useCustomKeywords({\n    queryEditorId: String(queryEditorId),\n    dbId,\n    catalog,\n    schema\n  });\n  const dispatch = useDispatch();\n  const hasFetchedKeywords = useRef(false);\n  // skipFetch is used to prevent re-evaluating memoized keywords\n  // due to updated api results by skip flag\n  const skipFetch = hasFetchedKeywords && skip;\n  const { currentData: schemaOptions } = useSchemasQueryState({\n    dbId,\n    catalog: catalog || undefined,\n    forceRefresh: false\n  }, { skip: skipFetch || !dbId });\n  const { currentData: tableData } = useTablesQueryState({\n    dbId,\n    catalog,\n    schema,\n    forceRefresh: false\n  }, { skip: skipFetch || !dbId || !schema });\n  const { currentData: functionNames, isError } = useDatabaseFunctionsQuery({ dbId }, { skip: skipFetch || !dbId });\n  useEffect(() => {\n    if (isError) {\n      dispatch(addDangerToast(t('An error occurred while fetching function names.')));\n    }\n  }, [dispatch, isError]);\n  const tablesForColumnMetadata = useSelector(({ sqlLab }) => {var _sqlLab$tables;return skip ?\n    [] :\n    ((_sqlLab$tables = sqlLab == null ? void 0 : sqlLab.tables) != null ? _sqlLab$tables : []).\n    filter((table) => table.queryEditorId === queryEditorId).\n    map((table) => table.name);}, shallowEqual);\n  const store = useStore();\n  const apiState = store.getState()[api.reducerPath];\n  const allColumns = useMemo(() => {\n    const columns = new Set();\n    tablesForColumnMetadata.forEach((table) => {var _tableEndpoints$table, _tableEndpoints$table2;\n      (_tableEndpoints$table = tableEndpoints.tableMetadata.\n      select(dbId && schema ?\n      {\n        dbId,\n        catalog,\n        schema,\n        table\n      } :\n      skipToken)({\n        [api.reducerPath]: apiState\n      }).\n      data) == null ? void 0 : (_tableEndpoints$table2 = _tableEndpoints$table.columns) == null ? void 0 : _tableEndpoints$table2.forEach(({ name }) => {\n        columns.add(name);\n      });\n    });\n    return [...columns];\n  }, [dbId, catalog, schema, apiState, tablesForColumnMetadata]);\n  const insertMatch = useEffectEvent((editor, data) => {\n    if (data.meta === 'table') {\n      dispatch(addTable({ id: queryEditorId, dbId }, data.value, catalog, schema));\n    }\n    let { caption } = data;\n    if (data.meta === 'table' && caption.includes(' ')) {\n      caption = `\"${caption}\"`;\n    }\n    // executing https://github.com/thlorenz/brace/blob/3a00c5d59777f9d826841178e1eb36694177f5e6/ext/language_tools.js#L1448\n    editor.completer.insertMatch(`${caption}${['function', 'schema'].includes(data.meta) ? '' : ' '}`);\n  });\n  const schemaKeywords = useMemo(() => (schemaOptions != null ? schemaOptions : []).map((s) => ({\n    name: s.label,\n    value: s.value,\n    score: SCHEMA_AUTOCOMPLETE_SCORE,\n    meta: 'schema',\n    completer: {\n      insertMatch\n    },\n    ...getHelperText(s.value)\n  })), [schemaOptions, insertMatch]);\n  const tableKeywords = useMemo(() => {var _tableData$options;return ((_tableData$options = tableData == null ? void 0 : tableData.options) != null ? _tableData$options : []).map(({ value, label }) => ({\n      name: label,\n      value,\n      score: TABLE_AUTOCOMPLETE_SCORE,\n      meta: 'table',\n      completer: {\n        insertMatch\n      },\n      ...getHelperText(value)\n    }));}, [tableData == null ? void 0 : tableData.options, insertMatch]);\n  const columnKeywords = useMemo(() => allColumns.map((col) => ({\n    name: col,\n    value: col,\n    score: COLUMN_AUTOCOMPLETE_SCORE,\n    meta: 'column',\n    ...getHelperText(col)\n  })), [allColumns]);\n  const functionKeywords = useMemo(() => (functionNames != null ? functionNames : []).map((func) => ({\n    name: func,\n    value: func,\n    score: SQL_FUNCTIONS_AUTOCOMPLETE_SCORE,\n    meta: 'function',\n    completer: {\n      insertMatch\n    },\n    ...getHelperText(func)\n  })), [functionNames, insertMatch]);\n  const keywords = useMemo(() => columnKeywords.\n  concat(schemaKeywords).\n  concat(tableKeywords).\n  concat(functionKeywords).\n  concat(sqlKeywords).\n  concat(customKeywords != null ? customKeywords : []), [\n  schemaKeywords,\n  tableKeywords,\n  columnKeywords,\n  functionKeywords,\n  customKeywords]\n  );\n  hasFetchedKeywords.current = !skip;\n  return skip ? EMPTY_LIST : keywords;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}