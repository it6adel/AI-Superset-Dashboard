{"ast":null,"code":"import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { forwardRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport { ensureIsArray, formatNumber, NumberFormats, t, usePrevious } from '@superset-ui/core';\n// eslint-disable-next-line no-restricted-imports\nimport AntdSelect from 'antd/lib/select'; // TODO: Remove antd\n\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, sortSelectedFirstHelper, sortComparatorWithSearchHelper, handleFilterOptionHelper, dropDownRenderHelper, getSuffixIcon, SELECT_ALL_VALUE, selectAllOption, mapValues, mapOptions, hasCustomLabels, getOption, isObject, isEqual as utilsIsEqual } from './utils';\nimport { StyledCheckOutlined, StyledContainer, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst Select = /*#__PURE__*/forwardRef(({ allowClear, allowNewOptions = false, allowSelectAll = true, ariaLabel, autoClearSearchValue = false, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, labelInValue = false, loading, mode = 'single', name, notFoundContent, onBlur, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props }, ref) => {\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = allowNewOptions ? true : showSearch;\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const { Option } = AntdSelect;\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValue), [selectValue]);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const initialOptions = useMemo(() => Array.isArray(options) ? options.slice() : EMPTY_OPTIONS, [options]);\n  const initialOptionsSorted = useMemo(() => initialOptions.slice().sort(sortSelectedFirst), [initialOptions, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(initialOptionsSorted);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    // check to see if selectOptions are grouped\n    let groupedOptions;\n    if (selectOptions.some((opt) => opt.options)) {\n      groupedOptions = selectOptions.reduce((acc, group) => [...acc, ...group.options], []);\n    }\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), groupedOptions || selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    const result = missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n    return result.filter((opt) => opt.value !== SELECT_ALL_VALUE);\n  }, [selectOptions, selectValue]);\n  const enabledOptions = useMemo(() => fullSelectOptions.filter((option) => !option.disabled), [fullSelectOptions]);\n  const selectAllEligible = useMemo(() => fullSelectOptions.filter((option) => hasOption(option.value, selectValue) || !option.disabled), [fullSelectOptions, selectValue]);\n  const selectAllEnabled = useMemo(() => !isSingleMode &&\n  allowSelectAll &&\n  selectOptions.length > 0 &&\n  enabledOptions.length > 1 &&\n  !inputValue, [\n  isSingleMode,\n  allowSelectAll,\n  selectOptions.length,\n  enabledOptions.length,\n  inputValue]\n  );\n  const selectAllMode = useMemo(() => ensureIsArray(selectValue).length === selectAllEligible.length + 1, [selectValue, selectAllEligible]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      // on select is fired in single value mode if the same value is selected\n      const valueChanged = !utilsIsEqual(selectedItem, selectValue, 'value');\n      setSelectValue(selectedItem);\n      if (valueChanged) {\n        fireOnChange();\n      }\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        // Tokenized values can contain duplicated values\n        if (value === getValue(SELECT_ALL_VALUE)) {\n          if (isLabeledValue(selectedItem)) {\n            return [\n            ...selectAllEligible,\n            selectAllOption];\n\n          }\n          return [\n          SELECT_ALL_VALUE,\n          ...selectAllEligible.map((opt) => opt.value)];\n\n        }\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          if (result.length === selectAllEligible.length &&\n          selectAllEnabled) {\n            return isLabeledValue(selectedItem) ?\n            [...result, selectAllOption] :\n            [...result, SELECT_ALL_VALUE];\n          }\n          return result;\n        }\n        return previousState;\n      });\n      fireOnChange();\n    }\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const clear = () => {\n    if (isSingleMode) {\n      setSelectValue(undefined);\n    } else\n    {\n      setSelectValue(fullSelectOptions.\n      filter((option) => option.disabled && hasOption(option.value, selectValue)).\n      map((option) => labelInValue ?\n      { label: option.label, value: option.value } :\n      option.value));\n    }\n    fireOnChange();\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      if (getValue(value) === getValue(SELECT_ALL_VALUE)) {\n        clear();\n      } else\n      {\n        let array = selectValue;\n        array = array.filter((element) => getValue(element) !== getValue(value));\n        // if this was not a new item, deselect select all option\n        if (selectAllMode && !option.isNewOption) {\n          array = array.filter((element) => getValue(element) !== SELECT_ALL_VALUE);\n        }\n        setSelectValue(array);\n        // removes new option\n        if (option.isNewOption) {\n          setSelectOptions(fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value)));\n        }\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const handleOnSearch = _debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true\n      };\n      const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      const newOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(newOptions);\n    }\n    setInputValue(searchValue);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      if (!_isEqual(initialOptionsSorted, selectOptions)) {\n        setSelectOptions(initialOptionsSorted);\n      }\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText);\n  const handleClear = () => {\n    clear();\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    setSelectOptions(initialOptions);\n  }, [initialOptions]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  useEffect(() => {\n    // if all values are selected, add select all to value\n    if (selectAllEnabled &&\n    ensureIsArray(value).length === selectAllEligible.length) {\n      setSelectValue(labelInValue ?\n      [...ensureIsArray(value), selectAllOption] :\n      [...ensureIsArray(value), SELECT_ALL_VALUE]);\n    }\n  }, [labelInValue, selectAllEligible.length, selectAllEnabled, value]);\n  useEffect(() => {\n    const checkSelectAll = ensureIsArray(selectValue).some((v) => getValue(v) === SELECT_ALL_VALUE);\n    if (checkSelectAll && !selectAllMode) {\n      const optionsToSelect = selectAllEligible.map((option) => labelInValue ? option : option.value);\n      optionsToSelect.push(labelInValue ? selectAllOption : SELECT_ALL_VALUE);\n      setSelectValue(optionsToSelect);\n      fireOnChange();\n    }\n  }, [\n  selectValue,\n  selectAllMode,\n  labelInValue,\n  selectAllEligible,\n  fireOnChange]\n  );\n  const selectAllLabel = useMemo(() => () =>\n  // TODO: localize\n  `${SELECT_ALL_VALUE} (${formatNumber(NumberFormats.INTEGER, selectAllEligible.length)})`, [selectAllEligible]);\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  const handleOnChange = useCallback((values, options) => {\n    // intercept onChange call to handle the select all case\n    // if the \"select all\" option is selected, we want to send all options to the onChange,\n    // otherwise we want to remove\n    let newValues = values;\n    let newOptions = options;\n    if (!isSingleMode) {\n      if (ensureIsArray(newValues).some((val) => getValue(val) === SELECT_ALL_VALUE)) {\n        // send all options to onchange if all are not currently there\n        if (!selectAllMode) {\n          newValues = mapValues(selectAllEligible, labelInValue);\n          newOptions = mapOptions(selectAllEligible);\n        } else\n        {\n          newValues = ensureIsArray(values).filter((val) => getValue(val) !== SELECT_ALL_VALUE);\n        }\n      } else\n      if (ensureIsArray(values).length === selectAllEligible.length &&\n      selectAllMode) {\n        const array = selectAllEligible.filter((option) => hasOption(option.value, selectValue) && option.disabled);\n        newValues = mapValues(array, labelInValue);\n        newOptions = mapOptions(array);\n      }\n    }\n    onChange == null ? void 0 : onChange(newValues, newOptions);\n  }, [\n  isSingleMode,\n  labelInValue,\n  onChange,\n  selectAllEligible,\n  selectAllMode,\n  selectValue]\n  );\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        handleOnChange(selectValue, selectValue ? options[0] : undefined);\n      } else\n      {\n        handleOnChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  handleOnChange,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]\n  );\n  const shouldRenderChildrenOptions = useMemo(() => selectAllEnabled || hasCustomLabels(options), [selectAllEnabled, options]);\n  const omittedCount = useMemo(() => {\n    const num_selected = ensureIsArray(selectValue).length;\n    const num_shown = maxTagCount;\n    return num_selected - num_shown - (selectAllMode ? 1 : 0);\n  }, [maxTagCount, selectAllMode, selectValue]);\n  const customMaxTagPlaceholder = () => `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n  // We can't remove the + tag so when Select All\n  // is the only item omitted, we subtract one from maxTagCount\n  let actualMaxTagCount = maxTagCount;\n  if (actualMaxTagCount !== 'responsive' &&\n  omittedCount === 0 &&\n  selectAllMode) {\n    actualMaxTagCount -= 1;\n  }\n  const getPastedTextValue = useCallback((text) => {\n    const option = getOption(text, fullSelectOptions, true);\n    if (!option && !allowNewOptions) {\n      return undefined;\n    }\n    if (labelInValue) {\n      const value = {\n        label: text,\n        value: text\n      };\n      if (option) {\n        value.label = isObject(option) ? option.label : option;\n        value.value = isObject(option) ? option.value : option;\n      }\n      return value;\n    }\n    return option ? isObject(option) ? option.value : option : text;\n  }, [allowNewOptions, fullSelectOptions, labelInValue]);\n  const onPaste = (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      const value = getPastedTextValue(pastedText);\n      if (value) {\n        setSelectValue(value);\n      }\n    } else\n    {\n      const token = tokenSeparators.find((token) => pastedText.includes(token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      const values = array.\n      map((item) => getPastedTextValue(item)).\n      filter((item) => item !== undefined);\n      if (labelInValue) {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...values]\n        );\n      } else\n      {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...values]\n        );\n      }\n    }\n    fireOnChange();\n  };\n  return _jsxs(StyledContainer, { headerPosition: headerPosition, children: [\n    header && _jsx(StyledHeader, { headerPosition: headerPosition, children: header }),\n    _jsxs(StyledSelect, { id: name, allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: labelInValue, maxTagCount: actualMaxTagCount, maxTagPlaceholder: customMaxTagPlaceholder, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n      // @ts-ignore\n      , onPaste: onPaste, onPopupScroll: undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, shouldShowSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? _jsx(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : _jsx(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), options: shouldRenderChildrenOptions ? undefined : fullSelectOptions, oneLine: oneLine, tagRender: customTagRender, ...props, ref: ref, children: [\n      selectAllEnabled && _jsx(Option, { id: \"select-all\", className: \"select-all\", value: SELECT_ALL_VALUE, children:\n        selectAllLabel() }, SELECT_ALL_VALUE\n      ),\n      shouldRenderChildrenOptions &&\n      renderSelectOptions(fullSelectOptions)] }\n    )] }\n  );\n});\nexport default Select;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}