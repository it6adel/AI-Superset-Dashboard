{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter, NumberFormats, t, getValueFormatter, tooltipHtml } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA as DEFAULT_PIE_FORM_DATA, EchartsPieLabelType } from './types';\nimport { DEFAULT_LEGEND_FORM_DATA, OpacityEnum } from '../constants';\nimport { extractGroupbyLabel, getChartPadding, getColtypesMapping, getLegendProps, sanitizeHtml } from '../utils/series';\nimport { defaultGrid } from '../defaults';\nimport { convertInteger } from '../utils/convertInteger';\nimport { getDefaultTooltip } from '../utils/tooltip';\nconst percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\nexport function parseParams({ params, numberFormatter, sanitizeName = false }) {\n  const { name: rawName = '', value, percent } = params;\n  const name = sanitizeName ? sanitizeHtml(rawName) : rawName;\n  const formattedValue = numberFormatter(value);\n  const formattedPercent = percentFormatter(percent / 100);\n  return [name, formattedValue, formattedPercent];\n}\nfunction getTotalValuePadding({ chartPadding, donut, width, height }) {\n  const padding = {\n    top: donut ? 'middle' : '0',\n    left: 'center'\n  };\n  const LEGEND_HEIGHT = 15;\n  const LEGEND_WIDTH = 215;\n  if (chartPadding.top) {\n    padding.top = donut ?\n    `${50 + (chartPadding.top - LEGEND_HEIGHT) / height / 2 * 100}%` :\n    `${(chartPadding.top + LEGEND_HEIGHT) / height * 100}%`;\n  }\n  if (chartPadding.bottom) {\n    padding.top = donut ?\n    `${50 - (chartPadding.bottom + LEGEND_HEIGHT) / height / 2 * 100}%` :\n    '0';\n  }\n  if (chartPadding.left) {\n    padding.left = `${50 + (chartPadding.left - LEGEND_WIDTH) / width / 2 * 100}%`;\n  }\n  if (chartPadding.right) {\n    padding.left = `${50 - (chartPadding.right + LEGEND_WIDTH) / width / 2 * 100}%`;\n  }\n  return padding;\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters, datasource } = chartProps;\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, donut, groupby, innerRadius, labelsOutside, labelLine, labelType, labelTemplate, legendMargin, legendOrientation, legendType, metric = '', numberFormat, currencyFormat, dateFormat, outerRadius, showLabels, showLegend, showLabelsThreshold, sliceId, showTotal, roseType } = {\n    ...DEFAULT_LEGEND_FORM_DATA,\n    ...DEFAULT_PIE_FORM_DATA,\n    ...formData\n  };\n  const refs = {};\n  const metricLabel = getMetricLabel(metric);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const keys = data.map((datum) => extractGroupbyLabel({\n    datum,\n    groupby: groupbyLabels,\n    coltypeMapping,\n    timeFormatter: getTimeFormatter(dateFormat)\n  }));\n  const labelMap = data.reduce((acc, datum) => {\n    const label = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    return {\n      ...acc,\n      [label]: groupbyLabels.map((col) => datum[col])\n    };\n  }, {});\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat, currencyFormat);\n  let totalValue = 0;\n  const transformedData = data.map((datum) => {\n    const name = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    const isFiltered = filterState.selectedValues && !filterState.selectedValues.includes(name);\n    const value = datum[metricLabel];\n    if (typeof value === 'number' || typeof value === 'string') {\n      totalValue += convertInteger(value);\n    }\n    return {\n      value,\n      name,\n      itemStyle: {\n        color: colorFn(name, sliceId),\n        opacity: isFiltered ?\n        OpacityEnum.SemiTransparent :\n        OpacityEnum.NonTransparent\n      }\n    };\n  });\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = transformedData.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  const formatTemplate = (template, formattedParams, rawParams) => {\n    // This function supports two forms of template variables:\n    // 1. {name}, {value}, {percent}, for values formatted by number formatter.\n    // 2. {a}, {b}, {c}, {d}, compatible with ECharts formatter.\n    //\n    // \\n is supported to represent a new line.\n    const items = {\n      '{name}': formattedParams.name,\n      '{value}': formattedParams.value,\n      '{percent}': formattedParams.percent,\n      '{a}': rawParams.seriesName || '',\n      '{b}': rawParams.name,\n      '{c}': `${rawParams.value}`,\n      '{d}': `${rawParams.percent}`,\n      '\\\\n': '\\n'\n    };\n    return Object.entries(items).reduce((acc, [key, value]) => acc.replaceAll(key, value), template);\n  };\n  const formatter = (params) => {\n    const [name, formattedValue, formattedPercent] = parseParams({\n      params,\n      numberFormatter\n    });\n    switch (labelType) {\n      case EchartsPieLabelType.Key:\n        return name;\n      case EchartsPieLabelType.Value:\n        return formattedValue;\n      case EchartsPieLabelType.Percent:\n        return formattedPercent;\n      case EchartsPieLabelType.KeyValue:\n        return `${name}: ${formattedValue}`;\n      case EchartsPieLabelType.KeyValuePercent:\n        return `${name}: ${formattedValue} (${formattedPercent})`;\n      case EchartsPieLabelType.KeyPercent:\n        return `${name}: ${formattedPercent}`;\n      case EchartsPieLabelType.ValuePercent:\n        return `${formattedValue} (${formattedPercent})`;\n      case EchartsPieLabelType.Template:\n        if (!labelTemplate) {\n          return '';\n        }\n        return formatTemplate(labelTemplate, {\n          name,\n          value: formattedValue,\n          percent: formattedPercent\n        }, params);\n      default:\n        return name;\n    }\n  };\n  const defaultLabel = {\n    formatter,\n    show: showLabels,\n    color: theme.colors.grayscale.dark2\n  };\n  const chartPadding = getChartPadding(showLegend, legendOrientation, legendMargin);\n  const series = [\n  {\n    type: 'pie',\n    ...chartPadding,\n    animation: false,\n    roseType: roseType || undefined,\n    radius: [`${donut ? innerRadius : 0}%`, `${outerRadius}%`],\n    center: ['50%', '50%'],\n    avoidLabelOverlap: true,\n    labelLine: labelsOutside && labelLine ? { show: true } : { show: false },\n    minShowLabelAngle,\n    label: labelsOutside ?\n    {\n      ...defaultLabel,\n      position: 'outer',\n      alignTo: 'none',\n      bleedMargin: 5\n    } :\n    {\n      ...defaultLabel,\n      position: 'inner'\n    },\n    emphasis: {\n      label: {\n        show: true,\n        fontWeight: 'bold',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    },\n    data: transformedData\n  }];\n\n  const echartOptions = {\n    grid: {\n      ...defaultGrid\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params) => {\n        const [name, formattedValue, formattedPercent] = parseParams({\n          params,\n          numberFormatter,\n          sanitizeName: true\n        });\n        return tooltipHtml([[metricLabel, formattedValue, formattedPercent]], name);\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: keys\n    },\n    graphic: showTotal ?\n    {\n      type: 'text',\n      ...getTotalValuePadding({ chartPadding, donut, width, height }),\n      style: {\n        text: t('Total: %s', numberFormatter(totalValue)),\n        fontSize: 16,\n        fontWeight: 'bold'\n      },\n      z: 10\n    } :\n    null,\n    series\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    labelMap,\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    emitCrossFilters,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}