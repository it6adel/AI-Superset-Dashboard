{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport tinycolor from 'tinycolor2';\nconst rgbRegex = /^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\nexport function getContrastingColor(color, thresholds = 186) {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  if (color.length > 7) {\n    // rgb\n    const matchColor = rgbRegex.exec(color);\n    if (!matchColor) {\n      throw new Error(`Invalid color: ${color}`);\n    }\n    r = parseInt(matchColor[1], 10);\n    g = parseInt(matchColor[2], 10);\n    b = parseInt(matchColor[3], 10);\n  } else\n  {\n    // hex\n    let hex = color;\n    if (hex.startsWith('#')) {\n      hex = hex.substring(1);\n    }\n    // #FFF\n    if (hex.length === 3) {\n      hex = [hex[0], hex[0], hex[1], hex[1], hex[2], hex[2]].join('');\n    }\n    if (hex.length !== 6) {\n      throw new Error(`Invalid color: ${color}`);\n    }\n    r = parseInt(hex.slice(0, 2), 16);\n    g = parseInt(hex.slice(2, 4), 16);\n    b = parseInt(hex.slice(4, 6), 16);\n  }\n  return r * 0.299 + g * 0.587 + b * 0.114 > thresholds ? '#000' : '#FFF';\n}\nexport function getAnalogousColors(colors, results) {\n  const generatedColors = [];\n  const ext = 3;\n  const analogousColors = colors.map((color) => {\n    // returns an array of tinycolor instances\n    const result = tinycolor(color).analogous(results + ext);\n    // remove the first three colors to avoid the same or very close colors\n    return result.slice(ext);\n  });\n  // [[A, AA, AAA], [B, BB, BBB]] => [A, B, AA, BB, AAA, BBB]\n  while ((_analogousColors = analogousColors[analogousColors.length - 1]) != null && _analogousColors.length) {var _analogousColors;\n    analogousColors.forEach((colors) => {\n      const color = colors.shift();\n      generatedColors.push(color.toHexString());\n    });\n  }\n  return generatedColors;\n}\nexport function addAlpha(color, opacity) {\n  // opacity value should be between 0 and 1.\n  if (opacity > 1 || opacity < 0) {\n    throw new Error(`The opacity should between 0 and 1, but got: ${opacity}`);\n  }\n  // the alpha value is between 00 - FF\n  const alpha = `0${Math.round(opacity * 255).\n  toString(16).\n  toUpperCase()}`.slice(-2);\n  return `${color}${alpha}`;\n}\nexport function hexToRgb(h) {\n  let r = '0';\n  let g = '0';\n  let b = '0';\n  // 3 digits\n  if (h.length === 4) {\n    r = `0x${h[1]}${h[1]}`;\n    g = `0x${h[2]}${h[2]}`;\n    b = `0x${h[3]}${h[3]}`;\n    // 6 digits\n  } else\n  if (h.length === 7) {\n    r = `0x${h[1]}${h[2]}`;\n    g = `0x${h[3]}${h[4]}`;\n    b = `0x${h[5]}${h[6]}`;\n  }\n  return `rgb(${+r}, ${+g}, ${+b})`;\n}\nexport function rgbToHex(red, green, blue) {\n  let r = red.toString(16);\n  let g = green.toString(16);\n  let b = blue.toString(16);\n  if (r.length === 1)\n  r = `0${r}`;\n  if (g.length === 1)\n  g = `0${g}`;\n  if (b.length === 1)\n  b = `0${b}`;\n  return `#${r}${g}${b}`;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}