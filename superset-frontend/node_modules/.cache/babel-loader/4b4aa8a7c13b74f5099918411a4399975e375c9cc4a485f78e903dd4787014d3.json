{"ast":null,"code":"import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ActionCreators as UndoActionCreators } from 'redux-undo';\nimport rison from 'rison';\nimport {\n  ensureIsArray,\n  isFeatureEnabled,\n  FeatureFlag,\n  getLabelsColorMap,\n  SupersetClient,\n  t,\n  getClientErrorObject,\n  getCategoricalSchemeRegistry,\n  promiseTimeout } from\n'@superset-ui/core';\nimport {\n  addChart,\n  removeChart,\n  refreshChart } from\n'src/components/Chart/chartAction';\nimport { chart as initChart } from 'src/components/Chart/chartReducer';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport {\n  SAVE_TYPE_OVERWRITE,\n  SAVE_TYPE_OVERWRITE_CONFIRMED } from\n'src/dashboard/util/constants';\nimport {\n  getCrossFiltersConfiguration,\n  isCrossFiltersEnabled } from\n'src/dashboard/util/crossFilters';\nimport {\n  addSuccessToast,\n  addWarningToast,\n  addDangerToast } from\n'src/components/MessageToasts/actions';\nimport serializeActiveFilterValues from 'src/dashboard/util/serializeActiveFilterValues';\nimport serializeFilterScopes from 'src/dashboard/util/serializeFilterScopes';\nimport { getActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { logEvent } from 'src/logger/actions';\nimport { LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA } from 'src/logger/LogUtils';\n\nimport { UPDATE_COMPONENTS_PARENTS_LIST } from './dashboardLayout';\nimport {\n  saveChartConfiguration,\n  dashboardInfoChanged,\n  SAVE_CHART_CONFIG_COMPLETE } from\n'./dashboardInfo';\nimport { fetchDatasourceMetadata, setDatasources } from './datasources';\nimport { updateDirectPathToFilter } from './dashboardFilters';\nimport { SET_IN_SCOPE_STATUS_OF_FILTERS } from './nativeFilters';\nimport getOverwriteItems from '../util/getOverwriteItems';\nimport {\n  applyColors,\n  enforceSharedLabelsColorsArray,\n  isLabelsColorMapSynced,\n  getColorSchemeDomain,\n  getColorNamespace,\n  getFreshLabelsColorMapEntries,\n  getFreshSharedLabels,\n  getDynamicLabelsColors } from\n'../../utils/colorScheme';\n\nexport const SET_UNSAVED_CHANGES = 'SET_UNSAVED_CHANGES';\nexport function setUnsavedChanges(hasUnsavedChanges) {\n  return { type: SET_UNSAVED_CHANGES, payload: { hasUnsavedChanges } };\n}\n\nexport const ADD_SLICE = 'ADD_SLICE';\nexport function addSlice(slice) {\n  return { type: ADD_SLICE, slice };\n}\n\nexport const REMOVE_SLICE = 'REMOVE_SLICE';\nexport function removeSlice(sliceId) {\n  return { type: REMOVE_SLICE, sliceId };\n}\n\nexport const TOGGLE_FAVE_STAR = 'TOGGLE_FAVE_STAR';\nexport function toggleFaveStar(isStarred) {\n  return { type: TOGGLE_FAVE_STAR, isStarred };\n}\n\nexport function fetchFaveStar(id) {\n  return function fetchFaveStarThunk(dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/dashboard/favorite_status/?q=${rison.encode([id])}`\n    }).\n    then(({ json }) => {var _json$result, _json$result$;\n      dispatch(toggleFaveStar(!!(json != null && (_json$result = json.result) != null && (_json$result$ = _json$result[0]) != null && _json$result$.value)));\n    }).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'There was an issue fetching the favorite status of this dashboard.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function saveFaveStar(id, isStarred) {\n  return function saveFaveStarThunk(dispatch) {\n    const endpoint = `/api/v1/dashboard/${id}/favorites/`;\n    const apiCall = isStarred ?\n    SupersetClient.delete({\n      endpoint\n    }) :\n    SupersetClient.post({ endpoint });\n\n    return apiCall.\n    then(() => {\n      dispatch(toggleFaveStar(!isStarred));\n    }).\n    catch(() =>\n    dispatch(\n      addDangerToast(t('There was an issue favoriting this dashboard.'))\n    )\n    );\n  };\n}\n\nexport const TOGGLE_PUBLISHED = 'TOGGLE_PUBLISHED';\nexport function togglePublished(isPublished) {\n  return { type: TOGGLE_PUBLISHED, isPublished };\n}\n\nexport function savePublished(id, isPublished) {\n  return function savePublishedThunk(dispatch) {\n    return SupersetClient.put({\n      endpoint: `/api/v1/dashboard/${id}`,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        published: isPublished\n      })\n    }).\n    then(() => {\n      dispatch(\n        addSuccessToast(\n          isPublished ?\n          t('This dashboard is now published') :\n          t('This dashboard is now hidden')\n        )\n      );\n      dispatch(togglePublished(isPublished));\n    }).\n    catch(() => {\n      dispatch(\n        addDangerToast(\n          t('You do not have permissions to edit this dashboard.')\n        )\n      );\n    });\n  };\n}\n\nexport const TOGGLE_EXPAND_SLICE = 'TOGGLE_EXPAND_SLICE';\nexport function toggleExpandSlice(sliceId) {\n  return { type: TOGGLE_EXPAND_SLICE, sliceId };\n}\n\nexport const UPDATE_CSS = 'UPDATE_CSS';\nexport function updateCss(css) {\n  return { type: UPDATE_CSS, css };\n}\n\nexport const SET_EDIT_MODE = 'SET_EDIT_MODE';\nexport function setEditMode(editMode) {\n  return { type: SET_EDIT_MODE, editMode };\n}\n\nexport const ON_CHANGE = 'ON_CHANGE';\nexport function onChange() {\n  return { type: ON_CHANGE };\n}\n\nexport const ON_SAVE = 'ON_SAVE';\nexport function onSave(lastModifiedTime) {\n  return { type: ON_SAVE, lastModifiedTime };\n}\n\nexport const SET_REFRESH_FREQUENCY = 'SET_REFRESH_FREQUENCY';\nexport function setRefreshFrequency(refreshFrequency, isPersistent = false) {\n  return { type: SET_REFRESH_FREQUENCY, refreshFrequency, isPersistent };\n}\n\nexport function saveDashboardRequestSuccess(lastModifiedTime) {\n  return (dispatch) => {\n    dispatch(onSave(lastModifiedTime));\n    // clear layout undo history\n    dispatch(UndoActionCreators.clearHistory());\n  };\n}\n\nexport const SET_OVERRIDE_CONFIRM = 'SET_OVERRIDE_CONFIRM';\nexport function setOverrideConfirm(overwriteConfirmMetadata) {\n  return {\n    type: SET_OVERRIDE_CONFIRM,\n    overwriteConfirmMetadata\n  };\n}\n\nexport const SAVE_DASHBOARD_STARTED = 'SAVE_DASHBOARD_STARTED';\nexport function saveDashboardStarted() {\n  return { type: SAVE_DASHBOARD_STARTED };\n}\n\nexport const SAVE_DASHBOARD_FINISHED = 'SAVE_DASHBOARD_FINISHED';\nexport function saveDashboardFinished() {\n  return { type: SAVE_DASHBOARD_FINISHED };\n}\n\nexport const SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE =\n'SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE';\nexport const SET_DASHBOARD_LABELS_COLORMAP_SYNCED =\n'SET_DASHBOARD_LABELS_COLORMAP_SYNCED';\nexport const SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE =\n'SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE';\nexport const SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED =\n'SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED';\n\nexport function setDashboardLabelsColorMapSync() {\n  return { type: SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE };\n}\n\nexport function setDashboardLabelsColorMapSynced() {\n  return { type: SET_DASHBOARD_LABELS_COLORMAP_SYNCED };\n}\n\nexport function setDashboardSharedLabelsColorsSync() {\n  return { type: SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE };\n}\n\nexport function setDashboardSharedLabelsColorsSynced() {\n  return { type: SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED };\n}\n\nexport const setDashboardMetadata =\n(updatedMetadata) => async (dispatch, getState) => {\n  const { dashboardInfo } = getState();\n  dispatch(\n    dashboardInfoChanged({\n      metadata: {\n        ...((dashboardInfo == null ? void 0 : dashboardInfo.metadata) || {}),\n        ...updatedMetadata\n      }\n    })\n  );\n};\n\nexport function saveDashboardRequest(data, id, saveType) {\n  return (dispatch, getState) => {var _data$metadata, _data$metadata2, _data$metadata3, _data$metadata4, _data$metadata5, _data$metadata6, _data$metadata7, _data$metadata8;\n    dispatch({ type: UPDATE_COMPONENTS_PARENTS_LIST });\n    dispatch(saveDashboardStarted());\n\n    const { dashboardFilters, dashboardLayout } = getState();\n    const layout = dashboardLayout.present;\n    Object.values(dashboardFilters).forEach((filter) => {var _layout$componentId;\n      const { chartId } = filter;\n      const componentId = filter.directPathToFilter.slice().pop();\n      const directPathToFilter = (((_layout$componentId = layout[componentId]) == null ? void 0 : _layout$componentId.parents) || []).slice();\n      directPathToFilter.push(componentId);\n      dispatch(updateDirectPathToFilter(chartId, directPathToFilter));\n    });\n    // serialize selected values for each filter field, grouped by filter id\n    const serializedFilters = serializeActiveFilterValues(getActiveFilters());\n    // serialize filter scope for each filter field, grouped by filter id\n    const serializedFilterScopes = serializeFilterScopes(dashboardFilters);\n    const {\n      certified_by,\n      certification_details,\n      css,\n      dashboard_title,\n      owners,\n      roles,\n      slug\n    } = data;\n\n    const hasId = (item) => item.id !== undefined;\n    const metadataCrossFiltersEnabled = (_data$metadata = data.metadata) == null ? void 0 : _data$metadata.cross_filters_enabled;\n    const colorScheme = (_data$metadata2 = data.metadata) == null ? void 0 : _data$metadata2.color_scheme;\n    const customLabelsColor = ((_data$metadata3 = data.metadata) == null ? void 0 : _data$metadata3.label_colors) || {};\n    const sharedLabelsColor = enforceSharedLabelsColorsArray((_data$metadata4 =\n    data.metadata) == null ? void 0 : _data$metadata4.shared_label_colors\n    );\n    const cleanedData = {\n      ...data,\n      certified_by: certified_by || '',\n      certification_details:\n      certified_by && certification_details ? certification_details : '',\n      css: css || '',\n      dashboard_title: dashboard_title || t('[ untitled dashboard ]'),\n      owners: ensureIsArray(owners).map((o) => hasId(o) ? o.id : o),\n      roles: !isFeatureEnabled(FeatureFlag.DashboardRbac) ?\n      undefined :\n      ensureIsArray(roles).map((r) => hasId(r) ? r.id : r),\n      slug: slug || null,\n      metadata: {\n        ...data.metadata,\n        color_namespace: getColorNamespace((_data$metadata5 = data.metadata) == null ? void 0 : _data$metadata5.color_namespace),\n        color_scheme: colorScheme || '',\n        color_scheme_domain: colorScheme ?\n        getColorSchemeDomain(colorScheme) :\n        [],\n        expanded_slices: ((_data$metadata6 = data.metadata) == null ? void 0 : _data$metadata6.expanded_slices) || {},\n        label_colors: customLabelsColor,\n        shared_label_colors: getFreshSharedLabels(sharedLabelsColor),\n        map_label_colors: getFreshLabelsColorMapEntries(customLabelsColor),\n        refresh_frequency: ((_data$metadata7 = data.metadata) == null ? void 0 : _data$metadata7.refresh_frequency) || 0,\n        timed_refresh_immune_slices:\n        ((_data$metadata8 = data.metadata) == null ? void 0 : _data$metadata8.timed_refresh_immune_slices) || [],\n        // cross-filters should be enabled by default\n        cross_filters_enabled: isCrossFiltersEnabled(\n          metadataCrossFiltersEnabled\n        )\n      }\n    };\n\n    const handleChartConfiguration = () => {\n      const {\n        dashboardLayout,\n        charts,\n        dashboardInfo: { metadata }\n      } = getState();\n      return getCrossFiltersConfiguration(\n        dashboardLayout.present,\n        metadata,\n        charts\n      );\n    };\n\n    const onCopySuccess = (response) => {\n      const lastModifiedTime = response.json.result.last_modified_time;\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      const { chartConfiguration, globalChartConfiguration } =\n      handleChartConfiguration();\n      dispatch(\n        saveChartConfiguration({\n          chartConfiguration,\n          globalChartConfiguration\n        })\n      );\n      dispatch(saveDashboardFinished());\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      return response;\n    };\n\n    const onUpdateSuccess = (response) => {\n      const updatedDashboard = response.json.result;\n      const lastModifiedTime = response.json.last_modified_time;\n      // syncing with the backend transformations of the metadata\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        dispatch(setDashboardMetadata(metadata));\n        if (metadata.chart_configuration) {\n          dispatch({\n            type: SAVE_CHART_CONFIG_COMPLETE,\n            chartConfiguration: metadata.chart_configuration\n          });\n        }\n        if (metadata.native_filter_configuration) {\n          dispatch({\n            type: SET_IN_SCOPE_STATUS_OF_FILTERS,\n            filterConfig: metadata.native_filter_configuration\n          });\n        }\n\n        // fetch datasets to make sure they are up to date\n        SupersetClient.get({\n          endpoint: `/api/v1/dashboard/${id}/datasets`,\n          headers: { 'Content-Type': 'application/json' }\n        }).then(({ json }) => {var _json$result2;\n          const datasources = (_json$result2 = json == null ? void 0 : json.result) != null ? _json$result2 : [];\n          if (datasources.length) {\n            dispatch(setDatasources(datasources));\n          }\n        });\n      }\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      dispatch(saveDashboardFinished());\n      // redirect to the new slug or id\n      window.history.pushState(\n        { event: 'dashboard_properties_changed' },\n        '',\n        `/superset/dashboard/${slug || id}/`\n      );\n\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      dispatch(setOverrideConfirm(undefined));\n      return response;\n    };\n\n    const onError = async (response) => {\n      const { error, message } = await getClientErrorObject(response);\n      let errorText = t('Sorry, an unknown error occurred');\n\n      if (error) {\n        errorText = t(\n          'Sorry, there was an error saving this dashboard: %s',\n          error\n        );\n      }\n      if (typeof message === 'string' && message === 'Forbidden') {\n        errorText = t('You do not have permission to edit this dashboard');\n      }\n      dispatch(saveDashboardFinished());\n      dispatch(addDangerToast(errorText));\n    };\n\n    if (\n    [SAVE_TYPE_OVERWRITE, SAVE_TYPE_OVERWRITE_CONFIRMED].includes(saveType))\n    {\n      const { chartConfiguration, globalChartConfiguration } =\n      handleChartConfiguration();\n      const updatedDashboard =\n      saveType === SAVE_TYPE_OVERWRITE_CONFIRMED ?\n      data :\n      {\n        certified_by: cleanedData.certified_by,\n        certification_details: cleanedData.certification_details,\n        css: cleanedData.css,\n        dashboard_title: cleanedData.dashboard_title,\n        slug: cleanedData.slug,\n        owners: cleanedData.owners,\n        roles: cleanedData.roles,\n        json_metadata: safeStringify({\n          ...((cleanedData == null ? void 0 : cleanedData.metadata) || {}),\n          default_filters: safeStringify(serializedFilters),\n          filter_scopes: serializedFilterScopes,\n          chart_configuration: chartConfiguration,\n          global_chart_configuration: globalChartConfiguration\n        })\n      };\n\n      const updateDashboard = () =>\n      SupersetClient.put({\n        endpoint: `/api/v1/dashboard/${id}`,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(updatedDashboard)\n      }).\n      then((response) => onUpdateSuccess(response)).\n      catch((response) => onError(response));\n      return new Promise((resolve, reject) => {\n        if (\n        !isFeatureEnabled(FeatureFlag.ConfirmDashboardDiff) ||\n        saveType === SAVE_TYPE_OVERWRITE_CONFIRMED)\n        {\n          // skip overwrite precheck\n          resolve();\n          return;\n        }\n\n        // precheck for overwrite items\n        SupersetClient.get({\n          endpoint: `/api/v1/dashboard/${id}`\n        }).then((response) => {\n          const dashboard = response.json.result;\n          const overwriteConfirmItems = getOverwriteItems(\n            dashboard,\n            updatedDashboard\n          );\n          if (overwriteConfirmItems.length > 0) {\n            dispatch(\n              setOverrideConfirm({\n                updatedAt: dashboard.changed_on,\n                updatedBy: dashboard.changed_by_name,\n                overwriteConfirmItems,\n                dashboardId: id,\n                data: updatedDashboard\n              })\n            );\n            return reject(overwriteConfirmItems);\n          }\n          return resolve();\n        });\n      }).\n      then(updateDashboard).\n      catch((overwriteConfirmItems) => {\n        const errorText = t('Please confirm the overwrite values.');\n        dispatch(\n          logEvent(LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA, {\n            dashboard_id: id,\n            items: overwriteConfirmItems\n          })\n        );\n        dispatch(addDangerToast(errorText));\n      });\n    }\n    // changing the data as the endpoint requires\n    if ('positions' in cleanedData && !('positions' in cleanedData.metadata)) {\n      cleanedData.metadata.positions = cleanedData.positions;\n    }\n    cleanedData.metadata.default_filters = safeStringify(serializedFilters);\n    cleanedData.metadata.filter_scopes = serializedFilterScopes;\n    const copyPayload = {\n      dashboard_title: cleanedData.dashboard_title,\n      css: cleanedData.css,\n      duplicate_slices: cleanedData.duplicate_slices,\n      json_metadata: JSON.stringify(cleanedData.metadata)\n    };\n\n    return SupersetClient.post({\n      endpoint: `/api/v1/dashboard/${id}/copy/`,\n      jsonPayload: copyPayload\n    }).\n    then((response) => onCopySuccess(response)).\n    catch((response) => onError(response));\n  };\n}\n\nexport function fetchCharts(\nchartList = [],\nforce = false,\ninterval = 0,\ndashboardId)\n{\n  return (dispatch, getState) => {\n    if (!interval) {\n      chartList.forEach((chartKey) =>\n      dispatch(refreshChart(chartKey, force, dashboardId))\n      );\n      return;\n    }\n\n    const { metadata: meta } = getState().dashboardInfo;\n    const refreshTime = Math.max(interval, meta.stagger_time || 5000); // default 5 seconds\n    if (typeof meta.stagger_refresh !== 'boolean') {\n      meta.stagger_refresh =\n      meta.stagger_refresh === undefined ?\n      true :\n      meta.stagger_refresh === 'true';\n    }\n    const delay = meta.stagger_refresh ?\n    refreshTime / (chartList.length - 1) :\n    0;\n    chartList.forEach((chartKey, i) => {\n      setTimeout(\n        () => dispatch(refreshChart(chartKey, force, dashboardId)),\n        delay * i\n      );\n    });\n  };\n}\n\nconst refreshCharts = (chartList, force, interval, dashboardId, dispatch) =>\nnew Promise((resolve) => {\n  dispatch(fetchCharts(chartList, force, interval, dashboardId));\n  resolve();\n});\n\nexport const ON_FILTERS_REFRESH = 'ON_FILTERS_REFRESH';\nexport function onFiltersRefresh() {\n  return { type: ON_FILTERS_REFRESH };\n}\n\nexport const ON_FILTERS_REFRESH_SUCCESS = 'ON_FILTERS_REFRESH_SUCCESS';\nexport function onFiltersRefreshSuccess() {\n  return { type: ON_FILTERS_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH_SUCCESS = 'ON_REFRESH_SUCCESS';\nexport function onRefreshSuccess() {\n  return { type: ON_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH = 'ON_REFRESH';\nexport function onRefresh(\nchartList = [],\nforce = false,\ninterval = 0,\ndashboardId)\n{\n  return (dispatch) => {\n    dispatch({ type: ON_REFRESH });\n    refreshCharts(chartList, force, interval, dashboardId, dispatch).then(\n      () => {\n        dispatch(onRefreshSuccess());\n        dispatch(onFiltersRefresh());\n      }\n    );\n  };\n}\n\nexport const SHOW_BUILDER_PANE = 'SHOW_BUILDER_PANE';\nexport function showBuilderPane() {\n  return { type: SHOW_BUILDER_PANE };\n}\n\nexport function addSliceToDashboard(id) {\n  return (dispatch, getState) => {\n    const { sliceEntities } = getState();\n    const selectedSlice = sliceEntities.slices[id];\n    if (!selectedSlice) {\n      return dispatch(\n        addWarningToast(\n          'Sorry, there is no chart definition associated with the chart trying to be added.'\n        )\n      );\n    }\n    const form_data = {\n      ...selectedSlice.form_data,\n      slice_id: selectedSlice.slice_id\n    };\n    const newChart = {\n      ...initChart,\n      id,\n      form_data: applyDefaultFormData(form_data)\n    };\n\n    return Promise.all([\n    dispatch(addChart(newChart, id)),\n    dispatch(fetchDatasourceMetadata(form_data.datasource))]\n    ).then(() => {\n      dispatch(addSlice(selectedSlice));\n    });\n  };\n}\n\nexport function removeSliceFromDashboard(id) {\n  return (dispatch) => {\n    dispatch(removeSlice(id));\n    dispatch(removeChart(id));\n    getLabelsColorMap().removeSlice(id);\n  };\n}\n\nexport const SET_COLOR_SCHEME = 'SET_COLOR_SCHEME';\nexport function setColorScheme(colorScheme) {\n  return { type: SET_COLOR_SCHEME, colorScheme };\n}\n\nexport const SET_DIRECT_PATH = 'SET_DIRECT_PATH';\nexport function setDirectPathToChild(path) {\n  return { type: SET_DIRECT_PATH, path };\n}\n\nexport const SET_ACTIVE_TAB = 'SET_ACTIVE_TAB';\nexport function setActiveTab(tabId, prevTabId) {\n  return { type: SET_ACTIVE_TAB, tabId, prevTabId };\n}\n\n// Even though SET_ACTIVE_TABS is not being called from Superset's codebase,\n// it is being used by Preset extensions.\nexport const SET_ACTIVE_TABS = 'SET_ACTIVE_TABS';\nexport function setActiveTabs(activeTabs) {\n  return { type: SET_ACTIVE_TABS, activeTabs };\n}\n\nexport const SET_FOCUSED_FILTER_FIELD = 'SET_FOCUSED_FILTER_FIELD';\nexport function setFocusedFilterField(chartId, column) {\n  return { type: SET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const UNSET_FOCUSED_FILTER_FIELD = 'UNSET_FOCUSED_FILTER_FIELD';\nexport function unsetFocusedFilterField(chartId, column) {\n  return { type: UNSET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const SET_FULL_SIZE_CHART_ID = 'SET_FULL_SIZE_CHART_ID';\nexport function setFullSizeChartId(chartId) {\n  return { type: SET_FULL_SIZE_CHART_ID, chartId };\n}\n\n// Undo history ---------------------------------------------------------------\nexport const SET_MAX_UNDO_HISTORY_EXCEEDED = 'SET_MAX_UNDO_HISTORY_EXCEEDED';\nexport function setMaxUndoHistoryExceeded(maxUndoHistoryExceeded = true) {\n  return {\n    type: SET_MAX_UNDO_HISTORY_EXCEEDED,\n    payload: { maxUndoHistoryExceeded }\n  };\n}\n\nexport function maxUndoHistoryToast() {\n  return (dispatch, getState) => {\n    const { dashboardLayout } = getState();\n    const historyLength = dashboardLayout.past.length;\n\n    return dispatch(\n      addWarningToast(\n        t(\n          'You have used all %(historyLength)s undo slots and will not be able to fully undo subsequent actions. You may save your current state to reset the history.',\n          { historyLength }\n        )\n      )\n    );\n  };\n}\n\nexport const SET_DATASETS_STATUS = 'SET_DATASETS_STATUS';\nexport function setDatasetsStatus(status) {\n  return {\n    type: SET_DATASETS_STATUS,\n    status\n  };\n}\n\nconst storeDashboardColorConfig = async (id, metadata) =>\nSupersetClient.put({\n  endpoint: `/api/v1/dashboard/${id}/colors?mark_updated=false`,\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    color_namespace: metadata.color_namespace,\n    color_scheme: metadata.color_scheme,\n    color_scheme_domain: metadata.color_scheme_domain || [],\n    shared_label_colors: metadata.shared_label_colors || [],\n    map_label_colors: metadata.map_label_colors || {},\n    label_colors: metadata.label_colors || {}\n  })\n});\n\n/**\n *\n * Persists the label colors maps in the dashboard metadata.\n * It runs when outdated color info are detected in stored metadata.\n *\n * @returns void\n */\nexport const persistDashboardLabelsColor = () => async (dispatch, getState) => {\n  const {\n    dashboardInfo: { id, metadata },\n    dashboardState: { labelsColorMapMustSync, sharedLabelsColorsMustSync }\n  } = getState();\n\n  if (labelsColorMapMustSync || sharedLabelsColorsMustSync) {\n    dispatch(setDashboardLabelsColorMapSynced());\n    dispatch(setDashboardSharedLabelsColorsSynced());\n    storeDashboardColorConfig(id, metadata);\n  }\n};\n\n/**\n * Checks the stored dashboard metadata for inconsistencies.\n * Update the current metadata with validated color information.\n * It runs only on Dashboard page load.\n *\n * @param {*} metadata - the stored dashboard metadata\n * @returns void\n */\nexport const applyDashboardLabelsColorOnLoad = (metadata) => async (dispatch) => {\n  try {\n    const customLabelsColor = metadata.label_colors || {};\n    let hasChanged = false;\n\n    // backward compatibility of shared_label_colors\n    const sharedLabels = metadata.shared_label_colors || [];\n    if (!Array.isArray(sharedLabels) && Object.keys(sharedLabels).length > 0) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          shared_label_colors: []\n        })\n      );\n    }\n    // backward compatibility of map_label_colors\n    const hasMapLabelColors = !!metadata.map_label_colors;\n\n    let updatedScheme = metadata.color_scheme;\n    const categoricalSchemes = getCategoricalSchemeRegistry();\n    const colorSchemeRegistry = categoricalSchemes.get(updatedScheme, true);\n    const hasInvalidColorScheme = !!updatedScheme && !colorSchemeRegistry;\n\n    // color scheme might not exist any longer\n    if (hasInvalidColorScheme) {\n      const defaultScheme = categoricalSchemes.defaultKey;\n      const fallbackScheme = (defaultScheme == null ? void 0 : defaultScheme.toString()) || 'supersetColors';\n      hasChanged = true;\n      updatedScheme = fallbackScheme;\n\n      dispatch(setColorScheme(updatedScheme));\n      dispatch(\n        setDashboardMetadata({\n          color_scheme: updatedScheme\n        })\n      );\n    }\n\n    // the stored color domain registry and fresh might differ at this point\n    const freshColorSchemeDomain = updatedScheme ?\n    getColorSchemeDomain(updatedScheme) :\n    [];\n    const currentColorSchemeDomain = metadata.color_scheme_domain || [];\n\n    if (!_isEqual(freshColorSchemeDomain, currentColorSchemeDomain)) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          color_scheme_domain: freshColorSchemeDomain\n        })\n      );\n    }\n\n    // if color scheme is invalid or map is missing, apply a fresh color map\n    // if valid, apply the stored map to keep consistency across refreshes\n    const shouldGoFresh = !hasMapLabelColors || hasInvalidColorScheme;\n    applyColors(metadata, shouldGoFresh);\n\n    if (shouldGoFresh) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          map_label_colors: getFreshLabelsColorMapEntries(customLabelsColor)\n        })\n      );\n    }\n\n    if (hasChanged) {\n      dispatch(setDashboardLabelsColorMapSync());\n    }\n  } catch (e) {\n    console.error('Failed to update dashboard color on load:', e);\n  }\n};\n\n/**\n *\n * Ensure that the stored color map matches fresh map.\n *\n * @param {*} metadata - the dashboard metadata\n * @returns void\n */\nexport const ensureSyncedLabelsColorMap = (metadata) => (dispatch, getState) => {\n  const syncLabelsColorMap = () => {\n    const {\n      dashboardState: { labelsColorMapMustSync }\n    } = getState();\n    const customLabelsColor = metadata.label_colors || {};\n    const fullLabelsColors = getDynamicLabelsColors(\n      metadata.map_label_colors || {},\n      customLabelsColor\n    );\n    const freshColorMapEntries =\n    getFreshLabelsColorMapEntries(customLabelsColor);\n    const isMapSynced = isLabelsColorMapSynced(\n      fullLabelsColors,\n      freshColorMapEntries,\n      customLabelsColor\n    );\n\n    if (!isMapSynced) {\n      dispatch(\n        setDashboardMetadata({\n          map_label_colors: freshColorMapEntries\n        })\n      );\n    }\n\n    if (!isMapSynced && !labelsColorMapMustSync) {\n      // prepare to persist the just applied labels color map\n      dispatch(setDashboardLabelsColorMapSync());\n    }\n  };\n  promiseTimeout(syncLabelsColorMap, 500);\n};\n\n/**\n *\n * Ensure that the stored shared labels colors match current.\n *\n * @param {*} metadata - the dashboard metadata\n * @param {*} forceFresh - when true it will use the fresh shared labels ignoring stored ones\n * @returns void\n */\nexport const ensureSyncedSharedLabelsColors =\n(metadata, forceFresh = false) =>\n(dispatch, getState) => {\n  const syncSharedLabelsColors = () => {\n    const {\n      dashboardState: { sharedLabelsColorsMustSync }\n    } = getState();\n    const sharedLabelsColors = enforceSharedLabelsColorsArray(\n      metadata.shared_label_colors\n    );\n    const freshLabelsColors = getFreshSharedLabels(\n      forceFresh ? [] : sharedLabelsColors\n    );\n    const isSharedLabelsColorsSynced = _isEqual(\n      sharedLabelsColors.sort(),\n      freshLabelsColors.sort()\n    );\n    const mustSync = !isSharedLabelsColorsSynced;\n\n    if (mustSync) {\n      dispatch(\n        setDashboardMetadata({\n          shared_label_colors: freshLabelsColors\n        })\n      );\n    }\n\n    if (mustSync && !sharedLabelsColorsMustSync) {\n      // prepare to persist the shared labels colors\n      dispatch(setDashboardSharedLabelsColorsSync());\n    }\n  };\n  promiseTimeout(syncSharedLabelsColors, 500);\n};\n\n/**\n *\n * Updates the color map with new labels and colors as they appear.\n *\n * @param {*} renderedChartIds - the charts that have finished rendering\n * @returns void\n */\nexport const updateDashboardLabelsColor = (renderedChartIds) => (_, getState) => {\n  try {\n    const {\n      dashboardInfo: { metadata },\n      charts\n    } = getState();\n    const colorScheme = metadata.color_scheme;\n    const labelsColorMapInstance = getLabelsColorMap();\n    const sharedLabelsColors = enforceSharedLabelsColorsArray(\n      metadata.shared_label_colors\n    );\n    const customLabelsColors = metadata.label_colors || {};\n    const fullLabelsColors = getDynamicLabelsColors(\n      metadata.map_label_colors || {},\n      customLabelsColors\n    );\n\n    // for dashboards with no color scheme, the charts should always use their individual schemes\n    // this logic looks for unique labels (not shared across multiple charts) of each rendered chart\n    // it applies a new color to those unique labels when the applied scheme is not up to date\n    // while leaving shared label colors and custom label colors intact for color consistency\n    const shouldReset = [];\n    if (renderedChartIds.length > 0) {\n      const sharedLabelsSet = new Set(sharedLabelsColors);\n      renderedChartIds.forEach((id) => {\n        const chart = charts[id];\n        const formData = chart.form_data || chart.latestQueryFormData;\n        // ensure charts have their original color scheme always available\n        labelsColorMapInstance.setOwnColorScheme(\n          formData.slice_id,\n          formData.color_scheme\n        );\n\n        // if dashboard has a scheme, charts should ignore individual schemes\n        // thus following logic is inapplicable if a dashboard color scheme exists\n        if (colorScheme) return;\n\n        const chartColorScheme = formData.color_scheme;\n        const currentChartConfig = labelsColorMapInstance.chartsLabelsMap.get(\n          formData.slice_id\n        );\n        const currentChartLabels = (currentChartConfig == null ? void 0 : currentChartConfig.labels) || [];\n        const uniqueChartLabels = currentChartLabels.filter(\n          (l) => !sharedLabelsSet.has(l) && !customLabelsColors.hasOwnProperty(l)\n        );\n\n        // Map unique labels to colors\n        const uniqueChartLabelsColor = new Set(\n          uniqueChartLabels.map((l) => fullLabelsColors[l]).filter(Boolean)\n        );\n\n        const expectedColorsForChartScheme = new Set(\n          getColorSchemeDomain(chartColorScheme)\n        );\n\n        // Check if any unique label color is not in the expected colors set\n        const shouldResetColors = [...uniqueChartLabelsColor].some(\n          (color) => !expectedColorsForChartScheme.has(color)\n        );\n\n        // Only push uniqueChartLabels if they require resetting\n        if (shouldResetColors) shouldReset.push(...uniqueChartLabels);\n      });\n    }\n\n    // an existing map is available, use mrge option\n    // to only apply colors to newly found labels\n    const shouldGoFresh = shouldReset.length > 0 ? shouldReset : false;\n    const shouldMerge = !shouldGoFresh;\n    // re-apply the color map first to get fresh maps accordingly\n    applyColors(metadata, shouldGoFresh, shouldMerge);\n  } catch (e) {\n    console.error('Failed to update colors for new charts and labels:', e);\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}