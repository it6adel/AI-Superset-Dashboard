{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CurrencyFormatter, ensureIsArray, GenericDataType, getMetricLabel, getNumberFormatter, getTimeFormatter, isAdhocColumn, rgbToHex, tooltipHtml } from '@superset-ui/core';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { ASSIST_MARK, LEGEND, TOKEN, TOTAL_MARK } from './constants';\nimport { getColtypesMapping } from '../utils/series';\nimport { NULL_STRING } from '../constants';\nfunction formatTooltip({ params, breakdownName, defaultFormatter, xAxisFormatter }) {\n  const series = params.find((param) => param.seriesName !== ASSIST_MARK && param.data.value !== TOKEN);\n  // We may have no matching series depending on the legend state\n  if (!series) {\n    return '';\n  }\n  const isTotal = (series == null ? void 0 : series.seriesName) === LEGEND.TOTAL;\n  if (!series) {\n    return NULL_STRING;\n  }\n  const title = !isTotal || breakdownName ?\n  xAxisFormatter(series.name, series.dataIndex) :\n  undefined;\n  const rows = [];\n  if (!isTotal) {\n    rows.push([\n    series.seriesName,\n    defaultFormatter(series.data.originalValue)]\n    );\n  }\n  rows.push([TOTAL_MARK, defaultFormatter(series.data.totalSum)]);\n  return tooltipHtml(rows, title);\n}\nfunction transformer({ data, xAxis, metric, breakdown }) {\n  // Group by series (temporary map)\n  const groupedData = data.reduce((acc, cur) => {\n    const categoryLabel = cur[xAxis];\n    const categoryData = acc.get(categoryLabel) || [];\n    categoryData.push(cur);\n    acc.set(categoryLabel, categoryData);\n    return acc;\n  }, new Map());\n  const transformedData = [];\n  if (breakdown) {\n    groupedData.forEach((value, key) => {\n      const tempValue = value;\n      // Calc total per period\n      const sum = tempValue.reduce((acc, cur) => {var _cur$metric;return acc + ((_cur$metric = cur[metric]) != null ? _cur$metric : 0);}, 0);\n      // Push total per period to the end of period values array\n      tempValue.push({\n        [xAxis]: key,\n        [breakdown]: TOTAL_MARK,\n        [metric]: sum\n      });\n      transformedData.push(...tempValue);\n    });\n  } else\n  {\n    let total = 0;\n    groupedData.forEach((value, key) => {\n      const sum = value.reduce((acc, cur) => {var _cur$metric2;return acc + ((_cur$metric2 = cur[metric]) != null ? _cur$metric2 : 0);}, 0);\n      transformedData.push({\n        [xAxis]: key,\n        [metric]: sum\n      });\n      total += sum;\n    });\n    transformedData.push({\n      [xAxis]: TOTAL_MARK,\n      [metric]: total\n    });\n  }\n  return transformedData;\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, legendState, queriesData, hooks, theme, inContextMenu } = chartProps;\n  const refs = {};\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { setDataMask = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const { currencyFormat, granularitySqla = '', groupby, increaseColor = { r: 90, g: 193, b: 137 }, decreaseColor = { r: 224, g: 67, b: 85 }, totalColor = { r: 102, g: 102, b: 102 }, metric = '', xAxis, xTicksLayout, xAxisTimeFormat, showLegend, yAxisLabel, xAxisLabel, yAxisFormat, showValue } = formData;\n  const defaultFormatter = currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat }) :\n  getNumberFormatter(yAxisFormat);\n  const seriesformatter = (params) => {\n    const { data } = params;\n    const { originalValue } = data;\n    return defaultFormatter(originalValue);\n  };\n  const groupbyArray = ensureIsArray(groupby);\n  const breakdownColumn = groupbyArray.length ? groupbyArray[0] : undefined;\n  const breakdownName = isAdhocColumn(breakdownColumn) ?\n  breakdownColumn.label :\n  breakdownColumn;\n  const xAxisColumn = xAxis || granularitySqla;\n  const xAxisName = isAdhocColumn(xAxisColumn) ?\n  xAxisColumn.label :\n  xAxisColumn;\n  const metricLabel = getMetricLabel(metric);\n  const transformedData = transformer({\n    data,\n    breakdown: breakdownName,\n    xAxis: xAxisName,\n    metric: metricLabel\n  });\n  const assistData = [];\n  const increaseData = [];\n  const decreaseData = [];\n  const totalData = [];\n  let previousTotal = 0;\n  transformedData.forEach((datum, index, self) => {\n    const totalSum = self.slice(0, index + 1).reduce((prev, cur, i) => {\n      if (breakdownName) {\n        if (cur[breakdownName] !== TOTAL_MARK || i === 0) {var _cur$metricLabel;\n          return prev + ((_cur$metricLabel = cur[metricLabel]) != null ? _cur$metricLabel : 0);\n        }\n      } else\n      if (cur[xAxisName] !== TOTAL_MARK) {var _cur$metricLabel2;\n        return prev + ((_cur$metricLabel2 = cur[metricLabel]) != null ? _cur$metricLabel2 : 0);\n      }\n      return prev;\n    }, 0);\n    const isTotal = breakdownName && datum[breakdownName] === TOTAL_MARK ||\n    datum[xAxisName] === TOTAL_MARK;\n    const originalValue = datum[metricLabel];\n    let value = originalValue;\n    const oppositeSigns = Math.sign(previousTotal) !== Math.sign(totalSum);\n    if (oppositeSigns) {\n      value = Math.sign(value) * (Math.abs(value) - Math.abs(previousTotal));\n    }\n    if (isTotal) {\n      increaseData.push({ value: TOKEN });\n      decreaseData.push({ value: TOKEN });\n      totalData.push({\n        value: totalSum,\n        originalValue: totalSum,\n        totalSum\n      });\n    } else\n    if (value < 0) {\n      increaseData.push({ value: TOKEN });\n      decreaseData.push({\n        value: totalSum < 0 ? value : -value,\n        originalValue,\n        totalSum\n      });\n      totalData.push({ value: TOKEN });\n    } else\n    {\n      increaseData.push({\n        value: totalSum > 0 ? value : -value,\n        originalValue,\n        totalSum\n      });\n      decreaseData.push({ value: TOKEN });\n      totalData.push({ value: TOKEN });\n    }\n    const color = oppositeSigns ?\n    value > 0 ?\n    rgbToHex(increaseColor.r, increaseColor.g, increaseColor.b) :\n    rgbToHex(decreaseColor.r, decreaseColor.g, decreaseColor.b) :\n    'transparent';\n    let opacity = 1;\n    if ((legendState == null ? void 0 : legendState[LEGEND.INCREASE]) === false && value > 0) {\n      opacity = 0;\n    } else\n    if ((legendState == null ? void 0 : legendState[LEGEND.DECREASE]) === false && value < 0) {\n      opacity = 0;\n    }\n    if (isTotal) {\n      assistData.push({ value: TOKEN });\n    } else\n    if (index === 0) {\n      assistData.push({\n        value: 0\n      });\n    } else\n    if (oppositeSigns || Math.abs(totalSum) > Math.abs(previousTotal)) {\n      assistData.push({\n        value: previousTotal,\n        itemStyle: { color, opacity }\n      });\n    } else\n    {\n      assistData.push({\n        value: totalSum,\n        itemStyle: { color, opacity }\n      });\n    }\n    previousTotal = totalSum;\n  });\n  const xAxisColumns = [];\n  const xAxisData = transformedData.map((row) => {\n    let column = xAxisName;\n    let value = row[xAxisName];\n    if (breakdownName && row[breakdownName] !== TOTAL_MARK) {\n      column = breakdownName;\n      value = row[breakdownName];\n    }\n    if (!value) {\n      value = NULL_STRING;\n    }\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      value = String(value);\n    }\n    xAxisColumns.push(column);\n    return value;\n  });\n  const xAxisFormatter = (value, index) => {\n    if (value === TOTAL_MARK) {\n      return TOTAL_MARK;\n    }\n    if (coltypeMapping[xAxisColumns[index]] === GenericDataType.Temporal) {\n      if (typeof value === 'string') {\n        return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n      }\n      return getTimeFormatter(xAxisTimeFormat)(value);\n    }\n    return String(value);\n  };\n  let axisLabel;\n  if (xTicksLayout === '45°') {\n    axisLabel = { rotate: -45 };\n  } else\n  if (xTicksLayout === '90°') {\n    axisLabel = { rotate: -90 };\n  } else\n  if (xTicksLayout === 'flat') {\n    axisLabel = { rotate: 0 };\n  } else\n  if (xTicksLayout === 'staggered') {\n    axisLabel = { rotate: -45 };\n  } else\n  {\n    axisLabel = { show: true };\n  }\n  axisLabel.formatter = xAxisFormatter;\n  axisLabel.hideOverlap = false;\n  const seriesProps = {\n    type: 'bar',\n    stack: 'stack',\n    emphasis: {\n      disabled: true\n    }\n  };\n  const barSeries = [\n  {\n    ...seriesProps,\n    name: ASSIST_MARK,\n    data: assistData\n  },\n  {\n    ...seriesProps,\n    name: LEGEND.INCREASE,\n    label: {\n      show: showValue,\n      position: 'top',\n      formatter: seriesformatter\n    },\n    itemStyle: {\n      color: rgbToHex(increaseColor.r, increaseColor.g, increaseColor.b)\n    },\n    data: increaseData\n  },\n  {\n    ...seriesProps,\n    name: LEGEND.DECREASE,\n    label: {\n      show: showValue,\n      position: 'bottom',\n      formatter: seriesformatter\n    },\n    itemStyle: {\n      color: rgbToHex(decreaseColor.r, decreaseColor.g, decreaseColor.b)\n    },\n    data: decreaseData\n  },\n  {\n    ...seriesProps,\n    name: LEGEND.TOTAL,\n    label: {\n      show: showValue,\n      position: 'top',\n      formatter: seriesformatter\n    },\n    itemStyle: {\n      color: rgbToHex(totalColor.r, totalColor.g, totalColor.b)\n    },\n    data: totalData\n  }];\n\n  const echartOptions = {\n    grid: {\n      ...defaultGrid,\n      top: theme.gridUnit * 7,\n      bottom: theme.gridUnit * 7,\n      left: theme.gridUnit * 5,\n      right: theme.gridUnit * 7\n    },\n    legend: {\n      show: showLegend,\n      selected: legendState,\n      data: [LEGEND.INCREASE, LEGEND.DECREASE, LEGEND.TOTAL]\n    },\n    xAxis: {\n      data: xAxisData,\n      type: 'category',\n      name: xAxisLabel,\n      nameTextStyle: {\n        padding: [theme.gridUnit * 4, 0, 0, 0]\n      },\n      nameLocation: 'middle',\n      axisLabel\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      nameTextStyle: {\n        padding: [0, 0, theme.gridUnit * 5, 0]\n      },\n      nameLocation: 'middle',\n      name: yAxisLabel,\n      axisLabel: { formatter: defaultFormatter }\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      appendToBody: true,\n      trigger: 'axis',\n      show: !inContextMenu,\n      formatter: (params) => formatTooltip({\n        params,\n        breakdownName,\n        defaultFormatter,\n        xAxisFormatter\n      })\n    },\n    series: barSeries\n  };\n  return {\n    refs,\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    onContextMenu,\n    onLegendStateChanged\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}