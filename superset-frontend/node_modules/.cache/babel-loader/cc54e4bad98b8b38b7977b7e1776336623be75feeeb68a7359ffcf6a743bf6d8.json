{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { t } from '@superset-ui/core';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nimport { CHART_TYPE } from 'src/dashboard/util/componentTypes';\nimport { useChartIds } from 'src/dashboard/util/charts/useChartIds';\nconst extractTabLabel = (tab) => {var _tab$meta, _tab$meta2;return (tab == null ? void 0 : (_tab$meta = tab.meta) == null ? void 0 : _tab$meta.text) || (tab == null ? void 0 : (_tab$meta2 = tab.meta) == null ? void 0 : _tab$meta2.defaultText) || '';};\nconst extractChartLabel = (chart) => {var _chart$meta, _chart$meta2;return (chart == null ? void 0 : (_chart$meta = chart.meta) == null ? void 0 : _chart$meta.sliceNameOverride) || (chart == null ? void 0 : (_chart$meta2 = chart.meta) == null ? void 0 : _chart$meta2.sliceName) || (chart == null ? void 0 : chart.id) || '';};\nexport const useFilterScope = (filter) => {\n  const layout = useSelector((state) => state.dashboardLayout.present);\n  const chartIds = useChartIds();\n  return useMemo(() => {var _topLevelTabs;\n    let topLevelTabs;\n    const topElementId = layout[DASHBOARD_ROOT_ID].children[0];\n    if (topElementId.startsWith('TABS-')) {\n      topLevelTabs = layout[topElementId].children;\n    }\n    // no charts in scope\n    if (filter.scope.rootPath.length === 0) {\n      return undefined;\n    }\n    // all charts in scope\n    // no charts excluded and no top level tabs\n    // OR no charts excluded and every top level tab is in rootPath\n    if (filter.scope.excluded.length === 0 && (\n    filter.scope.rootPath[0] === DASHBOARD_ROOT_ID || (_topLevelTabs =\n    topLevelTabs) != null && _topLevelTabs.every((topLevelTab) => filter.scope.rootPath.includes(topLevelTab)))) {\n      return { all: [t('All charts')] };\n    }\n    // no charts excluded and not every top level tab in scope\n    // returns \"TAB1, TAB2\"\n    if (filter.scope.excluded.length === 0 && topLevelTabs) {\n      return {\n        tabs: filter.scope.rootPath.\n        map((tabId) => extractTabLabel(layout[tabId])).\n        filter(Boolean)\n      };\n    }\n    const layoutCharts = Object.values(layout).filter((layoutElement) => layoutElement.type === CHART_TYPE);\n    // no top level tabs, charts excluded\n    // returns \"CHART1, CHART2\"\n    if (filter.scope.rootPath[0] === DASHBOARD_ROOT_ID) {\n      return {\n        charts: chartIds.\n        filter((chartId) => !filter.scope.excluded.includes(chartId)).\n        map((chartId) => {\n          const layoutElement = layoutCharts.find((layoutChart) => layoutChart.meta.chartId === chartId);\n          return extractChartLabel(layoutElement);\n        }).\n        filter(Boolean)\n      };\n    }\n    // top level tabs, charts excluded\n    // returns \"TAB1, TAB2, CHART1\"\n    if (topLevelTabs) {\n      // We start assuming that all charts are in scope for all tabs in the root path\n      const topLevelTabsInFullScope = [...filter.scope.rootPath];\n      const layoutChartElementsInTabsInScope = layoutCharts.filter((element) => {var _element$parents;return (_element$parents = element.parents) == null ? void 0 : _element$parents.some((parent) => topLevelTabsInFullScope.includes(parent));});\n      // Exclude the tabs that contain excluded charts\n      filter.scope.excluded.forEach((chartId) => {\n        const excludedIndex = topLevelTabsInFullScope.findIndex((tabId) => {var _layoutChartElementsI, _layoutChartElementsI2;return (_layoutChartElementsI = layoutChartElementsInTabsInScope.\n          find((chart) => chart.meta.chartId === chartId)) == null ? void 0 : (_layoutChartElementsI2 = _layoutChartElementsI.\n          parents) == null ? void 0 : _layoutChartElementsI2.includes(tabId);});\n        if (excludedIndex > -1) {\n          topLevelTabsInFullScope.splice(excludedIndex, 1);\n        }\n      });\n      // Handle charts that are in scope but belong to excluded tabs.\n      const chartsInExcludedTabs = chartIds.\n      filter((chartId) => !filter.scope.excluded.includes(chartId)).\n      reduce((acc, chartId) => {\n        const layoutChartElementInExcludedTab = layoutChartElementsInTabsInScope.find((element) => {var _element$parents2;return element.meta.chartId === chartId && ((_element$parents2 =\n          element.parents) == null ? void 0 : _element$parents2.every((parent) => !topLevelTabsInFullScope.includes(parent)));});\n        if (layoutChartElementInExcludedTab) {\n          acc.push(layoutChartElementInExcludedTab);\n        }\n        return acc;\n      }, []);\n      // Join tab names and chart names\n      return {\n        tabs: topLevelTabsInFullScope.\n        map((tabId) => extractTabLabel(layout[tabId])).\n        filter(Boolean),\n        charts: chartsInExcludedTabs.map(extractChartLabel).filter(Boolean)\n      };\n    }\n    return undefined;\n  }, [chartIds, filter.scope.excluded, filter.scope.rootPath, layout]);\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}