{"ast":null,"code":"import _throttle from \"lodash/throttle\";import _kebabCase from \"lodash/kebabCase\"; /* eslint-disable react/sort-prop-types */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport d3 from 'd3';\nimport dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport nv from 'nvd3-fork';\nimport PropTypes from 'prop-types';\nimport {\n  CategoricalColorNamespace,\n  evalExpression,\n  getNumberFormatter,\n  getTimeFormatter,\n  isDefined,\n  NumberFormats,\n  SMART_DATE_VERBOSE_ID,\n  t,\n  VizType } from\n'@superset-ui/core';\n\nimport 'nvd3-fork/build/nv.d3.css';\n\n/* eslint-disable-next-line */\nimport ANNOTATION_TYPES, {\n  applyNativeColumns } from\n'./vendor/superset/AnnotationTypes';\nimport isTruthy from './utils/isTruthy';\nimport {\n  cleanColorInput,\n  computeYDomain,\n  drawBarValues,\n  generateBubbleTooltipContent,\n  generateCompareTooltipContent,\n  generateTimePivotTooltip,\n  generateTooltipClassName,\n  getMaxLabelSize,\n  getTimeOrNumberFormatter,\n  hideTooltips,\n  tipFactory,\n  removeTooltip,\n  setAxisShowMaxMin,\n  stringifyTimeRange,\n  wrapTooltip } from\n'./utils';\nimport {\n  annotationLayerType,\n  boxPlotValueType,\n  bulletDataType,\n  categoryAndValueXYType,\n  rgbObjectType,\n  numericXYType,\n  numberOrAutoType,\n  stringOrObjectWithLabelType } from\n'./PropTypes';\n\nconst NO_DATA_RENDER_DATA = [\n{ text: 'No data', dy: '-.75em', class: 'header' },\n{\n  text: 'Adjust filters or check the Datasource.',\n  dy: '.75em',\n  class: 'body'\n}];\n\n\ndayjs.extend(utc);\n\nconst smartDateVerboseFormatter = getTimeFormatter(SMART_DATE_VERBOSE_ID);\n\n// Override the noData render function to make a prettier UX\n// Code adapted from https://github.com/novus/nvd3/blob/master/src/utils.js#L653\nnv.utils.noData = function noData(chart, container) {\n  const opt = chart.options();\n  const margin = opt.margin();\n  const height = nv.utils.availableHeight(null, container, margin);\n  const width = nv.utils.availableWidth(null, container, margin);\n  const x = margin.left + width / 2;\n  const y = margin.top + height / 2;\n\n  // Remove any previously created chart components\n  container.selectAll('g').remove();\n\n  const noDataText = container.\n  selectAll('.nv-noData').\n  data(NO_DATA_RENDER_DATA);\n\n  noDataText.\n  enter().\n  append('text').\n  attr('class', (d) => `nvd3 nv-noData ${d.class}`).\n  attr('dy', (d) => d.dy).\n  style('text-anchor', 'middle');\n\n  noDataText.\n  attr('x', x).\n  attr('y', y).\n  text((d) => d.text);\n};\n\nconst { getColor, getScale } = CategoricalColorNamespace;\n\n// Limit on how large axes margins can grow as the chart window is resized\nconst MAX_MARGIN_PAD = 30;\nconst MIN_HEIGHT_FOR_BRUSH = 480;\nconst MAX_NO_CHARACTERS_IN_LABEL = 40;\n\nconst BREAKPOINTS = {\n  small: 340\n};\n\nconst TIMESERIES_VIZ_TYPES = [VizType.Compare, VizType.TimePivot];\n\nconst CHART_ID_PREFIX = 'chart-id-';\n\nconst propTypes = {\n  data: PropTypes.oneOfType([\n  PropTypes.arrayOf(\n    PropTypes.oneOfType([\n    // pie\n    categoryAndValueXYType,\n    // dist-bar\n    PropTypes.shape({\n      key: PropTypes.string,\n      values: PropTypes.arrayOf(categoryAndValueXYType)\n    }),\n    // area, line, compare, bar\n    PropTypes.shape({\n      key: PropTypes.arrayOf(PropTypes.string),\n      values: PropTypes.arrayOf(numericXYType)\n    }),\n    // dual-line\n    PropTypes.shape({\n      classed: PropTypes.string,\n      key: PropTypes.string,\n      type: PropTypes.string,\n      values: PropTypes.arrayOf(numericXYType),\n      yAxis: PropTypes.number\n    }),\n    // box-plot\n    PropTypes.shape({\n      label: PropTypes.string,\n      values: PropTypes.arrayOf(boxPlotValueType)\n    }),\n    // bubble\n    PropTypes.shape({\n      key: PropTypes.string,\n      values: PropTypes.arrayOf(PropTypes.object)\n    })]\n    )\n  ),\n  bulletDataType]\n  ),\n  width: PropTypes.number,\n  height: PropTypes.number,\n  annotationData: PropTypes.object,\n  annotationLayers: PropTypes.arrayOf(annotationLayerType),\n  bottomMargin: numberOrAutoType,\n  colorScheme: PropTypes.string,\n  comparisonType: PropTypes.string,\n  contribution: PropTypes.bool,\n  leftMargin: numberOrAutoType,\n  onError: PropTypes.func,\n  showLegend: PropTypes.bool,\n  showMarkers: PropTypes.bool,\n  vizType: PropTypes.oneOf([\n  VizType.BoxPlot,\n  'bubble',\n  VizType.Bullet,\n  VizType.Compare,\n  'column',\n  VizType.TimePivot,\n  'pie']\n  ),\n  xAxisFormat: PropTypes.string,\n  numberFormat: PropTypes.string,\n  xAxisLabel: PropTypes.string,\n  xAxisShowMinMax: PropTypes.bool,\n  xIsLogScale: PropTypes.bool,\n  xTicksLayout: PropTypes.oneOf(['auto', 'staggered', '45°']),\n  yAxisFormat: PropTypes.string,\n  yAxisBounds: PropTypes.arrayOf(PropTypes.number),\n  yAxisLabel: PropTypes.string,\n  yAxisShowMinMax: PropTypes.bool,\n  yIsLogScale: PropTypes.bool,\n  // 'bar' or 'dist-bar'\n  isBarStacked: PropTypes.bool,\n  showBarValue: PropTypes.bool,\n  // 'line' only\n  showBrush: PropTypes.oneOf([true, 'yes', false, 'no', 'auto']),\n  onBrushEnd: PropTypes.func,\n  // 'line-multi' or 'dual-line'\n  yAxis2Format: PropTypes.string,\n  // 'line', 'time-pivot', 'dual-line' or 'line-multi'\n  lineInterpolation: PropTypes.string,\n  // 'pie' only\n  isDonut: PropTypes.bool,\n  isPieLabelOutside: PropTypes.bool,\n  pieLabelType: PropTypes.oneOf([\n  'key',\n  'value',\n  'percent',\n  'key_value',\n  'key_percent',\n  'key_value_percent']\n  ),\n  showLabels: PropTypes.bool,\n  // 'bubble' only\n  entity: PropTypes.string,\n  maxBubbleSize: PropTypes.number,\n  xField: stringOrObjectWithLabelType,\n  yField: stringOrObjectWithLabelType,\n  sizeField: stringOrObjectWithLabelType,\n  // time-pivot only\n  baseColor: rgbObjectType\n};\n\nconst NOOP = () => {};\nconst formatter = getNumberFormatter();\n\nfunction nvd3Vis(element, props) {\n  const {\n    data,\n    width: maxWidth,\n    height: maxHeight,\n    annotationData,\n    annotationLayers = [],\n    baseColor,\n    bottomMargin,\n    colorScheme,\n    comparisonType,\n    contribution,\n    entity,\n    isBarStacked,\n    isDonut,\n    isPieLabelOutside,\n    leftMargin,\n    lineInterpolation = 'linear',\n    markerLabels,\n    markerLines,\n    markerLineLabels,\n    markers,\n    maxBubbleSize,\n    onBrushEnd = NOOP,\n    onError = NOOP,\n    pieLabelType,\n    rangeLabels,\n    ranges,\n    showBarValue,\n    showBrush,\n    showLabels,\n    showLegend,\n    showMarkers,\n    sizeField,\n    vizType,\n    xAxisFormat,\n    numberFormat,\n    xAxisLabel,\n    xAxisShowMinMax = false,\n    xField,\n    xIsLogScale,\n    xTicksLayout,\n    yAxisFormat,\n    yAxisBounds,\n    yAxisLabel,\n    yAxisShowMinMax = false,\n    yAxis2ShowMinMax = false,\n    yField,\n    yIsLogScale,\n    sliceId\n  } = props;\n\n  const isExplore = document.querySelector('#explorer-container') !== null;\n  const container = element;\n  container.innerHTML = '';\n  const activeAnnotationLayers = annotationLayers.filter((layer) => layer.show);\n\n  // Search for the chart id in a parent div from the nvd3 chart\n  let chartContainer = container;\n  let chartId = null;\n  while (chartContainer.parentElement) {\n    if (chartContainer.parentElement.id.startsWith(CHART_ID_PREFIX)) {\n      chartId = chartContainer.parentElement.id;\n      break;\n    }\n\n    chartContainer = chartContainer.parentElement;\n  }\n\n  let chart;\n  const width = maxWidth;\n  let colorKey = 'key';\n\n  container.style.width = `${maxWidth}px`;\n  container.style.height = `${maxHeight}px`;\n\n  function isVizTypes(types) {\n    return types.includes(vizType);\n  }\n\n  const drawGraph = function drawGraph() {\n    const d3Element = d3.select(element);\n    d3Element.classed('superset-legacy-chart-nvd3', true);\n    d3Element.classed(`superset-legacy-chart-nvd3-${_kebabCase(vizType)}`, true);\n    let svg = d3Element.select('svg');\n    if (svg.empty()) {\n      svg = d3Element.append('svg');\n    }\n    const height =\n    vizType === VizType.Bullet ? Math.min(maxHeight, 50) : maxHeight;\n    const isTimeSeries = isVizTypes(TIMESERIES_VIZ_TYPES);\n\n    // Handling xAxis ticks settings\n    const staggerLabels = xTicksLayout === 'staggered';\n    const xLabelRotation = xTicksLayout === '45°' ? 45 : 0;\n    if (xLabelRotation === 45 && isTruthy(showBrush)) {\n      onError(\n        t('You cannot use 45° tick layout along with the time range filter')\n      );\n\n      return null;\n    }\n\n    const canShowBrush =\n    isTruthy(showBrush) ||\n    showBrush === 'auto' &&\n    maxHeight >= MIN_HEIGHT_FOR_BRUSH &&\n    xTicksLayout !== '45°';\n    const numberFormatter = getNumberFormatter(numberFormat);\n\n    switch (vizType) {\n      case VizType.TimePivot:\n        chart = nv.models.lineChart();\n        chart.xScale(d3.time.scale.utc());\n        chart.interpolate(lineInterpolation);\n        break;\n\n      case VizType.Pie:\n        chart = nv.models.pieChart();\n        colorKey = 'x';\n        chart.valueFormat(numberFormatter);\n        if (isDonut) {\n          chart.donut(true);\n        }\n        chart.showLabels(showLabels);\n        chart.labelsOutside(isPieLabelOutside);\n        // Configure the minimum slice size for labels to show up\n        chart.labelThreshold(0.05);\n        chart.cornerRadius(true);\n\n        if (['key', 'value', 'percent'].includes(pieLabelType)) {\n          chart.labelType(pieLabelType);\n        } else if (pieLabelType === 'key_value') {\n          chart.labelType((d) => `${d.data.x}: ${numberFormatter(d.data.y)}`);\n        } else {\n          // pieLabelType in ['key_percent', 'key_value_percent']\n          const total = d3.sum(data, (d) => d.y);\n          const percentFormatter = getNumberFormatter(\n            NumberFormats.PERCENT_2_POINT\n          );\n          if (pieLabelType === 'key_percent') {\n            chart.tooltip.valueFormatter((d) => percentFormatter(d));\n            chart.labelType(\n              (d) => `${d.data.x}: ${percentFormatter(d.data.y / total)}`\n            );\n          } else {\n            // pieLabelType === 'key_value_percent'\n            chart.tooltip.valueFormatter(\n              (d) => `${numberFormatter(d)} (${percentFormatter(d / total)})`\n            );\n            chart.labelType(\n              (d) =>\n              `${d.data.x}: ${numberFormatter(d.data.y)} (${percentFormatter(\n                d.data.y / total\n              )})`\n            );\n          }\n        }\n        // Pie chart does not need top margin\n        chart.margin({ top: 0 });\n        break;\n\n      case 'column':\n        chart = nv.models.multiBarChart().reduceXTicks(false);\n        break;\n\n      case VizType.Compare:\n        chart = nv.models.cumulativeLineChart();\n        chart.xScale(d3.time.scale.utc());\n        chart.useInteractiveGuideline(true);\n        chart.xAxis.showMaxMin(false);\n        break;\n\n      case VizType.LegacyBubble:\n        chart = nv.models.scatterChart();\n        chart.showDistX(false);\n        chart.showDistY(false);\n        chart.tooltip.contentGenerator((d) =>\n        generateBubbleTooltipContent({\n          point: d.point,\n          entity,\n          xField,\n          yField,\n          sizeField,\n          xFormatter: getTimeOrNumberFormatter(xAxisFormat),\n          yFormatter: getTimeOrNumberFormatter(yAxisFormat),\n          sizeFormatter: formatter\n        })\n        );\n        chart.pointRange([5, maxBubbleSize ** 2]);\n        chart.pointDomain([\n        0,\n        d3.max(data, (d) => d3.max(d.values, (v) => v.size))]\n        );\n        break;\n\n      case VizType.BoxPlot:\n        colorKey = 'label';\n        chart = nv.models.boxPlotChart();\n        chart.x((d) => d.label);\n        chart.maxBoxWidth(75); // prevent boxes from being incredibly wide\n        break;\n\n      case VizType.Bullet:\n        chart = nv.models.bulletChart();\n        data.rangeLabels = rangeLabels;\n        data.ranges = ranges;\n        data.markerLabels = markerLabels;\n        data.markerLines = markerLines;\n        data.markerLineLabels = markerLineLabels;\n        data.markers = markers;\n        break;\n\n      default:\n        throw new Error(`Unrecognized visualization for nvd3${vizType}`);\n    }\n    // Assuming the container has padding already other than for top margin\n    chart.margin({ left: 0, bottom: 0 });\n\n    if (showBarValue) {\n      drawBarValues(svg, data, isBarStacked, yAxisFormat);\n      chart.dispatch.on('stateChange.drawBarValues', () => {\n        drawBarValues(svg, data, isBarStacked, yAxisFormat);\n      });\n    }\n\n    if (canShowBrush && onBrushEnd !== NOOP) {\n      if (chart.focus) {\n        chart.focus.dispatch.on('brush', (event) => {\n          const timeRange = stringifyTimeRange(event.extent);\n          if (timeRange) {\n            event.brush.on('brushend', () => {\n              onBrushEnd(timeRange);\n            });\n          }\n        });\n      }\n    }\n\n    if (chart.xAxis && chart.xAxis.staggerLabels) {\n      chart.xAxis.staggerLabels(staggerLabels);\n    }\n    if (chart.xAxis && chart.xAxis.rotateLabels) {\n      chart.xAxis.rotateLabels(xLabelRotation);\n    }\n    if (chart.x2Axis && chart.x2Axis.staggerLabels) {\n      chart.x2Axis.staggerLabels(staggerLabels);\n    }\n    if (chart.x2Axis && chart.x2Axis.rotateLabels) {\n      chart.x2Axis.rotateLabels(xLabelRotation);\n    }\n\n    if ('showLegend' in chart && typeof showLegend !== 'undefined') {\n      if (width < BREAKPOINTS.small && vizType !== VizType.Pie) {\n        chart.showLegend(false);\n      } else {\n        chart.showLegend(showLegend);\n      }\n    }\n\n    if (yIsLogScale) {\n      chart.yScale(d3.scale.log());\n    }\n    if (xIsLogScale) {\n      chart.xScale(d3.scale.log());\n    }\n\n    let xAxisFormatter;\n    if (isTimeSeries) {\n      xAxisFormatter = getTimeFormatter(xAxisFormat);\n      // In tooltips, always use the verbose time format\n      chart.interactiveLayer.tooltip.headerFormatter(smartDateVerboseFormatter);\n    } else {\n      xAxisFormatter = getTimeOrNumberFormatter(xAxisFormat);\n    }\n    if (chart.x2Axis && chart.x2Axis.tickFormat) {\n      chart.x2Axis.tickFormat(xAxisFormatter);\n    }\n    if (chart.xAxis && chart.xAxis.tickFormat) {\n      const isXAxisString = isVizTypes([VizType.BoxPlot]);\n      if (isXAxisString) {\n        chart.xAxis.tickFormat((d) =>\n        d.length > MAX_NO_CHARACTERS_IN_LABEL ?\n        `${d.slice(0, Math.max(0, MAX_NO_CHARACTERS_IN_LABEL))}…` :\n        d\n        );\n      } else {\n        chart.xAxis.tickFormat(xAxisFormatter);\n      }\n    }\n\n    let yAxisFormatter = getTimeOrNumberFormatter(yAxisFormat);\n    if (chart.yAxis && chart.yAxis.tickFormat) {\n      if (\n      (contribution || comparisonType === 'percentage') && (\n      !yAxisFormat ||\n      yAxisFormat === NumberFormats.SMART_NUMBER ||\n      yAxisFormat === NumberFormats.SMART_NUMBER_SIGNED))\n      {\n        // When computing a \"Percentage\" or \"Contribution\" selected,\n        // force a percentage format if no custom formatting set\n        yAxisFormatter = getNumberFormatter(NumberFormats.PERCENT_1_POINT);\n      }\n      chart.yAxis.tickFormat(yAxisFormatter);\n    }\n    if (chart.y2Axis && chart.y2Axis.tickFormat) {\n      chart.y2Axis.tickFormat(yAxisFormatter);\n    }\n\n    if (chart.yAxis) {\n      chart.yAxis.ticks(5);\n    }\n    if (chart.y2Axis) {\n      chart.y2Axis.ticks(5);\n    }\n\n    // Set showMaxMin for all axis\n    setAxisShowMaxMin(chart.xAxis, xAxisShowMinMax);\n    setAxisShowMaxMin(chart.x2Axis, xAxisShowMinMax);\n    setAxisShowMaxMin(chart.yAxis, yAxisShowMinMax);\n    setAxisShowMaxMin(chart.y2Axis, yAxis2ShowMinMax || yAxisShowMinMax);\n\n    if (vizType === VizType.TimePivot) {\n      if (baseColor) {\n        const { r, g, b } = baseColor;\n        chart.color((d) => {\n          const alpha = d.rank > 0 ? d.perc * 0.5 : 1;\n\n          return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n        });\n      }\n\n      chart.useInteractiveGuideline(true);\n      chart.interactiveLayer.tooltip.contentGenerator((d) =>\n      generateTimePivotTooltip(d, xAxisFormatter, yAxisFormatter)\n      );\n    } else if (vizType !== VizType.Bullet) {\n      const colorFn = getScale(colorScheme);\n      chart.color(\n        (d) => d.color || colorFn(cleanColorInput(d[colorKey]), sliceId)\n      );\n    }\n\n    if (isVizTypes([VizType.Compare])) {\n      chart.interactiveLayer.tooltip.contentGenerator((d) =>\n      generateCompareTooltipContent(d, yAxisFormatter)\n      );\n    }\n\n    // This is needed for correct chart dimensions if a chart is rendered in a hidden container\n    chart.width(width);\n    chart.height(height);\n\n    svg.\n    datum(data).\n    transition().\n    duration(500).\n    attr('height', height).\n    attr('width', width).\n    call(chart);\n\n    // For log scale, only show 1, 10, 100, 1000, ...\n    if (yIsLogScale) {\n      chart.yAxis.tickFormat((d) =>\n      d !== 0 && Math.log10(d) % 1 === 0 ? yAxisFormatter(d) : ''\n      );\n    }\n\n    if (xLabelRotation > 0) {\n      // shift labels to the left so they look better\n      const xTicks = svg.select('.nv-x.nv-axis > g').selectAll('g');\n      xTicks.selectAll('text').attr('dx', -6.5);\n    }\n\n    const applyYAxisBounds = () => {\n      if (\n      chart.yDomain &&\n      Array.isArray(yAxisBounds) &&\n      yAxisBounds.length === 2)\n      {\n        const [customMin, customMax] = yAxisBounds;\n        const hasCustomMin = isDefined(customMin) && !Number.isNaN(customMin);\n        const hasCustomMax = isDefined(customMax) && !Number.isNaN(customMax);\n\n        if (hasCustomMin && hasCustomMax) {\n          // Override the y domain if there's both a custom min and max\n          chart.yDomain([customMin, customMax]);\n          chart.clipEdge(true);\n        } else if (hasCustomMin || hasCustomMax) {\n          // Only one of the bounds has been set, so we need to manually calculate the other one\n          const [trueMin, trueMax] = computeYDomain(data);\n          const min = hasCustomMin ? customMin : trueMin;\n          const max = hasCustomMax ? customMax : trueMax;\n          chart.yDomain([min, max]);\n          chart.clipEdge(true);\n        }\n      }\n    };\n    applyYAxisBounds();\n\n    // Also reapply on each state change to account for enabled/disabled series\n    if (chart.dispatch && chart.dispatch.stateChange) {\n      chart.dispatch.on('stateChange.applyYAxisBounds', applyYAxisBounds);\n    }\n\n    if (showMarkers) {\n      svg.\n      selectAll('.nv-point').\n      style('stroke-opacity', 1).\n      style('fill-opacity', 1);\n\n      // redo on legend toggle; nvd3 calls the callback *before* the line is\n      // drawn, so we need to add a small delay here\n      chart.dispatch.on('stateChange.showMarkers', () => {\n        setTimeout(() => {\n          svg.\n          selectAll('.nv-point').\n          style('stroke-opacity', 1).\n          style('fill-opacity', 1);\n        }, 10);\n      });\n    }\n\n    if (chart.yAxis !== undefined || chart.yAxis2 !== undefined) {\n      // Hack to adjust y axis left margin to accommodate long numbers\n      const marginPad = Math.ceil(\n        Math.min(maxWidth * (isExplore ? 0.01 : 0.03), MAX_MARGIN_PAD)\n      );\n      // Hack to adjust margins to accommodate long axis tick labels.\n      // - has to be done only after the chart has been rendered once\n      // - measure the width or height of the labels\n      // ---- (x axis labels are rotated 45 degrees so we use height),\n      // - adjust margins based on these measures and render again\n      const margins = chart.margin();\n      if (chart.xAxis) {\n        margins.bottom = 28;\n      }\n      const maxYAxisLabelWidth = getMaxLabelSize(\n        svg,\n        chart.yAxis2 ? 'nv-y1' : 'nv-y'\n      );\n      const maxXAxisLabelHeight = getMaxLabelSize(svg, 'nv-x');\n      margins.left = maxYAxisLabelWidth + marginPad;\n\n      if (yAxisLabel && yAxisLabel !== '') {\n        margins.left += 25;\n      }\n      if (showBarValue) {\n        // Add more margin to avoid label colliding with legend.\n        margins.top += 24;\n      }\n      if (xAxisShowMinMax) {\n        // If x bounds are shown, we need a right margin\n        margins.right = Math.max(20, maxXAxisLabelHeight / 2) + marginPad;\n      }\n      if (xLabelRotation === 45) {\n        margins.bottom =\n        maxXAxisLabelHeight * Math.sin(Math.PI * xLabelRotation / 180) +\n        marginPad +\n        30;\n        margins.right =\n        maxXAxisLabelHeight * Math.cos(Math.PI * xLabelRotation / 180) +\n        marginPad;\n      } else if (staggerLabels) {\n        margins.bottom = 40;\n      }\n\n      if (bottomMargin && bottomMargin !== 'auto') {\n        margins.bottom = parseInt(bottomMargin, 10);\n      }\n      if (leftMargin && leftMargin !== 'auto') {\n        margins.left = leftMargin;\n      }\n\n      if (xAxisLabel && xAxisLabel !== '' && chart.xAxis) {\n        margins.bottom += 25;\n        let distance = 0;\n        if (margins.bottom && !Number.isNaN(margins.bottom)) {\n          distance = margins.bottom - 45;\n        }\n        // nvd3 bug axisLabelDistance is disregarded on xAxis\n        // https://github.com/krispo/angular-nvd3/issues/90\n        chart.xAxis.axisLabel(xAxisLabel).axisLabelDistance(distance);\n      }\n\n      if (yAxisLabel && yAxisLabel !== '' && chart.yAxis) {\n        let distance = 0;\n        if (margins.left && !Number.isNaN(margins.left)) {\n          distance = margins.left - 70;\n        }\n        chart.yAxis.axisLabel(yAxisLabel).axisLabelDistance(distance);\n      }\n      if (isTimeSeries && annotationData && activeAnnotationLayers.length > 0) {\n        // Time series annotations add additional data\n        const timeSeriesAnnotations = activeAnnotationLayers.\n        filter(\n          (layer) => layer.annotationType === ANNOTATION_TYPES.TIME_SERIES\n        ).\n        reduce(\n          (bushel, a) =>\n          bushel.concat(\n            (annotationData[a.name] || []).map((series) => {\n              if (!series) {\n                return {};\n              }\n              const key = Array.isArray(series.key) ?\n              `${a.name}, ${series.key.join(', ')}` :\n              `${a.name}, ${series.key}`;\n\n              return {\n                ...series,\n                key,\n                color: a.color,\n                strokeWidth: a.width,\n                classed: `${a.opacity} ${a.style} nv-timeseries-annotation-layer showMarkers${a.showMarkers} hideLine${a.hideLine}`\n              };\n            })\n          ),\n          []\n        );\n        data.push(...timeSeriesAnnotations);\n      }\n\n      // Uniquely identify tooltips based on chartId so this chart instance only\n      // controls its own tooltips\n      if (chartId) {\n        if (chart && chart.interactiveLayer && chart.interactiveLayer.tooltip) {\n          chart.interactiveLayer.tooltip.classes([\n          generateTooltipClassName(chartId)]\n          );\n        }\n\n        if (chart && chart.tooltip) {\n          chart.tooltip.classes([generateTooltipClassName(chartId)]);\n        }\n      }\n\n      // render chart\n      chart.margin(margins);\n      svg.\n      datum(data).\n      transition().\n      duration(500).\n      attr('width', width).\n      attr('height', height).\n      call(chart);\n\n      // On scroll, hide (not remove) tooltips so they can reappear on hover.\n      // Throttle to only 4x/second.\n      window.addEventListener(\n        'scroll',\n        _throttle(() => hideTooltips(false), 250)\n      );\n\n      // The below code should be run AFTER rendering because chart is updated in call()\n      if (isTimeSeries && activeAnnotationLayers.length > 0) {\n        // Formula annotations\n        const formulas = activeAnnotationLayers.filter(\n          (a) => a.annotationType === ANNOTATION_TYPES.FORMULA\n        );\n\n        const xMax = chart.xAxis.scale().domain()[1].valueOf();\n        const xMin = chart.xAxis.scale().domain()[0].valueOf();\n        let xScale;\n        if (chart.xScale) {\n          xScale = chart.xScale();\n        } else if (chart.xAxis.scale) {\n          xScale = chart.xAxis.scale();\n        } else {\n          xScale = d3.scale.linear();\n        }\n        if (xScale && xScale.clamp) {\n          xScale.clamp(true);\n        }\n\n        if (formulas.length > 0) {\n          const xValues = [];\n          let period = Math.min(\n            ...data.map((d) =>\n            Math.min(...d.values.slice(1).map((v, i) => v.x - d.values[i].x))\n            )\n          );\n          const dataPoints = (xMax - xMin) / (period || 1);\n          // make sure that there are enough data points and not too many\n          period = dataPoints < 100 ? (xMax - xMin) / 100 : period;\n          period = dataPoints > 500 ? (xMax - xMin) / 500 : period;\n          xValues.push(xMin);\n          for (let x = xMin; x < xMax; x += period) {\n            xValues.push(x);\n          }\n          xValues.push(xMax);\n\n          const formulaData = formulas.map((fo) => {\n            const { value: expression } = fo;\n            return {\n              key: fo.name,\n              values: xValues.map((x) => ({\n                x,\n                y: evalExpression(expression, x)\n              })),\n              color: fo.color,\n              strokeWidth: fo.width,\n              classed: `${fo.opacity} ${fo.style}`\n            };\n          });\n          data.push(...formulaData);\n        }\n        const xAxis = chart.xAxis1 ? chart.xAxis1 : chart.xAxis;\n        const yAxis = chart.yAxis1 ? chart.yAxis1 : chart.yAxis;\n        const chartWidth = xAxis.scale().range()[1];\n        const annotationHeight = yAxis.scale().range()[0];\n\n        if (annotationData) {\n          // Event annotations\n          activeAnnotationLayers.\n          filter(\n            (x) =>\n            x.annotationType === ANNOTATION_TYPES.EVENT &&\n            annotationData &&\n            annotationData[x.name]\n          ).\n          forEach((config, index) => {\n            const e = applyNativeColumns(config);\n            // Add event annotation layer\n            const annotations = d3.\n            select(element).\n            select('.nv-wrap').\n            append('g').\n            attr('class', `nv-event-annotation-layer-${index}`);\n            const aColor =\n            e.color || getColor(cleanColorInput(e.name), colorScheme);\n\n            const tip = tipFactory({\n              ...e,\n              annotationTipClass: `arrow-down nv-event-annotation-layer-${config.sourceType}`\n            });\n            const records = (annotationData[e.name].records || []).\n            map((r) => {\n              const timeValue = new Date(dayjs.utc(r[e.timeColumn]));\n\n              return {\n                ...r,\n                [e.timeColumn]: timeValue\n              };\n            }).\n            filter(\n              (record) =>\n              !Number.isNaN(record[e.timeColumn].getMilliseconds())\n            );\n\n            if (records.length > 0) {\n              annotations.\n              selectAll('line').\n              data(records).\n              enter().\n              append('line').\n              attr({\n                x1: (d) => xScale(new Date(d[e.timeColumn])),\n                y1: 0,\n                x2: (d) => xScale(new Date(d[e.timeColumn])),\n                y2: annotationHeight\n              }).\n              attr('class', `${e.opacity} ${e.style}`).\n              style('stroke', aColor).\n              style('stroke-width', e.width).\n              on('mouseover', tip.show).\n              on('mouseout', tip.hide).\n              call(tip);\n            }\n\n            // update annotation positions on brush event\n            if (chart.focus) {\n              chart.focus.dispatch.on('onBrush.event-annotation', () => {\n                annotations.\n                selectAll('line').\n                data(records).\n                attr({\n                  x1: (d) => xScale(new Date(d[e.timeColumn])),\n                  y1: 0,\n                  x2: (d) => xScale(new Date(d[e.timeColumn])),\n                  y2: annotationHeight,\n                  opacity: (d) => {\n                    const x = xScale(new Date(d[e.timeColumn]));\n\n                    return x > 0 && x < chartWidth ? 1 : 0;\n                  }\n                });\n              });\n            }\n          });\n\n          // Interval annotations\n          activeAnnotationLayers.\n          filter(\n            (x) =>\n            x.annotationType === ANNOTATION_TYPES.INTERVAL &&\n            annotationData &&\n            annotationData[x.name]\n          ).\n          forEach((config, index) => {\n            const e = applyNativeColumns(config);\n            // Add interval annotation layer\n            const annotations = d3.\n            select(element).\n            select('.nv-wrap').\n            append('g').\n            attr('class', `nv-interval-annotation-layer-${index}`);\n\n            const aColor =\n            e.color || getColor(cleanColorInput(e.name), colorScheme);\n            const tip = tipFactory(e);\n\n            const records = (annotationData[e.name].records || []).\n            map((r) => {\n              const timeValue = new Date(dayjs.utc(r[e.timeColumn]));\n              const intervalEndValue = new Date(\n                dayjs.utc(r[e.intervalEndColumn])\n              );\n\n              return {\n                ...r,\n                [e.timeColumn]: timeValue,\n                [e.intervalEndColumn]: intervalEndValue\n              };\n            }).\n            filter(\n              (record) =>\n              !Number.isNaN(record[e.timeColumn].getMilliseconds()) &&\n              !Number.isNaN(\n                record[e.intervalEndColumn].getMilliseconds()\n              )\n            );\n\n            if (records.length > 0) {\n              annotations.\n              selectAll('rect').\n              data(records).\n              enter().\n              append('rect').\n              attr({\n                x: (d) =>\n                Math.min(\n                  xScale(new Date(d[e.timeColumn])),\n                  xScale(new Date(d[e.intervalEndColumn]))\n                ),\n                y: 0,\n                width: (d) =>\n                Math.max(\n                  Math.abs(\n                    xScale(new Date(d[e.intervalEndColumn])) -\n                    xScale(new Date(d[e.timeColumn]))\n                  ),\n                  1\n                ),\n                height: annotationHeight\n              }).\n              attr('class', `${e.opacity} ${e.style}`).\n              style('stroke-width', e.width).\n              style('stroke', aColor).\n              style('fill', aColor).\n              style('fill-opacity', 0.2).\n              on('mouseover', tip.show).\n              on('mouseout', tip.hide).\n              call(tip);\n            }\n\n            // update annotation positions on brush event\n            if (chart.focus) {\n              chart.focus.dispatch.on('onBrush.interval-annotation', () => {\n                annotations.\n                selectAll('rect').\n                data(records).\n                attr({\n                  x: (d) => xScale(new Date(d[e.timeColumn])),\n                  width: (d) => {\n                    const x1 = xScale(new Date(d[e.timeColumn]));\n                    const x2 = xScale(new Date(d[e.intervalEndColumn]));\n\n                    return x2 - x1;\n                  }\n                });\n              });\n            }\n          });\n        }\n\n        // rerender chart appended with annotation layer\n        svg.datum(data).attr('height', height).attr('width', width).call(chart);\n\n        // Display styles for Time Series Annotations\n        chart.dispatch.on('renderEnd.timeseries-annotation', () => {\n          d3.selectAll(\n            '.slice_container .nv-timeseries-annotation-layer.showMarkerstrue .nv-point'\n          ).\n          style('stroke-opacity', 1).\n          style('fill-opacity', 1);\n          d3.selectAll(\n            '.slice_container .nv-timeseries-annotation-layer.hideLinetrue'\n          ).style('stroke-width', 0);\n        });\n      }\n    }\n\n    wrapTooltip(chart);\n\n    return chart;\n  };\n\n  // Remove tooltips before rendering chart, if the chart is being re-rendered sometimes\n  // there are left over tooltips in the dom,\n  // this will clear them before rendering the chart again.\n  if (chartId) {\n    removeTooltip(chartId);\n  } else {\n    hideTooltips(true);\n  }\n\n  nv.addGraph(drawGraph);\n}\n\nnvd3Vis.displayName = 'NVD3';\nnvd3Vis.propTypes = propTypes;\nexport default nvd3Vis;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}