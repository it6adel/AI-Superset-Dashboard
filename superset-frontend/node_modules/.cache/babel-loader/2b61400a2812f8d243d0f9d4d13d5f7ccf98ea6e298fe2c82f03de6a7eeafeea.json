{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport memoizeOne from 'memoize-one';\nimport { addAlpha } from '@superset-ui/core';\nimport { Comparator, MultipleValueComparators } from '../types';\nexport const round = (num, precision = 0) => Number(`${Math.round(Number(`${num}e+${precision}`))}e-${precision}`);\nconst MIN_OPACITY_BOUNDED = 0.05;\nconst MIN_OPACITY_UNBOUNDED = 0;\nconst MAX_OPACITY = 1;\nexport const getOpacity = (value, cutoffPoint, extremeValue, minOpacity = MIN_OPACITY_BOUNDED, maxOpacity = MAX_OPACITY) => {\n  if (extremeValue === cutoffPoint) {\n    return maxOpacity;\n  }\n  return Math.min(maxOpacity, round(Math.abs((maxOpacity - minOpacity) / (extremeValue - cutoffPoint) * (\n  value - cutoffPoint)) + minOpacity, 2));\n};\nexport const getColorFunction = ({ operator, targetValue, targetValueLeft, targetValueRight, colorScheme }, columnValues, alpha) => {\n  let minOpacity = MIN_OPACITY_BOUNDED;\n  const maxOpacity = MAX_OPACITY;\n  let comparatorFunction;\n  if (operator === undefined || colorScheme === undefined) {\n    return () => undefined;\n  }\n  if (MultipleValueComparators.includes(operator) && (\n  targetValueLeft === undefined || targetValueRight === undefined)) {\n    return () => undefined;\n  }\n  if (operator !== Comparator.None &&\n  !MultipleValueComparators.includes(operator) &&\n  targetValue === undefined) {\n    return () => undefined;\n  }\n  switch (operator) {\n    case Comparator.None:\n      minOpacity = MIN_OPACITY_UNBOUNDED;\n      comparatorFunction = (value, allValues) => {\n        const cutoffValue = Math.min(...allValues);\n        const extremeValue = Math.max(...allValues);\n        return value >= cutoffValue && value <= extremeValue ?\n        { cutoffValue, extremeValue } :\n        false;\n      };\n      break;\n    case Comparator.GreaterThan:\n      comparatorFunction = (value, allValues) => value > targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.max(...allValues) } :\n      false;\n      break;\n    case Comparator.LessThan:\n      comparatorFunction = (value, allValues) => value < targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.min(...allValues) } :\n      false;\n      break;\n    case Comparator.GreaterOrEqual:\n      comparatorFunction = (value, allValues) => value >= targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.max(...allValues) } :\n      false;\n      break;\n    case Comparator.LessOrEqual:\n      comparatorFunction = (value, allValues) => value <= targetValue ?\n      { cutoffValue: targetValue, extremeValue: Math.min(...allValues) } :\n      false;\n      break;\n    case Comparator.Equal:\n      comparatorFunction = (value) => value === targetValue ?\n      { cutoffValue: targetValue, extremeValue: targetValue } :\n      false;\n      break;\n    case Comparator.NotEqual:\n      comparatorFunction = (value, allValues) => {\n        if (value === targetValue) {\n          return false;\n        }\n        const max = Math.max(...allValues);\n        const min = Math.min(...allValues);\n        return {\n          cutoffValue: targetValue,\n          extremeValue: Math.abs(targetValue - min) > Math.abs(max - targetValue) ?\n          min :\n          max\n        };\n      };\n      break;\n    case Comparator.Between:\n      comparatorFunction = (value) => value > targetValueLeft && value < targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case Comparator.BetweenOrEqual:\n      comparatorFunction = (value) => value >= targetValueLeft && value <= targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case Comparator.BetweenOrLeftEqual:\n      comparatorFunction = (value) => value >= targetValueLeft && value < targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    case Comparator.BetweenOrRightEqual:\n      comparatorFunction = (value) => value > targetValueLeft && value <= targetValueRight ?\n      { cutoffValue: targetValueLeft, extremeValue: targetValueRight } :\n      false;\n      break;\n    default:\n      comparatorFunction = () => false;\n      break;\n  }\n  return (value) => {\n    const compareResult = comparatorFunction(value, columnValues);\n    if (compareResult === false)\n    return undefined;\n    const { cutoffValue, extremeValue } = compareResult;\n    if (alpha === undefined || alpha) {\n      return addAlpha(colorScheme, getOpacity(value, cutoffValue, extremeValue, minOpacity, maxOpacity));\n    }\n    return colorScheme;\n  };\n};\nexport const getColorFormatters = memoizeOne((columnConfig, data, alpha) => {var _columnConfig$reduce;return (_columnConfig$reduce = columnConfig == null ? void 0 : columnConfig.reduce((acc, config) => {\n    if ((config == null ? void 0 : config.column) !== undefined && (\n    (config == null ? void 0 : config.operator) === Comparator.None ||\n    (config == null ? void 0 : config.operator) !== undefined && (\n    MultipleValueComparators.includes(config == null ? void 0 : config.operator) ?\n    (config == null ? void 0 : config.targetValueLeft) !== undefined &&\n    (config == null ? void 0 : config.targetValueRight) !== undefined :\n    (config == null ? void 0 : config.targetValue) !== undefined))) {\n      acc.push({\n        column: config == null ? void 0 : config.column,\n        getColorFromValue: getColorFunction(config, data.map((row) => row[config.column]), alpha)\n      });\n    }\n    return acc;\n  }, [])) != null ? _columnConfig$reduce : [];});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}