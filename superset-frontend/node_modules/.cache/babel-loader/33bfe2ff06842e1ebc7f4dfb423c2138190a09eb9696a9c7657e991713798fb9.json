{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useState, useEffect, useMemo } from 'react';\nimport rison from 'rison';\nimport { FeatureFlag, SupersetClient, isFeatureEnabled, styled, t, useTheme } from '@superset-ui/core';\nimport { Select } from 'src/components';\nimport Icons from 'src/components/Icons';\nimport RefreshLabel from 'src/components/RefreshLabel';\nimport { NotificationMethodOption } from '../types';\nimport { StyledInputContainer } from '../AlertReportModal';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst StyledNotificationMethod = styled.div`\n  ${({ theme }) => `\n    margin-bottom: ${theme.gridUnit * 3}px;\n\n    .input-container {\n      textarea {\n        height: auto;\n      }\n\n      &.error {\n        input {\n          border-color: ${theme.colors.error.base};\n        }\n      }\n\n      .helper {\n        margin-top: ${theme.gridUnit * 2}px;\n        font-size: ${theme.typography.sizes.s}px;\n        color: ${theme.colors.grayscale.base};\n      }\n    }\n\n    .inline-container {\n      margin-bottom: ${theme.gridUnit * 2}px;\n\n      > div {\n        margin: 0px;\n      }\n\n      .delete-button {\n        margin-left: ${theme.gridUnit * 2}px;\n        padding-top: ${theme.gridUnit}px;\n      }\n      .anticon {\n        margin-left: ${theme.gridUnit}px;\n      }\n    }\n\n    .ghost-button {\n      color: ${theme.colors.primary.dark1};\n      display: inline-flex;\n      align-items: center;\n      font-size: ${theme.typography.sizes.s}px;\n      cursor: pointer;\n\n      .icon {\n        width: ${theme.gridUnit * 3}px;\n        height: ${theme.gridUnit * 3}px;\n        font-size: ${theme.typography.sizes.s}px;\n        margin-right: ${theme.gridUnit}px;\n      }\n    }\n\n    .ghost-button + .ghost-button {\n      margin-left: ${theme.gridUnit * 4}px;\n    }\n\n    .ghost-button:first-child[style*='none'] + .ghost-button {\n      margin-left: 0px; /* Remove margin when the first button is hidden */\n    }\n  `}\n`;\nconst TRANSLATIONS = {\n  EMAIL_CC_NAME: t('CC recipients'),\n  EMAIL_BCC_NAME: t('BCC recipients'),\n  EMAIL_SUBJECT_NAME: t('Email subject name (optional)'),\n  EMAIL_SUBJECT_ERROR_TEXT: t('Please enter valid text. Spaces alone are not permitted.')\n};\nexport const mapSlackValues = ({ method, recipientValue, slackOptions }) => {\n  const prop = method === NotificationMethodOption.SlackV2 ? 'value' : 'label';\n  return recipientValue.\n  split(',').\n  map((recipient) => slackOptions.find((option) => option[prop].trim().toLowerCase() === recipient.trim().toLowerCase())).\n  filter((val) => !!val);\n};\nexport const mapChannelsToOptions = (result) => {\n  const publicChannels = [];\n  const privateChannels = [];\n  result.forEach((channel) => {\n    if (channel.is_private) {\n      privateChannels.push(channel);\n    } else\n    {\n      publicChannels.push(channel);\n    }\n  });\n  return [\n  {\n    label: 'Public Channels',\n    options: publicChannels.map((channel) => ({\n      label: `${channel.name} ${channel.is_member ? '' : t('(Bot not in channel)')}`,\n      value: channel.id,\n      key: channel.id\n    })),\n    key: 'public'\n  },\n  {\n    label: t('Private Channels (Bot in channel)'),\n    options: privateChannels.map((channel) => ({\n      label: channel.name,\n      value: channel.id,\n      key: channel.id\n    })),\n    key: 'private'\n  }];\n\n};\nexport const NotificationMethod = ({ setting = null, index, onUpdate, onRemove, onInputChange, email_subject, defaultSubject, setErrorSubject }) => {\n  const { method, recipients, cc, bcc, options } = setting || {};\n  const [recipientValue, setRecipientValue] = useState(recipients || '');\n  const [slackRecipients, setSlackRecipients] = useState([]);\n  const [error, setError] = useState(false);\n  const [ccVisible, setCcVisible] = useState(!!cc);\n  const [bccVisible, setBccVisible] = useState(!!bcc);\n  const [ccValue, setCcValue] = useState(cc || '');\n  const [bccValue, setBccValue] = useState(bcc || '');\n  const theme = useTheme();\n  const [methodOptionsLoading, setMethodOptionsLoading] = useState(true);\n  const [slackOptions, setSlackOptions] = useState([\n  {\n    label: '',\n    options: []\n  }]\n  );\n  const [useSlackV1, setUseSlackV1] = useState(false);\n  const [isSlackChannelsLoading, setIsSlackChannelsLoading] = useState(true);\n  const onMethodChange = (selected) => {\n    // Since we're swapping the method, reset the recipients\n    setRecipientValue('');\n    setCcValue('');\n    setBccValue('');\n    if (onUpdate && setting) {\n      const updatedSetting = {\n        ...setting,\n        method: selected.value,\n        recipients: '',\n        cc: '',\n        bcc: ''\n      };\n      onUpdate(index, updatedSetting);\n    }\n  };\n  const fetchSlackChannels = async ({ searchString = '', types = [], exactMatch = false, force = false } = {}) => {\n    const queryString = rison.encode({\n      searchString,\n      types,\n      exactMatch,\n      force\n    });\n    const endpoint = `/api/v1/report/slack_channels/?q=${queryString}`;\n    return SupersetClient.get({ endpoint });\n  };\n  const updateSlackOptions = async ({ force } = {}) => {\n    setIsSlackChannelsLoading(true);\n    fetchSlackChannels({ types: ['public_channel', 'private_channel'], force }).\n    then(({ json }) => {\n      const { result } = json;\n      const options = mapChannelsToOptions(result);\n      setSlackOptions(options);\n      if (isFeatureEnabled(FeatureFlag.AlertReportSlackV2)) {\n        // for edit mode, map existing ids to names for display if slack v2\n        // or names to ids if slack v1\n        const [publicOptions, privateOptions] = options;\n        if (method &&\n        [\n        NotificationMethodOption.SlackV2,\n        NotificationMethodOption.Slack].\n        includes(method)) {\n          setSlackRecipients(mapSlackValues({\n            method,\n            recipientValue,\n            slackOptions: [\n            ...publicOptions.options,\n            ...privateOptions.options]\n\n          }));\n        }\n      }\n    }).\n    catch((e) => {\n      // Fallback to slack v1 if slack v2 is not compatible\n      setUseSlackV1(true);\n    }).\n    finally(() => {\n      setMethodOptionsLoading(false);\n      setIsSlackChannelsLoading(false);\n    });\n  };\n  useEffect(() => {var _slackOptions$;\n    const slackEnabled = options == null ? void 0 : options.some((option) => option === NotificationMethodOption.Slack ||\n    option === NotificationMethodOption.SlackV2);\n    if (slackEnabled && !((_slackOptions$ = slackOptions[0]) != null && _slackOptions$.options.length)) {\n      updateSlackOptions();\n    }\n  }, []);\n  const methodOptions = useMemo(() => (options || []).\n  filter((method) => isFeatureEnabled(FeatureFlag.AlertReportSlackV2) &&\n  !useSlackV1 &&\n  method === NotificationMethodOption.SlackV2 ||\n  (!isFeatureEnabled(FeatureFlag.AlertReportSlackV2) ||\n  useSlackV1) &&\n  method === NotificationMethodOption.Slack ||\n  method === NotificationMethodOption.Email).\n  map((method) => ({\n    label: method === NotificationMethodOption.SlackV2 ?\n    NotificationMethodOption.Slack :\n    method,\n    value: method\n  })), [options, useSlackV1]);\n  if (!setting) {\n    return null;\n  }\n  const onRecipientsChange = (event) => {\n    const { target } = event;\n    setRecipientValue(target.value);\n    if (onUpdate) {\n      const updatedSetting = {\n        ...setting,\n        recipients: target.value\n      };\n      onUpdate(index, updatedSetting);\n    }\n  };\n  const onSlackRecipientsChange = (recipients) => {\n    setSlackRecipients(recipients);\n    if (onUpdate) {\n      const updatedSetting = {\n        ...setting,\n        recipients: recipients == null ? void 0 : recipients.map((obj) => obj.value).join(',')\n      };\n      onUpdate(index, updatedSetting);\n    }\n  };\n  const onSubjectChange = (event) => {\n    const { value } = event.target;\n    if (onInputChange) {\n      onInputChange(event);\n    }\n    const hasError = value.length > 0 && value.trim().length === 0;\n    setError(hasError);\n    if (setErrorSubject) {\n      setErrorSubject(hasError);\n    }\n  };\n  const onCcChange = (event) => {\n    const { target } = event;\n    setCcValue(target.value);\n    if (onUpdate) {\n      const updatedSetting = {\n        ...setting,\n        cc: target.value\n      };\n      onUpdate(index, updatedSetting);\n    }\n  };\n  const onBccChange = (event) => {\n    const { target } = event;\n    setBccValue(target.value);\n    if (onUpdate) {\n      const updatedSetting = {\n        ...setting,\n        bcc: target.value\n      };\n      onUpdate(index, updatedSetting);\n    }\n  };\n  // Set recipients\n  if (!!recipients && recipientValue !== recipients) {\n    setRecipientValue(recipients);\n  }\n  if (!!cc && ccValue !== cc) {\n    setCcValue(cc);\n  }\n  if (!!bcc && bccValue !== bcc) {\n    setBccValue(bcc);\n  }\n  return _jsxs(StyledNotificationMethod, { children: [\n    _jsx(\"div\", { className: \"inline-container\", children:\n      _jsxs(StyledInputContainer, { children: [\n        _jsx(\"div\", { className: \"control-label\", children: t('Notification Method') }),\n        _jsxs(\"div\", { className: \"input-container\", children: [\n          _jsx(Select, { ariaLabel: t('Delivery method'), labelInValue: true, onChange: onMethodChange, placeholder: t('Select Delivery Method'), options: methodOptions, showSearch: true, value: methodOptions.find((option) => option.value === method), loading: methodOptionsLoading }),\n          index !== 0 && !!onRemove ?\n          // eslint-disable-next-line jsx-a11y/control-has-associated-label\n          _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"delete-button\", onClick: () => onRemove(index), children:\n            _jsx(Icons.DeleteOutlined, { iconSize: \"l\" }) }\n          ) : null] }\n        )] }\n      ) }\n    ),\n    method !== undefined ? _jsxs(_Fragment, { children: [\n      _jsx(\"div\", { className: \"inline-container\", children:\n        _jsx(StyledInputContainer, { children:\n          method === NotificationMethodOption.Email ? _jsxs(_Fragment, { children: [\n            _jsx(\"div\", { className: \"control-label\", children:\n              TRANSLATIONS.EMAIL_SUBJECT_NAME }\n            ),\n            _jsx(\"div\", { className: `input-container ${error ? 'error' : ''}`, children:\n              _jsx(\"input\", { type: \"text\", name: \"email_subject\", value: email_subject, placeholder: defaultSubject, onChange: onSubjectChange }) }\n            ),\n            error && _jsx(\"div\", { style: {\n                color: theme.colors.error.base,\n                fontSize: theme.gridUnit * 3\n              }, children:\n              TRANSLATIONS.EMAIL_SUBJECT_ERROR_TEXT }\n            )] }\n          ) : null }\n        ) }\n      ),\n      _jsx(\"div\", { className: \"inline-container\", children:\n        _jsxs(StyledInputContainer, { children: [\n          _jsxs(\"div\", { className: \"control-label\", children: [\n            t('%s recipients', method === NotificationMethodOption.SlackV2 ?\n            NotificationMethodOption.Slack :\n            method),\n            _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n          ),\n          _jsx(\"div\", { children:\n            [\n            NotificationMethodOption.Email,\n            NotificationMethodOption.Slack].\n            includes(method) ? _jsxs(_Fragment, { children: [\n              _jsx(\"div\", { className: \"input-container\", children:\n                _jsx(\"textarea\", { name: \"To\", value: recipientValue, onChange: onRecipientsChange }) }\n              ),\n              _jsx(\"div\", { className: \"input-container\", children:\n                _jsx(\"div\", { className: \"helper\", children:\n                  t('Recipients are separated by \",\" or \";\"') }\n                ) }\n              )] }\n            ) :\n            // for SlackV2\n            _jsxs(\"div\", { className: \"input-container\", children: [\n              _jsx(Select, { ariaLabel: t('Select channels'), mode: \"multiple\", name: \"recipients\", value: slackRecipients, options: slackOptions, onChange: onSlackRecipientsChange, allowClear: true, loading: isSlackChannelsLoading, allowSelectAll: false, labelInValue: true }),\n              _jsx(RefreshLabel, { onClick: () => updateSlackOptions({ force: true }), tooltipContent: t('Force refresh Slack channels list'), disabled: isSlackChannelsLoading })] }\n            ) }\n          )] }\n        ) }\n      ),\n      method === NotificationMethodOption.Email && _jsxs(StyledInputContainer, { children: [\n\n        ccVisible && _jsxs(_Fragment, { children: [\n          _jsx(\"div\", { className: \"control-label\", children:\n            TRANSLATIONS.EMAIL_CC_NAME }\n          ),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(\"textarea\", { name: \"CC\", value: ccValue, onChange: onCcChange }) }\n          ),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(\"div\", { className: \"helper\", children:\n              t('Recipients are separated by \",\" or \";\"') }\n            ) }\n          )] }\n        ),\n\n        bccVisible && _jsxs(_Fragment, { children: [\n          _jsx(\"div\", { className: \"control-label\", children:\n            TRANSLATIONS.EMAIL_BCC_NAME }\n          ),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(\"textarea\", { name: \"BCC\", value: bccValue, onChange: onBccChange }) }\n          ),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(\"div\", { className: \"helper\", children:\n              t('Recipients are separated by \",\" or \";\"') }\n            ) }\n          )] }\n        ),\n\n        _jsxs(\"div\", { className: \"ghost-button\", children: [\n          _jsxs(\"span\", { className: \"ghost-button\", role: \"button\", tabIndex: 0, onClick: () => setCcVisible(true), style: { display: ccVisible ? 'none' : 'inline-flex' }, children: [\n            _jsx(Icons.MailOutlined, { iconSize: \"xs\", className: \"icon\" }),\n            t('Add CC Recipients')] }\n          ),\n          _jsxs(\"span\", { className: \"ghost-button\", role: \"button\", tabIndex: 0, onClick: () => setBccVisible(true), style: { display: bccVisible ? 'none' : 'inline-flex' }, children: [\n            _jsx(Icons.MailOutlined, { iconSize: \"xs\", className: \"icon\" }),\n            t('Add BCC Recipients')] }\n          )] }\n        )] }\n      )] }\n    ) : null] }\n  );\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}