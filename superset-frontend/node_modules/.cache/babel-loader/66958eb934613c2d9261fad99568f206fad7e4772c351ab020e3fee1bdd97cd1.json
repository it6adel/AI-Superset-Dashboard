{"ast":null,"code":"import { nanoid } from 'nanoid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { NativeFilterType, logging } from '@superset-ui/core';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nexport const REMOVAL_DELAY_SECS = 5;\nexport const hasCircularDependency = (dependencyMap, filterId, trace = []) => {\n  if (trace.includes(filterId)) {\n    return true;\n  }\n  const dependencies = dependencyMap.get(filterId);\n  if (dependencies) {\n    return dependencies.some((dependency) => hasCircularDependency(dependencyMap, dependency, [...trace, filterId]));\n  }\n  return false;\n};\nexport const validateForm = async (form, currentFilterId, setCurrentFilterId) => {\n  try {\n    let formValues;\n    try {\n      formValues = await form.validateFields();\n    }\n    catch (error) {var _error$errorFields;\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!(error != null && (_error$errorFields = error.errorFields) != null && _error$errorFields.length) && error != null && error.outOfDate) {\n        formValues = error.values;\n      } else\n      {\n        throw error;\n      }\n    }\n    return formValues;\n  }\n  catch (error) {var _error$errorFields2;\n    logging.warn('Filter configuration failed:', error);\n    if (!((_error$errorFields2 = error.errorFields) != null && _error$errorFields2.length))\n    return null; // not a validation error\n    const errorFields = error.errorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some((field) => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find((field) => field.name[0] === 'filters');\n      if (filterError) {\n        const filterId = filterError.name[1];\n        setCurrentFilterId(filterId);\n      }\n    }\n    return null;\n  }\n};\nexport const createHandleSave = (saveForm, filterChanges, values, filterConfigMap) => async () => {\n  const transformFilter = (id) => {var _values$filters, _formInputs$controlVa, _formInputs$requiredF, _formInputs$defaultDa;\n    const formInputs = ((_values$filters = values.filters) == null ? void 0 : _values$filters[id]) || filterConfigMap[id];\n    if (!formInputs) {\n      return undefined;\n    }\n    if (formInputs.type === NativeFilterType.Divider) {\n      return {\n        id,\n        type: NativeFilterType.Divider,\n        scope: {\n          rootPath: [DASHBOARD_ROOT_ID],\n          excluded: []\n        },\n        title: formInputs.title,\n        description: formInputs.description\n      };\n    }\n    const target = {};\n    if (formInputs.dataset) {\n      target.datasetId = formInputs.dataset.value;\n    }\n    if (formInputs.dataset && formInputs.column) {\n      target.column = { name: formInputs.column };\n    }\n    return {\n      id,\n      adhoc_filters: formInputs.adhoc_filters,\n      time_range: formInputs.time_range,\n      controlValues: (_formInputs$controlVa = formInputs.controlValues) != null ? _formInputs$controlVa : {},\n      granularity_sqla: formInputs.granularity_sqla,\n      requiredFirst: Object.values((_formInputs$requiredF = formInputs.requiredFirst) != null ? _formInputs$requiredF : {}).find((rf) => rf),\n      name: formInputs.name,\n      filterType: formInputs.filterType,\n      targets: [target],\n      defaultDataMask: (_formInputs$defaultDa = formInputs.defaultDataMask) != null ? _formInputs$defaultDa : getInitialDataMask(),\n      cascadeParentIds: formInputs.dependencies || [],\n      scope: formInputs.scope,\n      sortMetric: formInputs.sortMetric,\n      type: formInputs.type,\n      description: (formInputs.description || '').trim()\n    };\n    return undefined;\n  };\n  const transformedModified = filterChanges.modified.\n  map(transformFilter).\n  filter(Boolean);\n  const newFilterChanges = {\n    ...filterChanges,\n    modified: transformedModified\n  };\n  await saveForm(newFilterChanges);\n};\nexport const createHandleRemoveItem = (setRemovedFilters, setOrderedFilters, setSaveAlertVisible, removeFilter) => (filterId) => {\n  const completeFilterRemoval = (filterId) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters((removedFilters) => ({\n      ...removedFilters,\n      [filterId]: { isPending: false }\n    }));\n    setOrderedFilters((orderedFilters) => orderedFilters.filter((filter) => filter !== filterId));\n  };\n  // first set up the timer to completely remove it\n  const timerId = window.setTimeout(() => {\n    completeFilterRemoval(filterId);\n  }, REMOVAL_DELAY_SECS * 1000);\n  // mark the filter state as \"removal in progress\"\n  setRemovedFilters((removedFilters) => ({\n    ...removedFilters,\n    [filterId]: { isPending: true, timerId }\n  }));\n  removeFilter(filterId);\n  // eslint-disable-next-line no-param-reassign\n  setSaveAlertVisible(false);\n};\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const NATIVE_FILTER_DIVIDER_PREFIX = 'NATIVE_FILTER_DIVIDER-';\nexport const generateFilterId = (type) => {\n  const prefix = type === NativeFilterType.NativeFilter ?\n  NATIVE_FILTER_PREFIX :\n  NATIVE_FILTER_DIVIDER_PREFIX;\n  return `${prefix}${nanoid()}`;\n};\nexport const getFilterIds = (config) => config.map((filter) => filter.id);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}