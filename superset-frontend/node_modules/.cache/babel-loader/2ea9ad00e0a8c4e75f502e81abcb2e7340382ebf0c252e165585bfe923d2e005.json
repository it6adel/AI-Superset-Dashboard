{"ast":null,"code":"import _minBy from \"lodash/minBy\";import _maxBy from \"lodash/maxBy\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { GenericDataType, NumberFormats, getColumnLabel, getMetricLabel, getSequentialSchemeRegistry, getTimeFormatter, getValueFormatter, rgbToHex, addAlpha, supersetTheme, tooltipHtml } from '@superset-ui/core';\nimport memoizeOne from 'memoize-one';\n\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { parseAxisBound } from '../utils/controls';\nimport { NULL_STRING } from '../constants';\nimport { getPercentFormatter } from '../utils/formatters';\nconst DEFAULT_ECHARTS_BOUNDS = [0, 200];\n// Calculated totals per x and y categories plus total\nconst calculateTotals = memoizeOne((data, xAxis, groupby, metric) => data.reduce((acc, row) => {\n  const value = row[metric];\n  if (typeof value !== 'number') {\n    return acc;\n  }\n  const x = row[xAxis];\n  const y = row[groupby];\n  const xTotal = acc.x[x] || 0;\n  const yTotal = acc.y[y] || 0;\n  return {\n    x: { ...acc.x, [x]: xTotal + value },\n    y: { ...acc.y, [y]: yTotal + value },\n    total: acc.total + value\n  };\n}, { x: {}, y: {}, total: 0 }));\nexport default function transformProps(chartProps) {var _getSequentialSchemeR;\n  const refs = {};\n  const { width, height, formData, queriesData, datasource } = chartProps;\n  const { bottomMargin, xAxis, groupby, linearColorScheme, leftMargin, legendType = 'continuous', metric = '', normalizeAcross, normalized, borderColor, borderWidth = 0, showLegend, showPercentage, showValues, xscaleInterval, yscaleInterval, valueBounds, yAxisFormat, xAxisTimeFormat, currencyFormat } = formData;\n  const metricLabel = getMetricLabel(metric);\n  const xAxisLabel = getColumnLabel(xAxis);\n  // groupby is overridden to be a single value\n  const yAxisLabel = getColumnLabel(groupby);\n  const { data, colnames, coltypes } = queriesData[0];\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const colorColumn = normalized ? 'rank' : metricLabel;\n  const colors = (_getSequentialSchemeR = getSequentialSchemeRegistry().get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR.colors;\n  const getAxisFormatter = (colType) => (value) => {\n    if (colType === GenericDataType.Temporal) {\n      if (typeof value === 'string') {\n        return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n      }\n      return getTimeFormatter(xAxisTimeFormat)(value);\n    }\n    return String(value);\n  };\n  const xAxisFormatter = getAxisFormatter(coltypes[0]);\n  const yAxisFormatter = getAxisFormatter(coltypes[1]);\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const valueFormatter = getValueFormatter(metric, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  let [min, max] = (valueBounds || []).map(parseAxisBound);\n  if (min === undefined) {var _minBy2;\n    min =\n    ((_minBy2 = _minBy(data, (row) => row[colorColumn])) == null ? void 0 : _minBy2[colorColumn]) ||\n    DEFAULT_ECHARTS_BOUNDS[0];\n  }\n  if (max === undefined) {var _maxBy2;\n    max =\n    ((_maxBy2 = _maxBy(data, (row) => row[colorColumn])) == null ? void 0 : _maxBy2[colorColumn]) ||\n    DEFAULT_ECHARTS_BOUNDS[1];\n  }\n  const series = [\n  {\n    name: metricLabel,\n    type: 'heatmap',\n    data: data.map((row) => colnames.map((col) => {\n      const value = row[col];\n      if (!value) {\n        return NULL_STRING;\n      }\n      if (typeof value === 'boolean' || typeof value === 'bigint') {\n        return String(value);\n      }\n      return value;\n    })),\n    label: {\n      show: showValues,\n      formatter: (params) => {\n        const paramsValue = params.value;\n        return valueFormatter(paramsValue == null ? void 0 : paramsValue[2]);\n      }\n    },\n    itemStyle: {\n      borderColor: addAlpha(rgbToHex(borderColor.r, borderColor.g, borderColor.b), borderColor.a),\n      borderWidth\n    },\n    emphasis: {\n      itemStyle: {\n        borderColor: supersetTheme.colors.grayscale.light5,\n        shadowBlur: 10,\n        shadowColor: supersetTheme.colors.grayscale.dark2\n      }\n    }\n  }];\n\n  const echartOptions = {\n    grid: {\n      containLabel: true,\n      bottom: bottomMargin,\n      left: leftMargin\n    },\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (params) => {\n        const totals = calculateTotals(data, xAxisLabel, yAxisLabel, metricLabel);\n        const paramsValue = params.value;\n        const x = paramsValue == null ? void 0 : paramsValue[0];\n        const y = paramsValue == null ? void 0 : paramsValue[1];\n        const value = paramsValue == null ? void 0 : paramsValue[2];\n        const formattedX = xAxisFormatter(x);\n        const formattedY = yAxisFormatter(y);\n        const formattedValue = valueFormatter(value);\n        let percentage = 0;\n        let suffix = 'heatmap';\n        if (typeof value === 'number') {\n          if (normalizeAcross === 'x') {\n            percentage = value / totals.x[x];\n            suffix = formattedX;\n          } else\n          if (normalizeAcross === 'y') {\n            percentage = value / totals.y[y];\n            suffix = formattedY;\n          } else\n          {\n            percentage = value / totals.total;\n            suffix = 'heatmap';\n          }\n        }\n        const title = `${formattedX} (${formattedY})`;\n        const row = [colnames[2], formattedValue];\n        if (showPercentage) {\n          row.push(`${percentFormatter(percentage)} (${suffix})`);\n        }\n        return tooltipHtml([row], title);\n      }\n    },\n    visualMap: {\n      type: legendType,\n      min,\n      max,\n      calculable: true,\n      orient: 'horizontal',\n      right: 0,\n      top: 0,\n      itemHeight: legendType === 'continuous' ? 300 : 14,\n      itemWidth: 15,\n      formatter: (min) => valueFormatter(min),\n      inRange: {\n        color: colors\n      },\n      show: showLegend,\n      // By default, ECharts uses the last dimension which is rank\n      dimension: normalized ? 3 : 2\n    },\n    xAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        interval: xscaleInterval === -1 ? 'auto' : xscaleInterval - 1\n      }\n    },\n    yAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: yAxisFormatter,\n        interval: yscaleInterval === -1 ? 'auto' : yscaleInterval - 1\n      }\n    }\n  };\n  return {\n    refs,\n    echartOptions,\n    width,\n    height,\n    formData\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}