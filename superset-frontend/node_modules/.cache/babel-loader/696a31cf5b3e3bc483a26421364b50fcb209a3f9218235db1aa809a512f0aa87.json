{"ast":null,"code":"import _isEqualWith from \"lodash/isEqualWith\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { Behavior, isFeatureEnabled, FeatureFlag, getChartMetadataRegistry, styled, SuperChart, t, getClientErrorObject } from '@superset-ui/core';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { getChartDataRequest } from 'src/components/Chart/chartAction';\nimport Loading from 'src/components/Loading';\nimport ErrorMessageWithStackTrace from 'src/components/ErrorMessage/ErrorMessageWithStackTrace';\nimport { waitForAsyncData } from 'src/middleware/asyncEvent';\nimport { FilterBarOrientation } from 'src/dashboard/types';\nimport { onFiltersRefreshSuccess, setDirectPathToChild } from 'src/dashboard/actions/dashboardState';\nimport { RESPONSIVE_WIDTH } from 'src/filters/components/common';\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport ErrorAlert from 'src/components/ErrorMessage/ErrorAlert';\nimport { dispatchHoverAction, dispatchFocusAction } from './utils';\nimport { getFormData } from '../../utils';\nimport { useFilterDependencies } from './state';\nimport { useFilterOutlined } from '../useFilterOutlined';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst HEIGHT = 32;\n// Overrides superset-ui height with min-height\nconst StyledDiv = styled.div`\n  & > div {\n    height: auto !important;\n    min-height: ${HEIGHT}px;\n  }\n`;\nconst queriesDataPlaceholder = [{ data: [{}] }];\nconst behaviors = [Behavior.NativeFilter];\nconst useShouldFilterRefresh = () => {\n  const isDashboardRefreshing = useSelector((state) => state.dashboardState.isRefreshing);\n  const isFilterRefreshing = useSelector((state) => state.dashboardState.isFiltersRefreshing);\n  // trigger filter requests only after charts requests were triggered\n  return !isDashboardRefreshing && isFilterRefreshing;\n};\nconst FilterValue = ({ dataMaskSelected, filter, onFilterSelectionChange, inView = true, showOverflow, parentRef, setFilterActive, orientation = FilterBarOrientation.Vertical, overflow = false, validateStatus }) => {var _filter$dataMask3, _filter$dataMask4;\n  const { id, targets, filterType, adhoc_filters, time_range } = filter;\n  const metadata = getChartMetadataRegistry().get(filterType);\n  const dependencies = useFilterDependencies(id, dataMaskSelected);\n  const shouldRefresh = useShouldFilterRefresh();\n  const [state, setState] = useState([]);\n  const dashboardId = useSelector((state) => state.dashboardInfo.id);\n  const [error, setError] = useState();\n  const [formData, setFormData] = useState({\n    inView: false\n  });\n  const [ownState, setOwnState] = useState({});\n  const [inViewFirstTime, setInViewFirstTime] = useState(inView);\n  const inputRef = useRef(null);\n  const [target] = targets;\n  const { datasetId, column = {} } = target;\n  const { name: groupby } = column;\n  const hasDataSource = !!datasetId;\n  const [isLoading, setIsLoading] = useState(hasDataSource);\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const dispatch = useDispatch();\n  const { outlinedFilterId, lastUpdated } = useFilterOutlined();\n  const handleFilterLoadFinish = useCallback(() => {\n    setIsRefreshing(false);\n    setIsLoading(false);\n    if (shouldRefresh) {\n      dispatch(onFiltersRefreshSuccess());\n    }\n  }, [dispatch, shouldRefresh]);\n  useEffect(() => {\n    if (!inViewFirstTime && inView) {\n      setInViewFirstTime(true);\n    }\n  }, [inView, inViewFirstTime, setInViewFirstTime]);\n  useEffect(() => {var _filter$dataMask;\n    if (!inViewFirstTime) {\n      return;\n    }\n    const newFormData = getFormData({\n      ...filter,\n      datasetId,\n      dependencies,\n      groupby,\n      adhoc_filters,\n      time_range,\n      dashboardId\n    });\n    const filterOwnState = ((_filter$dataMask = filter.dataMask) == null ? void 0 : _filter$dataMask.ownState) || {};\n    // TODO: We should try to improve our useEffect hooks to depend more on\n    // granular information instead of big objects that require deep comparison.\n    const customizer = (objValue, othValue, key) => key === 'url_params' ? true : undefined;\n    if (!isRefreshing && (\n    !_isEqualWith(formData, newFormData, customizer) ||\n    !_isEqual(ownState, filterOwnState) ||\n    shouldRefresh)) {\n      setFormData(newFormData);\n      setOwnState(filterOwnState);\n      if (!hasDataSource) {\n        return;\n      }\n      setIsRefreshing(true);\n      getChartDataRequest({\n        formData: newFormData,\n        force: shouldRefresh,\n        ownState: filterOwnState\n      }).\n      then(({ response, json }) => {\n        if (isFeatureEnabled(FeatureFlag.GlobalAsyncQueries)) {\n          // deal with getChartDataRequest transforming the response data\n          const result = 'result' in json ? json.result[0] : json;\n          if (response.status === 200) {\n            setState([result]);\n            handleFilterLoadFinish();\n          } else\n          if (response.status === 202) {\n            waitForAsyncData(result).\n            then((asyncResult) => {\n              setState(asyncResult);\n              handleFilterLoadFinish();\n            }).\n            catch((error) => {\n              getClientErrorObject(error).then((clientErrorObject) => {\n                setError(clientErrorObject);\n                handleFilterLoadFinish();\n              });\n            });\n          } else\n          {\n            throw new Error(`Received unexpected response status (${response.status}) while fetching chart data`);\n          }\n        } else\n        {\n          setState(json.result);\n          setError(undefined);\n          handleFilterLoadFinish();\n        }\n      }).\n      catch((error) => {\n        getClientErrorObject(error).then((clientErrorObject) => {\n          setError(clientErrorObject);\n          handleFilterLoadFinish();\n        });\n      });\n    }\n  }, [\n  inViewFirstTime,\n  dependencies,\n  datasetId,\n  groupby,\n  handleFilterLoadFinish,\n  filter,\n  hasDataSource,\n  isRefreshing,\n  shouldRefresh]\n  );\n  useEffect(() => {\n    if (outlinedFilterId && outlinedFilterId === filter.id) {\n      setTimeout(() => {var _inputRef$current;\n        inputRef == null ? void 0 : (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();\n      }, overflow ? FAST_DEBOUNCE : 0);\n    }\n  }, [inputRef, outlinedFilterId, lastUpdated, filter.id, overflow]);\n  const setDataMask = useCallback((dataMask) => onFilterSelectionChange(filter, dataMask), [filter, onFilterSelectionChange]);\n  const setFocusedFilter = useCallback(() => {\n    // don't highlight charts in scope if filter was focused programmatically\n    if (outlinedFilterId !== id) {\n      dispatchFocusAction(dispatch, id);\n    }\n  }, [dispatch, id, outlinedFilterId]);\n  const unsetFocusedFilter = useCallback(() => {\n    dispatchFocusAction(dispatch);\n    if (outlinedFilterId === id) {\n      dispatch(setDirectPathToChild([]));\n    }\n  }, [dispatch, id, outlinedFilterId]);\n  const setHoveredFilter = useCallback(() => dispatchHoverAction(dispatch, id), [dispatch, id]);\n  const unsetHoveredFilter = useCallback(() => dispatchHoverAction(dispatch), [dispatch]);\n  const hooks = useMemo(() => ({\n    setDataMask,\n    setHoveredFilter,\n    unsetHoveredFilter,\n    setFocusedFilter,\n    unsetFocusedFilter,\n    setFilterActive\n  }), [\n  setDataMask,\n  setFilterActive,\n  setHoveredFilter,\n  unsetHoveredFilter,\n  setFocusedFilter,\n  unsetFocusedFilter]\n  );\n  const filterState = useMemo(() => {var _filter$dataMask2;return {\n      validateStatus,\n      ...((_filter$dataMask2 = filter.dataMask) == null ? void 0 : _filter$dataMask2.filterState)\n    };}, [(_filter$dataMask3 = filter.dataMask) == null ? void 0 : _filter$dataMask3.filterState, validateStatus]);\n  const displaySettings = useMemo(() => ({\n    filterBarOrientation: orientation,\n    isOverflowingFilterBar: overflow\n  }), [orientation, overflow]);\n  if (error) {var _error$errors;\n    return _jsx(ErrorMessageWithStackTrace, { error: (_error$errors = error.errors) == null ? void 0 : _error$errors[0], compact: true, fallback: _jsx(ErrorAlert, { errorType: t('Network error'), message: t('Network error while attempting to fetch resource'), type: \"error\", compact: true }) });\n  }\n  return _jsx(StyledDiv, { children:\n    isLoading ? _jsx(Loading, { position: \"inline-centered\" }) : _jsx(SuperChart, { height: HEIGHT, width: RESPONSIVE_WIDTH, showOverflow: showOverflow, formData: formData, displaySettings: displaySettings, parentRef: parentRef, inputRef: inputRef\n      // For charts that don't have datasource we need workaround for empty placeholder\n      , queriesData: hasDataSource ? state : queriesDataPlaceholder, chartType: filterType, behaviors: behaviors, filterState: filterState, ownState: (_filter$dataMask4 = filter.dataMask) == null ? void 0 : _filter$dataMask4.ownState, enableNoResults: metadata == null ? void 0 : metadata.enableNoResults, isRefreshing: isRefreshing, hooks: hooks }) }\n  );\n};\nexport default /*#__PURE__*/memo(FilterValue);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}