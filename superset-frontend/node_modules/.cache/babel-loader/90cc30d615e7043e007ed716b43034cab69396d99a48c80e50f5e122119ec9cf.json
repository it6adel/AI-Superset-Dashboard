{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport d3 from 'd3';\nimport d3tip from 'd3-tip';\nimport dompurify from 'dompurify';\nimport {\n  SMART_DATE_ID,\n  getTimeFormatter,\n  getNumberFormatter } from\n'@superset-ui/core';\n// Regexp for the label added to time shifted series\n// (1 hour offset, 2 days offset, etc.)\nconst TIME_SHIFT_PATTERN = /\\d+ \\w+ offset/;\n\nconst ANIMATION_TIME = 1000;\n\nexport function cleanColorInput(value) {\n  // for superset series that should have the same color\n  return String(value).\n  trim().\n  replace(' (right axis)', '').\n  split(', ').\n  filter((k) => !TIME_SHIFT_PATTERN.test(k)).\n  join(', ');\n}\n\n/**\n * If format is smart_date, format date\n * Otherwise, format number with the given format name\n * @param {*} format\n */\nexport function getTimeOrNumberFormatter(format) {\n  return format === SMART_DATE_ID ?\n  getTimeFormatter(SMART_DATE_ID) :\n  getNumberFormatter(format);\n}\n\nexport function drawBarValues(svg, data, stacked, axisFormat) {\n  const format = getNumberFormatter(axisFormat);\n  const countSeriesDisplayed = data.filter((d) => !d.disabled).length;\n  const totalStackedValues =\n  stacked && data.length !== 0 ?\n  data[0].values.map((bar, iBar) => {\n    const bars = data.\n    filter((series) => !series.disabled).\n    map((series) => series.values[iBar]);\n\n    return d3.sum(bars, (d) => d.y);\n  }) :\n  [];\n  svg.selectAll('.bar-chart-label-group').remove();\n  setTimeout(() => {\n    svg.selectAll('.bar-chart-label-group').remove();\n    const groupLabels = svg.\n    select('g.nv-barsWrap').\n    append('g').\n    attr('class', 'bar-chart-label-group');\n    svg.\n    selectAll('g.nv-group').\n    filter((d, i) => !stacked || i === countSeriesDisplayed - 1).\n    selectAll('rect').\n    each(function each(d, index) {\n      const rectObj = d3.select(this);\n      const transformAttr = rectObj.attr('transform');\n      const xPos = parseFloat(rectObj.attr('x'));\n      const yPos = parseFloat(rectObj.attr('y'));\n      const rectWidth = parseFloat(rectObj.attr('width'));\n      const rectHeight = parseFloat(rectObj.attr('height'));\n      const textEls = groupLabels.\n      append('text').\n      text(format(stacked ? totalStackedValues[index] : d.y)).\n      attr('transform', transformAttr).\n      attr('class', 'bar-chart-label');\n\n      // fine tune text position\n      const bbox = textEls.node().getBBox();\n      const labelWidth = bbox.width;\n      const labelHeight = bbox.height;\n      textEls.attr('x', xPos + rectWidth / 2 - labelWidth / 2);\n      if (rectObj.attr('class').includes('positive')) {\n        textEls.attr('y', yPos - 5);\n      } else {\n        textEls.attr('y', yPos + rectHeight + labelHeight);\n      }\n    });\n  }, ANIMATION_TIME);\n}\n\n// Formats the series key to account for a possible NULL value\nfunction getFormattedKey(seriesKey, shouldDompurify) {\n  if (seriesKey === '<NULL>') {\n    return `&lt;${seriesKey.slice(1, -1)}&gt;`;\n  }\n\n  return shouldDompurify ? dompurify.sanitize(seriesKey) : seriesKey;\n}\n\nexport function generateCompareTooltipContent(d, valueFormatter) {\n  let tooltip = '';\n  tooltip +=\n  \"<table><thead><tr><td colspan='3'>\" +\n  `<strong class='x-value'>${d.value}</strong>` +\n  '</td></tr></thead><tbody>';\n  d.series.sort((a, b) => a.value >= b.value ? -1 : 1);\n  d.series.forEach((series) => {\n    const key = getFormattedKey(series.key, true);\n    tooltip +=\n    `<tr class=\"${series.highlight ? 'emph' : ''}\">` +\n    `<td class='legend-color-guide' style=\"opacity: ${\n    series.highlight ? '1' : '0.75'};\"\">` +\n\n    '<div ' +\n    `style=\"border: 2px solid ${\n    series.highlight ? 'black' : 'transparent'}; background-color: ${\n    series.color};\"` +\n    '></div>' +\n    '</td>' +\n    `<td>${key}</td>` +\n    `<td>${valueFormatter(series.value)}</td>` +\n    '</tr>';\n  });\n  tooltip += '</tbody></table>';\n\n  return dompurify.sanitize(tooltip);\n}\n\nexport function generateMultiLineTooltipContent(d, xFormatter, yFormatters) {\n  const tooltipTitle = xFormatter(d.value);\n  let tooltip = '';\n\n  tooltip +=\n  \"<table><thead><tr><td colspan='3'>\" +\n  `<strong class='x-value'>${tooltipTitle}</strong>` +\n  '</td></tr></thead><tbody>';\n\n  d.series.forEach((series, i) => {\n    const yFormatter = yFormatters[i];\n    const key = getFormattedKey(series.key, false);\n    tooltip +=\n    \"<tr><td class='legend-color-guide'>\" +\n    `<div style=\"background-color: ${series.color};\"></div></td>` +\n    `<td class='key'>${key}</td>` +\n    `<td class='value'>${yFormatter(series.value)}</td></tr>`;\n  });\n\n  tooltip += '</tbody></table>';\n\n  return tooltip;\n}\n\nexport function generateTimePivotTooltip(d, xFormatter, yFormatter) {\n  const tooltipTitle = xFormatter(d.value);\n  let tooltip = '';\n\n  tooltip +=\n  \"<table><thead><tr><td colspan='3'>\" +\n  `<strong class='x-value'>${tooltipTitle}</strong>` +\n  '</td></tr></thead><tbody>';\n\n  d.series.forEach((series) => {\n    if (series.highlight) {\n      let label = '';\n      if (series.key === 'current') {\n        label = series.key;\n      } else {\n        label = `${series.key} of the selected frequency:`;\n      }\n      tooltip +=\n      \"<tr><td class='legend-color-guide'>\" +\n      `<div style=\"background-color: ${series.color};\"></div></td>` +\n      `<td class='key'>${label}</td>` +\n      `<td class='value'>${yFormatter(series.value)}</td></tr>`;\n    }\n  });\n\n  tooltip += '</tbody></table>';\n\n  return dompurify.sanitize(tooltip);\n}\n\nfunction getLabel(stringOrObjectWithLabel) {\n  return stringOrObjectWithLabel.label || stringOrObjectWithLabel;\n}\n\nfunction createHTMLRow(col1, col2) {\n  return `<tr><td>${col1}</td><td>${col2}</td></tr>`;\n}\n\nexport function generateBubbleTooltipContent({\n  point,\n  entity,\n  xField,\n  yField,\n  sizeField,\n  xFormatter,\n  yFormatter,\n  sizeFormatter\n}) {\n  let s = '<table>';\n  s +=\n  `<tr><td style=\"color: ${point.color};\">` +\n  `<strong>${point[entity]}</strong> (${point.group})` +\n  '</td></tr>';\n  s += createHTMLRow(getLabel(xField), xFormatter(point.x));\n  s += createHTMLRow(getLabel(yField), yFormatter(point.y));\n  s += createHTMLRow(getLabel(sizeField), sizeFormatter(point.size));\n  s += '</table>';\n\n  return s;\n}\n\n// shouldRemove indicates whether the nvtooltips should be removed from the DOM\nexport function hideTooltips(shouldRemove) {\n  const targets = document.querySelectorAll('.nvtooltip');\n  if (targets.length > 0) {\n    // Only set opacity to 0 when hiding tooltips so they would reappear\n    // on hover, which sets the opacity to 1\n    targets.forEach((t) => {\n      if (shouldRemove) {\n        t.remove();\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        t.style.opacity = 0;\n      }\n    });\n  }\n}\n\nexport function generateTooltipClassName(uuid) {\n  return `tooltip-${uuid}`;\n}\n\nexport function removeTooltip(uuid) {\n  const classSelector = `.${generateTooltipClassName(uuid)}`;\n  const target = document.querySelector(classSelector);\n  if (target) {\n    target.remove();\n  }\n}\n\nexport function wrapTooltip(chart) {\n  const tooltipLayer =\n  chart.useInteractiveGuideline && chart.useInteractiveGuideline() ?\n  chart.interactiveLayer :\n  chart;\n  const tooltipGeneratorFunc = tooltipLayer.tooltip.contentGenerator();\n  tooltipLayer.tooltip.contentGenerator((d) => {\n    let tooltip = `<div>`;\n    tooltip += tooltipGeneratorFunc(d);\n    tooltip += '</div>';\n\n    return tooltip;\n  });\n}\n\nexport function tipFactory(layer) {\n  return d3tip().\n  attr('class', `d3-tip ${layer.annotationTipClass || ''}`).\n  direction('n').\n  offset([-5, 0]).\n  html((d) => {\n    if (!d) {\n      return '';\n    }\n    const title =\n    d[layer.titleColumn] && d[layer.titleColumn].length > 0 ?\n    `${d[layer.titleColumn]} - ${layer.name}` :\n    layer.name;\n    const body = Array.isArray(layer.descriptionColumns) ?\n    layer.descriptionColumns.map((c) => d[c]) :\n    Object.values(d);\n\n    return `<div><strong>${title}</strong></div><br/><div>${body.join(\n      ', '\n    )}</div>`;\n  });\n}\n\nexport function getMaxLabelSize(svg, axisClass) {\n  // axis class = .nv-y2  // second y axis on dual line chart\n  // axis class = .nv-x  // x axis on time series line chart\n  const tickTexts = svg.selectAll(`.${axisClass} g.tick text`);\n  if (tickTexts.length > 0) {\n    const lengths = tickTexts[0].map((text) => text.getComputedTextLength());\n\n    return Math.ceil(Math.max(0, ...lengths));\n  }\n\n  return 0;\n}\n\nexport function formatLabel(input, verboseMap = {}) {\n  // The input for label may be a string or an array of string\n  // When using the time shift feature, the label contains a '---' in the array\n  const verboseLookup = (s) => verboseMap[s] || s;\n\n  return Array.isArray(input) && input.length > 0 ?\n  input.\n  map((l) => TIME_SHIFT_PATTERN.test(l) ? l : verboseLookup(l)).\n  join(', ') :\n  verboseLookup(input);\n}\n\nexport function stringifyTimeRange(extent) {\n  if (extent.some((d) => d.toISOString === undefined)) {\n    return null;\n  }\n\n  return extent.map((d) => d.toISOString().slice(0, -1)).join(' : ');\n}\n\nexport function setAxisShowMaxMin(axis, showminmax) {\n  if (axis && axis.showMaxMin && showminmax !== undefined) {\n    axis.showMaxMin(showminmax);\n  }\n}\n\nexport function computeYDomain(data) {\n  if (Array.isArray(data) && data.length > 0 && Array.isArray(data[0].values)) {\n    const extents = data.\n    filter((d) => !d.disabled).\n    map((row) => d3.extent(row.values, (v) => v.y));\n    const minOfMin = d3.min(extents, ([min]) => min);\n    const maxOfMax = d3.max(extents, ([, max]) => max);\n\n    return [minOfMin, maxOfMax];\n  }\n\n  return [0, 1];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}