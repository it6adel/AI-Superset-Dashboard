{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { ensureIsArray } from '../utils';\nimport { customTimeRangeDecode } from './customTimeRangeDecode';\nconst DAY_IN_MS = 24 * 60 * 60 * 1000;\nexport const parseDttmToDate = (dttm, isEndDate = false, computingShifts = false) => {\n  const now = new Date();\n  if (dttm === 'now' || dttm === 'No filter' || dttm === '') {\n    return now;\n  }\n  if (dttm === 'today') {\n    now.setHours(0, 0, 0, 0);\n    return now;\n  }\n  if (computingShifts) {\n    now.setHours(-now.getTimezoneOffset() / 60, 0, 0, 0);\n  } else\n  {\n    now.setHours(0, 0, 0, 0);\n  }\n  if (isEndDate && dttm != null && dttm.includes('Last')) {\n    return now;\n  }\n  switch (dttm) {\n    case 'Last day':\n      now.setUTCDate(now.getUTCDate() - 1);\n      return now;\n    case 'Last week':\n      now.setUTCDate(now.getUTCDate() - 7);\n      return now;\n    case 'Last month':\n      now.setUTCMonth(now.getUTCMonth() - 1);\n      return now;\n    case 'Last quarter':\n      now.setUTCMonth(now.getUTCMonth() - 3);\n      return now;\n    case 'Last year':\n      now.setUTCFullYear(now.getUTCFullYear() - 1);\n      return now;\n    case 'previous calendar week':\n      if (isEndDate) {\n        now.setDate(now.getDate() - now.getDay() + 1); // end date is the last day of the previous week (Sunday)\n      } else\n      {\n        now.setDate(now.getDate() - now.getDay() - 6); // start date is the first day of the previous week (Monday)\n      }\n      return now;\n    case 'previous calendar month':\n      if (isEndDate) {\n        now.setDate(1); // end date is the last day of the previous month\n      } else\n      {\n        now.setDate(1); // start date is the first day of the previous month\n        now.setMonth(now.getMonth() - 1);\n      }\n      return now;\n    case 'previous calendar year':\n      if (isEndDate) {\n        now.setFullYear(now.getFullYear(), 0, 1); // end date is the last day of the previous year\n      } else\n      {\n        now.setFullYear(now.getFullYear() - 1, 0, 1); // start date is the first day of the previous year\n      }\n      return now;\n    default:\n      break;\n  }\n  if (dttm != null && dttm.includes('ago')) {\n    const parts = dttm.split(' ');\n    const amount = parseInt(parts[0], 10);\n    const unit = parts[1];\n    switch (unit) {\n      case 'day':\n      case 'days':\n        now.setUTCDate(now.getUTCDate() - amount);\n        break;\n      case 'week':\n      case 'weeks':\n        now.setUTCDate(now.getUTCDate() - amount * 7);\n        break;\n      case 'month':\n      case 'months':\n        now.setUTCMonth(now.getUTCMonth() - amount);\n        break;\n      case 'year':\n      case 'years':\n        now.setUTCFullYear(now.getUTCFullYear() - amount);\n        break;\n      default:\n        break;\n    }\n    return now;\n  }\n  const parts = dttm == null ? void 0 : dttm.split('-');\n  let parsed = null;\n  if (parts && !_isEmpty(parts)) {\n    if (parts.length === 1) {\n      parsed = new Date(Date.UTC(parseInt(parts[0], 10), 0));\n    } else\n    if (parts.length === 2) {\n      parsed = new Date(Date.UTC(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1));\n    } else\n    if (parts.length === 3) {\n      parsed = new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parseInt(parts[2], 10));\n    } else\n    {\n      parsed = new Date(dttm);\n    }\n  } else\n  {\n    parsed = new Date(dttm);\n  }\n  if (parsed && !Number.isNaN(parsed.getTime())) {\n    if (computingShifts) {\n      parsed.setHours(-parsed.getTimezoneOffset() / 60, 0, 0, 0);\n    } else\n    {\n      parsed.setHours(0, 0, 0, 0);\n    }\n    return parsed;\n  }\n  // Return null if the string cannot be parsed into a date\n  return null;\n};\nexport const computeCustomDateTime = (dttm, grain, grainValue) => {\n  let parsed;\n  if (dttm === 'now' || dttm === 'today') {\n    parsed = new Date();\n  } else\n  {\n    parsed = new Date(dttm);\n  }\n  if (!Number.isNaN(parsed.getTime())) {\n    switch (grain) {\n      case 'second':\n        parsed.setSeconds(parsed.getSeconds() + grainValue);\n        break;\n      case 'minute':\n        parsed.setMinutes(parsed.getMinutes() + grainValue);\n        break;\n      case 'hour':\n        parsed.setHours(parsed.getHours() + grainValue);\n        break;\n      case 'day':\n        parsed.setDate(parsed.getDate() + grainValue);\n        break;\n      case 'week':\n        parsed.setDate(parsed.getDate() + grainValue * 7);\n        break;\n      case 'month':\n        parsed.setMonth(parsed.getMonth() + grainValue);\n        break;\n      case 'quarter':\n        parsed.setMonth(parsed.getMonth() + grainValue * 3);\n        break;\n      case 'year':\n        parsed.setFullYear(parsed.getFullYear() + grainValue);\n        break;\n      default:\n        break;\n    }\n    return parsed;\n  }\n  return null;\n};\nexport const getTimeOffset = ({ timeRangeFilter, shifts, startDate, includeFutureOffsets = true }) => {var _timeRangeFilter$comp, _timeRangeFilter$comp2, _ref, _customStartDate2, _ref2, _customEndDate2;\n  const { customRange, matchedFlag } = customTimeRangeDecode((_timeRangeFilter$comp = timeRangeFilter == null ? void 0 : timeRangeFilter.comparator) != null ? _timeRangeFilter$comp : '');\n  let customStartDate = null;\n  let customEndDate = null;\n  if (matchedFlag) {var _customStartDate, _customEndDate;\n    // Compute the start date and end date using the custom range information\n    const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue, untilDatetime, untilMode, untilGrain, untilGrainValue } = { ...customRange };\n    if (sinceMode !== 'relative') {\n      if (sinceMode === 'specific') {\n        customStartDate = new Date(sinceDatetime);\n      } else\n      {\n        customStartDate = parseDttmToDate(sinceDatetime, false, true);\n      }\n    } else\n    {\n      customStartDate = computeCustomDateTime(sinceDatetime, sinceGrain, sinceGrainValue);\n    }\n    (_customStartDate = customStartDate) == null ? void 0 : _customStartDate.setHours(0, 0, 0, 0);\n    if (untilMode !== 'relative') {\n      if (untilMode === 'specific') {\n        customEndDate = new Date(untilDatetime);\n      } else\n      {\n        customEndDate = parseDttmToDate(untilDatetime, false, true);\n      }\n    } else\n    {\n      customEndDate = computeCustomDateTime(untilDatetime, untilGrain, untilGrainValue);\n    }\n    (_customEndDate = customEndDate) == null ? void 0 : _customEndDate.setHours(0, 0, 0, 0);\n  }\n  const isCustom = shifts == null ? void 0 : shifts.includes('custom');\n  const isInherit = shifts == null ? void 0 : shifts.includes('inherit');\n  let customStartDateTime;\n  if (isCustom) {\n    if (matchedFlag) {\n      customStartDateTime = new Date(new Date(startDate).setUTCHours(new Date(startDate).getTimezoneOffset() / 60, 0, 0, 0)).getTime();\n    } else\n    {var _parseDttmToDate;\n      customStartDateTime = (_parseDttmToDate = parseDttmToDate(startDate)) == null ? void 0 : _parseDttmToDate.getTime();\n    }\n  }\n  const [startStr, endStr] = ((_timeRangeFilter$comp2 = timeRangeFilter == null ? void 0 : timeRangeFilter.comparator) != null ? _timeRangeFilter$comp2 : '').\n  split(' : ').\n  map((date) => date.trim());\n  const filterStartDateTime = ((_ref = (_customStartDate2 = customStartDate) != null ? _customStartDate2 : parseDttmToDate(startStr, false, false)) == null ? void 0 : _ref.getTime()) ||\n  0;\n  const filterEndDateTime = ((_ref2 = (_customEndDate2 = customEndDate) != null ? _customEndDate2 : parseDttmToDate(endStr || startStr, true, false)) == null ? void 0 : _ref2.getTime()) || 0;\n  const customShift = customStartDateTime &&\n  filterStartDateTime &&\n  Math.round((filterStartDateTime - customStartDateTime) / DAY_IN_MS);\n  const inInheritShift = isInherit &&\n  filterEndDateTime &&\n  filterStartDateTime &&\n  Math.round((filterEndDateTime - filterStartDateTime) / DAY_IN_MS);\n  const newShifts = ensureIsArray(shifts).\n  map((shift) => {\n    if (shift === 'custom') {\n      if (customShift !== undefined && !Number.isNaN(customShift)) {\n        if (includeFutureOffsets && customShift < 0) {\n          return `${customShift * -1} days after`;\n        }\n        if (customShift >= 0 && filterStartDateTime) {\n          return `${customShift} days ago`;\n        }\n      }\n    }\n    if (shift === 'inherit') {\n      if (inInheritShift && !Number.isNaN(inInheritShift)) {\n        if (includeFutureOffsets && inInheritShift < 0) {\n          return `${inInheritShift * -1} days after`;\n        }\n        if (inInheritShift > 0) {\n          return `${inInheritShift} days ago`;\n        }\n      }\n    }\n    return shift;\n  }).\n  filter((shift) => shift !== 'custom' && shift !== 'inherit');\n  return ensureIsArray(newShifts);\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}