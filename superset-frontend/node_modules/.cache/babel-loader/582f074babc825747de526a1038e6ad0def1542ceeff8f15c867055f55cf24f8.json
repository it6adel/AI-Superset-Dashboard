{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useContext, useEffect, useMemo, useState } from 'react';\nimport { css, ensureIsArray, isDefined, t, useTheme } from '@superset-ui/core';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { Link } from 'react-router-dom';\nimport Modal from 'src/components/Modal';\nimport Loading from 'src/components/Loading';\nimport Button from 'src/components/Button';\nimport { DashboardPageIdContext } from 'src/dashboard/containers/DashboardPage';\nimport { postFormData } from 'src/explore/exploreUtils/formData';\nimport { simpleFilterToAdhoc } from 'src/utils/simpleFilterToAdhoc';\nimport { useDatasetMetadataBar } from 'src/features/datasets/metadataBar/useDatasetMetadataBar';\nimport { useToasts } from 'src/components/MessageToasts/withToasts';\nimport Alert from 'src/components/Alert';\nimport { logEvent } from 'src/logger/actions';\nimport { LOG_ACTIONS_DRILL_BY_BREADCRUMB_CLICKED, LOG_ACTIONS_DRILL_BY_EDIT_CHART, LOG_ACTIONS_DRILL_BY_MODAL_OPENED, LOG_ACTIONS_FURTHER_DRILL_BY } from 'src/logger/LogUtils';\nimport { findPermission } from 'src/utils/findPermission';\nimport { getQuerySettings } from 'src/explore/exploreUtils';\nimport { DrillByType } from '../types';\nimport DrillByChart from './DrillByChart';\nimport { ContextMenuItem } from '../ChartContextMenu/ChartContextMenu';\nimport { useContextMenu } from '../ChartContextMenu/useContextMenu';\nimport { getChartDataRequest, handleChartDataResponse } from '../chartAction';\nimport { useDisplayModeToggle } from './useDisplayModeToggle';\nimport { useDrillByBreadcrumbs } from './useDrillByBreadcrumbs';\nimport { useResultsTableView } from './useResultsTableView';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst DEFAULT_ADHOC_FILTER_FIELD_NAME = 'adhoc_filters';\nconst ModalFooter = ({ formData, closeModal }) => {\n  const dispatch = useDispatch();\n  const { addDangerToast } = useToasts();\n  const theme = useTheme();\n  const [url, setUrl] = useState('');\n  const dashboardPageId = useContext(DashboardPageIdContext);\n  const onEditChartClick = useCallback(() => {\n    dispatch(logEvent(LOG_ACTIONS_DRILL_BY_EDIT_CHART, {\n      slice_id: formData.slice_id\n    }));\n  }, [dispatch, formData.slice_id]);\n  const canExplore = useSelector((state) => {var _state$user;return findPermission('can_explore', 'Superset', (_state$user = state.user) == null ? void 0 : _state$user.roles);});\n  const [datasource_id, datasource_type] = formData.datasource.split('__');\n  useEffect(() => {\n    postFormData(Number(datasource_id), datasource_type, formData, 0).\n    then((key) => {\n      setUrl(`/explore/?form_data_key=${key}&dashboard_page_id=${dashboardPageId}`);\n    }).\n    catch(() => {\n      addDangerToast(t('Failed to generate chart edit URL'));\n    });\n  }, [\n  addDangerToast,\n  dashboardPageId,\n  datasource_id,\n  datasource_type,\n  formData]\n  );\n  const isEditDisabled = !url || !canExplore;\n  return _jsxs(_Fragment, { children: [\n    _jsx(Button, { buttonStyle: \"secondary\", buttonSize: \"small\", onClick: onEditChartClick, disabled: isEditDisabled, tooltip: isEditDisabled ?\n      t('You do not have sufficient permissions to edit the chart') :\n      undefined, children:\n      _jsx(Link, { css: css`\n            &:hover {\n              text-decoration: none;\n            }\n          `, to: url, children:\n        t('Edit chart') }\n      ) }\n    ),\n\n    _jsx(Button, { buttonStyle: \"primary\", buttonSize: \"small\", onClick: closeModal, css: css`\n          margin-left: ${theme.gridUnit * 2}px;\n        `, children:\n      t('Close') }\n    )] }\n  );\n};\nexport default function DrillByModal({ column, dataset, drillByConfig, formData, onHideModal, canDownload }) {\n  const dispatch = useDispatch();\n  const theme = useTheme();\n  const { addDangerToast } = useToasts();\n  const [isChartDataLoading, setIsChartDataLoading] = useState(true);\n  const [drillByConfigs, setDrillByConfigs] = useState([\n  { ...drillByConfig, column }]\n  );\n  useEffect(() => {\n    dispatch(logEvent(LOG_ACTIONS_DRILL_BY_MODAL_OPENED, {\n      slice_id: formData.slice_id\n    }));\n  }, [dispatch, formData.slice_id]);\n  const { column: currentColumn, groupbyFieldName = drillByConfig.groupbyFieldName } = drillByConfigs[drillByConfigs.length - 1] || {};\n  const initialGroupbyColumns = useMemo(() => ensureIsArray(formData[groupbyFieldName]).\n  map((colName) => {var _dataset$columns;return (_dataset$columns = dataset.columns) == null ? void 0 : _dataset$columns.find((col) => col.column_name === colName);}).\n  filter(isDefined), [dataset.columns, formData, groupbyFieldName]);\n  const { displayModeToggle, drillByDisplayMode } = useDisplayModeToggle();\n  const [chartDataResult, setChartDataResult] = useState();\n  const resultsTable = useResultsTableView(chartDataResult, formData.datasource, canDownload);\n  const [currentFormData, setCurrentFormData] = useState(formData);\n  const [usedGroupbyColumns, setUsedGroupbyColumns] = useState([...initialGroupbyColumns, column].filter(isDefined));\n  const [breadcrumbsData, setBreadcrumbsData] = useState([\n  { groupby: initialGroupbyColumns, filters: drillByConfig.filters },\n  { groupby: column || [] }]\n  );\n  const getNewGroupby = useCallback((groupbyCol, fieldName = groupbyFieldName) => Array.isArray(formData[fieldName]) ?\n  [groupbyCol.column_name] :\n  groupbyCol.column_name, [formData, groupbyFieldName]);\n  const getFormDataChangesFromConfigs = useCallback((configs) => configs.reduce((acc, config) => {\n    if (config != null && config.groupbyFieldName && config.column) {\n      acc.formData[config.groupbyFieldName] = getNewGroupby(config.column, config.groupbyFieldName);\n      acc.overriddenGroupbyFields.add(config.groupbyFieldName);\n    }\n    const adhocFilterFieldName = (config == null ? void 0 : config.adhocFilterFieldName) || DEFAULT_ADHOC_FILTER_FIELD_NAME;\n    acc.formData[adhocFilterFieldName] = [\n    ...ensureIsArray(acc[adhocFilterFieldName]),\n    ...ensureIsArray(config.filters).map((filter) => simpleFilterToAdhoc(filter))];\n\n    acc.overriddenAdhocFilterFields.add(adhocFilterFieldName);\n    return acc;\n  }, {\n    formData: {},\n    overriddenGroupbyFields: new Set(),\n    overriddenAdhocFilterFields: new Set()\n  }), [getNewGroupby]);\n  const getFiltersFromConfigsByFieldName = useCallback(() => drillByConfigs.reduce((acc, config) => {\n    const adhocFilterFieldName = config.adhocFilterFieldName || DEFAULT_ADHOC_FILTER_FIELD_NAME;\n    acc[adhocFilterFieldName] = [\n    ...(acc[adhocFilterFieldName] || []),\n    ...config.filters.map((filter) => simpleFilterToAdhoc(filter))];\n\n    return acc;\n  }, {}), [drillByConfigs]);\n  const onBreadcrumbClick = useCallback((breadcrumb, index) => {\n    dispatch(logEvent(LOG_ACTIONS_DRILL_BY_BREADCRUMB_CLICKED, {\n      slice_id: formData.slice_id\n    }));\n    setDrillByConfigs((prevConfigs) => prevConfigs.slice(0, index));\n    setBreadcrumbsData((prevBreadcrumbs) => {\n      const newBreadcrumbs = prevBreadcrumbs.slice(0, index + 1);\n      delete newBreadcrumbs[newBreadcrumbs.length - 1].filters;\n      return newBreadcrumbs;\n    });\n    setUsedGroupbyColumns((prevUsedGroupbyColumns) => prevUsedGroupbyColumns.slice(0, index));\n    setCurrentFormData(() => {\n      if (index === 0) {\n        return formData;\n      }\n      const { formData: overrideFormData, overriddenAdhocFilterFields } = getFormDataChangesFromConfigs(drillByConfigs.slice(0, index));\n      const newFormData = {\n        ...formData,\n        ...overrideFormData\n      };\n      overriddenAdhocFilterFields.forEach((adhocFilterField) => ({\n        ...newFormData,\n        [adhocFilterField]: [\n        ...formData[adhocFilterField],\n        ...overrideFormData[adhocFilterField]]\n\n      }));\n      return newFormData;\n    });\n  }, [dispatch, drillByConfigs, formData, getFormDataChangesFromConfigs]);\n  const breadcrumbs = useDrillByBreadcrumbs(breadcrumbsData, onBreadcrumbClick);\n  const drilledFormData = useMemo(() => {\n    let updatedFormData = { ...currentFormData };\n    if (currentColumn && groupbyFieldName) {\n      updatedFormData[groupbyFieldName] = getNewGroupby(currentColumn);\n    }\n    const adhocFilters = getFiltersFromConfigsByFieldName();\n    Object.keys(adhocFilters).forEach((adhocFilterFieldName) => {\n      updatedFormData = {\n        ...updatedFormData,\n        [adhocFilterFieldName]: [\n        ...ensureIsArray(formData[adhocFilterFieldName]),\n        ...adhocFilters[adhocFilterFieldName]]\n\n      };\n    });\n    updatedFormData.slice_id = 0;\n    delete updatedFormData.slice_name;\n    delete updatedFormData.dashboards;\n    return updatedFormData;\n  }, [\n  currentFormData,\n  currentColumn,\n  groupbyFieldName,\n  getFiltersFromConfigsByFieldName,\n  getNewGroupby,\n  formData]\n  );\n  useEffect(() => {\n    setUsedGroupbyColumns((usedCols) => !currentColumn ||\n    usedCols.some((usedCol) => usedCol.column_name === currentColumn.column_name) ?\n    usedCols :\n    [...usedCols, currentColumn]);\n  }, [currentColumn]);\n  const onSelection = useCallback((newColumn, drillByConfig) => {\n    dispatch(logEvent(LOG_ACTIONS_FURTHER_DRILL_BY, {\n      drill_depth: drillByConfigs.length + 1,\n      slice_id: formData.slice_id\n    }));\n    setCurrentFormData(drilledFormData);\n    setDrillByConfigs((prevConfigs) => [\n    ...prevConfigs,\n    { ...drillByConfig, column: newColumn }]\n    );\n    setBreadcrumbsData((prevBreadcrumbs) => {\n      const newBreadcrumbs = [...prevBreadcrumbs, { groupby: newColumn }];\n      newBreadcrumbs[newBreadcrumbs.length - 2].filters =\n      drillByConfig.filters;\n      return newBreadcrumbs;\n    });\n  }, [dispatch, drillByConfigs.length, drilledFormData, formData.slice_id]);\n  const additionalConfig = useMemo(() => ({\n    drillBy: { excludedColumns: usedGroupbyColumns, openNewModal: false }\n  }), [usedGroupbyColumns]);\n  const { contextMenu, inContextMenu, onContextMenu } = useContextMenu(0, currentFormData, onSelection, ContextMenuItem.DrillBy, additionalConfig);\n  const chartName = useSelector((state) => {\n    const chartLayoutItem = Object.values(state.dashboardLayout.present).find((layoutItem) => {var _layoutItem$meta;return ((_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === formData.slice_id;});\n    return (chartLayoutItem == null ? void 0 : chartLayoutItem.meta.sliceNameOverride) || (chartLayoutItem == null ? void 0 : chartLayoutItem.meta.sliceName);\n  });\n  useEffect(() => {\n    if (drilledFormData) {\n      const [useLegacyApi] = getQuerySettings(drilledFormData);\n      setIsChartDataLoading(true);\n      setChartDataResult(undefined);\n      getChartDataRequest({\n        formData: drilledFormData\n      }).\n      then(({ response, json }) => handleChartDataResponse(response, json, useLegacyApi)).\n      then((queriesResponse) => {\n        setChartDataResult(queriesResponse);\n      }).\n      catch(() => {\n        addDangerToast(t('Failed to load chart data.'));\n      }).\n      finally(() => {\n        setIsChartDataLoading(false);\n      });\n    }\n  }, [addDangerToast, drilledFormData]);\n  const { metadataBar } = useDatasetMetadataBar({ dataset });\n  return _jsx(Modal, { css: css`\n        .antd5-modal-footer {\n          border-top: none;\n        }\n      `, show: true, onHide: onHideModal != null ? onHideModal : () => null, title: t('Drill by: %s', chartName), footer: _jsx(ModalFooter, { formData: drilledFormData }), responsive: true, resizable: true, resizableConfig: {\n      minHeight: theme.gridUnit * 128,\n      minWidth: theme.gridUnit * 128,\n      defaultSize: {\n        width: 'auto',\n        height: '80vh'\n      }\n    }, draggable: true, destroyOnClose: true, maskClosable: false, children:\n    _jsxs(\"div\", { css: css`\n          display: flex;\n          flex-direction: column;\n          height: 100%;\n        `, children: [\n      metadataBar,\n      breadcrumbs,\n      displayModeToggle,\n      isChartDataLoading && _jsx(Loading, {}),\n      !isChartDataLoading && !chartDataResult && _jsx(Alert, { type: \"error\", message: t('There was an error loading the chart data') }),\n      drillByDisplayMode === DrillByType.Chart && chartDataResult && _jsx(DrillByChart, { dataset: dataset, formData: drilledFormData, result: chartDataResult, onContextMenu: onContextMenu, inContextMenu: inContextMenu }),\n      drillByDisplayMode === DrillByType.Table &&\n      chartDataResult &&\n      resultsTable,\n      contextMenu] }\n    ) }\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}