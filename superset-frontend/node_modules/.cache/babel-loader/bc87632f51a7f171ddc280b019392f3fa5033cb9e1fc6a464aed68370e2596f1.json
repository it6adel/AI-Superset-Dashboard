{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { api } from './queryApi';\nconst catalogApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    catalogs: builder.query({\n      providesTags: [{ type: 'Catalogs', id: 'LIST' }],\n      query: ({ dbId, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId}/catalogs/`,\n        urlParams: {\n          force: forceRefresh\n        },\n        transformResponse: ({ json }) => json.result.sort().map((value) => ({\n          value,\n          label: value,\n          title: value\n        }))\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId } }) => ({\n        dbId\n      })\n    })\n  })\n});\nexport const { useLazyCatalogsQuery, useCatalogsQuery, endpoints: catalogEndpoints, util: catalogApiUtil } = catalogApi;\nexport const EMPTY_CATALOGS = [];\nexport function useCatalogs(options) {\n  const { dbId, onSuccess, onError } = options || {};\n  const [trigger] = useLazyCatalogsQuery();\n  const result = useCatalogsQuery({ dbId, forceRefresh: false }, {\n    skip: !dbId\n  });\n  useEffect(() => {\n    if (result.isError) {\n      onError == null ? void 0 : onError(result.error);\n    }\n  }, [result.isError, result.error, onError]);\n  const fetchData = useEffectEvent((dbId, forceRefresh = false) => {\n    if (dbId && (!result.currentData || forceRefresh)) {\n      trigger({ dbId, forceRefresh }).then(({ isSuccess, isError, data }) => {\n        if (isSuccess) {\n          onSuccess == null ? void 0 : onSuccess(data || EMPTY_CATALOGS, forceRefresh);\n        }\n        if (isError) {\n          onError == null ? void 0 : onError(result.error);\n        }\n      });\n    }\n  });\n  const refetch = useCallback(() => {\n    fetchData(dbId, true);\n  }, [dbId, fetchData]);\n  useEffect(() => {\n    fetchData(dbId, false);\n  }, [dbId, fetchData]);\n  return {\n    ...result,\n    refetch\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}