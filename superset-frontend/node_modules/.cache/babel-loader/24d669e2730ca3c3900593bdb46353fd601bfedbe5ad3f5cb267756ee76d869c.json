{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/sort-prop-types */\nimport d3 from 'd3';\nimport PropTypes from 'prop-types';\nimport { extent as d3Extent } from 'd3-array';\nimport {\n  getNumberFormatter,\n  getSequentialSchemeRegistry,\n  CategoricalColorNamespace } from\n'@superset-ui/core';\nimport countries, { countryOptions } from './countries';\n\nconst propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.shape({\n      country_id: PropTypes.string,\n      metric: PropTypes.number\n    })\n  ),\n  width: PropTypes.number,\n  height: PropTypes.number,\n  country: PropTypes.string,\n  colorScheme: PropTypes.string,\n  linearColorScheme: PropTypes.string,\n  mapBaseUrl: PropTypes.string,\n  numberFormat: PropTypes.string\n};\n\nconst maps = {};\n\nfunction CountryMap(element, props) {\n  const {\n    data,\n    width,\n    height,\n    country,\n    linearColorScheme,\n    numberFormat,\n    colorScheme,\n    sliceId\n  } = props;\n\n  const container = element;\n  const format = getNumberFormatter(numberFormat);\n  const linearColorScale = getSequentialSchemeRegistry().\n  get(linearColorScheme).\n  createLinearScale(d3Extent(data, (v) => v.metric));\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n\n  const colorMap = {};\n  data.forEach((d) => {\n    colorMap[d.country_id] = colorScheme ?\n    colorScale(d.country_id, sliceId) :\n    linearColorScale(d.metric);\n  });\n  const colorFn = (d) => colorMap[d.properties.ISO] || 'none';\n\n  const path = d3.geo.path();\n  const div = d3.select(container);\n  div.classed('superset-legacy-chart-country-map', true);\n  div.selectAll('*').remove();\n  container.style.height = `${height}px`;\n  container.style.width = `${width}px`;\n  const svg = div.\n  append('svg:svg').\n  attr('width', width).\n  attr('height', height).\n  attr('preserveAspectRatio', 'xMidYMid meet');\n  const backgroundRect = svg.\n  append('rect').\n  attr('class', 'background').\n  attr('width', width).\n  attr('height', height);\n  const g = svg.append('g');\n  const mapLayer = g.append('g').classed('map-layer', true);\n  const textLayer = g.\n  append('g').\n  classed('text-layer', true).\n  attr('transform', `translate(${width / 2}, 45)`);\n  const bigText = textLayer.append('text').classed('big-text', true);\n  const resultText = textLayer.\n  append('text').\n  classed('result-text', true).\n  attr('dy', '1em');\n\n  let centered;\n\n  const clicked = function clicked(d) {\n    const hasCenter = d && centered !== d;\n    let x;\n    let y;\n    let k;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    if (hasCenter) {\n      const centroid = path.centroid(d);\n      [x, y] = centroid;\n      k = 4;\n      centered = d;\n    } else {\n      x = halfWidth;\n      y = halfHeight;\n      k = 1;\n      centered = null;\n    }\n\n    g.transition().\n    duration(750).\n    attr(\n      'transform',\n      `translate(${halfWidth},${halfHeight})scale(${k})translate(${-x},${-y})`\n    );\n    textLayer.\n    style('opacity', 0).\n    attr(\n      'transform',\n      `translate(0,0)translate(${x},${hasCenter ? y - 5 : 45})`\n    ).\n    transition().\n    duration(750).\n    style('opacity', 1);\n    bigText.\n    transition().\n    duration(750).\n    style('font-size', hasCenter ? 6 : 16);\n    resultText.\n    transition().\n    duration(750).\n    style('font-size', hasCenter ? 16 : 24);\n  };\n\n  backgroundRect.on('click', clicked);\n\n  const selectAndDisplayNameOfRegion = function selectAndDisplayNameOfRegion(\n  feature)\n  {\n    let name = '';\n    if (feature && feature.properties) {\n      if (feature.properties.ID_2) {\n        name = feature.properties.NAME_2;\n      } else {\n        name = feature.properties.NAME_1;\n      }\n    }\n    bigText.text(name);\n  };\n\n  const updateMetrics = function updateMetrics(region) {\n    if (region.length > 0) {\n      resultText.text(format(region[0].metric));\n    }\n  };\n\n  const mouseenter = function mouseenter(d) {\n    // Darken color\n    let c = colorFn(d);\n    if (c !== 'none') {\n      c = d3.rgb(c).darker().toString();\n    }\n    d3.select(this).style('fill', c);\n    selectAndDisplayNameOfRegion(d);\n    const result = data.filter(\n      (region) => region.country_id === d.properties.ISO\n    );\n    updateMetrics(result);\n  };\n\n  const mouseout = function mouseout() {\n    d3.select(this).style('fill', colorFn);\n    bigText.text('');\n    resultText.text('');\n  };\n\n  function drawMap(mapData) {\n    const { features } = mapData;\n    const center = d3.geo.centroid(mapData);\n    const scale = 100;\n    const projection = d3.geo.\n    mercator().\n    scale(scale).\n    center(center).\n    translate([width / 2, height / 2]);\n    path.projection(projection);\n\n    // Compute scale that fits container.\n    const bounds = path.bounds(mapData);\n    const hscale = scale * width / (bounds[1][0] - bounds[0][0]);\n    const vscale = scale * height / (bounds[1][1] - bounds[0][1]);\n    const newScale = hscale < vscale ? hscale : vscale;\n\n    // Compute bounds and offset using the updated scale.\n    projection.scale(newScale);\n    const newBounds = path.bounds(mapData);\n    projection.translate([\n    width - (newBounds[0][0] + newBounds[1][0]) / 2,\n    height - (newBounds[0][1] + newBounds[1][1]) / 2]\n    );\n\n    // Draw each province as a path\n    mapLayer.\n    selectAll('path').\n    data(features).\n    enter().\n    append('path').\n    attr('d', path).\n    attr('class', 'region').\n    attr('vector-effect', 'non-scaling-stroke').\n    style('fill', colorFn).\n    on('mouseenter', mouseenter).\n    on('mouseout', mouseout).\n    on('click', clicked);\n  }\n\n  const map = maps[country];\n  if (map) {\n    drawMap(map);\n  } else {\n    const url = countries[country];\n    d3.json(url, (error, mapData) => {\n      if (error) {var _countryOptions$find;\n        const countryName =\n        ((_countryOptions$find = countryOptions.find((x) => x[0] === country)) == null ? void 0 : _countryOptions$find[1]) || country;\n        d3.select(element).html(\n          `<div class=\"alert alert-danger\">Could not load map data for ${countryName}</div>`\n        );\n      } else {\n        maps[country] = mapData;\n        drawMap(mapData);\n      }\n    });\n  }\n}\n\nCountryMap.displayName = 'CountryMap';\nCountryMap.propTypes = propTypes;\n\nexport default CountryMap;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}