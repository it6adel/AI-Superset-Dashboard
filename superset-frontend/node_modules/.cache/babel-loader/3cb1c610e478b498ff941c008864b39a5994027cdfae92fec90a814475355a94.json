{"ast":null,"code":"import _omit from \"lodash/omit\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { ensureIsArray, getChartControlPanelRegistry } from '@superset-ui/core';\nimport { getStandardizedControls, isStandardizedFormData } from '@superset-ui/chart-controls';\nimport { getControlsState } from 'src/explore/store';\nimport { getFormDataFromControls } from './getFormDataFromControls';\nexport const sharedMetricsKey = [\n'metric',\n'metrics',\n'metric_2',\n'size',\n'x',\n'y',\n'secondary_metric' // via sharedControls, scalar\n];\nexport const sharedColumnsKey = [\n'groupby',\n'columns',\n'groupbyColumns',\n'groupbyRows',\n'entity',\n'series',\n'series_columns' // via sharedControls, array\n];\nexport const publicControls = [\n// time section\n'granularity_sqla',\n'time_grain_sqla',\n'time_range',\n// filters\n'adhoc_filters',\n// subquery limit(series limit)\n'limit',\n// order by clause\n'timeseries_limit_metric',\n'series_limit_metric',\n// desc or asc in order by clause\n'order_desc',\n// outer query limit\n'row_limit',\n// x asxs column\n'x_axis',\n// advanced analytics - rolling window\n'rolling_type',\n'rolling_periods',\n'min_periods',\n// advanced analytics - time comparison\n'time_compare',\n'comparison_type',\n// advanced analytics - resample\n'resample_rule',\n'resample_method' // via sections.advancedAnalytics\n];\nexport class StandardizedFormData {\n\n  constructor(sourceFormData) {var _formData$standardize, _mfd$slice$0$;this.sfd = void 0;\n    /*\n     * Support form_data for smooth switching between different viz\n     * */\n    const formData = Object.freeze(sourceFormData);\n    // generates an ordered map, the key is viz_type and the value is form_data. the last item is current viz.\n    const mfd = formData == null ? void 0 : (_formData$standardize = formData.standardizedFormData) == null ? void 0 : _formData$standardize.memorizedFormData;\n    const vizType = formData.viz_type;\n    let memorizedFormData = new Map();\n    let controls;\n    if (Array.isArray(mfd) &&\n    mfd.length > 0 &&\n    formData.datasource === ((_mfd$slice$0$ = mfd.slice(-1)[0][1]) == null ? void 0 : _mfd$slice$0$.datasource)) {\n      memorizedFormData = new Map(formData.standardizedFormData.memorizedFormData);\n      if (memorizedFormData.has(vizType)) {\n        memorizedFormData.delete(vizType);\n      }\n      memorizedFormData.set(vizType, formData);\n      controls = StandardizedFormData.getStandardizedControls(formData);\n    } else\n    {\n      // reset the `memorizedFormData` if a request between different datasource.\n      const restFormData = _omit(formData, 'standardizedFormData');\n      memorizedFormData.set(vizType, restFormData);\n      controls = StandardizedFormData.getStandardizedControls(restFormData);\n    }\n    this.sfd = {\n      controls,\n      memorizedFormData\n    };\n  }\n  static getStandardizedControls(formData) {\n    // 1. initial StandardizedControls\n    const controls = {\n      metrics: [],\n      columns: []\n    };\n    // 2. collect current sharedControls\n    Object.entries(formData).forEach(([key, value]) => {\n      if (sharedMetricsKey.includes(key)) {\n        controls.metrics.push(...ensureIsArray(value));\n      }\n      if (sharedColumnsKey.includes(key)) {\n        controls.columns.push(...ensureIsArray(value));\n      }\n    });\n    // 3. append inherit sharedControls\n    if (isStandardizedFormData(formData)) {\n      const { metrics, columns } = formData.standardizedFormData.controls;\n      controls.metrics.push(...metrics);\n      controls.columns.push(...columns);\n    }\n    return controls;\n  }\n  getLatestFormData(vizType) {\n    if (this.has(vizType)) {\n      return this.get(vizType);\n    }\n    return this.memorizedFormData.slice(-1)[0][1];\n  }\n  get standardizedControls() {\n    return this.sfd.controls;\n  }\n  get memorizedFormData() {\n    return Array.from(this.sfd.memorizedFormData.entries());\n  }\n  serialize() {\n    return {\n      controls: this.standardizedControls,\n      memorizedFormData: this.memorizedFormData\n    };\n  }\n  has(vizType) {\n    return this.sfd.memorizedFormData.has(vizType);\n  }\n  get(vizType) {\n    return this.sfd.memorizedFormData.get(vizType);\n  }\n  transform(targetVizType, exploreState) {\n    /*\n     * Transform form_data between different viz. Return new form_data and controlsState.\n     * 1. get memorized form_data by viz type or get previous form_data\n     * 2. collect public control values\n     * 3. generate initial targetControlsState\n     * 4. attach `standardizedFormData` to the initial form_data\n     * 5. call formDataOverrides to transform initial form_data if the plugin was defined\n     * 6. use final form_data to generate controlsState\n     * 7. to refresh validator message\n     * */\n    const latestFormData = this.getLatestFormData(targetVizType);\n    const publicFormData = {};\n    publicControls.forEach((key) => {\n      if (key in exploreState.form_data) {\n        publicFormData[key] = exploreState.form_data[key];\n      }\n    });\n    const targetControlsState = getControlsState(exploreState, {\n      ...latestFormData,\n      ...publicFormData,\n      viz_type: targetVizType\n    });\n    const targetFormData = {\n      ...getFormDataFromControls(targetControlsState),\n      standardizedFormData: this.serialize()\n    };\n    let rv = {\n      formData: targetFormData,\n      controlsState: targetControlsState\n    };\n    const controlPanel = getChartControlPanelRegistry().get(targetVizType);\n    if (controlPanel != null && controlPanel.formDataOverrides) {\n      getStandardizedControls().setStandardizedControls(targetFormData);\n      const transformed = {\n        ...controlPanel.formDataOverrides(targetFormData),\n        standardizedFormData: {\n          controls: { ...getStandardizedControls().controls },\n          memorizedFormData: this.memorizedFormData\n        }\n      };\n      getStandardizedControls().clear();\n      rv = {\n        formData: transformed,\n        controlsState: getControlsState(exploreState, transformed)\n      };\n    }\n    // refresh validator message\n    rv.controlsState = getControlsState({ ...exploreState, controls: rv.controlsState }, rv.formData);\n    return rv;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}