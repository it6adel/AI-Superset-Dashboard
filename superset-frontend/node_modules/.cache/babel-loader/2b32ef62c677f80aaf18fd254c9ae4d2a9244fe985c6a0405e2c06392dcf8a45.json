{"ast":null,"code":"import _isNumber from \"lodash/isNumber\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, getColumnLabel, getNumberFormatter, isEqualArray, NumberFormats, styled, t } from '@superset-ui/core';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { InputNumber } from 'src/components/Input';\nimport { FilterBarOrientation } from 'src/dashboard/types';\nimport Metadata from 'src/components/Metadata';\n\nimport { StatusMessage, StyledFormItem, FilterPluginStyle } from '../common';\nimport { getRangeExtraFormData } from '../../utils';\nimport { SingleValueType } from './SingleValueType';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst StyledDivider = styled.span`\n  margin: 0 ${({ theme }) => theme.gridUnit * 3}px;\n  color: ${({ theme }) => theme.colors.grayscale.light1};\n  font-weight: ${({ theme }) => theme.typography.weights.bold};\n  font-size: ${({ theme }) => theme.typography.sizes.m}px;\n  align-content: center;\n`;\nconst Wrapper = styled.div`\n  display: flex;\n  justify-content: space-between;\n\n  .antd5-input-number {\n    width: 100%;\n    position: relative;\n  }\n`;\nconst numberFormatter = getNumberFormatter(NumberFormats.SMART_NUMBER);\nconst getLabel = (lower, upper, enableSingleExactValue = false) => {\n  if (enableSingleExactValue && lower !== null ||\n  lower !== null && lower === upper) {\n    return `x = ${numberFormatter(lower)}`;\n  }\n  if (lower !== null && upper !== null) {\n    return `${numberFormatter(lower)} ≤ x ≤ ${numberFormatter(upper)}`;\n  }\n  if (lower !== null) {\n    return `x ≥ ${numberFormatter(lower)}`;\n  }\n  if (upper !== null) {\n    return `x ≤ ${numberFormatter(upper)}`;\n  }\n  return '';\n};\nconst validateRange = (values, min, max, enableEmptyFilter, enableSingleValue) => {\n  const [inputMin, inputMax] = values;\n  const requiredError = t('Filter value is required');\n  const rangeError = t('Please provide a value within range');\n  if (enableSingleValue !== undefined) {\n    const isSingleMin = enableSingleValue === SingleValueType.Minimum ||\n    enableSingleValue === SingleValueType.Exact;\n    const value = isSingleMin ? inputMin : inputMax;\n    if (!value && enableEmptyFilter) {\n      return { isValid: false, errorMessage: requiredError };\n    }\n    if (_isNumber(value) && (value < min || value > max)) {\n      return { isValid: false, errorMessage: rangeError };\n    }\n    return { isValid: true, errorMessage: null };\n  }\n  // Range validation\n  if (enableEmptyFilter && (inputMin === null || inputMax === null)) {\n    return { isValid: false, errorMessage: t('Please provide a valid range') };\n  }\n  if (!enableEmptyFilter && inputMin !== null !== (inputMax !== null)) {\n    return { isValid: false, errorMessage: t('Please provide a valid range') };\n  }\n  if (inputMin !== null && inputMax !== null) {\n    if (inputMin > inputMax) {\n      return {\n        isValid: false,\n        errorMessage: t('Minimum value cannot be higher than maximum value')\n      };\n    }\n    if (inputMin < min || inputMax > max) {\n      return {\n        isValid: false,\n        errorMessage: t('Your range is not within the dataset range')\n      };\n    }\n  }\n  return { isValid: true, errorMessage: null };\n};\nexport default function RangeFilterPlugin(props) {\n  const { data, formData, height, width, setDataMask, setFocusedFilter, unsetFocusedFilter, setHoveredFilter, unsetHoveredFilter, setFilterActive, filterState, inputRef, filterBarOrientation = FilterBarOrientation.Vertical } = props;\n  const [row] = data;\n  // @ts-ignore\n  const { min, max } = row;\n  const { groupby, enableSingleValue, enableEmptyFilter, defaultValue } = formData;\n  const minIndex = 0;\n  const maxIndex = 1;\n  const enableSingleExactValue = enableSingleValue === SingleValueType.Exact;\n  const rangeInput = enableSingleValue === undefined;\n  const [col = ''] = ensureIsArray(groupby).map(getColumnLabel);\n  const [inputValue, setInputValue] = useState(filterState.value || defaultValue || [null, null]);\n  const [error, setError] = useState(null);\n  const updateDataMaskError = useCallback((errorMessage) => {\n    setDataMask({\n      extraFormData: {},\n      filterState: {\n        value: null,\n        label: '',\n        validateStatus: 'error',\n        validateMessage: errorMessage || ''\n      }\n    });\n  }, [setDataMask]);\n  const updateDataMaskValue = useCallback((value) => {\n    const [inputMin, inputMax] = value;\n    setDataMask({\n      extraFormData: getRangeExtraFormData(col, inputMin, inputMax),\n      filterState: {\n        value: enableSingleExactValue ?\n        [inputMin, inputMin] :\n        [inputMin, inputMax],\n        label: getLabel(inputMin, inputMax, enableSingleExactValue),\n        validateStatus: undefined,\n        validateMessage: ''\n      }\n    });\n  }, [setDataMask]);\n  useEffect(() => {\n    if ((row == null ? void 0 : row.min) === undefined && (row == null ? void 0 : row.max) === undefined) {\n      return;\n    }\n    if (filterState.validateStatus === 'error' &&\n    error !== filterState.validateMessage) {\n      setError(filterState.validateMessage);\n      const [inputMin, inputMax] = inputValue;\n      const { isValid, errorMessage } = validateRange(inputValue, min, max, enableEmptyFilter, enableSingleValue);\n      const isDefaultError = inputMin === null &&\n      inputMax === null &&\n      filterState.validateStatus === 'error';\n      if (!isValid || isDefaultError) {\n        setError(errorMessage);\n        updateDataMaskError(errorMessage);\n        return;\n      }\n      setError(null);\n      updateDataMaskValue(inputValue);\n      return;\n    }\n    if (filterState.validateStatus === 'error') {\n      setError(filterState.validateMessage);\n      return;\n    }\n    // Clear all case\n    if (filterState.value === undefined && !filterState.validateStatus) {\n      setInputValue([null, null]);\n      updateDataMaskValue([null, null]);\n      return;\n    }\n    if (isEqualArray(defaultValue, inputValue)) {\n      updateDataMaskValue(defaultValue);\n      return;\n    }\n    // Filter state is pre-set case\n    if (filterState.value && !filterState.validateStatus) {\n      setInputValue(filterState.value);\n      updateDataMaskValue(filterState.value);\n    }\n  }, [JSON.stringify(filterState.value)]);\n  const metadataText = useMemo(() => {\n    switch (enableSingleValue) {\n      case SingleValueType.Minimum:\n        return t('Filters for values greater than or equal.');\n      case SingleValueType.Maximum:\n        return t('Filters for values less than or equal.');\n      case SingleValueType.Exact:\n        return t('Filters for values equal to this exact value.');\n      default:\n        return '';\n    }\n  }, [enableSingleValue]);\n  const handleChange = useCallback((newValue, index) => {\n    if ((row == null ? void 0 : row.min) === undefined && (row == null ? void 0 : row.max) === undefined) {\n      return;\n    }\n    const newInputValue = index === minIndex ?\n    [newValue, inputValue[maxIndex]] :\n    [inputValue[minIndex], newValue];\n    setInputValue(newInputValue);\n    const { isValid, errorMessage } = validateRange(newInputValue, min, max, enableEmptyFilter, enableSingleValue);\n    if (!isValid) {\n      setError(errorMessage);\n      updateDataMaskError(errorMessage);\n      return;\n    }\n    setError(null);\n    updateDataMaskValue(newInputValue);\n  }, [col, min, max, enableEmptyFilter, enableSingleValue, setDataMask]);\n  const formItemExtra = useMemo(() => {\n    if (error) {\n      return _jsx(StatusMessage, { status: \"error\", children: error });\n    }\n    return undefined;\n  }, [error]);\n  useEffect(() => {\n    switch (enableSingleValue) {\n      case SingleValueType.Minimum:\n      case SingleValueType.Exact:\n        handleChange(null, maxIndex);\n        break;\n      case SingleValueType.Maximum:\n        handleChange(null, minIndex);\n        break;\n      default:\n        break;\n    }\n    setDataMask({\n      extraFormData: {},\n      filterState: {\n        value: null,\n        label: ''\n      }\n    });\n  }, [enableSingleValue]);\n  return _jsx(FilterPluginStyle, { height: height, width: width, children:\n    Number.isNaN(Number(min)) || Number.isNaN(Number(max)) ? _jsx(\"h4\", { children: t('Chosen non-numeric column') }) : _jsxs(StyledFormItem, { \"aria-labelledby\": `filter-name-${formData.nativeFilterId}`, extra: formItemExtra, children: [\n      _jsxs(Wrapper, { tabIndex: -1, ref: inputRef, onFocus: setFocusedFilter, onBlur: unsetFocusedFilter, onMouseEnter: setHoveredFilter, onMouseLeave: unsetHoveredFilter, onMouseDown: () => setFilterActive(true), onMouseUp: () => setFilterActive(false), children: [\n        (enableSingleValue === SingleValueType.Minimum ||\n        enableSingleValue === SingleValueType.Exact ||\n        enableSingleValue === undefined) && _jsx(InputNumber, { value: inputValue[minIndex], onChange: (val) => handleChange(val, minIndex), placeholder: `${min}`, status: filterState.validateStatus }),\n        enableSingleValue === undefined && _jsx(StyledDivider, { children: \"-\" }),\n        (enableSingleValue === SingleValueType.Maximum ||\n        enableSingleValue === undefined) && _jsx(InputNumber, { value: inputValue[maxIndex], onChange: (val) => handleChange(val, maxIndex), placeholder: `${max}`, status: filterState.validateStatus })] }\n      ),\n      (rangeInput ||\n      filterBarOrientation === FilterBarOrientation.Vertical) &&\n      !filterState.validateStatus && _jsx(Metadata, { value: metadataText })] }\n    ) }\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}