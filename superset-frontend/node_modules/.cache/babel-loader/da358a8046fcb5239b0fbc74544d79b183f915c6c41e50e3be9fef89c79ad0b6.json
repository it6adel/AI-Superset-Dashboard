{"ast":null,"code":"import _sumBy from \"lodash/sumBy\";import _orderBy from \"lodash/orderBy\";import _minBy from \"lodash/minBy\";import _meanBy from \"lodash/meanBy\";import _maxBy from \"lodash/maxBy\";import _isEmpty from \"lodash/isEmpty\"; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AxisType, DTTM_ALIAS, ensureIsArray, GenericDataType, normalizeTimestamp, NumberFormats, NumberFormatter } from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format } from 'echarts/core';\n\nimport { NULL_STRING, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\nimport { EchartsTimeseriesSeriesType, LegendOrientation } from '../types';\nimport { defaultLegendPadding } from '../defaults';\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nexport function extractDataTotalValues(data, opts) {\n  const totalStackedValues = [];\n  const thresholdValues = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach((datum) => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + value;\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push((percentageThreshold || 0) / 100 * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues\n  };\n}\nexport function extractShowValueIndexes(series, opts) {\n  const showValueIndexes = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      data.forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (!showValueIndexes[dataIndex] &&\n          datum[isHorizontal ? 0 : 1] !== null) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\nexport function sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending) {\n  const seriesNames = Object.keys(rows[0]).\n  filter((key) => key !== xAxis).\n  filter((key) => !extraMetricLabels.includes(key));\n  let aggregator;\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = (name) => ({ name, value: _sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = (name) => {var _minBy2;return { name, value: (_minBy2 = _minBy(rows, name)) == null ? void 0 : _minBy2[name] };};\n      break;\n    case SortSeriesType.Max:\n      aggregator = (name) => {var _maxBy2;return { name, value: (_maxBy2 = _maxBy(rows, name)) == null ? void 0 : _maxBy2[name] };};\n      break;\n    case SortSeriesType.Avg:\n      aggregator = (name) => ({ name, value: _meanBy(rows, name) });\n      break;\n    default:\n      aggregator = (name) => ({ name, value: name.toLowerCase() });\n      break;\n  }\n  const sortedValues = seriesNames.map(aggregator);\n  return _orderBy(sortedValues, ['value'], [sortSeriesAscending ? 'asc' : 'desc']).map(({ name }) => name);\n}\nexport function sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey = '';\n    let aggregate;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (xAxisSortSeries === SortSeriesType.Name ||\n      typeof value !== 'number') {\n        return;\n      }\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else\n          {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n          aggregate === undefined || isValueDefined && value < aggregate ?\n          value :\n          aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n          aggregate === undefined || isValueDefined && value > aggregate ?\n          value :\n          aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (xAxisSortSeries === SortSeriesType.Avg &&\n    entries > 0 &&\n    aggregate !== undefined) {\n      aggregate /= entries;\n    }\n    const value = xAxisSortSeries === SortSeriesType.Name ?\n    typeof sortKey === 'string' ?\n    sortKey.toLowerCase() :\n    sortKey :\n    aggregate;\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx]\n    };\n  });\n  return _orderBy(sortedRows, ['value'], [xAxisSortSeriesAscending ? 'asc' : 'desc']).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\nexport function extractSeries(data, opts = {}) {\n  const { fillNeighborValue, xAxis = DTTM_ALIAS, extraMetricLabels = [], removeNulls = false, stack = false, totalStackedValues = [], isHorizontal = false, sortSeriesType, sortSeriesAscending, xAxisSortSeries, xAxisSortSeriesAscending } = opts;\n  if (data.length === 0)\n  return [[], [], undefined];\n  const rows = data.map((datum) => ({\n    ...datum,\n    [xAxis]: datum[xAxis]\n  }));\n  const sortedSeries = sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending);\n  const sortedRows = isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending) ?\n  sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) :\n  rows.map((row, idx) => ({\n    row,\n    totalStackedValue: totalStackedValues[idx]\n  }));\n  let minPositiveValue;\n  const finalSeries = sortedSeries.map((name) => ({\n    id: name,\n    name,\n    data: sortedRows.\n    map(({ row, totalStackedValue }, idx) => {var _rows, _rows2;\n      const currentValue = row[name];\n      if (typeof currentValue === 'number' &&\n      currentValue > 0 && (\n      minPositiveValue === undefined || minPositiveValue > currentValue)) {\n        minPositiveValue = currentValue;\n      }\n      const isNextToDefinedValue = isDefined((_rows = rows[idx - 1]) == null ? void 0 : _rows[name]) || isDefined((_rows2 = rows[idx + 1]) == null ? void 0 : _rows2[name]);\n      const isFillNeighborValue = !isDefined(currentValue) &&\n      isNextToDefinedValue &&\n      fillNeighborValue !== undefined;\n      let value = currentValue;\n      if (isFillNeighborValue) {\n        value = fillNeighborValue;\n      } else\n      if (stack === StackControlsValue.Expand &&\n      totalStackedValue !== undefined) {\n        value = (value || 0) / totalStackedValue;\n      }\n      return [row[xAxis], value];\n    }).\n    filter((obs) => !removeNulls || obs[0] !== null && obs[1] !== null).\n    map((obs) => isHorizontal ? [obs[1], obs[0]] : obs)\n  }));\n  return [\n  finalSeries,\n  sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n  minPositiveValue];\n\n}\nexport function formatSeriesName(name, { numberFormatter, timeFormatter, coltype } = {}) {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean' || typeof name === 'bigint') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.Temporal) {\n    const normalizedName = typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d = normalizedName instanceof Date ?\n    normalizedName :\n    new Date(normalizedName);\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\nexport const getColtypesMapping = ({ coltypes = [], colnames = [] }) => colnames.reduce((accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }), {});\nexport function extractGroupbyLabel({ datum = {}, groupby, numberFormatter, timeFormatter, coltypeMapping = {} }) {\n  return ensureIsArray(groupby).\n  map((val) => formatSeriesName(datum[val], {\n    numberFormatter,\n    timeFormatter,\n    ...(coltypeMapping[val] && { coltype: coltypeMapping[val] })\n  })).\n  join(', ');\n}\nexport function getLegendProps(type, orientation, show, theme, zoomable = false, legendState, padding) {\n  const legend = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(orientation) ?\n    'horizontal' :\n    'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base\n    }\n  };\n  const MIN_LEGEND_WIDTH = 0;\n  const MARGIN_GUTTER = 45;\n  const getLegendWidth = (paddingWidth) => Math.max(paddingWidth - MARGIN_GUTTER, MIN_LEGEND_WIDTH);\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      if (padding != null && padding.left) {\n        legend.textStyle = {\n          overflow: 'truncate',\n          width: getLegendWidth(padding.left)\n        };\n      }\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      if (padding != null && padding.right) {\n        legend.textStyle = {\n          overflow: 'truncate',\n          width: getLegendWidth(padding.right)\n        };\n      }\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\nexport function getChartPadding(show, orientation, margin, padding, isHorizontal) {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else\n  if (margin === null ||\n  margin === undefined ||\n  typeof margin === 'string') {\n    legendMargin = defaultLegendPadding[orientation];\n  } else\n  {\n    legendMargin = margin;\n  }\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  if (isHorizontal) {\n    return {\n      left: left + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n      right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n      top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n      bottom: bottom + (orientation === LegendOrientation.Left ? legendMargin : 0)\n    };\n  }\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom: bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0)\n  };\n}\nexport function dedupSeries(series) {\n  const counter = new Map();\n  return series.map((row) => {\n    let { id } = row;\n    if (id === undefined)\n    return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`\n    };\n  });\n}\nexport function sanitizeHtml(text) {\n  return format.encodeHTML(text);\n}\nexport function getAxisType(stack, forceCategorical, dataType) {\n  if (forceCategorical) {\n    return AxisType.Category;\n  }\n  if (dataType === GenericDataType.Temporal) {\n    return AxisType.Time;\n  }\n  if (dataType === GenericDataType.Numeric && !stack) {\n    return AxisType.Value;\n  }\n  return AxisType.Category;\n}\nexport function getOverMaxHiddenFormatter(config = {}) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n  return new NumberFormatter({\n    formatFunc: (value) => `${shouldHideIfOverMax && value > max ?\n    '' :\n    (formatter == null ? void 0 : formatter.format(value)) || value}`,\n    id: NumberFormats.OVER_MAX_HIDDEN\n  });\n}\nexport function calculateLowerLogTick(minPositiveValue) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}\nexport function getMinAndMaxFromBounds(axisType, truncateAxis, min, max, seriesType) {\n  if (axisType === AxisType.Value && truncateAxis) {\n    const ret = {};\n    if (seriesType === EchartsTimeseriesSeriesType.Bar) {\n      ret.scale = true;\n    }\n    if (min !== undefined) {\n      ret.min = min;\n    } else\n    if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.min = 'dataMin';\n    }\n    if (max !== undefined) {\n      ret.max = max;\n    } else\n    if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.max = 'dataMax';\n    }\n    return ret;\n  }\n  return {};\n}\n/**\n * Returns the stackId used in stacked series.\n * It will return the defaultId if the chart is not using time comparison.\n * If time comparison is used, it will return the time comparison value as the stackId\n * if the name includes the time comparison value.\n *\n * @param {string} defaultId The default stackId.\n * @param {string[]} timeCompare The time comparison values.\n * @param {string | number} name The name of the serie.\n *\n * @returns {string} The stackId.\n */\nexport function getTimeCompareStackId(defaultId, timeCompare, name) {\n  if (_isEmpty(timeCompare)) {\n    return defaultId;\n  }\n  // Each timeCompare is its own stack so it doesn't stack on top of original ones\n  return timeCompare.find((value) => {\n    if (typeof name === 'string') {\n      // offset is represented as <offset>, group by list\n      return name.includes(`${value},`) ||\n      // offset is represented as <metric>__<offset>\n      name.includes(`__${value}`);\n    }\n    return name == null ? void 0 : name.toString().includes(value);\n  }) || defaultId;\n}\nconst TOOLTIP_SERIES_KEY = 'seriesId';\nexport function extractTooltipKeys(forecastValue, yIndex, richTooltip, tooltipSortByMetric) {\n  if (richTooltip && tooltipSortByMetric) {\n    return forecastValue.\n    slice().\n    sort((a, b) => b.data[yIndex] - a.data[yIndex]).\n    map((value) => value[TOOLTIP_SERIES_KEY]);\n  }\n  if (richTooltip) {\n    return forecastValue.map((s) => s[TOOLTIP_SERIES_KEY]);\n  }\n  return [forecastValue[0][TOOLTIP_SERIES_KEY]];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}