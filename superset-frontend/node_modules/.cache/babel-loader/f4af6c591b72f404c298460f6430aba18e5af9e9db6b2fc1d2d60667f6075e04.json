{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter, NumberFormats, getValueFormatter, tooltipHtml } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA as DEFAULT_TREEMAP_FORM_DATA, EchartsTreemapLabelType } from './types';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { COLOR_SATURATION, BORDER_WIDTH, GAP_WIDTH, LABEL_FONTSIZE, extractTreePathInfo, BORDER_COLOR } from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { treeBuilder } from '../utils/treeBuilder';\nexport function formatLabel({ params, labelType, numberFormatter }) {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsTreemapLabelType.Key:\n      return name;\n    case EchartsTreemapLabelType.Value:\n      return formattedValue;\n    case EchartsTreemapLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\nexport function formatTooltip({ params, numberFormatter }) {\n  const { value, treePathInfo = [] } = params;\n  const formattedValue = numberFormatter(value);\n  const { metricLabel, treePath } = extractTreePathInfo(treePathInfo);\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  let formattedPercent = '';\n  // the last item is current node, here we should find the parent node\n  const currentNode = treePathInfo[treePathInfo.length - 1];\n  const parentNode = treePathInfo[treePathInfo.length - 2];\n  if (parentNode) {\n    const percent = parentNode.value ?\n    currentNode.value / parentNode.value :\n    0;\n    formattedPercent = percentFormatter(percent);\n  }\n  const row = [metricLabel, formattedValue];\n  if (formattedPercent) {\n    row.push(formattedPercent);\n  }\n  return tooltipHtml([row], treePath.join(' â–¸ '));\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, queriesData, width, hooks, filterState, theme, inContextMenu, emitCrossFilters, datasource } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, groupby = [], metric = '', labelType, labelPosition, numberFormat, currencyFormat, dateFormat, showLabels, showUpperLabels, dashboardId, sliceId } = {\n    ...DEFAULT_TREEMAP_FORM_DATA,\n    ...formData\n  };\n  const refs = {};\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat, currencyFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter,\n    labelType\n  });\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const treeData = treeBuilder(data, groupbyLabels, metricLabel);\n  const traverse = (treeNodes, path) => treeNodes.map((treeNode) => {var _treeNode$children;\n    const { name: nodeName, value, groupBy } = treeNode;\n    const name = formatSeriesName(nodeName, {\n      timeFormatter: getTimeFormatter(dateFormat),\n      ...(coltypeMapping[groupBy] && {\n        coltype: coltypeMapping[groupBy]\n      })\n    });\n    const newPath = path.concat(name);\n    let item = {\n      name,\n      value,\n      colorSaturation: COLOR_SATURATION,\n      itemStyle: {\n        borderColor: BORDER_COLOR,\n        color: colorFn(name, sliceId),\n        borderWidth: BORDER_WIDTH,\n        gapWidth: GAP_WIDTH\n      }\n    };\n    if ((_treeNode$children = treeNode.children) != null && _treeNode$children.length) {\n      item = {\n        ...item,\n        children: traverse(treeNode.children, newPath)\n      };\n    } else\n    {\n      const joinedName = newPath.join(',');\n      // map(joined_name: [columnLabel_1, columnLabel_2, ...])\n      columnsLabelMap.set(joinedName, newPath);\n      if (filterState.selectedValues &&\n      !filterState.selectedValues.includes(joinedName)) {\n        item = {\n          ...item,\n          itemStyle: {\n            colorAlpha: OpacityEnum.SemiTransparent\n          },\n          label: {\n            color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})`\n          }\n        };\n      }\n    }\n    return item;\n  });\n  const transformedData = [\n  {\n    name: metricLabel,\n    colorSaturation: COLOR_SATURATION,\n    itemStyle: {\n      borderColor: BORDER_COLOR,\n      color: colorFn(`${metricLabel}`, sliceId),\n      borderWidth: BORDER_WIDTH,\n      gapWidth: GAP_WIDTH\n    },\n    upperLabel: {\n      show: false\n    },\n    children: traverse(treeData, [])\n  }];\n\n  // set a default color when metric values are 0 over all.\n  const levels = [\n  {\n    upperLabel: {\n      show: false\n    },\n    label: {\n      show: false\n    },\n    itemStyle: {\n      color: theme.colors.primary.base\n    }\n  }];\n\n  const series = [\n  {\n    type: 'treemap',\n    width: '100%',\n    height: '100%',\n    nodeClick: undefined,\n    roam: !dashboardId,\n    breadcrumb: {\n      show: false,\n      emptyItemWidth: 25\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    },\n    levels,\n    label: {\n      show: showLabels,\n      position: labelPosition,\n      formatter,\n      color: theme.colors.grayscale.dark2,\n      fontSize: LABEL_FONTSIZE\n    },\n    upperLabel: {\n      show: showUpperLabels,\n      formatter,\n      textBorderColor: 'transparent',\n      fontSize: LABEL_FONTSIZE\n    },\n    data: transformedData\n  }];\n\n  const echartOptions = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params) => formatTooltip({\n        params,\n        numberFormatter\n      })\n    },\n    series\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}