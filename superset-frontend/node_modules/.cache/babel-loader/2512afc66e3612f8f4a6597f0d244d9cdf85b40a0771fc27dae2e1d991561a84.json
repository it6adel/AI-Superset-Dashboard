{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport 'whatwg-fetch';\nimport fetchRetry from 'fetch-retry';\nimport { CACHE_AVAILABLE, CACHE_KEY, HTTP_STATUS_NOT_MODIFIED, HTTP_STATUS_OK } from '../constants';\nfunction tryParsePayload(payload) {\n  try {\n    return typeof payload === 'string' ?\n    JSON.parse(payload) :\n    payload;\n  }\n  catch (error) {\n    throw new Error(`Invalid payload:\\n\\n${payload}`);\n  }\n}\n/**\n * Try appending search params to an URL if needed.\n */\nfunction getFullUrl(partialUrl, params) {\n  if (params) {\n    const url = new URL(partialUrl, window.location.href);\n    const search = params instanceof URLSearchParams ? params : new URLSearchParams(params);\n    // will completely override any existing search params\n    url.search = search.toString();\n    return url.href;\n  }\n  return partialUrl;\n}\n/**\n * Fetch an API response and returns the corresponding json.\n *\n * @param {Payload} postPayload payload to send as FormData in a post form\n * @param {Payload} jsonPayload json payload to post, will automatically add Content-Type header\n * @param {string} stringify whether to stringify field values when post as formData\n */\nexport default async function callApi({ body, cache = 'default', credentials = 'same-origin', fetchRetryOptions, headers, method = 'GET', mode = 'same-origin', postPayload, jsonPayload, redirect = 'follow', signal, stringify = true, url: url_, searchParams }) {var _window$location;\n  const fetchWithRetry = fetchRetry(fetch, fetchRetryOptions);\n  const url = `${getFullUrl(url_, searchParams)}`;\n  const request = {\n    body,\n    cache,\n    credentials,\n    headers,\n    method,\n    mode,\n    redirect,\n    signal\n  };\n  if (method === 'GET' &&\n  cache !== 'no-store' &&\n  cache !== 'reload' &&\n  CACHE_AVAILABLE &&\n  ((_window$location = window.location) == null ? void 0 : _window$location.protocol) === 'https:') {\n    let supersetCache = null;\n    try {\n      supersetCache = await caches.open(CACHE_KEY);\n      const cachedResponse = await supersetCache.match(url);\n      if (cachedResponse) {\n        // if we have a cached response, send its ETag in the\n        // `If-None-Match` header in a conditional request\n        const etag = cachedResponse.headers.get('Etag');\n        request.headers = { ...request.headers, 'If-None-Match': etag };\n      }\n    }\n    catch {\n\n      // If superset is in an iframe and third-party cookies are disabled, caches.open throws\n    }const response = await fetchWithRetry(url, request);\n    if (supersetCache && response.status === HTTP_STATUS_NOT_MODIFIED) {\n      const cachedFullResponse = await supersetCache.match(url);\n      if (cachedFullResponse) {\n        return cachedFullResponse.clone();\n      }\n      throw new Error('Received 304 but no content is cached!');\n    }\n    if (supersetCache &&\n    response.status === HTTP_STATUS_OK &&\n    response.headers.get('Etag')) {\n      supersetCache.delete(url);\n      supersetCache.put(url, response.clone());\n    }\n    return response;\n  }\n  if (method === 'POST' || method === 'PATCH' || method === 'PUT') {\n    if (postPayload && jsonPayload) {\n      throw new Error('Please provide only one of jsonPayload or postPayload');\n    }\n    if (postPayload instanceof FormData) {\n      request.body = postPayload;\n    } else\n    if (postPayload) {\n      const payload = tryParsePayload(postPayload);\n      if (payload && typeof payload === 'object') {\n        // using FormData has the effect that Content-Type header is set to `multipart/form-data`,\n        // not e.g., 'application/x-www-form-urlencoded'\n        const formData = new FormData();\n        Object.keys(payload).forEach((key) => {\n          const value = payload[key];\n          if (typeof value !== 'undefined') {\n            let valueString;\n            try {\n              // We have seen instances where casting to String() throws error\n              // This check allows all valid attributes to be appended to the formData\n              // while logging error to console for any attribute that fails the cast to String\n              valueString = stringify ? JSON.stringify(value) : String(value);\n            }\n            catch (e) {\n              // eslint-disable-next-line no-console\n              console.error(`Unable to convert attribute '${key}' to a String(). '${key}' was not added to the formData in request.body for call to ${url}`, value, e);\n            }\n            if (valueString !== undefined) {\n              formData.append(key, valueString);\n            }\n          }\n        });\n        request.body = formData;\n      }\n    }\n    if (jsonPayload !== undefined) {\n      request.body = JSON.stringify(jsonPayload);\n      request.headers = {\n        ...request.headers,\n        'Content-Type': 'application/json'\n      };\n    }\n  }\n  return fetchWithRetry(url, request);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}