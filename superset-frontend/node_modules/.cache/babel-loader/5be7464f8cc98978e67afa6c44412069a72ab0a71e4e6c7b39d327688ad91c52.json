{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { scaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getLabelsColorMap, { LabelsColorMapSource } from './LabelsColorMapSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\nclass CategoricalColorScale extends ExtensibleFunction {\n\n\n\n\n\n\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} forcedColors optional parameter that comes from parent\n   * @param {*} appliedColorScheme the color scheme applied to the chart\n   *\n   */\n  constructor(colors, forcedColors = {}, appliedColorScheme) {\n    super((value, sliceId) => this.getColor(value, sliceId, appliedColorScheme));\n    // holds original color scheme colors\n    this.originColors = void 0;this.colors = void 0;this.scale = void 0;this.forcedColors = void 0;this.labelsColorMapInstance = void 0;this.chartLabelsColorMap = void 0;this.multiple = void 0;this.originColors = colors;\n    // holds the extended color range (includes analogous colors)\n    this.colors = colors;\n    // holds the values of this specific slice (label+color)\n    this.chartLabelsColorMap = new Map();\n    // shared color map instance (when context is shared, i.e. dashboard)\n    this.labelsColorMapInstance = getLabelsColorMap();\n    // holds the multiple value for analogous colors range\n    this.multiple = 0;\n    this.scale = scaleOrdinal();\n    this.scale.range(colors);\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(forcedColors).forEach(([key, value]) => {\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        forcedColors[key] = colors[value % colors.length];\n      }\n    });\n    // forced colors from parent (usually CategoricalColorNamespace)\n    // currently used in dashboards to set custom label colors\n    this.forcedColors = forcedColors;\n  }\n  /**\n   * Increment the color range with analogous colors\n   */\n  incrementColorRange() {\n    const multiple = Math.floor(this.domain().length / this.originColors.length);\n    // the domain has grown larger than the original range\n    // increments the range with analogous colors\n    if (multiple > this.multiple) {\n      this.multiple = multiple;\n      const newRange = getAnalogousColors(this.originColors, multiple);\n      const extendedColors = this.originColors.concat(newRange);\n      this.range(extendedColors);\n      this.colors = extendedColors;\n    }\n  }\n  /**\n   * Get the color for a given value\n   *\n   * @param value the value of a label to get the color for\n   * @param sliceId the ID of the current chart\n   * @param appliedColorScheme the color scheme applied to the chart\n   * @returns the color or the next available color\n   */\n  getColor(value, sliceId, appliedColorScheme) {var _this$forcedColors;\n    const cleanedValue = stringifyAndTrim(value);\n    // priority: forced color (aka custom label colors) > shared color > scale color\n    const forcedColor = (_this$forcedColors = this.forcedColors) == null ? void 0 : _this$forcedColors[cleanedValue];\n    const { source } = this.labelsColorMapInstance;\n    const currentColorMap = source === LabelsColorMapSource.Dashboard ?\n    this.labelsColorMapInstance.getColorMap() :\n    this.chartLabelsColorMap;\n    const isExistingLabel = currentColorMap.has(cleanedValue);\n    let color = forcedColor || (\n    isExistingLabel ?\n    currentColorMap.get(cleanedValue) :\n    this.scale(cleanedValue));\n    // a forced color will always be used independently of the usage count\n    if (!forcedColor && !isExistingLabel) {\n      if (isFeatureEnabled(FeatureFlag.UseAnalogousColors)) {\n        this.incrementColorRange();\n      }\n      if (\n      // feature flag to be deprecated (will become standard behaviour)\n      isFeatureEnabled(FeatureFlag.AvoidColorsCollision) &&\n      this.isColorUsed(color)) {\n        // fallback to least used color\n        color = this.getNextAvailableColor(cleanedValue, color);\n      }\n    }\n    // keep track of values in this slice\n    this.chartLabelsColorMap.set(cleanedValue, color);\n    // store the value+color in the LabelsColorMapSingleton\n    if (sliceId) {\n      this.labelsColorMapInstance.addSlice(cleanedValue, color, sliceId, appliedColorScheme);\n    }\n    return color;\n  }\n  /**\n   * Verify if a color is used in this slice\n   *\n   * @param color\n   * @returns true if the color is used in this slice\n   */\n  isColorUsed(color) {\n    return this.getColorUsageCount(color) > 0;\n  }\n  /**\n   * Get the count of the color usage in this slice\n   *\n   * @param sliceId the ID of the current slice\n   * @param color the color to check\n   * @returns the count of the color usage in this slice\n   */\n  getColorUsageCount(color) {\n    return Array.from(this.chartLabelsColorMap.values()).filter((value) => value === color).length;\n  }\n  /**\n   * Lower chances of color collision by returning the least used color.\n   * Checks across colors of current slice within chartLabelsColorMap.\n   *\n   * @param currentLabel the current label\n   * @param currentColor the current color\n   * @returns the least used color that is not the current color\n   */\n  getNextAvailableColor(currentLabel, currentColor) {\n    // Precompute color usage counts for all colors\n    const colorUsageCounts = new Map(this.colors.map((color) => [color, this.getColorUsageCount(color)]));\n    // Get an ordered array of labels from the map\n    const orderedLabels = Array.from(this.chartLabelsColorMap.keys());\n    const currentLabelIndex = orderedLabels.indexOf(currentLabel);\n    // Helper to infer \"previous\" and \"next\" labels based on index\n    const getAdjacentLabelsColors = () => {\n      const previousLabel = currentLabelIndex > 0 ? orderedLabels[currentLabelIndex - 1] : null;\n      const nextLabel = currentLabelIndex < orderedLabels.length - 1 ?\n      orderedLabels[currentLabelIndex + 1] :\n      null;\n      const previousColor = previousLabel ?\n      this.chartLabelsColorMap.get(previousLabel) :\n      null;\n      const nextColor = nextLabel ?\n      this.chartLabelsColorMap.get(nextLabel) :\n      null;\n      return [previousColor, nextColor].filter((color) => color);\n    };\n    const adjacentColors = getAdjacentLabelsColors();\n    // Determine adjusted score (usage count + penalties)\n    const calculateScore = (color) => {\n      /* istanbul ignore next */\n      const usageCount = colorUsageCounts.get(color) || 0;\n      const adjacencyPenalty = adjacentColors.includes(color) ? 100 : 0;\n      return usageCount + adjacencyPenalty;\n    };\n    // If there is any color that has never been used, prioritize it\n    const unusedColor = this.colors.find((color) => (colorUsageCounts.get(color) || 0) === 0);\n    if (unusedColor) {\n      return unusedColor;\n    }\n    // If all colors are used, calculate scores and choose the best one\n    const otherColors = this.colors.filter((color) => color !== currentColor);\n    // Find the color with the minimum score, defaulting to currentColor\n    return otherColors.reduce((bestColor, color) => {\n      const bestScore = calculateScore(bestColor);\n      const currentScore = calculateScore(color);\n      return currentScore < bestScore ? color : bestColor;\n    }, currentColor);\n  }\n  /**\n   * Enforce specific color for a given value at the scale level\n   * Overrides any existing color and forced color for the given value\n   *\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   * @returns {CategoricalColorScale}\n   */\n  setColor(value, forcedColor) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n  /**\n   * Get a mapping of data values to colors\n   *\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap = {};\n    this.scale.domain().forEach((value) => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n    return {\n      ...colorMap,\n      ...this.forcedColors\n    };\n  }\n  /**\n   * Return an exact copy of this scale.\n   * Changes to this scale will not affect the returned scale and vice versa.\n   *\n   * @returns {CategoricalColorScale} A copy of this scale.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(this.scale.range(), this.forcedColors);\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n    return copy;\n  }\n  domain(newDomain) {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n    this.scale.domain(newDomain);\n    return this;\n  }\n  range(newRange) {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n  unknown(value) {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n    this.scale.unknown(value);\n    return this;\n  }\n}\nexport default CategoricalColorScale;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}