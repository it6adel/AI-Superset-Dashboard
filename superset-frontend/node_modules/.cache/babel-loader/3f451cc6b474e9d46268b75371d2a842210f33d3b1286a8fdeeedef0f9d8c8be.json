{"ast":null,"code":"/* eslint-disable camelcase */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t, validateNonEmpty } from '@superset-ui/core';\nimport { isDataset } from '../types';\nimport { DATASET_TIME_COLUMN_OPTION, TIME_FILTER_LABELS } from '../constants';\nimport { QUERY_TIME_COLUMN_OPTION, defineSavedMetrics, ColumnOption, temporalColumnMixin, datePickerInAdhocFilterMixin, xAxisMixin } from '..';\n/*\n * Note: Previous to the commit that introduced this comment, the shared controls module\n * would check feature flags at module execution time and expose a different control\n * configuration (component + props) depending on the status of drag-and-drop feature\n * flags.  This commit combines those configs, merging the required props for both the\n * drag-and-drop and non-drag-and-drop components, and renders a wrapper component that\n * checks feature flags at component render time to avoid race conditions between when\n * feature flags are set and when they're checked.\n */import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport const dndGroupByControl = {\n  type: 'DndColumnSelect',\n  label: t('Dimensions'),\n  multi: true,\n  freeForm: true,\n  clearable: true,\n  default: [],\n  includeTime: false,\n  description: t('Dimensions contain qualitative values such as names, dates, or geographical data. ' +\n  'Use dimensions to categorize, segment, and reveal the details in your data. ' +\n  'Dimensions affect the level of detail in the view.'),\n  optionRenderer: (c) => _jsx(ColumnOption, { showType: true, column: c }),\n  valueRenderer: (c) => _jsx(ColumnOption, { column: c }),\n  valueKey: 'column_name',\n  allowAll: true,\n  filterOption: ({ data: opt }, text) => {var _opt$column_name, _opt$verbose_name;return ((_opt$column_name = opt.column_name) == null ? void 0 : _opt$column_name.toLowerCase().includes(text.toLowerCase())) || ((_opt$verbose_name =\n    opt.verbose_name) == null ? void 0 : _opt$verbose_name.toLowerCase().includes(text.toLowerCase())) ||\n    false;},\n  promptTextCreator: (label) => label,\n  mapStateToProps(state, controlState) {var _datasource$columns$;\n    const newState = {};\n    const { datasource } = state;\n    if (datasource != null && (_datasource$columns$ = datasource.columns[0]) != null && _datasource$columns$.hasOwnProperty('groupby')) {\n      const options = datasource.columns.filter((c) => c.groupby);\n      if (controlState != null && controlState.includeTime) {\n        options.unshift(DATASET_TIME_COLUMN_OPTION);\n      }\n      newState.options = options;\n      newState.savedMetrics = datasource.metrics || [];\n    } else\n    {\n      const options = (datasource == null ? void 0 : datasource.columns) || [];\n      if (controlState != null && controlState.includeTime) {\n        options.unshift(QUERY_TIME_COLUMN_OPTION);\n      }\n      newState.options = options;\n    }\n    return newState;\n  },\n  commaChoosesOption: false\n};\nexport const dndColumnsControl = {\n  ...dndGroupByControl,\n  label: t('Columns'),\n  description: t('Add dataset columns here to group the pivot table columns.')\n};\nexport const dndSeriesControl = {\n  ...dndGroupByControl,\n  label: t('Dimension'),\n  multi: false,\n  default: null,\n  description: t('Defines the grouping of entities. ' +\n  'Each series is represented by a specific color in the chart.')\n};\nexport const dndEntityControl = {\n  ...dndGroupByControl,\n  label: t('Entity'),\n  default: null,\n  multi: false,\n  validators: [validateNonEmpty],\n  description: t('This defines the element to be plotted on the chart')\n};\nexport const dndAdhocFilterControl = {\n  type: 'DndFilterSelect',\n  label: t('Filters'),\n  default: [],\n  description: '',\n  mapStateToProps: ({ datasource, form_data }) => ({\n    columns: isDataset(datasource) ?\n    datasource.columns.filter((c) => c.filterable) :\n    (datasource == null ? void 0 : datasource.columns) || [],\n    savedMetrics: defineSavedMetrics(datasource),\n    // current active adhoc metrics\n    selectedMetrics: form_data.metrics || (form_data.metric ? [form_data.metric] : []),\n    datasource\n  }),\n  provideFormDataToProps: true,\n  ...datePickerInAdhocFilterMixin\n};\nexport const dndAdhocMetricsControl = {\n  type: 'DndMetricSelect',\n  multi: true,\n  label: t('Metrics'),\n  validators: [validateNonEmpty],\n  mapStateToProps: ({ datasource }) => ({\n    columns: (datasource == null ? void 0 : datasource.columns) || [],\n    savedMetrics: defineSavedMetrics(datasource),\n    datasource,\n    datasourceType: datasource == null ? void 0 : datasource.type\n  }),\n  description: t('Select one or many metrics to display. ' +\n  'You can use an aggregation function on a column ' +\n  'or write custom SQL to create a metric.')\n};\nexport const dndAdhocMetricControl = {\n  ...dndAdhocMetricsControl,\n  multi: false,\n  label: t('Metric'),\n  description: t('Select a metric to display. ' +\n  'You can use an aggregation function on a column ' +\n  'or write custom SQL to create a metric.')\n};\nexport const dndAdhocMetricControl2 = {\n  ...dndAdhocMetricControl,\n  label: t('Right Axis Metric'),\n  clearable: true,\n  description: t('Select a metric to display on the right axis')\n};\nexport const dndSortByControl = {\n  type: 'DndMetricSelect',\n  label: t('Sort query by'),\n  default: null,\n  description: t('Orders the query result that generates the source data for this chart. ' +\n  'If a series or row limit is reached, this determines what data are truncated. ' +\n  'If undefined, defaults to the first metric (where appropriate).'),\n  mapStateToProps: ({ datasource }) => ({\n    columns: (datasource == null ? void 0 : datasource.columns) || [],\n    savedMetrics: defineSavedMetrics(datasource),\n    datasource,\n    datasourceType: datasource == null ? void 0 : datasource.type\n  })\n};\nexport const dndSizeControl = {\n  ...dndAdhocMetricControl,\n  label: t('Bubble Size'),\n  description: t('Metric used to calculate bubble size'),\n  default: null\n};\nexport const dndXControl = {\n  ...dndAdhocMetricControl,\n  label: t('X Axis'),\n  description: t(\"The dataset column/metric that returns the values on your chart's x-axis.\"),\n  default: null\n};\nexport const dndYControl = {\n  ...dndAdhocMetricControl,\n  label: t('Y Axis'),\n  description: t(\"The dataset column/metric that returns the values on your chart's y-axis.\"),\n  default: null\n};\nexport const dndSecondaryMetricControl = {\n  ...dndAdhocMetricControl,\n  label: t('Color Metric'),\n  default: null,\n  validators: [],\n  description: t('A metric to use for color')\n};\nexport const dndGranularitySqlaControl = {\n  ...dndSeriesControl,\n  ...temporalColumnMixin,\n  label: TIME_FILTER_LABELS.granularity_sqla,\n  description: t('The time column for the visualization. Note that you ' +\n  'can define arbitrary expression that return a DATETIME ' +\n  'column in the table. Also note that the ' +\n  'filter below is applied against this column or ' +\n  'expression'),\n  default: (c) => c.default,\n  clearable: false,\n  canDelete: false,\n  ghostButtonText: t('Drop a temporal column here or click'),\n  optionRenderer: (c) => _jsx(ColumnOption, { showType: true, column: c }),\n  valueRenderer: (c) => _jsx(ColumnOption, { column: c }),\n  valueKey: 'column_name'\n};\nexport const dndXAxisControl = {\n  ...dndGroupByControl,\n  ...xAxisMixin\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}