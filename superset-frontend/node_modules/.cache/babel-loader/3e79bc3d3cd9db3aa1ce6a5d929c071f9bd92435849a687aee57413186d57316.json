{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport { extractGroupbyLabel, getColtypesMapping, sanitizeHtml } from '../utils/series';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding } from '../Timeseries/transformers';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, filterState, queriesData, inContextMenu, emitCrossFilters } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, groupby = [], metrics = [], numberFormat, dateFormat, xTicksLayout, legendOrientation = 'top', xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId } = formData;\n  const refs = {};\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const transformedData = data.\n  map((datum) => {\n    const groupbyLabel = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    return metricLabels.map((metric) => {\n      const name = metricLabels.length === 1 ?\n      groupbyLabel :\n      `${groupbyLabel}, ${metric}`;\n      const isFiltered = filterState.selectedValues &&\n      !filterState.selectedValues.includes(name);\n      return {\n        name,\n        value: [\n        datum[`${metric}__min`],\n        datum[`${metric}__q1`],\n        datum[`${metric}__median`],\n        datum[`${metric}__q3`],\n        datum[`${metric}__max`],\n        datum[`${metric}__mean`],\n        datum[`${metric}__count`],\n        datum[`${metric}__outliers`]],\n\n        itemStyle: {\n          color: colorFn(groupbyLabel, sliceId),\n          opacity: isFiltered ? OpacityEnum.SemiTransparent : 0.6,\n          borderColor: colorFn(groupbyLabel, sliceId)\n        }\n      };\n    });\n  }).\n  flatMap((row) => row);\n  const outlierData = data.\n  map((datum) => metricLabels.map((metric) => {\n    const groupbyLabel = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    const name = metricLabels.length === 1 ?\n    groupbyLabel :\n    `${groupbyLabel}, ${metric}`;\n    // Outlier data is a nested array of numbers (uncommon, therefore no need to add to DataRecordValue)\n    const outlierDatum = datum[`${metric}__outliers`] || [];\n    const isFiltered = filterState.selectedValues &&\n    !filterState.selectedValues.includes(name);\n    return {\n      name: 'outlier',\n      type: 'scatter',\n      data: outlierDatum.map((val) => [name, val]),\n      tooltip: {\n        ...getDefaultTooltip(refs),\n        formatter: (param) => {\n          const [outlierName, stats] = param.data;\n          const headline = groupbyLabels.length ?\n          `<p><strong>${sanitizeHtml(outlierName)}</strong></p>` :\n          '';\n          return `${headline}${numberFormatter(stats)}`;\n        }\n      },\n      itemStyle: {\n        color: colorFn(groupbyLabel, sliceId),\n        opacity: isFiltered ?\n        OpacityEnum.SemiTransparent :\n        OpacityEnum.NonTransparent\n      }\n    };\n  })).\n  flat(2);\n  const labelMap = data.reduce((acc, datum) => {\n    const label = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    return {\n      ...acc,\n      [label]: groupbyLabels.map((col) => datum[col])\n    };\n  }, {});\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = transformedData.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  let axisLabel;\n  if (xTicksLayout === '45°')\n  axisLabel = { rotate: -45 };else\n  if (xTicksLayout === '90°')\n  axisLabel = { rotate: -90 };else\n  if (xTicksLayout === 'flat')\n  axisLabel = { rotate: 0 };else\n  if (xTicksLayout === 'staggered')\n  axisLabel = { rotate: -45 };else\n\n  axisLabel = { show: true };\n  const series = [\n  {\n    name: 'boxplot',\n    type: 'boxplot',\n    data: transformedData,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (param) => {\n        // @ts-ignore\n        const { value, name } = param;\n        const headline = name ?\n        `<p><strong>${sanitizeHtml(name)}</strong></p>` :\n        '';\n        const stats = [\n        `Max: ${numberFormatter(value[5])}`,\n        `3rd Quartile: ${numberFormatter(value[4])}`,\n        `Mean: ${numberFormatter(value[6])}`,\n        `Median: ${numberFormatter(value[3])}`,\n        `1st Quartile: ${numberFormatter(value[2])}`,\n        `Min: ${numberFormatter(value[1])}`,\n        `# Observations: ${value[7]}`];\n\n        if (value[8].length > 0) {\n          stats.push(`# Outliers: ${value[8].length}`);\n        }\n        return headline + stats.join('<br/>');\n      }\n    }\n  },\n  // @ts-ignore\n  ...outlierData];\n\n  const addYAxisTitleOffset = !!yAxisTitle;\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(true, legendOrientation, addYAxisTitleOffset, false, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const echartOptions = {\n    grid: {\n      ...defaultGrid,\n      ...chartPadding\n    },\n    xAxis: {\n      type: 'category',\n      data: transformedData.map((row) => row.name),\n      axisLabel,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle'\n    },\n    yAxis: {\n      ...defaultYAxis,\n      type: 'value',\n      axisLabel: { formatter: numberFormatter },\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end'\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      axisPointer: {\n        type: 'shadow'\n      }\n    },\n    series\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}