{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { COMMON_ERR_MESSAGES, t, ErrorTypeEnum, isProbablyHTML, isJsonString } from '@superset-ui/core';\nconst ERROR_CODE_LOOKUP = {\n  400: 'Bad request',\n  401: 'Unauthorized',\n  402: 'Payment required',\n  403: 'Forbidden',\n  404: 'Not found',\n  405: 'Method not allowed',\n  406: 'Not acceptable',\n  407: 'Proxy authentication required',\n  408: 'Request timeout',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length required',\n  412: 'Precondition failed',\n  413: 'Payload too large',\n  414: 'URI too long',\n  415: 'Unsupported media type',\n  416: 'Range not satisfiable',\n  417: 'Expectation failed',\n  418: \"I'm a teapot\",\n  500: 'Server error',\n  501: 'Not implemented',\n  502: 'Bad gateway',\n  503: 'Service unavailable',\n  504: 'Gateway timeout',\n  505: 'HTTP version not supported',\n  506: 'Variant also negotiates',\n  507: 'Insufficient storage',\n  508: 'Loop detected',\n  510: 'Not extended',\n  511: 'Network authentication required',\n  599: 'Network error'\n};\nexport function checkForHtml(str) {\n  return !isJsonString(str) && isProbablyHTML(str);\n}\nexport function parseStringResponse(str) {\n  if (checkForHtml(str)) {\n    for (const [code, message] of Object.entries(ERROR_CODE_LOOKUP)) {\n      const regex = new RegExp(`${code}|${message}`, 'i');\n      if (regex.test(str)) {\n        return t(message);\n      }\n    }\n    return t('Unknown error');\n  }\n  return str;\n}\nexport function getErrorFromStatusCode(status) {\n  return ERROR_CODE_LOOKUP[status] || null;\n}\nexport function retrieveErrorMessage(str, errorObject) {\n  const statusError = 'status' in errorObject ? getErrorFromStatusCode(errorObject.status) : null;\n  // Prefer status code message over the response or HTML text\n  return statusError || parseStringResponse(str);\n}\nexport function parseErrorJson(responseJson) {\n  let error = { ...responseJson };\n  // Backwards compatibility for old error renderers with the new error object\n  if (error.errors && error.errors.length > 0) {var _error$errors$, _error$errors$$extra;\n    error.error = error.description = error.errors[0].message;\n    error.link = (_error$errors$ = error.errors[0]) == null ? void 0 : (_error$errors$$extra = _error$errors$.extra) == null ? void 0 : _error$errors$$extra.link;\n  }\n  // Marshmallow field validation returns the error message in the format\n  // of { message: { field1: [msg1, msg2], field2: [msg], } }\n  if (!error.error && error.message) {\n    if (typeof error.message === 'object') {var _Object$values$;\n      error.error =\n      ((_Object$values$ = Object.values(error.message)[0]) == null ? void 0 : _Object$values$[0]) ||\n      t('Invalid input');\n    }\n    if (typeof error.message === 'string') {\n      if (checkForHtml(error.message)) {\n        error.error = retrieveErrorMessage(error.message, error);\n      } else\n      {\n        error.error = error.message;\n      }\n    }\n  }\n  if (error.stack) {\n    error = {\n      ...error,\n      error: t('Unexpected error: ') + (\n      error.description || t('(no description, click to see stack trace)')),\n      stacktrace: error.stack\n    };\n  } else\n  if (error.responseText && error.responseText.indexOf('CSRF') >= 0) {\n    error = {\n      ...error,\n      error: t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT)\n    };\n  }\n  return { ...error, error: error.error }; // explicit ClientErrorObject\n}\nexport function getClientErrorObject(response) {\n  // takes a SupersetClientResponse as input, attempts to read response as Json\n  // if possible, and returns a Promise that resolves to a plain object with\n  // error key and text value.\n  return new Promise((resolve) => {\n    if (typeof response === 'string') {\n      resolve({ error: parseStringResponse(response) });\n      return;\n    }\n    if (response instanceof TypeError &&\n    response.message === 'Failed to fetch') {\n      resolve({\n        error: t('Network error')\n      });\n      return;\n    }\n    if ('timeout' in response &&\n    'statusText' in response &&\n    response.statusText === 'timeout') {\n      resolve({\n        ...response,\n        error: t('Request timed out'),\n        errors: [\n        {\n          error_type: ErrorTypeEnum.FRONTEND_TIMEOUT_ERROR,\n          extra: {\n            timeout: response.timeout / 1000,\n            issue_codes: [\n            {\n              code: 1000,\n              message: t('Issue 1000 - The dataset is too large to query.')\n            },\n            {\n              code: 1001,\n              message: t('Issue 1001 - The database is under an unusual load.')\n            }]\n\n          },\n          level: 'error',\n          message: 'Request timed out'\n        }]\n\n      });\n      return;\n    }\n    const responseObject = response instanceof Response ? response : response.response;\n    if (responseObject && !responseObject.bodyUsed) {\n      // attempt to read the body as json, and fallback to text. we must clone\n      // the response in order to fallback to .text() because Response is\n      // single-read\n      responseObject.\n      clone().\n      json().\n      then((errorJson) => {\n        // Destructuring instead of spreading to avoid loss of sibling properties to the body\n        const { url, status, statusText, redirected, type } = responseObject;\n        const responseSummary = { url, status, statusText, redirected, type };\n        const error = {\n          ...errorJson,\n          ...responseSummary\n        };\n        resolve(parseErrorJson(error));\n      }).\n      catch(() => {\n        // fall back to reading as text\n        responseObject.text().then((errorText) => {\n          resolve({\n            // Destructuring not necessary here\n            ...responseObject,\n            error: retrieveErrorMessage(errorText, responseObject)\n          });\n        });\n      });\n      return;\n    }\n    // fall back to Response.statusText or generic error of we cannot read the response\n    let error = response.statusText || response.message;\n    if (!error) {\n      // eslint-disable-next-line no-console\n      console.error('non-standard error:', response);\n      error = t('An error occurred');\n    }\n    resolve({\n      ...responseObject,\n      error: parseStringResponse(error)\n    });\n  });\n}\n/*\n * Utility to get standardized error text for generic update failures\n */\nexport async function getErrorText(errorObject, source) {\n  const { error, message } = await getClientErrorObject(errorObject);\n  let errorText = t('Sorry, an unknown error occurred.');\n  if (error) {\n    errorText = t('Sorry, there was an error saving this %s: %s', source, error);\n  }\n  if (typeof message === 'string' && message === 'Forbidden') {\n    errorText = t('You do not have permission to edit this %s', source);\n  }\n  return errorText;\n}\nexport function getClientErrorMessage(message, clientError) {\n  let finalMessage = message;\n  const errorMessage = (clientError == null ? void 0 : clientError.message) || (clientError == null ? void 0 : clientError.error);\n  if (errorMessage) {\n    finalMessage = `${finalMessage}:\\n${errorMessage}`;\n  }\n  return finalMessage;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}