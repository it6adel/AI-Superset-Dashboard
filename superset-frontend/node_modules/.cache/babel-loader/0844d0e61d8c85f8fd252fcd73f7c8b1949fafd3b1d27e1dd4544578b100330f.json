{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isDefined, SupersetClient } from '../..';\nimport getChartBuildQueryRegistry from '../registries/ChartBuildQueryRegistrySingleton';\nimport getChartMetadataRegistry from '../registries/ChartMetadataRegistrySingleton';\nexport default class ChartClient {\n\n  constructor(config = {}) {this.client = void 0;\n    const { client = SupersetClient } = config;\n    this.client = client;\n  }\n  loadFormData(input, options) {\n    /* If sliceId is provided, use it to fetch stored formData from API */\n    if ('sliceId' in input) {\n      const promise = this.client.\n      get({\n        endpoint: `/api/v1/form_data/?slice_id=${input.sliceId}`,\n        ...options\n      }).\n      then((response) => response.json);\n      /*\n       * If formData is also specified, override API result\n       * with user-specified formData\n       */\n      return promise.then((dbFormData) => ({\n        ...dbFormData,\n        ...input.formData\n      }));\n    }\n    /* If sliceId is not provided, returned formData wrapped in a Promise */\n    return input.formData ?\n    Promise.resolve(input.formData) :\n    Promise.reject(new Error('At least one of sliceId or formData must be specified'));\n  }\n  async loadQueryData(formData, options) {\n    const { viz_type: visType } = formData;\n    const metaDataRegistry = getChartMetadataRegistry();\n    const buildQueryRegistry = getChartBuildQueryRegistry();\n    if (metaDataRegistry.has(visType)) {var _await$buildQueryRegi;\n      const { useLegacyApi } = metaDataRegistry.get(visType);\n      const buildQuery = (_await$buildQueryRegi = await buildQueryRegistry.get(visType)) != null ? _await$buildQueryRegi : () => formData;\n      const requestConfig = useLegacyApi ?\n      {\n        endpoint: '/superset/explore_json/',\n        postPayload: {\n          form_data: buildQuery(formData)\n        },\n        ...options\n      } :\n      {\n        endpoint: '/api/v1/chart/data',\n        jsonPayload: {\n          query_context: buildQuery(formData)\n        },\n        ...options\n      };\n      return this.client.\n      post(requestConfig).\n      then((response) => Array.isArray(response.json) ? response.json : [response.json]);\n    }\n    return Promise.reject(new Error(`Unknown chart type: ${visType}`));\n  }\n  loadDatasource(datasourceKey, options) {\n    return this.client.\n    get({\n      endpoint: `/superset/fetch_datasource_metadata?datasourceKey=${datasourceKey}`,\n      ...options\n    }).\n    then((response) => response.json);\n  }\n  // eslint-disable-next-line class-methods-use-this\n  loadAnnotation(annotationLayer) {\n    /* When annotation does not require query */\n    if (!isDefined(annotationLayer.sourceType)) {\n      return Promise.resolve({});\n    }\n    // TODO: Implement\n    return Promise.reject(new Error('This feature is not implemented yet.'));\n  }\n  loadAnnotations(annotationLayers) {\n    if (Array.isArray(annotationLayers) && annotationLayers.length > 0) {\n      return Promise.all(annotationLayers.map((layer) => this.loadAnnotation(layer))).then((results) => annotationLayers.reduce((prev, layer, i) => {\n        const output = prev;\n        output[layer.name] = results[i];\n        return output;\n      }, {}));\n    }\n    return Promise.resolve({});\n  }\n  loadChartData(input) {\n    return this.loadFormData(input).then((formData) => Promise.all([\n    this.loadAnnotations(formData.annotation_layers),\n    this.loadDatasource(formData.datasource),\n    this.loadQueryData(formData)]\n    ).then(([annotationData, datasource, queriesData]) => ({\n      annotationData,\n      datasource,\n      formData,\n      queriesData\n    })));\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}