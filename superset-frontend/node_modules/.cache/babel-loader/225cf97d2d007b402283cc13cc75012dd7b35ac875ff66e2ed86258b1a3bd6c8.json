{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DTTM_ALIAS } from '@superset-ui/core';\nimport { ForecastSeriesEnum } from '../types';\nimport { sanitizeHtml } from './series';\nconst seriesTypeRegex = new RegExp(`(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`);\nexport const extractForecastSeriesContext = (seriesName) => {\n  const name = seriesName;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch)\n  return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2]\n  };\n};\nexport const extractForecastSeriesContexts = (seriesNames) => seriesNames.reduce((agg, name) => {\n  const context = extractForecastSeriesContext(name);\n  const currentContexts = agg[context.name] || [];\n  currentContexts.push(context.type);\n  return { ...agg, [context.name]: currentContexts };\n}, {});\nexport const extractForecastValuesFromTooltipParams = (params, isHorizontal = false) => {\n  const values = {};\n  params.forEach((param) => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (typeof numericValue === 'number') {\n      if (!(context.name in values))\n      values[context.name] = {\n        marker: marker || ''\n      };\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n      forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n      forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n      forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n      forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\nexport const formatForecastTooltipSeries = ({ seriesName, observation, forecastTrend, forecastLower, forecastUpper, marker, formatter }) => {\n  const name = `${marker}${sanitizeHtml(seriesName)}`;\n  let value = typeof observation === 'number' ? formatter(observation) : '';\n  if (forecastTrend || forecastLower || forecastUpper) {\n    // forecast values take the form of \"20, y = 30 (10, 40)\"\n    // where the first part is the observation, the second part is the forecast trend\n    // and the third part is the lower and upper bounds\n    if (forecastTrend) {\n      if (value)\n      value += ', ';\n      value += `Å· = ${formatter(forecastTrend)}`;\n    }\n    if (forecastLower && forecastUpper) {\n      if (value)\n      value += ' ';\n      // the lower bound needs to be added to the upper bound\n      value += `(${formatter(forecastLower)}, ${formatter(forecastLower + forecastUpper)})`;\n    }\n  }\n  return [name, value];\n};\nexport function rebaseForecastDatum(data, verboseMap = {}) {\n  const keys = data.length ? Object.keys(data[0]) : [];\n  return data.map((row) => {\n    const newRow = {};\n    keys.forEach((key) => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey = key !== DTTM_ALIAS && verboseMap[forecastContext.name] ?\n      `${verboseMap[forecastContext.name]}${forecastContext.type}` :\n      key;\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key];\n      if (forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n      keys.includes(lowerForecastKey) &&\n      value !== null &&\n      row[lowerForecastKey] !== null) {\n        value -= row[lowerForecastKey];\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n}\n// For Confidence Bands, forecast series on mixed charts require the series sent in the following sortOrder:\nexport function reorderForecastSeries(row) {\n  const sortOrder = {\n    [ForecastSeriesEnum.ForecastLower]: 1,\n    [ForecastSeriesEnum.ForecastUpper]: 2,\n    [ForecastSeriesEnum.ForecastTrend]: 3,\n    [ForecastSeriesEnum.Observation]: 4\n  };\n  // Check if any item needs reordering\n  if (!row.some((item) => item.id &&\n  sortOrder.hasOwnProperty(extractForecastSeriesContext(item.id).type))) {\n    return row;\n  }\n  return row.sort((a, b) => {var _sortOrder$extractFor, _a$id, _sortOrder$extractFor2, _b$id;\n    const aOrder = (_sortOrder$extractFor = sortOrder[extractForecastSeriesContext((_a$id = a.id) != null ? _a$id : '').type]) != null ? _sortOrder$extractFor :\n    Number.MAX_SAFE_INTEGER;\n    const bOrder = (_sortOrder$extractFor2 = sortOrder[extractForecastSeriesContext((_b$id = b.id) != null ? _b$id : '').type]) != null ? _sortOrder$extractFor2 :\n    Number.MAX_SAFE_INTEGER;\n    return aOrder - bOrder;\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}