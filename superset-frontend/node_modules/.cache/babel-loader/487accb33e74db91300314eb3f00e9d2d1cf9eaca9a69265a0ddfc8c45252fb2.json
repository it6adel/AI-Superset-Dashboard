{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback } from 'react';\nimport { AxisType, DTTM_ALIAS, getColumnLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport Echart from '../components/Echart';\nimport { formatSeriesName } from '../utils/series';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport default function EchartsMixedTimeseries({ height, width, echartOptions, setDataMask, labelMap, labelMapB, groupby, groupbyB, selectedValues, formData, emitCrossFilters, seriesBreakdown, onContextMenu, onFocusedSeries, xValueFormatter, xAxis, refs, coltypeMapping }) {\n  const isFirstQuery = useCallback((seriesIndex) => seriesIndex < seriesBreakdown, [seriesBreakdown]);\n  const getCrossFilterDataMask = useCallback((seriesName, seriesIndex) => {\n    const selected = Object.values(selectedValues || {});\n    let values;\n    if (selected.includes(seriesName)) {\n      values = selected.filter((v) => v !== seriesName);\n    } else\n    {\n      values = [seriesName];\n    }\n    const currentGroupBy = isFirstQuery(seriesIndex) ? groupby : groupbyB;\n    const currentLabelMap = isFirstQuery(seriesIndex) ? labelMap : labelMapB;\n    const groupbyValues = values.\n    map((value) => currentLabelMap == null ? void 0 : currentLabelMap[value]).\n    filter((value) => !!value);\n    return {\n      dataMask: {\n        extraFormData: {\n          // @ts-ignore\n          filters: values.length === 0 ?\n          [] :\n          [\n          ...currentGroupBy.map((col, idx) => {\n            const val = groupbyValues.map((v) => v[idx]);\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL'\n            };\n            return {\n              col,\n              op: 'IN',\n              val: val\n            };\n          })]\n\n        },\n        filterState: {\n          value: !groupbyValues.length ? null : groupbyValues,\n          selectedValues: values.length ? values : null\n        }\n      },\n      isCurrentValueSelected: selected.includes(seriesName)\n    };\n  }, [groupby, groupbyB, isFirstQuery, labelMap, labelMapB, selectedValues]);\n  const handleChange = useCallback((seriesName, seriesIndex) => {\n    const isFirst = isFirstQuery(seriesIndex);\n    if (!emitCrossFilters ||\n    isFirst && groupby.length === 0 ||\n    !isFirst && groupbyB.length === 0) {\n      return;\n    }\n    setDataMask(getCrossFilterDataMask(seriesName, seriesIndex).dataMask);\n  }, [\n  isFirstQuery,\n  emitCrossFilters,\n  groupby.length,\n  groupbyB.length,\n  setDataMask,\n  getCrossFilterDataMask]\n  );\n  const eventHandlers = {\n    click: (props) => {\n      const { seriesName, seriesIndex } = props;\n      handleChange(seriesName, seriesIndex);\n    },\n    mouseout: () => {\n      onFocusedSeries(null);\n    },\n    mouseover: (params) => {\n      onFocusedSeries(params.seriesName);\n    },\n    contextmenu: async (eventParams) => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, seriesName, seriesIndex } = eventParams;\n        const pointerEvent = eventParams.event.event;\n        const drillToDetailFilters = [];\n        const drillByFilters = [];\n        const isFirst = isFirstQuery(seriesIndex);\n        const values = [\n        ...(eventParams.name ? [eventParams.name] : []),\n        ...((isFirst ? labelMap : labelMapB)[eventParams.seriesName] || [])];\n\n        if (data && xAxis.type === AxisType.Time) {\n          drillToDetailFilters.push({\n            col: xAxis.label === DTTM_ALIAS ?\n            formData.granularitySqla :\n            xAxis.label,\n            grain: formData.timeGrainSqla,\n            op: '==',\n            val: data[0],\n            formattedVal: xValueFormatter(data[0])\n          });\n        }\n        [\n        ...(data && xAxis.type === AxisType.Category ? [xAxis.label] : []),\n        ...(isFirst ? formData.groupby : formData.groupbyB)].\n        forEach((dimension, i) => drillToDetailFilters.push({\n          col: dimension,\n          op: '==',\n          val: values[i],\n          formattedVal: String(values[i])\n        }));\n        [...(isFirst ? formData.groupby : formData.groupbyB)].forEach((dimension, i) => drillByFilters.push({\n          col: dimension,\n          op: '==',\n          val: values[i],\n          formattedVal: formatSeriesName(values[i], {\n            timeFormatter: getTimeFormatter(formData.dateFormat),\n            numberFormatter: getNumberFormatter(formData.numberFormat),\n            coltype: coltypeMapping == null ? void 0 : coltypeMapping[getColumnLabel(dimension)]\n          })\n        }));\n        const hasCrossFilter = isFirst && groupby.length > 0 || !isFirst && groupbyB.length > 0;\n        onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n          drillToDetail: drillToDetailFilters,\n          crossFilter: hasCrossFilter ?\n          getCrossFilterDataMask(seriesName, seriesIndex) :\n          undefined,\n          drillBy: {\n            filters: drillByFilters,\n            groupbyFieldName: isFirst ? 'groupby' : 'groupby_b',\n            adhocFilterFieldName: isFirst ? 'adhoc_filters' : 'adhoc_filters_b'\n          }\n        });\n      }\n    }\n  };\n  return _jsx(Echart, { refs: refs, height: height, width: width, echartOptions: echartOptions, eventHandlers: eventHandlers, selectedValues: selectedValues });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}