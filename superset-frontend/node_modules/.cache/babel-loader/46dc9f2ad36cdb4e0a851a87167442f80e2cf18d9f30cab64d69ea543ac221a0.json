{"ast":null,"code":"import _sortBy from \"lodash/sortBy\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useMemo } from 'react';\nimport { css, ColorSchemeGroup, t, useTheme, getLabelsColorMap, CategoricalColorNamespace } from '@superset-ui/core';\n// eslint-disable-next-line no-restricted-imports\nimport AntdSelect from 'antd/lib/select'; // TODO: Remove antd\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { Tooltip } from 'src/components/Tooltip';\nimport Icons from 'src/components/Icons';\nimport { StyledSelect } from 'src/components/Select/styles';\nimport { handleFilterOptionHelper } from 'src/components/Select/utils';\nimport { getColorNamespace } from 'src/utils/colorScheme';\nimport ColorSchemeLabel from './ColorSchemeLabel';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst { Option, OptGroup } = AntdSelect;\nconst CUSTOM_LABEL_ALERT = t(`The colors of this chart might be overridden by custom label colors of the related dashboard.\n    Check the JSON metadata in the Advanced settings.`);\nconst DASHBOARD_ALERT = t(`The color scheme is determined by the related dashboard.\n        Edit the color scheme in the dashboard properties.`);\nconst DASHBOARD_CONTEXT_ALERT = t(`You are viewing this chart in a dashboard context with labels shared across multiple charts.\n        The color scheme selection is disabled.`);\nconst DASHBOARD_CONTEXT_TOOLTIP = t(`You are viewing this chart in the context of a dashboard that is directly affecting its colors.\n        To edit the color scheme, open this chart outside of the dashboard.`);\nconst Label = ({ label, dashboardId, hasSharedLabelsColor, hasCustomLabelsColor, hasDashboardColorScheme }) => {\n  const theme = useTheme();\n  if (hasSharedLabelsColor || hasCustomLabelsColor || hasDashboardColorScheme) {\n    const alertTitle = hasCustomLabelsColor && !hasSharedLabelsColor ?\n    CUSTOM_LABEL_ALERT :\n    dashboardId && hasDashboardColorScheme ?\n    DASHBOARD_ALERT :\n    DASHBOARD_CONTEXT_ALERT;\n    return _jsxs(_Fragment, { children: [\n      label, ' ',\n      _jsx(Tooltip, { title: alertTitle, children:\n        _jsx(Icons.WarningOutlined, { iconColor: theme.colors.warning.base, css: css`\n              vertical-align: baseline;\n            `, iconSize: \"s\" }) }\n      )] }\n    );\n  }\n  return _jsx(_Fragment, { children: label });\n};\nconst ColorSchemeControl = ({ hasCustomLabelsColor = false, hasDashboardColorScheme = false, mapLabelsColors = {}, sharedLabelsColors = [], dashboardId, colorNamespace, chartId, label = t('Color scheme'), onChange = () => {}, value, clearable = false, defaultScheme, choices = [], schemes = {}, isLinear, ...rest }) => {var _colorMapInstance$cha;\n  const countSharedLabelsColor = sharedLabelsColors.length;\n  const colorMapInstance = getLabelsColorMap();\n  const chartLabels = chartId ?\n  ((_colorMapInstance$cha = colorMapInstance.chartsLabelsMap.get(chartId)) == null ? void 0 : _colorMapInstance$cha.labels) || [] :\n  [];\n  const hasSharedLabelsColor = !!(dashboardId &&\n  countSharedLabelsColor > 0 &&\n  chartLabels.some((label) => sharedLabelsColors.includes(label)));\n  const hasDashboardScheme = dashboardId && hasDashboardColorScheme;\n  const showDashboardLockedOption = hasDashboardScheme || hasSharedLabelsColor;\n  const theme = useTheme();\n  const currentScheme = useMemo(() => {\n    if (showDashboardLockedOption) {\n      return 'dashboard';\n    }\n    let result = value || defaultScheme;\n    if (result === 'SUPERSET_DEFAULT') {var _schemesObject$SUPERS;\n      const schemesObject = typeof schemes === 'function' ? schemes() : schemes;\n      result = schemesObject == null ? void 0 : (_schemesObject$SUPERS = schemesObject.SUPERSET_DEFAULT) == null ? void 0 : _schemesObject$SUPERS.id;\n    }\n    return result;\n  }, [defaultScheme, schemes, showDashboardLockedOption, value]);\n  const options = useMemo(() => {\n    if (showDashboardLockedOption) {\n      return [\n      _jsx(Option, { value: \"dashboard\", label: t('Dashboard'), children:\n        _jsx(Tooltip, { title: DASHBOARD_CONTEXT_TOOLTIP, children:\n          t('Dashboard scheme') }\n        ) }, \"dashboard\"\n      )];\n\n    }\n    const schemesObject = typeof schemes === 'function' ? schemes() : schemes;\n    const controlChoices = typeof choices === 'function' ? choices() : choices;\n    const allColorOptions = [];\n    const filteredColorOptions = controlChoices.filter((o) => {\n      const option = o[0];\n      const isValidColorOption = option !== 'SUPERSET_DEFAULT' && !allColorOptions.includes(option);\n      allColorOptions.push(option);\n      return isValidColorOption;\n    });\n    const groups = filteredColorOptions.reduce((acc, [value]) => {var _schemesObject$value, _currentScheme$group;\n      const currentScheme = schemesObject[value];\n      // For categorical scheme, display all the colors\n      // For sequential scheme, show 10 or interpolate to 10.\n      // Sequential schemes usually have at most 10 colors.\n      let colors = [];\n      if (currentScheme) {\n        colors = isLinear ?\n        currentScheme.getColors(10) :\n        currentScheme.colors;\n      }\n      const option = {\n        customLabel: _jsx(ColorSchemeLabel, { id: currentScheme.id, label: currentScheme.label, colors: colors }),\n        label: (schemesObject == null ? void 0 : (_schemesObject$value = schemesObject[value]) == null ? void 0 : _schemesObject$value.label) || value,\n        value\n      };\n      acc[(_currentScheme$group = currentScheme.group) != null ? _currentScheme$group : ColorSchemeGroup.Other].options.push(option);\n      return acc;\n    }, {\n      [ColorSchemeGroup.Custom]: {\n        title: ColorSchemeGroup.Custom,\n        label: t('Custom color palettes'),\n        options: []\n      },\n      [ColorSchemeGroup.Featured]: {\n        title: ColorSchemeGroup.Featured,\n        label: t('Featured color palettes'),\n        options: []\n      },\n      [ColorSchemeGroup.Other]: {\n        title: ColorSchemeGroup.Other,\n        label: t('Other color palettes'),\n        options: []\n      }\n    });\n    const nonEmptyGroups = Object.values(groups).\n    filter((group) => group.options.length > 0).\n    map((group) => ({\n      ...group,\n      options: _sortBy(group.options, (opt) => opt.label)\n    }));\n    // if there are no featured or custom color schemes, return the ungrouped options\n    if (nonEmptyGroups.length === 1 &&\n    nonEmptyGroups[0].title === ColorSchemeGroup.Other) {\n      return nonEmptyGroups[0].options.map((opt, index) => _jsx(Option, { value: opt.value, label: opt.label, children:\n        opt.customLabel }, index\n      ));\n    }\n    return nonEmptyGroups.map((group, groupIndex) => _jsx(OptGroup, { label: group.label, children:\n      group.options.map((opt, optIndex) => _jsx(Option, { value: opt.value, label: opt.label, children:\n        opt.customLabel }, `${groupIndex}-${optIndex}`\n      )) }, groupIndex\n    ));\n  }, [choices, hasDashboardScheme, hasSharedLabelsColor, isLinear, schemes]);\n  // We can't pass on change directly because it receives a second\n  // parameter and it would be interpreted as the error parameter\n  const handleOnChange = (value) => {\n    if (chartId) {\n      colorMapInstance.setOwnColorScheme(chartId, value);\n      if (dashboardId) {\n        const colorNameSpace = getColorNamespace(colorNamespace);\n        const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n        const sharedLabelsSet = new Set(sharedLabelsColors);\n        // reset colors except shared and custom labels to keep dashboard consistency\n        const resettableLabels = Object.keys(mapLabelsColors).filter((l) => !sharedLabelsSet.has(l));\n        categoricalNamespace.resetColorsForLabels(resettableLabels);\n      }\n    }\n    onChange(value);\n  };\n  return _jsxs(_Fragment, { children: [\n    _jsx(ControlHeader, { ...rest, label: _jsx(Label, { label: label, dashboardId: dashboardId, hasCustomLabelsColor: hasCustomLabelsColor, hasDashboardColorScheme: hasDashboardColorScheme, hasSharedLabelsColor: hasSharedLabelsColor }) }),\n    _jsx(StyledSelect, { css: css`\n          width: 100%;\n          & .ant-select-item.ant-select-item-group {\n            padding-left: ${theme.gridUnit}px;\n            font-size: ${theme.typography.sizes.m}px;\n          }\n          & .ant-select-item-option-grouped {\n            padding-left: ${theme.gridUnit * 3}px;\n          }\n        `, \"aria-label\": t('Select color scheme'), allowClear: clearable, disabled: hasDashboardScheme || hasSharedLabelsColor, onChange: handleOnChange, placeholder: t('Select scheme'), value: currentScheme, getPopupContainer: (triggerNode) => triggerNode.parentNode, showSearch: true, filterOption: (search, option) => handleFilterOptionHelper(search, option, ['label', 'value'], true), children:\n      options }\n    )] }\n  );\n};\nexport default ColorSchemeControl;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}