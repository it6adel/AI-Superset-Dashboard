{"ast":null,"code":"import _pick from \"lodash/pick\";import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t, styled, getExtensionsRegistry, css, useTheme } from '@superset-ui/core';\nimport { useEffect, useRef, useState, useReducer, useCallback } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { setItem, LocalStorageKeys } from 'src/utils/localStorageHelpers';\nimport Tabs from 'src/components/Tabs';\nimport { AntdSelect, Upload } from 'src/components';\nimport Alert from 'src/components/Alert';\nimport Modal from 'src/components/Modal';\nimport Button from 'src/components/Button';\nimport IconButton from 'src/components/IconButton';\nimport InfoTooltip from 'src/components/InfoTooltip';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport ValidatedInput from 'src/components/Form/LabeledErrorBoundInput';\nimport ErrorMessageWithStackTrace from 'src/components/ErrorMessage/ErrorMessageWithStackTrace';\nimport ErrorAlert from 'src/components/ImportModal/ErrorAlert';\nimport Icons from 'src/components/Icons';\nimport { testDatabaseConnection, useSingleViewResource, useAvailableDatabases, useDatabaseValidation, getDatabaseImages, getConnectionAlert, useImportResource } from 'src/views/CRUD/hooks';\nimport { useCommonConf } from 'src/features/databases/state';\nimport Loading from 'src/components/Loading';\n\nimport { ConfigurationMethod, Engines } from '../types';\nimport ExtraOptions from './ExtraOptions';\nimport SqlAlchemyForm from './SqlAlchemyForm';\nimport DatabaseConnectionForm from './DatabaseConnectionForm';\nimport { antDAlertStyles, antdWarningAlertStyles, StyledAlertMargin, antDModalNoPaddingStyles, antDModalStyles, antDTabsStyles, buttonLinkStyles, importDbButtonLinkStyles, alchemyButtonLinkStyles, TabHeader, formHelperStyles, formStyles, StyledAlignment, SelectDatabaseStyles, infoTooltip, StyledFooterButton, StyledStickyHeader, formScrollableStyles, StyledUploadWrapper } from './styles';\nimport ModalHeader, { DOCUMENTATION_LINK } from './ModalHeader';\nimport SSHTunnelForm from './SSHTunnelForm';\nimport SSHTunnelSwitch from './SSHTunnelSwitch';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst extensionsRegistry = getExtensionsRegistry();\nconst DEFAULT_EXTRA = JSON.stringify({ allows_virtual_table_explore: true });\nconst engineSpecificAlertMapping = {\n  [Engines.GSheet]: {\n    message: 'Why do I need to create a database?',\n    description: 'To begin using your Google Sheets, you need to create a database first. ' +\n    'Databases are used as a way to identify ' +\n    'your data so that it can be queried and visualized. This ' +\n    'database will hold all of your individual Google Sheets ' +\n    'you choose to connect here.'\n  }\n};\nconst TabsStyled = styled(Tabs)`\n  .ant-tabs-content {\n    display: flex;\n    width: 100%;\n    overflow: inherit;\n\n    & > .ant-tabs-tabpane {\n      position: relative;\n    }\n  }\n`;\nconst ErrorAlertContainer = styled.div`\n  ${({ theme }) => `\n    margin: ${theme.gridUnit * 8}px ${theme.gridUnit * 4}px;\n  `};\n`;\nconst SSHTunnelContainer = styled.div`\n  ${({ theme }) => `\n    padding: 0px ${theme.gridUnit * 4}px;\n  `};\n`;\nexport var ActionType;\n(function (ActionType) {\n  ActionType[ActionType[\"AddTableCatalogSheet\"] = 0] = \"AddTableCatalogSheet\";\n  ActionType[ActionType[\"ConfigMethodChange\"] = 1] = \"ConfigMethodChange\";\n  ActionType[ActionType[\"DbSelected\"] = 2] = \"DbSelected\";\n  ActionType[ActionType[\"EditorChange\"] = 3] = \"EditorChange\";\n  ActionType[ActionType[\"ExtraEditorChange\"] = 4] = \"ExtraEditorChange\";\n  ActionType[ActionType[\"ExtraInputChange\"] = 5] = \"ExtraInputChange\";\n  ActionType[ActionType[\"EncryptedExtraInputChange\"] = 6] = \"EncryptedExtraInputChange\";\n  ActionType[ActionType[\"Fetched\"] = 7] = \"Fetched\";\n  ActionType[ActionType[\"InputChange\"] = 8] = \"InputChange\";\n  ActionType[ActionType[\"ParametersChange\"] = 9] = \"ParametersChange\";\n  ActionType[ActionType[\"QueryChange\"] = 10] = \"QueryChange\";\n  ActionType[ActionType[\"RemoveTableCatalogSheet\"] = 11] = \"RemoveTableCatalogSheet\";\n  ActionType[ActionType[\"Reset\"] = 12] = \"Reset\";\n  ActionType[ActionType[\"TextChange\"] = 13] = \"TextChange\";\n  ActionType[ActionType[\"ParametersSSHTunnelChange\"] = 14] = \"ParametersSSHTunnelChange\";\n  ActionType[ActionType[\"SetSSHTunnelLoginMethod\"] = 15] = \"SetSSHTunnelLoginMethod\";\n  ActionType[ActionType[\"RemoveSSHTunnelConfig\"] = 16] = \"RemoveSSHTunnelConfig\";\n})(ActionType || (ActionType = {}));\nexport var AuthType;\n(function (AuthType) {\n  AuthType[AuthType[\"Password\"] = 0] = \"Password\";\n  AuthType[AuthType[\"PrivateKey\"] = 1] = \"PrivateKey\";\n})(AuthType || (AuthType = {}));\nconst StyledBtns = styled.div`\n  margin-bottom: ${({ theme }) => theme.gridUnit * 3}px;\n  margin-left: ${({ theme }) => theme.gridUnit * 3}px;\n`;\nexport function dbReducer(state, action) {var _action$payload$type, _trimmedState$catalog, _action$payload, _action$payload$param;\n  const trimmedState = {\n    ...(state || {})\n  };\n  let query = {};\n  let query_input = '';\n  let parametersCatalog;\n  let actionPayloadJson;\n  const extraJson = JSON.parse(trimmedState.extra || '{}');\n  switch (action.type) {\n    case ActionType.ExtraEditorChange:\n      // \"extra\" payload in state is a string\n      try {\n        // we don't want to stringify encoded strings twice\n        actionPayloadJson = JSON.parse(action.payload.json || '{}');\n      }\n      catch (e) {\n        actionPayloadJson = action.payload.json;\n      }\n      return {\n        ...trimmedState,\n        extra: JSON.stringify({\n          ...extraJson,\n          [action.payload.name]: actionPayloadJson\n        })\n      };\n    case ActionType.EncryptedExtraInputChange:\n      return {\n        ...trimmedState,\n        masked_encrypted_extra: JSON.stringify({\n          ...JSON.parse(trimmedState.masked_encrypted_extra || '{}'),\n          [action.payload.name]: action.payload.value\n        })\n      };\n    case ActionType.ExtraInputChange:\n      // \"extra\" payload in state is a string\n      if (action.payload.name === 'schema_cache_timeout' ||\n      action.payload.name === 'table_cache_timeout') {\n        return {\n          ...trimmedState,\n          extra: JSON.stringify({\n            ...extraJson,\n            metadata_cache_timeout: {\n              ...(extraJson == null ? void 0 : extraJson.metadata_cache_timeout),\n              [action.payload.name]: action.payload.value\n            }\n          })\n        };\n      }\n      if (action.payload.name === 'schemas_allowed_for_file_upload') {\n        return {\n          ...trimmedState,\n          extra: JSON.stringify({\n            ...extraJson,\n            schemas_allowed_for_file_upload: (action.payload.value || '').\n            split(',').\n            filter((schema) => schema !== '')\n          })\n        };\n      }\n      if (action.payload.name === 'http_path') {var _action$payload$value;\n        return {\n          ...trimmedState,\n          extra: JSON.stringify({\n            ...extraJson,\n            engine_params: {\n              connect_args: {\n                [action.payload.name]: (_action$payload$value = action.payload.value) == null ? void 0 : _action$payload$value.trim()\n              }\n            }\n          })\n        };\n      }\n      if (action.payload.name === 'expand_rows') {\n        return {\n          ...trimmedState,\n          extra: JSON.stringify({\n            ...extraJson,\n            schema_options: {\n              ...(extraJson == null ? void 0 : extraJson.schema_options),\n              [action.payload.name]: !!action.payload.value\n            }\n          })\n        };\n      }\n      return {\n        ...trimmedState,\n        extra: JSON.stringify({\n          ...extraJson,\n          [action.payload.name]: action.payload.type === 'checkbox' ?\n          action.payload.checked :\n          action.payload.value\n        })\n      };\n    case ActionType.InputChange:\n      if (action.payload.type === 'checkbox') {\n        return {\n          ...trimmedState,\n          [action.payload.name]: action.payload.checked\n        };\n      }\n      return {\n        ...trimmedState,\n        [action.payload.name]: action.payload.value\n      };\n    case ActionType.ParametersChange:\n      // catalog params will always have a catalog state for\n      // dbs that use a catalog, i.e., gsheets, even if the\n      // fields are empty strings\n      if ((_action$payload$type = action.payload.type) != null && _action$payload$type.startsWith('catalog') &&\n      trimmedState.catalog !== undefined) {var _action$payload$type2;\n        // Formatting wrapping google sheets table catalog\n        const catalogCopy = [...trimmedState.catalog];\n        const idx = (_action$payload$type2 = action.payload.type) == null ? void 0 : _action$payload$type2.split('-')[1];\n        const catalogToUpdate = catalogCopy[parseInt(idx, 10)] || {};\n        if (action.payload.value !== undefined) {\n          catalogToUpdate[action.payload.name] =\n          action.payload.value;\n        }\n        // insert updated catalog to existing state\n        catalogCopy.splice(parseInt(idx, 10), 1, catalogToUpdate);\n        // format catalog for state\n        // eslint-disable-next-line array-callback-return\n        parametersCatalog = catalogCopy.reduce((obj, item) => {\n          const catalog = { ...obj };\n          catalog[item.name] = item.value;\n          return catalog;\n        }, {});\n        return {\n          ...trimmedState,\n          catalog: catalogCopy,\n          parameters: {\n            ...trimmedState.parameters,\n            catalog: parametersCatalog\n          }\n        };\n      }\n      return {\n        ...trimmedState,\n        parameters: {\n          ...trimmedState.parameters,\n          [action.payload.name]: action.payload.value\n        }\n      };\n    case ActionType.ParametersSSHTunnelChange:\n      return {\n        ...trimmedState,\n        ssh_tunnel: {\n          ...trimmedState.ssh_tunnel,\n          [action.payload.name]: action.payload.value\n        }\n      };\n    case ActionType.SetSSHTunnelLoginMethod:{\n        let ssh_tunnel = {};\n        if (trimmedState != null && trimmedState.ssh_tunnel) {\n          // remove any attributes that are considered sensitive\n          ssh_tunnel = _pick(trimmedState.ssh_tunnel, [\n          'id',\n          'server_address',\n          'server_port',\n          'username']\n          );\n        }\n        if (action.payload.login_method === AuthType.PrivateKey) {var _trimmedState$ssh_tun, _trimmedState$ssh_tun2;\n          return {\n            ...trimmedState,\n            ssh_tunnel: {\n              private_key: trimmedState == null ? void 0 : (_trimmedState$ssh_tun = trimmedState.ssh_tunnel) == null ? void 0 : _trimmedState$ssh_tun.private_key,\n              private_key_password: trimmedState == null ? void 0 : (_trimmedState$ssh_tun2 = trimmedState.ssh_tunnel) == null ? void 0 : _trimmedState$ssh_tun2.private_key_password,\n              ...ssh_tunnel\n            }\n          };\n        }\n        if (action.payload.login_method === AuthType.Password) {var _trimmedState$ssh_tun3;\n          return {\n            ...trimmedState,\n            ssh_tunnel: {\n              password: trimmedState == null ? void 0 : (_trimmedState$ssh_tun3 = trimmedState.ssh_tunnel) == null ? void 0 : _trimmedState$ssh_tun3.password,\n              ...ssh_tunnel\n            }\n          };\n        }\n        return {\n          ...trimmedState\n        };\n      }\n    case ActionType.RemoveSSHTunnelConfig:\n      return {\n        ...trimmedState,\n        ssh_tunnel: undefined\n      };\n    case ActionType.AddTableCatalogSheet:\n      if (trimmedState.catalog !== undefined) {\n        return {\n          ...trimmedState,\n          catalog: [...trimmedState.catalog, { name: '', value: '' }]\n        };\n      }\n      return {\n        ...trimmedState,\n        catalog: [{ name: '', value: '' }]\n      };\n    case ActionType.RemoveTableCatalogSheet:\n      (_trimmedState$catalog = trimmedState.catalog) == null ? void 0 : _trimmedState$catalog.splice(action.payload.indexToDelete, 1);\n      return {\n        ...trimmedState\n      };\n    case ActionType.EditorChange:\n      return {\n        ...trimmedState,\n        [action.payload.name]: action.payload.json\n      };\n    case ActionType.QueryChange:\n      return {\n        ...trimmedState,\n        parameters: {\n          ...trimmedState.parameters,\n          query: Object.fromEntries(new URLSearchParams(action.payload.value))\n        },\n        query_input: action.payload.value\n      };\n    case ActionType.TextChange:\n      return {\n        ...trimmedState,\n        [action.payload.name]: action.payload.value\n      };\n    case ActionType.Fetched:\n      // convert query to a string and store in query_input\n      query = ((_action$payload = action.payload) == null ? void 0 : (_action$payload$param = _action$payload.parameters) == null ? void 0 : _action$payload$param.query) || {};\n      query_input = Object.entries(query).\n      map(([key, value]) => `${key}=${value}`).\n      join('&');\n      if (action.payload.masked_encrypted_extra &&\n      action.payload.configuration_method === ConfigurationMethod.DynamicForm) {var _extraJsonPayload$eng;\n        // \"extra\" payload from the api is a string\n        const extraJsonPayload = {\n          ...JSON.parse(action.payload.extra || '{}')\n        };\n        const payloadCatalog = (_extraJsonPayload$eng = extraJsonPayload.engine_params) == null ? void 0 : _extraJsonPayload$eng.catalog;\n        const engineRootCatalog = Object.entries(payloadCatalog || {}).map(([name, value]) => ({ name, value }));\n        return {\n          ...action.payload,\n          engine: action.payload.backend || trimmedState.engine,\n          configuration_method: action.payload.configuration_method,\n          catalog: engineRootCatalog,\n          parameters: {\n            ...(action.payload.parameters || trimmedState.parameters),\n            catalog: payloadCatalog\n          },\n          query_input\n        };\n      }\n      return {\n        ...action.payload,\n        masked_encrypted_extra: action.payload.masked_encrypted_extra || '',\n        engine: action.payload.backend || trimmedState.engine,\n        configuration_method: action.payload.configuration_method,\n        parameters: action.payload.parameters || trimmedState.parameters,\n        ssh_tunnel: action.payload.ssh_tunnel || trimmedState.ssh_tunnel,\n        query_input\n      };\n    case ActionType.DbSelected:\n      // set initial state for blank form\n      return {\n        ...action.payload,\n        extra: DEFAULT_EXTRA,\n        expose_in_sqllab: true\n      };\n    case ActionType.ConfigMethodChange:\n      return {\n        ...action.payload\n      };\n    case ActionType.Reset:\n    default:\n      return null;\n  }\n}\nconst DEFAULT_TAB_KEY = '1';\nconst DatabaseModal = ({ addDangerToast, addSuccessToast, onDatabaseAdd, onHide, show, databaseId, dbEngine }) => {var _extensionsRegistry$g, _availableDbs$databas3, _availableDbs$databas4, _db$parameters2;\n  const theme = useTheme();\n  const [db, setDB] = useReducer(dbReducer, null);\n  // Database fetch logic\n  const { state: { loading: dbLoading, resource: dbFetched, error: dbErrors }, fetchResource, createResource, updateResource, clearError } = useSingleViewResource('database', t('database'), addDangerToast, 'connection');\n  const [tabKey, setTabKey] = useState(DEFAULT_TAB_KEY);\n  const [availableDbs, getAvailableDbs] = useAvailableDatabases();\n  const [validationErrors, getValidation, setValidationErrors] = useDatabaseValidation();\n  const [hasConnectedDb, setHasConnectedDb] = useState(false);\n  const [showCTAbtns, setShowCTAbtns] = useState(false);\n  const [dbName, setDbName] = useState('');\n  const [editNewDb, setEditNewDb] = useState(false);\n  const [isLoading, setLoading] = useState(false);\n  const [testInProgress, setTestInProgress] = useState(false);\n  const [passwords, setPasswords] = useState({});\n  const [sshTunnelPasswords, setSSHTunnelPasswords] = useState({});\n  const [sshTunnelPrivateKeys, setSSHTunnelPrivateKeys] = useState({});\n  const [sshTunnelPrivateKeyPasswords, setSSHTunnelPrivateKeyPasswords] = useState({});\n  const [confirmedOverwrite, setConfirmedOverwrite] = useState(false);\n  const [fileList, setFileList] = useState([]);\n  const [importingModal, setImportingModal] = useState(false);\n  const [importingErrorMessage, setImportingErrorMessage] = useState();\n  const [passwordFields, setPasswordFields] = useState([]);\n  const [sshTunnelPasswordFields, setSSHTunnelPasswordFields] = useState([]);\n  const [sshTunnelPrivateKeyFields, setSSHTunnelPrivateKeyFields] = useState([]);\n  const [sshTunnelPrivateKeyPasswordFields, setSSHTunnelPrivateKeyPasswordFields] = useState([]);\n  const [extraExtensionComponentState, setExtraExtensionComponentState] = useState({});\n  const SSHTunnelSwitchComponent = (_extensionsRegistry$g = extensionsRegistry.get('ssh_tunnel.form.switch')) != null ? _extensionsRegistry$g : SSHTunnelSwitch;\n  const [useSSHTunneling, setUseSSHTunneling] = useState(undefined);\n  let dbConfigExtraExtension = extensionsRegistry.get('databaseconnection.extraOption');\n  if (dbConfigExtraExtension) {\n    // add method for db modal to store data\n    dbConfigExtraExtension = {\n      ...dbConfigExtraExtension,\n      onEdit: (componentState) => {\n        setExtraExtensionComponentState({\n          ...extraExtensionComponentState,\n          ...componentState\n        });\n      }\n    };\n  }\n  const conf = useCommonConf();\n  const dbImages = getDatabaseImages();\n  const connectionAlert = getConnectionAlert();\n  const isEditMode = !!databaseId;\n  const hasAlert = connectionAlert ||\n  !!(db != null && db.engine &&\n  engineSpecificAlertMapping[db.engine]);\n  const useSqlAlchemyForm = (db == null ? void 0 : db.configuration_method) === ConfigurationMethod.SqlalchemyUri;\n  const useTabLayout = isEditMode || useSqlAlchemyForm;\n  const isDynamic = (engine) => {var _availableDbs$databas, _availableDbs$databas2;return (availableDbs == null ? void 0 : (_availableDbs$databas = availableDbs.databases) == null ? void 0 : (_availableDbs$databas2 = _availableDbs$databas.find((DB) => DB.backend === engine || DB.engine === engine)) == null ? void 0 : _availableDbs$databas2.parameters) !== undefined;};\n  const showDBError = validationErrors || dbErrors;\n  const history = useHistory();\n  const dbModel =\n  // TODO: we need a centralized engine in one place\n  // first try to match both engine and driver\n  (availableDbs == null ? void 0 : (_availableDbs$databas3 = availableDbs.databases) == null ? void 0 : _availableDbs$databas3.find((available) => available.engine === (isEditMode ? db == null ? void 0 : db.backend : db == null ? void 0 : db.engine) &&\n  available.default_driver === (db == null ? void 0 : db.driver))) || (\n  // alternatively try to match only engine\n  availableDbs == null ? void 0 : (_availableDbs$databas4 = availableDbs.databases) == null ? void 0 : _availableDbs$databas4.find((available) => available.engine === (isEditMode ? db == null ? void 0 : db.backend : db == null ? void 0 : db.engine))) ||\n  {};\n  // Test Connection logic\n  const testConnection = () => {var _db$database_name;\n    if (!(db != null && db.sqlalchemy_uri)) {\n      addDangerToast(t('Please enter a SQLAlchemy URI to test'));\n      return;\n    }\n    const connection = {\n      sqlalchemy_uri: (db == null ? void 0 : db.sqlalchemy_uri) || '',\n      database_name: (db == null ? void 0 : (_db$database_name = db.database_name) == null ? void 0 : _db$database_name.trim()) || undefined,\n      impersonate_user: (db == null ? void 0 : db.impersonate_user) || undefined,\n      extra: db == null ? void 0 : db.extra,\n      masked_encrypted_extra: (db == null ? void 0 : db.masked_encrypted_extra) || '',\n      server_cert: (db == null ? void 0 : db.server_cert) || undefined,\n      ssh_tunnel: !_isEmpty(db == null ? void 0 : db.ssh_tunnel) && useSSHTunneling ?\n      {\n        ...db.ssh_tunnel,\n        server_port: Number(db.ssh_tunnel.server_port)\n      } :\n      undefined\n    };\n    setTestInProgress(true);\n    testDatabaseConnection(connection, (errorMsg) => {\n      setTestInProgress(false);\n      addDangerToast(errorMsg);\n    }, (errorMsg) => {\n      setTestInProgress(false);\n      addSuccessToast(errorMsg);\n    });\n  };\n  const getPlaceholder = (field) => {\n    if (field === 'database') {\n      return t('e.g. world_population');\n    }\n    return undefined;\n  };\n  const removeFile = (removedFile) => {\n    setFileList(fileList.filter((file) => file.uid !== removedFile.uid));\n    return false;\n  };\n  const onChange = useCallback((type, payload) => {\n    setDB({ type, payload });\n  }, []);\n  const handleClearValidationErrors = useCallback(() => {\n    setValidationErrors(null);\n  }, [setValidationErrors]);\n  const handleParametersChange = useCallback(({ target }) => {\n    onChange(ActionType.ParametersChange, {\n      type: target.type,\n      name: target.name,\n      checked: target.checked,\n      value: target.value\n    });\n  }, [onChange]);\n  const onClose = () => {\n    setDB({ type: ActionType.Reset });\n    setHasConnectedDb(false);\n    handleClearValidationErrors(); // reset validation errors on close\n    clearError();\n    setEditNewDb(false);\n    setFileList([]);\n    setImportingModal(false);\n    setImportingErrorMessage('');\n    setPasswordFields([]);\n    setSSHTunnelPasswordFields([]);\n    setSSHTunnelPrivateKeyFields([]);\n    setSSHTunnelPrivateKeyPasswordFields([]);\n    setPasswords({});\n    setSSHTunnelPasswords({});\n    setSSHTunnelPrivateKeys({});\n    setSSHTunnelPrivateKeyPasswords({});\n    setConfirmedOverwrite(false);\n    setUseSSHTunneling(undefined);\n    onHide();\n  };\n  const redirectURL = (url) => {\n    history.push(url);\n  };\n  // Database import logic\n  const { state: { alreadyExists, passwordsNeeded, sshPasswordNeeded, sshPrivateKeyNeeded, sshPrivateKeyPasswordNeeded, loading: importLoading, failed: importErrored }, importResource } = useImportResource('database', t('database'), (msg) => {\n    setImportingErrorMessage(msg);\n  });\n  const onSave = async () => {var _dbConfigExtraExtensi, _dbToUpdate$parameter7;\n    let dbConfigExtraExtensionOnSaveError;\n    setLoading(true);\n    (_dbConfigExtraExtensi = dbConfigExtraExtension) == null ? void 0 : _dbConfigExtraExtensi.\n    onSave(extraExtensionComponentState, db).\n    then(({ error }) => {\n      if (error) {\n        dbConfigExtraExtensionOnSaveError = error;\n        addDangerToast(error);\n      }\n    });\n    if (dbConfigExtraExtensionOnSaveError) {\n      setLoading(false);\n      return;\n    }\n    // Clone DB object\n    const dbToUpdate = { ...(db || {}) };\n    if (dbToUpdate.configuration_method === ConfigurationMethod.DynamicForm) {var _dbToUpdate$parameter, _dbToUpdate$parameter2;\n      // Validate DB before saving\n      if (dbToUpdate != null && (_dbToUpdate$parameter = dbToUpdate.parameters) != null && _dbToUpdate$parameter.catalog) {\n        // need to stringify gsheets catalog to allow it to be serialized\n        dbToUpdate.extra = JSON.stringify({\n          ...JSON.parse(dbToUpdate.extra || '{}'),\n          engine_params: {\n            catalog: dbToUpdate.parameters.catalog\n          }\n        });\n      }\n      const errors = await getValidation(dbToUpdate, true);\n      if (!_isEmpty(validationErrors) || errors != null && errors.length) {\n        addDangerToast(t('Connection failed, please check your connection settings.'));\n        setLoading(false);\n        return;\n      }\n      const parameters_schema = isEditMode ? (_dbToUpdate$parameter2 =\n      dbToUpdate.parameters_schema) == null ? void 0 : _dbToUpdate$parameter2.properties :\n      dbModel == null ? void 0 : dbModel.parameters.properties;\n      const additionalEncryptedExtra = JSON.parse(dbToUpdate.masked_encrypted_extra || '{}');\n      const paramConfigArray = Object.keys(parameters_schema || {});\n      paramConfigArray.forEach((paramConfig) => {var _dbToUpdate$parameter3;\n        /*\n         * Parameters that are annotated with the `x-encrypted-extra` properties should be\n         * moved to `masked_encrypted_extra`, so that they are stored encrypted in the\n         * backend when the database is created or edited.\n         */\n        if (parameters_schema[paramConfig]['x-encrypted-extra'] && (_dbToUpdate$parameter3 =\n        dbToUpdate.parameters) != null && _dbToUpdate$parameter3[paramConfig]) {var _dbToUpdate$parameter4;\n          if (typeof ((_dbToUpdate$parameter4 = dbToUpdate.parameters) == null ? void 0 : _dbToUpdate$parameter4[paramConfig]) === 'object') {var _dbToUpdate$parameter5;\n            // add new encrypted extra to masked_encrypted_extra object\n            additionalEncryptedExtra[paramConfig] = (_dbToUpdate$parameter5 =\n            dbToUpdate.parameters) == null ? void 0 : _dbToUpdate$parameter5[paramConfig];\n            // The backend expects `masked_encrypted_extra` as a string for historical\n            // reasons.\n            dbToUpdate.parameters[paramConfig] = JSON.stringify(dbToUpdate.parameters[paramConfig]);\n          } else\n          {var _dbToUpdate$parameter6;\n            additionalEncryptedExtra[paramConfig] = JSON.parse(((_dbToUpdate$parameter6 = dbToUpdate.parameters) == null ? void 0 : _dbToUpdate$parameter6[paramConfig]) || '{}');\n          }\n        }\n      });\n      // cast the new encrypted extra object into a string\n      dbToUpdate.masked_encrypted_extra = JSON.stringify(additionalEncryptedExtra);\n      // this needs to be added by default to gsheets\n      if (dbToUpdate.engine === Engines.GSheet) {\n        dbToUpdate.impersonate_user = true;\n      }\n    }\n    if (dbToUpdate != null && (_dbToUpdate$parameter7 = dbToUpdate.parameters) != null && _dbToUpdate$parameter7.catalog) {\n      // need to stringify gsheets catalog to allow it to be serialized\n      dbToUpdate.extra = JSON.stringify({\n        ...JSON.parse(dbToUpdate.extra || '{}'),\n        engine_params: {\n          catalog: dbToUpdate.parameters.catalog\n        }\n      });\n    }\n    // strictly checking for false as an indication that the toggle got unchecked\n    if (useSSHTunneling === false) {\n      // remove ssh tunnel\n      dbToUpdate.ssh_tunnel = null;\n    }\n    if (db != null && db.id) {\n      const result = await updateResource(db.id, dbToUpdate, dbToUpdate.configuration_method === ConfigurationMethod.DynamicForm);\n      if (result) {var _dbConfigExtraExtensi2;\n        if (onDatabaseAdd)\n        onDatabaseAdd();\n        (_dbConfigExtraExtensi2 = dbConfigExtraExtension) == null ? void 0 : _dbConfigExtraExtensi2.\n        onSave(extraExtensionComponentState, db).\n        then(({ error }) => {\n          if (error) {\n            dbConfigExtraExtensionOnSaveError = error;\n            addDangerToast(error);\n          }\n        });\n        if (dbConfigExtraExtensionOnSaveError) {\n          setLoading(false);\n          return;\n        }\n        if (!editNewDb) {\n          onClose();\n          addSuccessToast(t('Database settings updated'));\n        }\n      }\n    } else\n    if (db) {\n      // Create\n      const dbId = await createResource(dbToUpdate, dbToUpdate.configuration_method === ConfigurationMethod.DynamicForm);\n      if (dbId) {var _dbConfigExtraExtensi3;\n        setHasConnectedDb(true);\n        if (onDatabaseAdd)\n        onDatabaseAdd();\n        (_dbConfigExtraExtensi3 = dbConfigExtraExtension) == null ? void 0 : _dbConfigExtraExtensi3.\n        onSave(extraExtensionComponentState, db).\n        then(({ error }) => {\n          if (error) {\n            dbConfigExtraExtensionOnSaveError = error;\n            addDangerToast(error);\n          }\n        });\n        if (dbConfigExtraExtensionOnSaveError) {\n          setLoading(false);\n          return;\n        }\n        if (useTabLayout) {\n          // tab layout only has one step\n          // so it should close immediately on save\n          onClose();\n          addSuccessToast(t('Database connected'));\n        }\n      }\n    } else\n    {\n      // Import - doesn't use db state\n      setImportingModal(true);\n      if (!(fileList[0].originFileObj instanceof File)) {\n        return;\n      }\n      const dbId = await importResource(fileList[0].originFileObj, passwords, sshTunnelPasswords, sshTunnelPrivateKeys, sshTunnelPrivateKeyPasswords, confirmedOverwrite);\n      if (dbId) {\n        if (onDatabaseAdd)\n        onDatabaseAdd();\n        onClose();\n        addSuccessToast(t('Database connected'));\n      }\n    }\n    setShowCTAbtns(true);\n    setEditNewDb(false);\n    setLoading(false);\n  };\n  // Initialize\n  const fetchDB = () => {\n    if (isEditMode && databaseId) {\n      if (!dbLoading) {\n        fetchResource(databaseId).catch((e) => addDangerToast(t('Sorry there was an error fetching database information: %s', e.message)));\n      }\n    }\n  };\n  const setDatabaseModel = (database_name) => {\n    if (database_name === 'Other') {\n      // Allow users to connect to DB via legacy SQLA form\n      setDB({\n        type: ActionType.DbSelected,\n        payload: {\n          database_name,\n          configuration_method: ConfigurationMethod.SqlalchemyUri,\n          engine: undefined,\n          engine_information: {\n            supports_file_upload: true\n          }\n        }\n      });\n    } else\n    {\n      const selectedDbModel = availableDbs == null ? void 0 : availableDbs.databases.filter((db) => db.name === database_name)[0];\n      const { engine, parameters, engine_information, default_driver, sqlalchemy_uri_placeholder } = selectedDbModel;\n      const isDynamic = parameters !== undefined;\n      setDB({\n        type: ActionType.DbSelected,\n        payload: {\n          database_name,\n          engine,\n          configuration_method: isDynamic ?\n          ConfigurationMethod.DynamicForm :\n          ConfigurationMethod.SqlalchemyUri,\n          engine_information,\n          driver: default_driver,\n          sqlalchemy_uri_placeholder\n        }\n      });\n      if (engine === Engines.GSheet) {\n        // only create a catalog if the DB is Google Sheets\n        setDB({ type: ActionType.AddTableCatalogSheet });\n      }\n    }\n  };\n  const renderAvailableSelector = () => {var _ref, _connectionAlert$ADD_;return _jsxs(\"div\", { className: \"available\", children: [\n      _jsx(\"h4\", { className: \"available-label\", children:\n        t('Or choose from a list of other databases we support:') }\n      ),\n      _jsx(\"div\", { className: \"control-label\", children: t('Supported databases') }),\n      _jsxs(AntdSelect, { className: \"available-select\", onChange: setDatabaseModel, placeholder: t('Choose a database...'), showSearch: true, children: [(_ref =\n        [...((availableDbs == null ? void 0 : availableDbs.databases) || [])]) == null ? void 0 : _ref.\n        sort((a, b) => a.name.localeCompare(b.name)).\n        map((database, index) => _jsx(AntdSelect.Option, { value: database.name, children:\n          database.name }, `database-${index}`\n        )),\n\n        _jsx(AntdSelect.Option, { value: \"Other\", children:\n          t('Other') }, \"Other\"\n        )] }\n      ),\n      _jsx(Alert, { showIcon: true, closable: false, css: (theme) => antDAlertStyles(theme), type: \"info\", message: (connectionAlert == null ? void 0 : (_connectionAlert$ADD_ = connectionAlert.ADD_DATABASE) == null ? void 0 : _connectionAlert$ADD_.message) ||\n        t('Want to add a new database?'), description: connectionAlert != null && connectionAlert.ADD_DATABASE ? _jsxs(_Fragment, { children: [\n          t('Any databases that allow connections via SQL Alchemy URIs can be added. '),\n          _jsx(\"a\", { href: connectionAlert == null ? void 0 : connectionAlert.ADD_DATABASE.contact_link, target: \"_blank\", rel: \"noopener noreferrer\", children:\n            connectionAlert == null ? void 0 : connectionAlert.ADD_DATABASE.contact_description_link }\n          ), ' ',\n          connectionAlert == null ? void 0 : connectionAlert.ADD_DATABASE.description] }\n        ) : _jsxs(_Fragment, { children: [\n          t('Any databases that allow connections via SQL Alchemy URIs can be added. Learn about how to connect a database driver '),\n          _jsx(\"a\", { href: DOCUMENTATION_LINK, target: \"_blank\", rel: \"noopener noreferrer\", children:\n            t('here') }\n          ), \".\"] }\n\n        ) })] }\n    );};\n  const renderPreferredSelector = () => {var _availableDbs$databas5;return _jsx(\"div\", { className: \"preferred\", children:\n      availableDbs == null ? void 0 : (_availableDbs$databas5 = availableDbs.databases) == null ? void 0 : _availableDbs$databas5.\n      filter((db) => db.preferred).\n      map((database) => _jsx(IconButton, { className: \"preferred-item\", onClick: () => setDatabaseModel(database.name), buttonText: database.name, icon: dbImages == null ? void 0 : dbImages[database.engine] }, `${database.name}`)) }\n    );};\n  const handleBackButtonOnFinish = () => {\n    if (dbFetched) {\n      fetchResource(dbFetched.id);\n    }\n    setShowCTAbtns(false);\n    setEditNewDb(true);\n  };\n  const handleBackButtonOnConnect = () => {\n    if (editNewDb)\n    setHasConnectedDb(false);\n    if (importingModal)\n    setImportingModal(false);\n    if (importErrored) {\n      setImportingModal(false);\n      setImportingErrorMessage('');\n      setPasswordFields([]);\n      setSSHTunnelPasswordFields([]);\n      setSSHTunnelPrivateKeyFields([]);\n      setSSHTunnelPrivateKeyPasswordFields([]);\n      setPasswords({});\n      setSSHTunnelPasswords({});\n      setSSHTunnelPrivateKeys({});\n      setSSHTunnelPrivateKeyPasswords({});\n    }\n    setDB({ type: ActionType.Reset });\n    setFileList([]);\n  };\n  const handleDisableOnImport = () => {\n    if (importLoading ||\n    alreadyExists.length && !confirmedOverwrite ||\n    passwordsNeeded.length && JSON.stringify(passwords) === '{}' ||\n    sshPasswordNeeded.length &&\n    JSON.stringify(sshTunnelPasswords) === '{}' ||\n    sshPrivateKeyNeeded.length &&\n    JSON.stringify(sshTunnelPrivateKeys) === '{}' ||\n    sshPrivateKeyPasswordNeeded.length &&\n    JSON.stringify(sshTunnelPrivateKeyPasswords) === '{}')\n    return true;\n    return false;\n  };\n  const renderModalFooter = () => {\n    if (db) {\n      // if db show back + connect\n      if (!hasConnectedDb || editNewDb) {\n        return _jsxs(_Fragment, { children: [\n          _jsx(StyledFooterButton, { onClick: handleBackButtonOnConnect, children:\n            t('Back') }, \"back\"\n          ),\n          _jsx(StyledFooterButton, { buttonStyle: \"primary\", onClick: onSave, loading: isLoading, children:\n            t('Connect') }, \"submit\"\n          )] }\n        );\n      }\n      return _jsxs(_Fragment, { children: [\n        _jsx(StyledFooterButton, { onClick: handleBackButtonOnFinish, children:\n          t('Back') }, \"back\"\n        ),\n        _jsx(StyledFooterButton, { buttonStyle: \"primary\", onClick: onSave, loading: isLoading, children:\n          t('Finish') }, \"submit\"\n        )] }\n      );\n    }\n    // Import doesn't use db state, so footer will not render in the if statement above\n    if (importingModal) {\n      return _jsxs(_Fragment, { children: [\n        _jsx(StyledFooterButton, { onClick: handleBackButtonOnConnect, children:\n          t('Back') }, \"back\"\n        ),\n        _jsx(StyledFooterButton, { buttonStyle: \"primary\", onClick: onSave, disabled: handleDisableOnImport(), loading: isLoading, children:\n          t('Connect') }, \"submit\"\n        )] }\n      );\n    }\n    return _jsx(_Fragment, {});\n  };\n  const renderEditModalFooter = (db) => _jsxs(_Fragment, { children: [\n    _jsx(StyledFooterButton, { onClick: onClose, children:\n      t('Close') }, \"close\"\n    ),\n    _jsx(StyledFooterButton, { buttonStyle: \"primary\", onClick: onSave, disabled: db == null ? void 0 : db.is_managed_externally, loading: isLoading, tooltip: db != null && db.is_managed_externally ?\n      t(\"This database is managed externally, and can't be edited in Superset\") :\n      '', children:\n      t('Finish') }, \"submit\"\n    )] }\n  );\n  const firstUpdate = useRef(true); // Captures first render\n  // Only runs when importing files don't need user input\n  useEffect(() => {\n    // Will not run on first render\n    if (firstUpdate.current) {\n      firstUpdate.current = false;\n      return;\n    }\n    if (!importLoading &&\n    !alreadyExists.length &&\n    !passwordsNeeded.length &&\n    !sshPasswordNeeded.length &&\n    !sshPrivateKeyNeeded.length &&\n    !sshPrivateKeyPasswordNeeded.length &&\n    !isLoading && // This prevents a double toast for non-related imports\n    !importErrored // This prevents a success toast on error\n    ) {\n      onClose();\n      addSuccessToast(t('Database connected'));\n    }\n  }, [\n  alreadyExists,\n  passwordsNeeded,\n  importLoading,\n  importErrored,\n  sshPasswordNeeded,\n  sshPrivateKeyNeeded,\n  sshPrivateKeyPasswordNeeded]\n  );\n  useEffect(() => {\n    if (show) {\n      setTabKey(DEFAULT_TAB_KEY);\n      setLoading(true);\n      getAvailableDbs();\n    }\n    if (databaseId && show) {\n      fetchDB();\n    }\n  }, [show, databaseId]);\n  useEffect(() => {\n    if (dbFetched) {\n      setDB({\n        type: ActionType.Fetched,\n        payload: dbFetched\n      });\n      // keep a copy of the name separate for display purposes\n      // because it shouldn't change when the form is updated\n      setDbName(dbFetched.database_name);\n    }\n  }, [dbFetched]);\n  useEffect(() => {\n    if (isLoading) {\n      setLoading(false);\n    }\n    if (availableDbs && dbEngine) {\n      // set model if passed into props\n      setDatabaseModel(dbEngine);\n    }\n  }, [availableDbs]);\n  // This forces the modal to scroll until the importing filename is in view\n  useEffect(() => {\n    if (importingModal) {var _document;\n      (_document = document) == null ? void 0 : _document.\n      getElementsByClassName('ant-upload-list-item-name')[0].\n      scrollIntoView();\n    }\n  }, [importingModal]);\n  useEffect(() => {\n    setPasswordFields([...passwordsNeeded]);\n  }, [passwordsNeeded]);\n  useEffect(() => {\n    setSSHTunnelPasswordFields([...sshPasswordNeeded]);\n  }, [sshPasswordNeeded]);\n  useEffect(() => {\n    setSSHTunnelPrivateKeyFields([...sshPrivateKeyNeeded]);\n  }, [sshPrivateKeyNeeded]);\n  useEffect(() => {\n    setSSHTunnelPrivateKeyPasswordFields([...sshPrivateKeyPasswordNeeded]);\n  }, [sshPrivateKeyPasswordNeeded]);\n  useEffect(() => {var _db$parameters;\n    if ((db == null ? void 0 : (_db$parameters = db.parameters) == null ? void 0 : _db$parameters.ssh) !== undefined) {\n      setUseSSHTunneling(db.parameters.ssh);\n    }\n  }, [db == null ? void 0 : (_db$parameters2 = db.parameters) == null ? void 0 : _db$parameters2.ssh]);\n  const onDbImport = async (info) => {\n    setImportingErrorMessage('');\n    setPasswordFields([]);\n    setSSHTunnelPasswordFields([]);\n    setSSHTunnelPrivateKeyFields([]);\n    setSSHTunnelPrivateKeyPasswordFields([]);\n    setPasswords({});\n    setSSHTunnelPasswords({});\n    setSSHTunnelPrivateKeys({});\n    setSSHTunnelPrivateKeyPasswords({});\n    setImportingModal(true);\n    setFileList([\n    {\n      ...info.file,\n      status: 'done'\n    }]\n    );\n    if (!(info.file.originFileObj instanceof File))\n    return;\n    const dbId = await importResource(info.file.originFileObj, passwords, sshTunnelPasswords, sshTunnelPrivateKeys, sshTunnelPrivateKeyPasswords, confirmedOverwrite);\n    if (dbId)\n    onDatabaseAdd == null ? void 0 : onDatabaseAdd();\n  };\n  const passwordNeededField = () => {\n    if (!passwordFields.length &&\n    !sshTunnelPasswordFields.length &&\n    !sshTunnelPrivateKeyFields.length &&\n    !sshTunnelPrivateKeyPasswordFields.length)\n    return null;\n    const files = [\n    ...new Set([\n    ...passwordFields,\n    ...sshTunnelPasswordFields,\n    ...sshTunnelPrivateKeyFields,\n    ...sshTunnelPrivateKeyPasswordFields]\n    )];\n\n    return files.map((database) => _jsxs(_Fragment, { children: [\n      _jsx(StyledAlertMargin, { children:\n        _jsx(Alert, { closable: false, css: (theme) => antDAlertStyles(theme), type: \"info\", showIcon: true, message: \"Database passwords\", description: t(`The passwords for the databases below are needed in order to import them. Please note that the \"Secure Extra\" and \"Certificate\" sections of the database configuration are not present in explore files and should be added manually after the import if they are needed.`) }) }\n      ),\n      (passwordFields == null ? void 0 : passwordFields.indexOf(database)) >= 0 && _jsx(ValidatedInput, { id: \"password_needed\", name: \"password_needed\", required: true, value: passwords[database], onChange: (event) => setPasswords({ ...passwords, [database]: event.target.value }), validationMethods: { onBlur: () => {} }, errorMessage: validationErrors == null ? void 0 : validationErrors.password_needed, label: t('%s PASSWORD', database.slice(10)), css: formScrollableStyles }),\n      (sshTunnelPasswordFields == null ? void 0 : sshTunnelPasswordFields.indexOf(database)) >= 0 && _jsx(ValidatedInput, { id: \"ssh_tunnel_password_needed\", name: \"ssh_tunnel_password_needed\", required: true, value: sshTunnelPasswords[database], onChange: (event) => setSSHTunnelPasswords({\n          ...sshTunnelPasswords,\n          [database]: event.target.value\n        }), validationMethods: { onBlur: () => {} }, errorMessage: validationErrors == null ? void 0 : validationErrors.ssh_tunnel_password_needed, label: t('%s SSH TUNNEL PASSWORD', database.slice(10)), css: formScrollableStyles }),\n      (sshTunnelPrivateKeyFields == null ? void 0 : sshTunnelPrivateKeyFields.indexOf(database)) >= 0 && _jsx(ValidatedInput, { id: \"ssh_tunnel_private_key_needed\", name: \"ssh_tunnel_private_key_needed\", required: true, value: sshTunnelPrivateKeys[database], onChange: (event) => setSSHTunnelPrivateKeys({\n          ...sshTunnelPrivateKeys,\n          [database]: event.target.value\n        }), validationMethods: { onBlur: () => {} }, errorMessage: validationErrors == null ? void 0 : validationErrors.ssh_tunnel_private_key_needed, label: t('%s SSH TUNNEL PRIVATE KEY', database.slice(10)), css: formScrollableStyles }),\n      (sshTunnelPrivateKeyPasswordFields == null ? void 0 : sshTunnelPrivateKeyPasswordFields.indexOf(database)) >= 0 && _jsx(ValidatedInput, { id: \"ssh_tunnel_private_key_password_needed\", name: \"ssh_tunnel_private_key_password_needed\", required: true, value: sshTunnelPrivateKeyPasswords[database], onChange: (event) => setSSHTunnelPrivateKeyPasswords({\n          ...sshTunnelPrivateKeyPasswords,\n          [database]: event.target.value\n        }), validationMethods: { onBlur: () => {} }, errorMessage: validationErrors == null ? void 0 : validationErrors.ssh_tunnel_private_key_password_needed, label: t('%s SSH TUNNEL PRIVATE KEY PASSWORD', database.slice(10)), css: formScrollableStyles })] }\n    ));\n  };\n  const importingErrorAlert = () => {\n    if (!importingErrorMessage)\n    return null;\n    return _jsx(StyledAlertMargin, { children:\n      _jsx(ErrorAlert, { errorMessage: importingErrorMessage, showDbInstallInstructions: passwordFields.length > 0 }) }\n    );\n  };\n  const confirmOverwrite = (event) => {var _event$currentTarget$, _event$currentTarget;\n    const targetValue = (_event$currentTarget$ = (_event$currentTarget = event.currentTarget) == null ? void 0 : _event$currentTarget.value) != null ? _event$currentTarget$ : '';\n    setConfirmedOverwrite(targetValue.toUpperCase() === t('OVERWRITE'));\n  };\n  const confirmOverwriteField = () => {\n    if (!alreadyExists.length)\n    return null;\n    return _jsxs(_Fragment, { children: [\n      _jsx(StyledAlertMargin, { children:\n        _jsx(Alert, { closable: false, css: (theme) => antdWarningAlertStyles(theme), type: \"warning\", showIcon: true, message: \"\", description: t('You are importing one or more databases that already exist. Overwriting might cause you to lose some of your work. Are you sure you want to overwrite?') }) }\n      ),\n      _jsx(ValidatedInput, { id: \"confirm_overwrite\", name: \"confirm_overwrite\", required: true, validationMethods: { onBlur: () => {} }, errorMessage: validationErrors == null ? void 0 : validationErrors.confirm_overwrite, label: t('Type \"%s\" to confirm', t('OVERWRITE')), onChange: confirmOverwrite, css: formScrollableStyles })] }\n    );\n  };\n  const tabChange = (key) => setTabKey(key);\n  const renderStepTwoAlert = () => {var _connectionAlert$REGI, _engineSpecificAlertM, _connectionAlert$DEFA, _engineSpecificAlertM2, _connectionAlert$DEFA2;\n    const { hostname } = window.location;\n    let ipAlert = (connectionAlert == null ? void 0 : (_connectionAlert$REGI = connectionAlert.REGIONAL_IPS) == null ? void 0 : _connectionAlert$REGI.default) || '';\n    const regionalIPs = (connectionAlert == null ? void 0 : connectionAlert.REGIONAL_IPS) || {};\n    Object.entries(regionalIPs).forEach(([ipRegion, ipRange]) => {\n      const regex = new RegExp(ipRegion);\n      if (hostname.match(regex))\n      ipAlert = ipRange;\n    });\n    return (db == null ? void 0 : db.engine) && _jsx(StyledAlertMargin, { children:\n      _jsx(Alert, { closable: false, css: (theme) => antDAlertStyles(theme), type: \"info\", showIcon: true, message: ((_engineSpecificAlertM = engineSpecificAlertMapping[db.engine]) == null ? void 0 : _engineSpecificAlertM.message) || (connectionAlert == null ? void 0 : (_connectionAlert$DEFA = connectionAlert.DEFAULT) == null ? void 0 : _connectionAlert$DEFA.message), description: ((_engineSpecificAlertM2 = engineSpecificAlertMapping[db.engine]) == null ? void 0 : _engineSpecificAlertM2.description) || (connectionAlert == null ? void 0 : (_connectionAlert$DEFA2 = connectionAlert.DEFAULT) == null ? void 0 : _connectionAlert$DEFA2.description) + ipAlert }) }\n    );\n  };\n  // eslint-disable-next-line consistent-return\n  const errorAlert = () => {\n    let alertErrors = [];\n    if (!_isEmpty(dbErrors)) {\n      alertErrors =\n      typeof dbErrors === 'object' ?\n      Object.values(dbErrors) :\n      typeof dbErrors === 'string' ?\n      [dbErrors] :\n      [];\n    } else\n    if (!_isEmpty(validationErrors) &&\n    (validationErrors == null ? void 0 : validationErrors.error_type) === 'GENERIC_DB_ENGINE_ERROR') {\n      alertErrors = [\n      (validationErrors == null ? void 0 : validationErrors.description) || (validationErrors == null ? void 0 : validationErrors.message)];\n\n    }\n    if (alertErrors.length) {var _alertErrors;\n      return _jsx(ErrorAlertContainer, { children:\n        _jsx(ErrorMessageWithStackTrace, { title: t('Database Creation Error'), description: t('We are unable to connect to your database. Click \"See more\" for database-provided information that may help troubleshoot the issue.'), descriptionDetails: ((_alertErrors = alertErrors) == null ? void 0 : _alertErrors[0]) || (validationErrors == null ? void 0 : validationErrors.description) }) }\n      );\n    }\n    return _jsx(_Fragment, {});\n  };\n  const fetchAndSetDB = () => {\n    setLoading(true);\n    fetchResource(dbFetched == null ? void 0 : dbFetched.id).then((r) => {\n      setItem(LocalStorageKeys.Database, r);\n    });\n  };\n  const renderSSHTunnelForm = () => _jsx(SSHTunnelForm, { db: db, onSSHTunnelParametersChange: ({ target }) => {\n      onChange(ActionType.ParametersSSHTunnelChange, {\n        type: target.type,\n        name: target.name,\n        value: target.value\n      });\n      handleClearValidationErrors();\n    }, setSSHTunnelLoginMethod: (method) => setDB({\n      type: ActionType.SetSSHTunnelLoginMethod,\n      payload: { login_method: method }\n    }) });\n  const renderCTABtns = () => _jsxs(StyledBtns, { children: [\n    _jsx(Button, { buttonStyle: \"secondary\", onClick: () => {\n        setLoading(true);\n        fetchAndSetDB();\n        redirectURL('/dataset/add/');\n      }, children:\n      t('CREATE DATASET') }\n    ),\n    _jsx(Button, { buttonStyle: \"secondary\", onClick: () => {\n        setLoading(true);\n        fetchAndSetDB();\n        redirectURL(`/sqllab?db=true`);\n      }, children:\n      t('QUERY DATA IN SQL LAB') }\n    )] }\n  );\n  const renderDatabaseConnectionForm = () => _jsxs(_Fragment, { children: [\n    _jsx(DatabaseConnectionForm, { isEditMode: isEditMode, db: db, sslForced: false, dbModel: dbModel, onAddTableCatalog: () => {\n        setDB({ type: ActionType.AddTableCatalogSheet });\n      }, onQueryChange: ({ target }) => onChange(ActionType.QueryChange, {\n        name: target.name,\n        value: target.value\n      }), onExtraInputChange: ({ target }) => onChange(ActionType.ExtraInputChange, {\n        name: target.name,\n        value: target.value\n      }), onEncryptedExtraInputChange: ({ target }) => onChange(ActionType.EncryptedExtraInputChange, {\n        name: target.name,\n        value: target.value\n      }), onRemoveTableCatalog: (idx) => {\n        setDB({\n          type: ActionType.RemoveTableCatalogSheet,\n          payload: { indexToDelete: idx }\n        });\n      }, onParametersChange: handleParametersChange, onChange: ({ target }) => onChange(ActionType.TextChange, {\n        name: target.name,\n        value: target.value\n      }), getValidation: () => getValidation(db), validationErrors: validationErrors, getPlaceholder: getPlaceholder, clearValidationErrors: handleClearValidationErrors }),\n    useSSHTunneling && _jsx(SSHTunnelContainer, { children: renderSSHTunnelForm() })] }\n  );\n  const renderFinishState = () => {\n    if (!editNewDb) {\n      return _jsx(ExtraOptions, { extraExtension: dbConfigExtraExtension, db: db, onInputChange: ({ target }) => onChange(ActionType.InputChange, {\n          type: target.type,\n          name: target.name,\n          checked: target.checked,\n          value: target.value\n        }), onTextChange: ({ target }) => onChange(ActionType.TextChange, {\n          name: target.name,\n          value: target.value\n        }), onEditorChange: (payload) => onChange(ActionType.EditorChange, payload), onExtraInputChange: ({ target }) => {\n          onChange(ActionType.ExtraInputChange, {\n            type: target.type,\n            name: target.name,\n            checked: target.checked,\n            value: target.value\n          });\n        }, onExtraEditorChange: (payload) => onChange(ActionType.ExtraEditorChange, payload) });\n    }\n    return renderDatabaseConnectionForm();\n  };\n  if (fileList.length > 0 && (\n  alreadyExists.length ||\n  passwordFields.length ||\n  sshTunnelPasswordFields.length ||\n  sshTunnelPrivateKeyFields.length ||\n  sshTunnelPrivateKeyPasswordFields.length)) {\n    return _jsxs(Modal, { centered: true, css: (theme) => [\n      antDModalNoPaddingStyles,\n      antDModalStyles(theme),\n      formHelperStyles(theme),\n      formStyles(theme)],\n      footer: renderModalFooter(), maskClosable: false, name: \"database\", onHide: onClose, onHandledPrimaryAction: onSave, primaryButtonName: t('Connect'), show: show, title: _jsx(\"h4\", { children: t('Connect a database') }), width: \"500px\", children: [\n      _jsx(ModalHeader, { db: db, dbName: dbName, dbModel: dbModel, fileList: fileList, hasConnectedDb: hasConnectedDb, isEditMode: isEditMode, isLoading: isLoading, useSqlAlchemyForm: useSqlAlchemyForm }),\n      confirmOverwriteField(),\n      importingErrorAlert(),\n      passwordNeededField()] }\n    );\n  }\n  const modalFooter = isEditMode ?\n  renderEditModalFooter(db) :\n  renderModalFooter();\n  return useTabLayout ? _jsxs(Modal, { css: (theme) => [\n    antDTabsStyles,\n    antDModalNoPaddingStyles,\n    antDModalStyles(theme),\n    formHelperStyles(theme),\n    formStyles(theme)],\n    name: \"database\", onHandledPrimaryAction: onSave, onHide: onClose, primaryButtonName: isEditMode ? t('Save') : t('Connect'), width: \"500px\", centered: true, show: show, title: _jsxs(\"h4\", { children: [\n      isEditMode ? _jsx(Icons.EditOutlined, { iconSize: \"l\", css: css`\n                margin: auto ${theme.gridUnit * 2}px auto 0;\n              ` }) : _jsx(Icons.InsertRowAboveOutlined, { iconSize: \"l\", css: css`\n                margin: auto ${theme.gridUnit * 2}px auto 0;\n              ` }),\n      isEditMode ? t('Edit database') : t('Connect a database')] }\n    ), footer: modalFooter, maskClosable: false, children: [\n    _jsx(StyledStickyHeader, { children:\n      _jsx(TabHeader, { children:\n        _jsx(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel }) }\n      ) }\n    ),\n    _jsxs(TabsStyled, { defaultActiveKey: DEFAULT_TAB_KEY, activeKey: tabKey, onTabClick: tabChange, animated: { inkBar: true, tabPane: true }, children: [\n      _jsxs(Tabs.TabPane, { tab: _jsx(\"span\", { children: t('Basic') }), children: [\n        useSqlAlchemyForm ? _jsxs(StyledAlignment, { children: [\n          _jsxs(SqlAlchemyForm, { db: db, onInputChange: ({ target }) => onChange(ActionType.InputChange, {\n              type: target.type,\n              name: target.name,\n              checked: target.checked,\n              value: target.value\n            }), conf: conf, testConnection: testConnection, testInProgress: testInProgress, children: [\n            _jsx(SSHTunnelSwitchComponent, { dbModel: dbModel, db: db, changeMethods: {\n                onParametersChange: handleParametersChange\n              }, clearValidationErrors: handleClearValidationErrors }),\n            useSSHTunneling && renderSSHTunnelForm()] }\n          ),\n          isDynamic((db == null ? void 0 : db.backend) || (db == null ? void 0 : db.engine)) && !isEditMode && _jsxs(\"div\", { css: (theme) => infoTooltip(theme), children: [\n            _jsx(Button, { buttonStyle: \"link\", onClick: () => setDB({\n                type: ActionType.ConfigMethodChange,\n                payload: {\n                  database_name: db == null ? void 0 : db.database_name,\n                  configuration_method: ConfigurationMethod.DynamicForm,\n                  engine: db == null ? void 0 : db.engine\n                }\n              }), css: (theme) => alchemyButtonLinkStyles(theme), children:\n              t('Connect this database using the dynamic form instead') }\n            ),\n            _jsx(InfoTooltip, { tooltip: t('Click this link to switch to an alternate form that exposes only the required fields needed to connect this database.'), viewBox: \"0 -6 24 24\" })] }\n          )] }\n        ) : renderDatabaseConnectionForm(),\n        !isEditMode && _jsx(StyledAlertMargin, { children:\n          _jsx(Alert, { closable: false, css: (theme) => antDAlertStyles(theme), message: t('Additional fields may be required'), showIcon: true, description: _jsxs(_Fragment, { children: [\n              t('Select databases require additional fields to be completed in the Advanced tab to successfully connect the database. Learn what requirements your databases has '),\n              _jsx(\"a\", { href: DOCUMENTATION_LINK, target: \"_blank\", rel: \"noopener noreferrer\", className: \"additional-fields-alert-description\", children:\n                t('here') }\n              ), \".\"] }\n\n            ), type: \"info\" }) }\n        ),\n        showDBError && errorAlert()] }, \"1\"\n      ),\n      _jsx(Tabs.TabPane, { tab: _jsx(\"span\", { children: t('Advanced') }), children:\n        _jsx(ExtraOptions, { extraExtension: dbConfigExtraExtension, db: db, onInputChange: ({ target }) => onChange(ActionType.InputChange, {\n            type: target.type,\n            name: target.name,\n            checked: target.checked,\n            value: target.value\n          }), onTextChange: ({ target }) => onChange(ActionType.TextChange, {\n            name: target.name,\n            value: target.value\n          }), onEditorChange: (payload) => onChange(ActionType.EditorChange, payload), onExtraInputChange: ({ target }) => {\n            onChange(ActionType.ExtraInputChange, {\n              type: target.type,\n              name: target.name,\n              checked: target.checked,\n              value: target.value\n            });\n          }, onExtraEditorChange: (payload) => {\n            onChange(ActionType.ExtraEditorChange, payload);\n          } }) }, \"2\"\n      )] }\n    )] }\n  ) : _jsxs(Modal, { css: (theme) => [\n    antDModalNoPaddingStyles,\n    antDModalStyles(theme),\n    formHelperStyles(theme),\n    formStyles(theme)],\n    name: \"database\", onHandledPrimaryAction: onSave, onHide: onClose, primaryButtonName: hasConnectedDb ? t('Finish') : t('Connect'), width: \"500px\", centered: true, show: show, title: _jsxs(\"h4\", { children: [\n      _jsx(Icons.InsertRowAboveOutlined, { iconSize: \"l\", css: css`\n              margin: auto ${theme.gridUnit * 2}px auto 0;\n            ` }),\n      t('Connect a database')] }\n    ), footer: renderModalFooter(), maskClosable: false, children: [\n    !isLoading && hasConnectedDb ? _jsxs(_Fragment, { children: [\n      _jsx(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel, editNewDb: editNewDb }),\n      showCTAbtns && renderCTABtns(),\n      renderFinishState()] }\n    ) : _jsx(_Fragment, { children:\n\n      !isLoading && (\n      !db ? _jsxs(SelectDatabaseStyles, { children: [\n        _jsx(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel }),\n        renderPreferredSelector(),\n        renderAvailableSelector(),\n        _jsx(StyledUploadWrapper, { children:\n          _jsx(Upload, { name: \"databaseFile\", id: \"databaseFile\", accept: \".yaml,.json,.yml,.zip\", customRequest: () => {}, onChange: onDbImport, onRemove: removeFile, children:\n            _jsx(Button, { buttonStyle: \"link\", type: \"link\", css: importDbButtonLinkStyles, children:\n              t('Import database from file') }\n            ) }\n          ) }\n        ),\n        importingErrorAlert()] }\n      ) : _jsxs(_Fragment, { children: [\n        _jsx(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel }),\n        hasAlert && renderStepTwoAlert(),\n        renderDatabaseConnectionForm(),\n        _jsx(\"div\", { css: (theme) => infoTooltip(theme), children:\n          dbModel.engine !== Engines.GSheet && _jsxs(_Fragment, { children: [\n            _jsx(Button, { buttonStyle: \"link\", onClick: () => setDB({\n                type: ActionType.ConfigMethodChange,\n                payload: {\n                  engine: db.engine,\n                  configuration_method: ConfigurationMethod.SqlalchemyUri,\n                  database_name: db.database_name\n                }\n              }), css: buttonLinkStyles, children:\n              t('Connect this database with a SQLAlchemy URI string instead') }\n            ),\n            _jsx(InfoTooltip, { tooltip: t('Click this link to switch to an alternate form that allows you to input the SQLAlchemy URL for this database manually.'), viewBox: \"0 -6 24 24\" })] }\n          ) }\n        ),\n\n        showDBError && errorAlert()] }\n      )) }\n    ),\n    isLoading && _jsx(Loading, {})] }\n  );\n};\nexport default withToasts(DatabaseModal);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}