{"ast":null,"code":"import _intersection from \"lodash/intersection\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { logging, styled, SupersetClient, getClientErrorObject, t, lruCache } from '@superset-ui/core';\n\nimport rison from 'rison';\nimport SupersetText from 'src/utils/textUtils';\nimport { findPermission } from 'src/utils/findPermission';\nimport { WelcomeTable } from 'src/features/home/types';\nimport { TableTab } from './types';\n// Modifies the rison encoding slightly to match the backend's rison encoding/decoding. Applies globally.\n// Code pulled from rison.js (https://github.com/Nanonid/rison), rison is licensed under the MIT license.\n(() => {\n  const risonRef = rison;\n  const l = [];\n  for (let hi = 0; hi < 16; hi += 1) {\n    for (let lo = 0; lo < 16; lo += 1) {\n      if (hi + lo === 0)\n      continue;\n      const c = String.fromCharCode(hi * 16 + lo);\n      if (!/\\w|[-_./~]/.test(c))\n      l.push(`\\\\u00${hi.toString(16)}${lo.toString(16)}`);\n    }\n  }\n  risonRef.not_idchar = l.join('');\n  risonRef.not_idstart = '-0123456789';\n  const idrx = `[^${risonRef.not_idstart}${risonRef.not_idchar}][^${risonRef.not_idchar}]*`;\n  risonRef.id_ok = new RegExp(`^${idrx}$`);\n  risonRef.next_id = new RegExp(idrx, 'g');\n})();\nexport const Actions = styled.div`\n  color: ${({ theme }) => theme.colors.grayscale.base};\n`;\nconst createFetchResourceMethod = (method) => (resource, relation, handleError, user) => async (filterValue = '', page, pageSize) => {var _json$result;\n  const resourceEndpoint = `/api/v1/${resource}/${method}/${relation}`;\n  const queryParams = rison.encode_uri({\n    filter: filterValue,\n    page,\n    page_size: pageSize\n  });\n  const { json = {} } = await SupersetClient.get({\n    endpoint: `${resourceEndpoint}?q=${queryParams}`\n  });\n  let fetchedLoggedUser = false;\n  const loggedUser = user ?\n  {\n    label: `${user.firstName} ${user.lastName}`,\n    value: user.userId\n  } :\n  undefined;\n  const data = [];\n  json == null ? void 0 : (_json$result = json.result) == null ? void 0 : _json$result.\n  filter(({ text }) => text.trim().length > 0).\n  forEach(({ text, value }) => {\n    if (loggedUser &&\n    value === loggedUser.value &&\n    text === loggedUser.label) {\n      fetchedLoggedUser = true;\n    } else\n    {\n      data.push({\n        label: text,\n        value\n      });\n    }\n  });\n  if (loggedUser && (!filterValue || fetchedLoggedUser)) {\n    data.unshift(loggedUser);\n  }\n  return {\n    data,\n    totalCount: json == null ? void 0 : json.count\n  };\n};\nexport const PAGE_SIZE = 5;\nconst getParams = (filters, selectColumns) => {\n  const params = {\n    order_column: 'changed_on_delta_humanized',\n    order_direction: 'desc',\n    page: 0,\n    page_size: PAGE_SIZE,\n    filters,\n    select_columns: selectColumns\n  };\n  if (!filters)\n  delete params.filters;\n  if (!selectColumns)\n  delete params.select_columns;\n  return rison.encode(params);\n};\nexport const getEditedObjects = (userId) => {\n  const filters = {\n    edited: [\n    {\n      col: 'changed_by',\n      opr: 'rel_o_m',\n      value: `${userId}`\n    }]\n\n  };\n  const batch = [\n  SupersetClient.get({\n    endpoint: `/api/v1/dashboard/?q=${getParams(filters.edited)}`\n  }),\n  SupersetClient.get({\n    endpoint: `/api/v1/chart/?q=${getParams(filters.edited)}`\n  })];\n\n  return Promise.all(batch).\n  then(([editedCharts, editedDashboards]) => {var _editedDashboards$jso, _editedCharts$json;\n    const res = {\n      editedDash: (_editedDashboards$jso = editedDashboards.json) == null ? void 0 : _editedDashboards$jso.result.slice(0, 3),\n      editedChart: (_editedCharts$json = editedCharts.json) == null ? void 0 : _editedCharts$json.result.slice(0, 3)\n    };\n    return res;\n  }).\n  catch((err) => err);\n};\nexport const getUserOwnedObjects = (userId, resource, filters = [\n{\n  col: 'owners',\n  opr: 'rel_m_m',\n  value: `${userId}`\n}],\nselectColumns) => SupersetClient.get({\n  endpoint: `/api/v1/${resource}/?q=${getParams(filters, selectColumns)}`\n}).then((res) => {var _res$json;return (_res$json = res.json) == null ? void 0 : _res$json.result;});\nexport const getFilteredChartsandDashboards = (addDangerToast, filters, dashboardSelectColumns, chartSelectColumns) => {\n  const newBatch = [\n  SupersetClient.get({\n    endpoint: `/api/v1/chart/?q=${getParams(filters, chartSelectColumns)}`\n  }),\n  SupersetClient.get({\n    endpoint: `/api/v1/dashboard/?q=${getParams(filters, dashboardSelectColumns)}`\n  })];\n\n  return Promise.all(newBatch).\n  then(([chartRes, dashboardRes]) => ({\n    other: [...chartRes.json.result, ...dashboardRes.json.result]\n  })).\n  catch((errMsg) => {\n    addDangerToast(t('There was an error fetching the filtered charts and dashboards:'), errMsg);\n    return { other: [] };\n  });\n};\nexport const getRecentActivityObjs = (userId, recent, addDangerToast, filters) => SupersetClient.get({ endpoint: recent }).then((recentsRes) => {\n  const res = {};\n  const distinctRes = lruCache(6);\n  recentsRes.json.result.reverse().forEach((record) => {\n    distinctRes.set(record.item_url, record);\n  });\n  return getFilteredChartsandDashboards(addDangerToast, filters).then(({ other }) => {\n    res.other = other;\n    res.viewed = distinctRes.values().reverse();\n    return res;\n  });\n});\nexport const createFetchRelated = createFetchResourceMethod('related');\nexport const createFetchDistinct = createFetchResourceMethod('distinct');\nexport function createErrorHandler(handleErrorFunc) {\n  return async (e) => {\n    const parsedError = await getClientErrorObject(e);\n    // Taking the first error returned from the API\n    // @ts-ignore\n    const errorsArray = parsedError == null ? void 0 : parsedError.errors;\n    const config = await SupersetText;\n    if (errorsArray != null && errorsArray.length &&\n    config != null && config.ERRORS &&\n    errorsArray[0].error_type in config.ERRORS) {\n      parsedError.message = config.ERRORS[errorsArray[0].error_type];\n    }\n    logging.error(e);\n    handleErrorFunc(parsedError.message || parsedError.error);\n  };\n}\nexport function handleChartDelete({ id, slice_name: sliceName }, addSuccessToast, addDangerToast, refreshData, chartFilter, userId) {\n  const filters = {\n    pageIndex: 0,\n    pageSize: PAGE_SIZE,\n    sortBy: [\n    {\n      id: 'changed_on_delta_humanized',\n      desc: true\n    }],\n\n    filters: [\n    {\n      id: 'created_by',\n      operator: 'rel_o_m',\n      value: `${userId}`\n    }]\n\n  };\n  SupersetClient.delete({\n    endpoint: `/api/v1/chart/${id}`\n  }).then(() => {\n    if (chartFilter === 'Mine')\n    refreshData(filters);else\n\n    refreshData();\n    addSuccessToast(t('Deleted: %s', sliceName));\n  }, () => {\n    addDangerToast(t('There was an issue deleting: %s', sliceName));\n  });\n}\nexport function handleDashboardDelete({ id, dashboard_title: dashboardTitle }, refreshData, addSuccessToast, addDangerToast, dashboardFilter, userId) {\n  return SupersetClient.delete({\n    endpoint: `/api/v1/dashboard/${id}`\n  }).then(() => {\n    const filters = {\n      pageIndex: 0,\n      pageSize: PAGE_SIZE,\n      sortBy: [\n      {\n        id: 'changed_on_delta_humanized',\n        desc: true\n      }],\n\n      filters: [\n      {\n        id: 'owners',\n        operator: 'rel_m_m',\n        value: `${userId}`\n      }]\n\n    };\n    if (dashboardFilter === 'Mine')\n    refreshData(filters);else\n\n    refreshData();\n    addSuccessToast(t('Deleted: %s', dashboardTitle));\n  }, createErrorHandler((errMsg) => addDangerToast(t('There was an issue deleting %s: %s', dashboardTitle, errMsg))));\n}\nexport function shortenSQL(sql, maxLines) {\n  let lines = sql.split('\\n');\n  if (lines.length >= maxLines) {\n    lines = lines.slice(0, maxLines);\n    lines.push('...');\n  }\n  return lines.join('\\n');\n}\n// loading card count for homepage\nexport const loadingCardCount = 5;\nconst breakpoints = [576, 768, 992, 1200];\nexport const mq = breakpoints.map((bp) => `@media (max-width: ${bp}px)`);\nexport const CardContainer = styled.div`\n  ${({ showThumbnails, theme }) => `\n    overflow: hidden;\n    display: grid;\n    grid-gap: ${theme.gridUnit * 12}px ${theme.gridUnit * 4}px;\n    grid-template-columns: repeat(auto-fit, 300px);\n    max-height: ${showThumbnails ? '314' : '148'}px;\n    margin-top: ${theme.gridUnit * -6}px;\n    padding: ${showThumbnails ?\n`${theme.gridUnit * 8 + 3}px ${theme.gridUnit * 9}px` :\n`${theme.gridUnit * 8 + 1}px ${theme.gridUnit * 9}px`};\n  `}\n`;\nexport const CardStyles = styled.div`\n  cursor: pointer;\n  a {\n    text-decoration: none;\n  }\n  .antd5-card-cover > div {\n    /* Height is calculated based on 300px width, to keep the same aspect ratio as the 800*450 thumbnails */\n    height: 168px;\n  }\n`;\nexport /* eslint-disable no-underscore-dangle */const isNeedsPassword = (payload) => {var _payload$_schema;return typeof payload === 'object' &&\n  Array.isArray(payload._schema) &&\n  !!((_payload$_schema = payload._schema) != null && _payload$_schema.find((e) => e === 'Must provide a password for the database'));};\nexport /* eslint-disable no-underscore-dangle */const isNeedsSSHPassword = (payload) => {var _payload$_schema2;return typeof payload === 'object' &&\n  Array.isArray(payload._schema) &&\n  !!((_payload$_schema2 = payload._schema) != null && _payload$_schema2.find((e) => e === 'Must provide a password for the ssh tunnel'));};\nexport /* eslint-disable no-underscore-dangle */const isNeedsSSHPrivateKey = (payload) => {var _payload$_schema3;return typeof payload === 'object' &&\n  Array.isArray(payload._schema) &&\n  !!((_payload$_schema3 = payload._schema) != null && _payload$_schema3.find((e) => e === 'Must provide a private key for the ssh tunnel'));};\nexport /* eslint-disable no-underscore-dangle */const isNeedsSSHPrivateKeyPassword = (payload) => {var _payload$_schema4;return typeof payload === 'object' &&\n  Array.isArray(payload._schema) &&\n  !!((_payload$_schema4 = payload._schema) != null && _payload$_schema4.find((e) => e === 'Must provide a private key password for the ssh tunnel'));};\nexport const isAlreadyExists = (payload) => typeof payload === 'string' &&\npayload.includes('already exists and `overwrite=true` was not passed');\nexport const getPasswordsNeeded = (errors) => errors.\nmap((error) => Object.entries(error.extra).\nfilter(([, payload]) => isNeedsPassword(payload)).\nmap(([fileName]) => fileName)).\nflat();\nexport const getSSHPasswordsNeeded = (errors) => errors.\nmap((error) => Object.entries(error.extra).\nfilter(([, payload]) => isNeedsSSHPassword(payload)).\nmap(([fileName]) => fileName)).\nflat();\nexport const getSSHPrivateKeysNeeded = (errors) => errors.\nmap((error) => Object.entries(error.extra).\nfilter(([, payload]) => isNeedsSSHPrivateKey(payload)).\nmap(([fileName]) => fileName)).\nflat();\nexport const getSSHPrivateKeyPasswordsNeeded = (errors) => errors.\nmap((error) => Object.entries(error.extra).\nfilter(([, payload]) => isNeedsSSHPrivateKeyPassword(payload)).\nmap(([fileName]) => fileName)).\nflat();\nexport const getAlreadyExists = (errors) => errors.\nmap((error) => Object.entries(error.extra).\nfilter(([, payload]) => isAlreadyExists(payload)).\nmap(([fileName]) => fileName)).\nflat();\nexport const hasTerminalValidation = (errors) => errors.some((error) => {\n  const noIssuesCodes = Object.entries(error.extra).filter(([key]) => key !== 'issue_codes');\n  if (noIssuesCodes.length === 0)\n  return true;\n  return !noIssuesCodes.every(([, payload]) => isNeedsPassword(payload) ||\n  isAlreadyExists(payload) ||\n  isNeedsSSHPassword(payload) ||\n  isNeedsSSHPrivateKey(payload) ||\n  isNeedsSSHPrivateKeyPassword(payload));\n});\nexport const checkUploadExtensions = (perm, cons) => {\n  if (perm !== undefined) {\n    return _intersection(perm, cons).length > 0;\n  }\n  return false;\n};\nexport const uploadUserPerms = (roles, csvExt, colExt, excelExt, allowedExt) => {\n  const canUploadCSV = findPermission('can_upload', 'Database', roles) &&\n  checkUploadExtensions(csvExt, allowedExt);\n  const canUploadColumnar = checkUploadExtensions(colExt, allowedExt) &&\n  findPermission('can_upload', 'Database', roles);\n  const canUploadExcel = checkUploadExtensions(excelExt, allowedExt) &&\n  findPermission('can_upload', 'Database', roles);\n  return {\n    canUploadCSV,\n    canUploadColumnar,\n    canUploadExcel,\n    canUploadData: canUploadCSV || canUploadColumnar || canUploadExcel\n  };\n};\nexport function getFilterValues(tab, welcomeTable, user, otherTabFilters) {\n  if (tab === TableTab.Created ||\n  welcomeTable === WelcomeTable.SavedQueries && tab === TableTab.Mine) {\n    return [\n    {\n      id: 'created_by',\n      operator: 'rel_o_m',\n      value: `${user == null ? void 0 : user.userId}`\n    }];\n\n  }\n  if (welcomeTable === WelcomeTable.SavedQueries && tab === TableTab.Favorite) {\n    return [\n    {\n      id: 'id',\n      operator: 'saved_query_is_fav',\n      value: true\n    }];\n\n  }\n  if (tab === TableTab.Mine && user) {\n    return [\n    {\n      id: 'owners',\n      operator: 'rel_m_m',\n      value: `${user.userId}`\n    }];\n\n  }\n  if (tab === TableTab.Favorite &&\n  [WelcomeTable.Dashboards, WelcomeTable.Charts].includes(welcomeTable)) {\n    return [\n    {\n      id: 'id',\n      operator: welcomeTable === WelcomeTable.Dashboards ?\n      'dashboard_is_favorite' :\n      'chart_is_favorite',\n      value: true\n    }];\n\n  }\n  if (tab === TableTab.Other) {\n    return (otherTabFilters || []).map((flt) => ({\n      id: flt.col,\n      operator: flt.opr,\n      value: flt.value\n    }));\n  }\n  return [];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}