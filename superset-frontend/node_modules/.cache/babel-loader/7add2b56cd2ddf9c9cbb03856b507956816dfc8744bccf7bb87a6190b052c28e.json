{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useState, useMemo, useCallback, useEffect, memo } from 'react';\nimport cx from 'classnames';\nimport { useSelector } from 'react-redux';\nimport { css, useTheme } from '@superset-ui/core';\nimport AnchorLink from 'src/dashboard/components/AnchorLink';\nimport Chart from 'src/dashboard/components/gridComponents/Chart';\nimport DeleteComponentButton from 'src/dashboard/components/DeleteComponentButton';\nimport { Draggable } from 'src/dashboard/components/dnd/DragDroppable';\nimport HoverMenu from 'src/dashboard/components/menu/HoverMenu';\nimport ResizableContainer from 'src/dashboard/components/resizable/ResizableContainer';\nimport getChartAndLabelComponentIdFromPath from 'src/dashboard/util/getChartAndLabelComponentIdFromPath';\nimport useFilterFocusHighlightStyles from 'src/dashboard/util/useFilterFocusHighlightStyles';\nimport { COLUMN_TYPE, ROW_TYPE } from 'src/dashboard/util/componentTypes';\nimport { GRID_BASE_UNIT, GRID_GUTTER_SIZE, GRID_MIN_COLUMN_COUNT, GRID_MIN_ROW_UNITS } from 'src/dashboard/util/constants';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nexport const CHART_MARGIN = 32;\nconst ChartHolder = ({ id, parentId, component, parentComponent, index, depth, availableColumnCount, columnWidth, onResizeStart, onResize, onResizeStop, editMode, isComponentVisible, dashboardId, fullSizeChartId, getComponentById = () => undefined, deleteComponent, updateComponents, handleComponentDrop, setFullSizeChartId, isInView }) => {\n  const theme = useTheme();\n  const fullSizeStyle = css`\n    && {\n      position: fixed;\n      z-index: 3000;\n      left: 0;\n      top: 0;\n      padding: ${theme.gridUnit * 2}px;\n    }\n  `;\n  const { chartId } = component.meta;\n  const isFullSize = fullSizeChartId === chartId;\n  const focusHighlightStyles = useFilterFocusHighlightStyles(chartId);\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const directPathLastUpdated = useSelector((state) => {var _state$dashboardState;return (_state$dashboardState = state.dashboardState.directPathLastUpdated) != null ? _state$dashboardState : 0;});\n  const [extraControls, setExtraControls] = useState({});\n  const [outlinedComponentId, setOutlinedComponentId] = useState();\n  const [outlinedColumnName, setOutlinedColumnName] = useState();\n  const [currentDirectPathLastUpdated, setCurrentDirectPathLastUpdated] = useState(0);\n  const infoFromPath = useMemo(() => getChartAndLabelComponentIdFromPath(directPathToChild != null ? directPathToChild : []), [directPathToChild]);\n  // Calculate if the chart should be outlined\n  useEffect(() => {\n    const { label: columnName, chart: chartComponentId } = infoFromPath;\n    if (directPathLastUpdated !== currentDirectPathLastUpdated &&\n    component.id === chartComponentId) {\n      setCurrentDirectPathLastUpdated(directPathLastUpdated);\n      setOutlinedComponentId(component.id);\n      setOutlinedColumnName(columnName);\n    }\n  }, [\n  component,\n  currentDirectPathLastUpdated,\n  directPathLastUpdated,\n  infoFromPath]\n  );\n  // Remove the chart outline after a defined time\n  useEffect(() => {\n    let timerId;\n    if (outlinedComponentId) {\n      timerId = setTimeout(() => {\n        setOutlinedComponentId(undefined);\n        setOutlinedColumnName(undefined);\n      }, 2000);\n    }\n    return () => {\n      if (timerId) {\n        clearTimeout(timerId);\n      }\n    };\n  }, [outlinedComponentId]);\n  const widthMultiple = useMemo(() => {var _getComponentById, _getComponentById$met, _parentComponent$pare;\n    const columnParentWidth = (_getComponentById = getComponentById((_parentComponent$pare = parentComponent.parents) == null ? void 0 : _parentComponent$pare.find((parent) => parent.startsWith(COLUMN_TYPE)))) == null ? void 0 : (_getComponentById$met = _getComponentById.meta) == null ? void 0 : _getComponentById$met.width;\n    let widthMultiple = component.meta.width || GRID_MIN_COLUMN_COUNT;\n    if (parentComponent.type === COLUMN_TYPE) {\n      widthMultiple = parentComponent.meta.width || GRID_MIN_COLUMN_COUNT;\n    } else\n    if (columnParentWidth && widthMultiple > columnParentWidth) {\n      widthMultiple = columnParentWidth;\n    }\n    return widthMultiple;\n  }, [\n  component,\n  getComponentById,\n  parentComponent.meta.width,\n  parentComponent.parents,\n  parentComponent.type]\n  );\n  const { chartWidth, chartHeight } = useMemo(() => {\n    let width = 0;\n    let height = 0;\n    if (isFullSize) {\n      width = window.innerWidth - CHART_MARGIN;\n      height = window.innerHeight - CHART_MARGIN;\n    } else\n    {\n      width = Math.floor(widthMultiple * columnWidth +\n      (widthMultiple - 1) * GRID_GUTTER_SIZE -\n      CHART_MARGIN);\n      height = Math.floor(component.meta.height * GRID_BASE_UNIT - CHART_MARGIN);\n    }\n    return {\n      chartWidth: width,\n      chartHeight: height\n    };\n  }, [columnWidth, component, isFullSize, widthMultiple]);\n  const handleDeleteComponent = useCallback(() => {\n    deleteComponent(id, parentId);\n  }, [deleteComponent, id, parentId]);\n  const handleUpdateSliceName = useCallback((nextName) => {\n    updateComponents({\n      [component.id]: {\n        ...component,\n        meta: {\n          ...component.meta,\n          sliceNameOverride: nextName\n        }\n      }\n    });\n  }, [component, updateComponents]);\n  const handleToggleFullSize = useCallback(() => {\n    setFullSizeChartId(isFullSize ? null : chartId);\n  }, [chartId, isFullSize, setFullSizeChartId]);\n  const handleExtraControl = useCallback((name, value) => {\n    setExtraControls((current) => ({\n      ...current,\n      [name]: value\n    }));\n  }, []);\n  const renderChild = useCallback(({ dragSourceRef }) => _jsx(ResizableContainer, { id: component.id, adjustableWidth: parentComponent.type === ROW_TYPE, adjustableHeight: true, widthStep: columnWidth, widthMultiple: widthMultiple, heightStep: GRID_BASE_UNIT, heightMultiple: component.meta.height, minWidthMultiple: GRID_MIN_COLUMN_COUNT, minHeightMultiple: GRID_MIN_ROW_UNITS, maxWidthMultiple: availableColumnCount + widthMultiple, onResizeStart: onResizeStart, onResize: onResize, onResizeStop: onResizeStop, editMode: editMode, children:\n    _jsxs(\"div\", { ref: dragSourceRef, style: focusHighlightStyles, css: isFullSize ? fullSizeStyle : undefined, className: cx('dashboard-component', 'dashboard-component-chart-holder',\n      // The following class is added to support custom dashboard styling via the CSS editor\n      `dashboard-chart-id-${chartId}`, outlinedComponentId ? 'fade-in' : 'fade-out'), children: [\n      !editMode && _jsx(AnchorLink, { id: component.id, scrollIntoView: outlinedComponentId === component.id }),\n      !!outlinedComponentId && _jsx(\"style\", { children:\n        `label[for=${outlinedColumnName}] + .Select .Select__control {\n                    border-color: #00736a;\n                    transition: border-color 1s ease-in-out;\n                  }` }\n      ),\n      _jsx(Chart, { componentId: component.id, id: component.meta.chartId, dashboardId: dashboardId, width: chartWidth, height: chartHeight, sliceName: component.meta.sliceNameOverride || component.meta.sliceName || '', updateSliceName: handleUpdateSliceName, isComponentVisible: isComponentVisible, handleToggleFullSize: handleToggleFullSize, isFullSize: isFullSize, setControlValue: handleExtraControl, extraControls: extraControls, isInView: isInView }),\n      editMode && _jsx(HoverMenu, { position: \"top\", children:\n        _jsx(\"div\", { children:\n          _jsx(DeleteComponentButton, { onDelete: handleDeleteComponent }) }\n        ) }\n      )] }\n    ) }\n  ), [\n  component.id,\n  component.meta.height,\n  component.meta.chartId,\n  component.meta.sliceNameOverride,\n  component.meta.sliceName,\n  parentComponent.type,\n  columnWidth,\n  widthMultiple,\n  availableColumnCount,\n  onResizeStart,\n  onResize,\n  onResizeStop,\n  editMode,\n  focusHighlightStyles,\n  isFullSize,\n  fullSizeStyle,\n  chartId,\n  outlinedComponentId,\n  outlinedColumnName,\n  dashboardId,\n  chartWidth,\n  chartHeight,\n  handleUpdateSliceName,\n  isComponentVisible,\n  handleToggleFullSize,\n  handleExtraControl,\n  extraControls,\n  isInView,\n  handleDeleteComponent]\n  );\n  return _jsx(Draggable, { component: component, parentComponent: parentComponent, orientation: parentComponent.type === ROW_TYPE ? 'column' : 'row', index: index, depth: depth, onDrop: handleComponentDrop, disableDragDrop: false, editMode: editMode, children:\n    renderChild }\n  );\n};\nexport default /*#__PURE__*/memo(ChartHolder);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}