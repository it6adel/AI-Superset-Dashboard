{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { cloneElement, forwardRef, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useState, useRef } from 'react';\nimport { Global } from '@emotion/react';\nimport { css, t, useTheme, usePrevious } from '@superset-ui/core';\nimport { useResizeDetector } from 'react-resize-detector';\nimport Badge from '../Badge';\nimport Icons from '../Icons';\nimport Button from '../Button';\nimport Popover from '../Popover';\nimport { Tooltip } from '../Tooltip';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst MAX_HEIGHT = 500;\nconst DropdownContainer = /*#__PURE__*/forwardRef(({ items, onOverflowingStateChange, dropdownContent, dropdownRef, dropdownStyle = {}, dropdownTriggerCount, dropdownTriggerIcon, dropdownTriggerText = t('More'), dropdownTriggerTooltip = null, forceRender, style }, outerRef) => {\n  const theme = useTheme();\n  const { ref, width = 0 } = useResizeDetector();\n  const previousWidth = usePrevious(width) || 0;\n  const { current } = ref;\n  const [itemsWidth, setItemsWidth] = useState([]);\n  const [popoverVisible, setPopoverVisible] = useState(false);\n  // We use React.useState to be able to mock the state in Jest\n  const [overflowingIndex, setOverflowingIndex] = useState(-1);\n  let targetRef = useRef(null);\n  if (dropdownRef) {\n    targetRef = dropdownRef;\n  }\n  const [showOverflow, setShowOverflow] = useState(false);\n  const reduceItems = (items) => items.reduce(([items, ids], item) => {\n    items.push({\n      id: item.id,\n      element: /*#__PURE__*/cloneElement(item.element, { key: item.id })\n    });\n    ids.push(item.id);\n    return [items, ids];\n  }, [[], []]);\n  const [notOverflowedItems, notOverflowedIds] = useMemo(() => reduceItems(items.slice(0, overflowingIndex !== -1 ? overflowingIndex : items.length)), [items, overflowingIndex]);\n  const [overflowedItems, overflowedIds] = useMemo(() => overflowingIndex !== -1 ?\n  reduceItems(items.slice(overflowingIndex)) :\n  [[], []], [items, overflowingIndex]);\n  useLayoutEffect(() => {\n    if (popoverVisible) {\n      return;\n    }\n    const container = current == null ? void 0 : current.children.item(0);\n    if (container) {\n      const { children } = container;\n      const childrenArray = Array.from(children);\n      // If items length change, add all items to the container\n      // and recalculate the widths\n      if (itemsWidth.length !== items.length) {\n        if (childrenArray.length === items.length) {\n          setItemsWidth(childrenArray.map((child) => child.getBoundingClientRect().width));\n        } else\n        {\n          setOverflowingIndex(-1);\n          return;\n        }\n      }\n      // Calculates the index of the first overflowed element\n      // +1 is to give at least one pixel of difference and avoid flakiness\n      const index = childrenArray.findIndex((child) => child.getBoundingClientRect().right >\n      container.getBoundingClientRect().right + 1);\n      // If elements fit (-1) and there's overflowed items\n      // then preserve the overflow index. We can't use overflowIndex\n      // directly because the items may have been modified\n      let newOverflowingIndex = index === -1 && overflowedItems.length > 0 ?\n      items.length - overflowedItems.length :\n      index;\n      if (width > previousWidth) {\n        // Calculates remaining space in the container\n        const button = current == null ? void 0 : current.children.item(1);\n        const buttonRight = (button == null ? void 0 : button.getBoundingClientRect().right) || 0;\n        const containerRight = (current == null ? void 0 : current.getBoundingClientRect().right) || 0;\n        const remainingSpace = containerRight - buttonRight;\n        // Checks if some elements in the dropdown fits in the remaining space\n        let sum = 0;\n        for (let i = childrenArray.length; i < items.length; i += 1) {\n          sum += itemsWidth[i];\n          if (sum <= remainingSpace) {\n            newOverflowingIndex = i + 1;\n          } else\n          {\n            break;\n          }\n        }\n      }\n      setOverflowingIndex(newOverflowingIndex);\n    }\n  }, [\n  current,\n  items.length,\n  itemsWidth,\n  overflowedItems.length,\n  previousWidth,\n  width]\n  );\n  useEffect(() => {\n    if (onOverflowingStateChange) {\n      onOverflowingStateChange({\n        notOverflowed: notOverflowedIds,\n        overflowed: overflowedIds\n      });\n    }\n  }, [notOverflowedIds, onOverflowingStateChange, overflowedIds]);\n  const overflowingCount = overflowingIndex !== -1 ? items.length - overflowingIndex : 0;\n  const popoverContent = useMemo(() => dropdownContent || overflowingCount ? _jsx(\"div\", { css: css`\n              display: flex;\n              flex-direction: column;\n              gap: ${theme.gridUnit * 4}px;\n            `, style: dropdownStyle, ref: targetRef, children:\n    dropdownContent ?\n    dropdownContent(overflowedItems) :\n    overflowedItems.map((item) => item.element) }\n  ) : null, [\n  dropdownContent,\n  overflowingCount,\n  theme.gridUnit,\n  dropdownStyle,\n  overflowedItems]\n  );\n  useLayoutEffect(() => {\n    if (popoverVisible) {\n      // Measures scroll height after rendering the elements\n      setTimeout(() => {\n        if (targetRef.current) {\n          // We only set overflow when there's enough space to display\n          // Select's popovers because they are restrained by the overflow property.\n          setShowOverflow(targetRef.current.scrollHeight > MAX_HEIGHT);\n        }\n      }, 100);\n    }\n  }, [popoverVisible]);\n  useImperativeHandle(outerRef, () => ({\n    ...ref.current,\n    open: () => setPopoverVisible(true)\n  }), [ref]);\n  // Closes the popover when scrolling on the document\n  useEffect(() => {\n    document.onscroll = popoverVisible ?\n    () => setPopoverVisible(false) :\n    null;\n    return () => {\n      document.onscroll = null;\n    };\n  }, [popoverVisible]);\n  return _jsxs(\"div\", { ref: ref, css: css`\n          display: flex;\n          align-items: center;\n        `, children: [\n    _jsx(\"div\", { css: css`\n            display: flex;\n            align-items: center;\n            gap: ${theme.gridUnit * 4}px;\n            margin-right: ${theme.gridUnit * 4}px;\n            min-width: 0px;\n          `, style: style, children:\n      notOverflowedItems.map((item) => item.element) }\n    ),\n    popoverContent && _jsxs(_Fragment, { children: [\n      _jsx(Global, { styles: css`\n                .antd5-popover-inner {\n                  // Some OS versions only show the scroll when hovering.\n                  // These settings will make the scroll always visible.\n                  ::-webkit-scrollbar {\n                    -webkit-appearance: none;\n                    width: 14px;\n                  }\n                  ::-webkit-scrollbar-thumb {\n                    border-radius: 9px;\n                    background-color: ${theme.colors.grayscale.light1};\n                    border: 3px solid transparent;\n                    background-clip: content-box;\n                  }\n                  ::-webkit-scrollbar-track {\n                    background-color: ${theme.colors.grayscale.light4};\n                    border-left: 1px solid ${theme.colors.grayscale.light2};\n                  }\n                }\n              ` }),\n\n      _jsx(Popover, { overlayInnerStyle: {\n          maxHeight: `${MAX_HEIGHT}px`,\n          overflow: showOverflow ? 'auto' : 'visible'\n        }, content: popoverContent, trigger: \"click\", open: popoverVisible, onOpenChange: (visible) => setPopoverVisible(visible), placement: \"bottom\", forceRender: forceRender, children:\n        _jsx(Tooltip, { title: dropdownTriggerTooltip, children:\n          _jsxs(Button, { buttonStyle: \"secondary\", children: [\n            dropdownTriggerIcon,\n            dropdownTriggerText,\n            _jsx(Badge, { count: dropdownTriggerCount != null ? dropdownTriggerCount : overflowingCount, color: (dropdownTriggerCount != null ? dropdownTriggerCount : overflowingCount) > 0 ?\n              theme.colors.primary.base :\n              theme.colors.grayscale.light1, showZero: true, css: css`\n                      margin-left: ${theme.gridUnit * 2}px;\n                    ` }),\n            _jsx(Icons.DownOutlined, { iconSize: \"m\", iconColor: theme.colors.grayscale.light1, css: css`\n                      .anticon {\n                        display: flex;\n                      }\n                    ` })] }\n          ) }\n        ) }\n      )] }\n    )] }\n  );\n});\nexport default DropdownContainer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}