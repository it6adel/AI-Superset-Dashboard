{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useSelector } from 'react-redux';\nimport { isAdhocColumn, t, styled, css, DatasourceType } from '@superset-ui/core';\nimport { isSavedExpression } from '@superset-ui/chart-controls';\nimport Tabs from 'src/components/Tabs';\nimport Button from 'src/components/Button';\nimport { Select } from 'src/components';\nimport { Form, FormItem } from 'src/components/Form';\nimport sqlKeywords from 'src/SqlLab/utils/sqlKeywords';\nimport { SQLEditor } from 'src/components/AsyncAceEditor';\nimport { EmptyState } from 'src/components/EmptyState';\nimport { getColumnKeywords } from 'src/explore/controlUtils/getColumnKeywords';\nimport { StyledColumnOption } from 'src/explore/components/optionRenderers';\nimport { POPOVER_INITIAL_HEIGHT, POPOVER_INITIAL_WIDTH } from 'src/explore/constants';\nimport useResizeButton from './useResizeButton';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst StyledSelect = styled(Select)`\n  .metric-option {\n    & > svg {\n      min-width: ${({ theme }) => `${theme.gridUnit * 4}px`};\n    }\n    & > .option-label {\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n`;\nconst getInitialColumnValues = (editedColumn) => {\n  if (!editedColumn) {\n    return [undefined, undefined, undefined];\n  }\n  if (isAdhocColumn(editedColumn)) {\n    return [editedColumn, undefined, undefined];\n  }\n  if (isSavedExpression(editedColumn)) {\n    return [undefined, editedColumn, undefined];\n  }\n  return [undefined, undefined, editedColumn];\n};\nconst ColumnSelectPopover = ({ columns, editedColumn, getCurrentTab, hasCustomLabel, isTemporal, label, onChange, onClose, setDatasetModal, setLabel, disabledTabs = new Set() }) => {\n  const datasourceType = useSelector((state) => state.explore.datasource.type);\n  const [initialLabel] = useState(label);\n  const [initialAdhocColumn, initialCalculatedColumn, initialSimpleColumn] = getInitialColumnValues(editedColumn);\n  const [adhocColumn, setAdhocColumn] = useState(initialAdhocColumn);\n  const [selectedCalculatedColumn, setSelectedCalculatedColumn] = useState(initialCalculatedColumn);\n  const [selectedSimpleColumn, setSelectedSimpleColumn] = useState(initialSimpleColumn);\n  const [selectedTab, setSelectedTab] = useState(null);\n  const [resizeButton, width, height] = useResizeButton(POPOVER_INITIAL_WIDTH, POPOVER_INITIAL_HEIGHT);\n  const sqlEditorRef = useRef(null);\n  const [calculatedColumns, simpleColumns] = useMemo(() => columns == null ? void 0 : columns.reduce((acc, column) => {\n    if (column.expression) {\n      acc[0].push(column);\n    } else\n    {\n      acc[1].push(column);\n    }\n    return acc;\n  }, [[], []]), [columns]);\n  const onSqlExpressionChange = useCallback((sqlExpression) => {\n    setAdhocColumn({ label, sqlExpression, expressionType: 'SQL' });\n    setSelectedSimpleColumn(undefined);\n    setSelectedCalculatedColumn(undefined);\n  }, [label]);\n  const onCalculatedColumnChange = useCallback((selectedColumnName) => {\n    const selectedColumn = calculatedColumns.find((col) => col.column_name === selectedColumnName);\n    setSelectedCalculatedColumn(selectedColumn);\n    setSelectedSimpleColumn(undefined);\n    setAdhocColumn(undefined);\n    setLabel((selectedColumn == null ? void 0 : selectedColumn.verbose_name) || (selectedColumn == null ? void 0 : selectedColumn.column_name) || '');\n  }, [calculatedColumns, setLabel]);\n  const onSimpleColumnChange = useCallback((selectedColumnName) => {\n    const selectedColumn = simpleColumns.find((col) => col.column_name === selectedColumnName);\n    setSelectedCalculatedColumn(undefined);\n    setSelectedSimpleColumn(selectedColumn);\n    setAdhocColumn(undefined);\n    setLabel((selectedColumn == null ? void 0 : selectedColumn.verbose_name) || (selectedColumn == null ? void 0 : selectedColumn.column_name) || '');\n  }, [setLabel, simpleColumns]);\n  const defaultActiveTabKey = initialAdhocColumn ?\n  'sqlExpression' :\n  selectedCalculatedColumn ?\n  'saved' :\n  'simple';\n  useEffect(() => {\n    getCurrentTab(defaultActiveTabKey);\n    setSelectedTab(defaultActiveTabKey);\n  }, [defaultActiveTabKey, getCurrentTab, setSelectedTab]);\n  useEffect(() => {\n    /* if the adhoc column is not set (because it was never edited) but the\n     * tab is selected and the label has changed, then we need to set the\n     * adhoc column manually */\n    if (adhocColumn === undefined &&\n    selectedTab === 'sqlExpression' &&\n    hasCustomLabel) {\n      const sqlExpression = (selectedSimpleColumn == null ? void 0 : selectedSimpleColumn.column_name) || (\n      selectedCalculatedColumn == null ? void 0 : selectedCalculatedColumn.expression) ||\n      '';\n      setAdhocColumn({ label, sqlExpression, expressionType: 'SQL' });\n    }\n  }, [\n  adhocColumn,\n  defaultActiveTabKey,\n  hasCustomLabel,\n  getCurrentTab,\n  label,\n  selectedCalculatedColumn,\n  selectedSimpleColumn,\n  selectedTab]\n  );\n  const onSave = useCallback(() => {\n    if (adhocColumn && adhocColumn.label !== label) {\n      adhocColumn.label = label;\n    }\n    const selectedColumn = adhocColumn || selectedCalculatedColumn || selectedSimpleColumn;\n    if (!selectedColumn) {\n      return;\n    }\n    onChange(selectedColumn);\n    onClose();\n  }, [\n  adhocColumn,\n  label,\n  onChange,\n  onClose,\n  selectedCalculatedColumn,\n  selectedSimpleColumn]\n  );\n  const onResetStateAndClose = useCallback(() => {\n    setSelectedCalculatedColumn(initialCalculatedColumn);\n    setSelectedSimpleColumn(initialSimpleColumn);\n    setAdhocColumn(initialAdhocColumn);\n    onClose();\n  }, [\n  initialAdhocColumn,\n  initialCalculatedColumn,\n  initialSimpleColumn,\n  onClose]\n  );\n  const onTabChange = useCallback((tab) => {var _sqlEditorRef$current;\n    getCurrentTab(tab);\n    setSelectedTab(tab);\n    // @ts-ignore\n    (_sqlEditorRef$current = sqlEditorRef.current) == null ? void 0 : _sqlEditorRef$current.editor.focus();\n  }, [getCurrentTab]);\n  const onSqlEditorFocus = useCallback(() => {var _sqlEditorRef$current2;\n    // @ts-ignore\n    (_sqlEditorRef$current2 = sqlEditorRef.current) == null ? void 0 : _sqlEditorRef$current2.editor.resize();\n  }, []);\n  const setDatasetAndClose = () => {\n    if (setDatasetModal) {\n      setDatasetModal(true);\n    }\n    onClose();\n  };\n  const stateIsValid = adhocColumn || selectedCalculatedColumn || selectedSimpleColumn;\n  const hasUnsavedChanges = initialLabel !== label ||\n  (selectedCalculatedColumn == null ? void 0 : selectedCalculatedColumn.column_name) !== (\n  initialCalculatedColumn == null ? void 0 : initialCalculatedColumn.column_name) ||\n  (selectedSimpleColumn == null ? void 0 : selectedSimpleColumn.column_name) !== (initialSimpleColumn == null ? void 0 : initialSimpleColumn.column_name) ||\n  (adhocColumn == null ? void 0 : adhocColumn.sqlExpression) !== (initialAdhocColumn == null ? void 0 : initialAdhocColumn.sqlExpression);\n  const savedExpressionsLabel = t('Saved expressions');\n  const simpleColumnsLabel = t('Column');\n  const keywords = useMemo(() => sqlKeywords.concat(getColumnKeywords(columns)), [columns]);\n  return _jsxs(Form, { layout: \"vertical\", id: \"metrics-edit-popover\", children: [\n    _jsxs(Tabs, { id: \"adhoc-metric-edit-tabs\", defaultActiveKey: defaultActiveTabKey, onChange: onTabChange, className: \"adhoc-metric-edit-tabs\", allowOverflow: true, css: css`\n          height: ${height}px;\n          width: ${width}px;\n        `, children: [\n      _jsx(Tabs.TabPane, { tab: t('Saved'), disabled: disabledTabs.has('saved'), children:\n        calculatedColumns.length > 0 ? _jsx(FormItem, { label: savedExpressionsLabel, children:\n          _jsx(StyledSelect, { ariaLabel: savedExpressionsLabel, value: selectedCalculatedColumn == null ? void 0 : selectedCalculatedColumn.column_name, onChange: onCalculatedColumnChange, allowClear: true, autoFocus: !selectedCalculatedColumn, placeholder: t('%s column(s)', calculatedColumns.length), options: calculatedColumns.map((calculatedColumn) => ({\n              value: calculatedColumn.column_name,\n              label: calculatedColumn.verbose_name ||\n              calculatedColumn.column_name,\n              customLabel: _jsx(StyledColumnOption, { column: calculatedColumn, showType: true }),\n              key: calculatedColumn.column_name\n            })) }) }\n        ) : datasourceType === DatasourceType.Table ? _jsx(EmptyState, { image: \"empty.svg\", size: \"small\", title: isTemporal ?\n          t('No temporal columns found') :\n          t('No saved expressions found'), description: isTemporal ?\n          t('Add calculated temporal columns to dataset in \"Edit datasource\" modal') :\n          t('Add calculated columns to dataset in \"Edit datasource\" modal') }) : _jsx(EmptyState, { image: \"empty.svg\", size: \"small\", title: isTemporal ?\n          t('No temporal columns found') :\n          t('No saved expressions found'), description: isTemporal ? _jsxs(_Fragment, { children: [\n            _jsx(\"span\", { role: \"button\", tabIndex: 0, onClick: setDatasetAndClose, children:\n              t('Create a dataset') }\n            ), ' ',\n            t(' to mark a column as a time column')] }\n          ) : _jsxs(_Fragment, { children: [\n            _jsx(\"span\", { role: \"button\", tabIndex: 0, onClick: setDatasetAndClose, children:\n              t('Create a dataset') }\n            ), ' ',\n            t(' to add calculated columns')] }\n          ) }) }, \"saved\"\n      ),\n      _jsx(Tabs.TabPane, { tab: t('Simple'), disabled: disabledTabs.has('simple'), children:\n        isTemporal && simpleColumns.length === 0 ? _jsx(EmptyState, { image: \"empty.svg\", size: \"small\", title: t('No temporal columns found'), description: datasourceType === DatasourceType.Table ? t('Mark a column as temporal in \"Edit datasource\" modal') : _jsxs(_Fragment, { children: [\n            _jsx(\"span\", { role: \"button\", tabIndex: 0, onClick: setDatasetAndClose, children:\n              t('Create a dataset') }\n            ), ' ',\n            t(' to mark a column as a time column')] }\n          ) }) : _jsx(FormItem, { label: simpleColumnsLabel, children:\n          _jsx(Select, { ariaLabel: simpleColumnsLabel, value: selectedSimpleColumn == null ? void 0 : selectedSimpleColumn.column_name, onChange: onSimpleColumnChange, allowClear: true, autoFocus: !selectedSimpleColumn, placeholder: t('%s column(s)', simpleColumns.length), options: simpleColumns.map((simpleColumn) => ({\n              value: simpleColumn.column_name,\n              label: simpleColumn.verbose_name || simpleColumn.column_name,\n              customLabel: _jsx(StyledColumnOption, { column: simpleColumn, showType: true }),\n              key: simpleColumn.column_name\n            })) }) }\n        ) }, \"simple\"\n      ),\n\n      _jsx(Tabs.TabPane, { tab: t('Custom SQL'), disabled: disabledTabs.has('sqlExpression'), children:\n        _jsx(SQLEditor, { value: (adhocColumn == null ? void 0 : adhocColumn.sqlExpression) || (\n          selectedSimpleColumn == null ? void 0 : selectedSimpleColumn.column_name) || (\n          selectedCalculatedColumn == null ? void 0 : selectedCalculatedColumn.expression), onFocus: onSqlEditorFocus, showLoadingForImport: true, onChange: onSqlExpressionChange, width: \"100%\", height: `${height - 80}px`, showGutter: false, editorProps: { $blockScrolling: true }, enableLiveAutocompletion: true, className: \"filter-sql-editor\", wrapEnabled: true, ref: sqlEditorRef, keywords: keywords }) }, \"sqlExpression\"\n      )] }\n    ),\n    _jsxs(\"div\", { children: [\n      _jsx(Button, { buttonSize: \"small\", onClick: onResetStateAndClose, cta: true, children:\n        t('Close') }\n      ),\n      _jsx(Button, { disabled: !stateIsValid || !hasUnsavedChanges, buttonStyle: \"primary\", buttonSize: \"small\", onClick: onSave, cta: true, children:\n        t('Save') }\n      ),\n      resizeButton] }\n    )] }\n  );\n};\nexport default ColumnSelectPopover;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}