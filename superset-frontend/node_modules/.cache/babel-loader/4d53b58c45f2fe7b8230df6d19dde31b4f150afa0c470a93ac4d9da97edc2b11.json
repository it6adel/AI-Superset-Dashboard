{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { extendedDayjs } from 'src/utils/dates';\nimport { parseDttmToDate, customTimeRangeDecode, computeCustomDateTime, fetchTimeRange } from '@superset-ui/core';\nimport { DatePicker } from 'src/components/DatePicker';\nimport { useSelector } from 'react-redux';\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { DEFAULT_DATE_PATTERN, INVALID_DATE } from '@superset-ui/chart-controls';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst DAYJS_FORMAT = 'YYYY-MM-DD';\nconst isTimeRangeEqual = (left, right) => _isEqual(left, right);\nconst isStartDateEqual = (left, right) => _isEqual(left, right);\nexport default function TimeOffsetControls({ onChange, ...props }) {\n  const [startDate, setStartDate] = useState('');\n  const [formatedDate, setFormatedDate] = useState(undefined);\n  const [customStartDateInFilter, setCustomStartDateInFilter] = useState(undefined);\n  const [formatedFilterDate, setFormatedFilterDate] = useState(undefined);\n  const [savedStartDate, setSavedStartDate] = useState(null);\n  const [isDateSelected, setIsDateSelected] = useState(true);\n  const currentTimeRangeFilters = useSelector((state) => state.explore.form_data.adhoc_filters.filter((adhoc_filter) => adhoc_filter.operator === 'TEMPORAL_RANGE'), isTimeRangeEqual);\n  const currentStartDate = useSelector((state) => state.explore.form_data.start_date_offset, isStartDateEqual);\n  useEffect(() => {\n    if (savedStartDate !== currentStartDate) {\n      setSavedStartDate(currentStartDate);\n      if (currentStartDate !== INVALID_DATE) {\n        onChange(extendedDayjs(currentStartDate).format(DAYJS_FORMAT));\n        setIsDateSelected(true);\n      } else\n      {\n        setIsDateSelected(false);\n      }\n    }\n  }, [currentStartDate]);\n  const previousCustomFilter = useSelector((state) => {var _state$explore$form_d;return (_state$explore$form_d = state.explore.form_data.adhoc_custom) == null ? void 0 : _state$explore$form_d.filter((adhoc_filter) => adhoc_filter.operator === 'TEMPORAL_RANGE');}, isTimeRangeEqual);\n  // let's use useCallback to compute the custom start date\n  const customTimeRange = useCallback((date) => {\n    const customRange = customTimeRangeDecode(date);\n    if (customRange.matchedFlag) {var _customStartDate;\n      const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue } = {\n        ...customRange.customRange\n      };\n      let customStartDate = null;\n      if (sinceMode !== 'relative') {\n        if (sinceMode === 'specific') {\n          customStartDate = new Date(sinceDatetime);\n        } else\n        {\n          customStartDate = parseDttmToDate(sinceDatetime, false, true);\n        }\n      } else\n      {\n        customStartDate = computeCustomDateTime(sinceDatetime, sinceGrain, sinceGrainValue);\n      }\n      (_customStartDate = customStartDate) == null ? void 0 : _customStartDate.setHours(0, 0, 0, 0);\n      setCustomStartDateInFilter(extendedDayjs(customStartDate));\n    } else\n    {\n      setCustomStartDateInFilter(undefined);\n    }\n  }, [setCustomStartDateInFilter]);\n  useEffect(() => {\n    if (!_isEmpty(currentTimeRangeFilters)) {var _currentTimeRangeFilt, _currentTimeRangeFilt2;\n      fetchTimeRange((_currentTimeRangeFilt = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt.comparator, (_currentTimeRangeFilt2 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt2.subject).then((res) => {var _res$value;\n        const dates = res == null ? void 0 : (_res$value = res.value) == null ? void 0 : _res$value.match(DEFAULT_DATE_PATTERN);\n        const [startDate, endDate] = dates != null ? dates : [];\n        customTimeRange(`${startDate} : ${endDate}`);\n        setFormatedFilterDate(extendedDayjs(parseDttmToDate(startDate)));\n      });\n    } else\n    {\n      setCustomStartDateInFilter(undefined);\n      setFormatedFilterDate(extendedDayjs(parseDttmToDate('')));\n    }\n  }, [currentTimeRangeFilters, customTimeRange]);\n  useEffect(() => {\n    if (!savedStartDate && (previousCustomFilter || customStartDateInFilter)) {var _previousCustomFilter;\n      let date = '';\n      if (_isEmpty(previousCustomFilter)) {var _currentTimeRangeFilt3;\n        date = (_currentTimeRangeFilt3 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt3.comparator.split(' : ')[0];\n      } else\n      if (((_previousCustomFilter = previousCustomFilter[0]) == null ? void 0 : _previousCustomFilter.comparator.split(' : ')[0]) !== 'No filter') {var _previousCustomFilter2;\n        date = (_previousCustomFilter2 = previousCustomFilter[0]) == null ? void 0 : _previousCustomFilter2.comparator.split(' : ')[0];\n      }\n      if (customStartDateInFilter) {\n        setStartDate(customStartDateInFilter.toString());\n        setFormatedDate(extendedDayjs(customStartDateInFilter));\n      } else\n      if (date) {\n        setStartDate(date);\n        setFormatedDate(extendedDayjs(parseDttmToDate(date)));\n      }\n    } else\n    if (savedStartDate) {\n      if (savedStartDate !== INVALID_DATE) {\n        setStartDate(savedStartDate);\n        setFormatedDate(extendedDayjs(parseDttmToDate(savedStartDate)));\n      }\n    }\n  }, [previousCustomFilter, savedStartDate, customStartDateInFilter]);\n  useEffect(() => {\n    // When switching offsets from inherit and the previous custom is no longer valid\n    if (customStartDateInFilter) {\n      if (formatedDate && formatedDate > customStartDateInFilter) {\n        const resetDate = extendedDayjs.\n        utc(customStartDateInFilter).\n        subtract(1, 'day');\n        setStartDate(resetDate.toString());\n        setFormatedDate(resetDate);\n        onChange(extendedDayjs.utc(resetDate).format(DAYJS_FORMAT));\n        setIsDateSelected(true);\n      }\n    }\n    if (formatedDate &&\n    formatedFilterDate &&\n    formatedDate > formatedFilterDate) {\n      const resetDate = extendedDayjs.\n      utc(formatedFilterDate).\n      subtract(1, 'day');\n      setStartDate(resetDate.toString());\n      setFormatedDate(resetDate);\n      onChange(extendedDayjs.utc(resetDate).format(DAYJS_FORMAT));\n      setIsDateSelected(true);\n    }\n  }, [formatedFilterDate, formatedDate, customStartDateInFilter]);\n  const disabledDate = (current) => {\n    if (!customStartDateInFilter) {\n      return formatedFilterDate ?\n      current && current > formatedFilterDate :\n      false;\n    }\n    return current && current > extendedDayjs(customStartDateInFilter);\n  };\n  return startDate || formatedDate ? _jsxs(\"div\", { children: [\n    _jsx(ControlHeader, { ...props }),\n    _jsx(DatePicker, { onChange: (datetime) => onChange(datetime ? datetime.format(DAYJS_FORMAT) : ''), defaultPickerValue: startDate ? extendedDayjs(formatedDate).subtract(1, 'day') : undefined, disabledDate: disabledDate, defaultValue: extendedDayjs(formatedDate), value: isDateSelected ? extendedDayjs(formatedDate) : null })] }\n  ) : null;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}