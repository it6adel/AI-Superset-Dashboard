{"ast":null,"code":"import { css as _css } from \"@emotion/react\";import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useMemo, useState, useEffect, useRef } from 'react';\nimport { css, GenericDataType, getTimeFormatter, safeHtmlSpan, styled, t, TimeFormats, useTheme } from '@superset-ui/core';\n\nimport { Input } from 'src/components/Input';\nimport { BOOL_FALSE_DISPLAY, BOOL_TRUE_DISPLAY, NULL_DISPLAY, SLOW_DEBOUNCE } from 'src/constants';\nimport { Radio } from 'src/components/Radio';\nimport Icons from 'src/components/Icons';\nimport Button from 'src/components/Button';\nimport Popover from 'src/components/Popover';\nimport { prepareCopyToClipboardTabularData } from 'src/utils/common';\nimport CopyToClipboard from 'src/components/CopyToClipboard';\nimport { getTimeColumns, setTimeColumns } from './utils';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nexport const CellNull = styled('span')`\n  color: ${({ theme }) => theme.colors.grayscale.light1};\n`;\nexport const CopyButton = styled(Button)`\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n\n  // needed to override button's first-of-type margin: 0\n  && {\n    margin: 0 ${({ theme }) => theme.gridUnit * 2}px;\n  }\n\n  i {\n    padding: 0 ${({ theme }) => theme.gridUnit}px;\n  }\n`;\nexport const CopyToClipboardButton = ({ data, columns }) => _jsx(CopyToClipboard, { text: data && columns ? prepareCopyToClipboardTabularData(data, columns) : '', wrapped: false, copyNode: _jsx(Icons.CopyOutlined, { iconSize: \"l\", \"aria-label\": t('Copy'), role: \"button\", css: css`\n          &.anticon > * {\n            line-height: 0;\n          }\n        ` }) });\nexport const FilterInput = ({ onChangeHandler, shouldFocus = false }) => {\n  const inputRef = useRef(null);\n  useEffect(() => {\n    // Focus the input element when the component mounts\n    if (inputRef.current && shouldFocus) {\n      inputRef.current.focus();\n    }\n  }, []);\n  const theme = useTheme();\n  const debouncedChangeHandler = _debounce(onChangeHandler, SLOW_DEBOUNCE);\n  return _jsx(Input, { prefix: _jsx(Icons.SearchOutlined, { iconSize: \"l\" }), placeholder: t('Search'), onChange: (event) => {\n      const filterText = event.target.value;\n      debouncedChangeHandler(filterText);\n    }, css: css`\n        width: 200px;\n        margin-right: ${theme.gridUnit * 2}px;\n      `, ref: inputRef });\n};\nvar FormatPickerValue;\n(function (FormatPickerValue) {\n  FormatPickerValue[\"Formatted\"] = \"formatted\";\n  FormatPickerValue[\"Original\"] = \"original\";\n})(FormatPickerValue || (FormatPickerValue = {}));\nconst FormatPicker = ({ onChange, value }) => _jsx(Radio.GroupWrapper, { spaceConfig: {\n    direction: 'vertical',\n    align: 'start',\n    size: 15,\n    wrap: false\n  }, size: \"large\", value: value, onChange: onChange, options: [\n  { label: t('Formatted date'), value: FormatPickerValue.Formatted },\n  { label: t('Original value'), value: FormatPickerValue.Original }] }\n);\nconst FormatPickerContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n\n  padding: ${({ theme }) => `${theme.gridUnit * 4}px`};\n`;\nconst FormatPickerLabel = styled.span`\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  color: ${({ theme }) => theme.colors.grayscale.base};\n  margin-bottom: ${({ theme }) => theme.gridUnit * 2}px;\n`;\nconst DataTableTemporalHeaderCell = ({ columnName, onTimeColumnChange, datasourceId, isOriginalTimeColumn }) => {\n  const theme = useTheme();\n  const onChange = (e) => {\n    onTimeColumnChange(columnName, e.target.value);\n  };\n  const overlayContent = useMemo(() => datasourceId ? // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n  _jsxs(FormatPickerContainer, { onClick: (e) => e.stopPropagation(), children: [\n\n    _jsx(FormatPickerLabel, { children: t('Column Formatting') }),\n    _jsx(FormatPicker, { onChange: onChange, value: isOriginalTimeColumn ?\n      FormatPickerValue.Original :\n      FormatPickerValue.Formatted })] }\n  ) : null, [datasourceId, isOriginalTimeColumn]);\n  return datasourceId ? _jsxs(\"span\", { children: [\n    _jsx(Popover, { trigger: \"click\", content: overlayContent, placement: \"bottomLeft\", arrow: { pointAtCenter: true }, children:\n      _jsx(Icons.SettingOutlined, { iconSize: \"m\", iconColor: theme.colors.grayscale.light1, css: /*#__PURE__*/_css({ marginRight: `${theme.gridUnit}px` }, process.env.NODE_ENV === \"production\" ? \"\" : \";label:DataTableTemporalHeaderCell;\", process.env.NODE_ENV === \"production\" ? \"\" : \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL2V4cGxvcmUvY29tcG9uZW50cy9EYXRhVGFibGVDb250cm9sL2luZGV4LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE0R3NGIiwiZmlsZSI6Ii9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL2V4cGxvcmUvY29tcG9uZW50cy9EYXRhVGFibGVDb250cm9sL2luZGV4LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcywgR2VuZXJpY0RhdGFUeXBlLCBnZXRUaW1lRm9ybWF0dGVyLCBzYWZlSHRtbFNwYW4sIHN0eWxlZCwgdCwgVGltZUZvcm1hdHMsIHVzZVRoZW1lLCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnc3JjL2NvbXBvbmVudHMvSW5wdXQnO1xuaW1wb3J0IHsgQk9PTF9GQUxTRV9ESVNQTEFZLCBCT09MX1RSVUVfRElTUExBWSwgTlVMTF9ESVNQTEFZLCBTTE9XX0RFQk9VTkNFLCB9IGZyb20gJ3NyYy9jb25zdGFudHMnO1xuaW1wb3J0IHsgUmFkaW8gfSBmcm9tICdzcmMvY29tcG9uZW50cy9SYWRpbyc7XG5pbXBvcnQgSWNvbnMgZnJvbSAnc3JjL2NvbXBvbmVudHMvSWNvbnMnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b24nO1xuaW1wb3J0IFBvcG92ZXIgZnJvbSAnc3JjL2NvbXBvbmVudHMvUG9wb3Zlcic7XG5pbXBvcnQgeyBwcmVwYXJlQ29weVRvQ2xpcGJvYXJkVGFidWxhckRhdGEgfSBmcm9tICdzcmMvdXRpbHMvY29tbW9uJztcbmltcG9ydCBDb3B5VG9DbGlwYm9hcmQgZnJvbSAnc3JjL2NvbXBvbmVudHMvQ29weVRvQ2xpcGJvYXJkJztcbmltcG9ydCB7IGdldFRpbWVDb2x1bW5zLCBzZXRUaW1lQ29sdW1ucyB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGNvbnN0IENlbGxOdWxsID0gc3R5bGVkKCdzcGFuJykgYFxuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0MX07XG5gO1xuZXhwb3J0IGNvbnN0IENvcHlCdXR0b24gPSBzdHlsZWQoQnV0dG9uKSBgXG4gIGZvbnQtc2l6ZTogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XG5cbiAgLy8gbmVlZGVkIHRvIG92ZXJyaWRlIGJ1dHRvbidzIGZpcnN0LW9mLXR5cGUgbWFyZ2luOiAwXG4gICYmIHtcbiAgICBtYXJnaW46IDAgJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdCAqIDJ9cHg7XG4gIH1cblxuICBpIHtcbiAgICBwYWRkaW5nOiAwICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXR9cHg7XG4gIH1cbmA7XG5leHBvcnQgY29uc3QgQ29weVRvQ2xpcGJvYXJkQnV0dG9uID0gKHsgZGF0YSwgY29sdW1ucywgfSkgPT4gKDxDb3B5VG9DbGlwYm9hcmQgdGV4dD17ZGF0YSAmJiBjb2x1bW5zID8gcHJlcGFyZUNvcHlUb0NsaXBib2FyZFRhYnVsYXJEYXRhKGRhdGEsIGNvbHVtbnMpIDogJyd9IHdyYXBwZWQ9e2ZhbHNlfSBjb3B5Tm9kZT17PEljb25zLkNvcHlPdXRsaW5lZCBpY29uU2l6ZT1cImxcIiBhcmlhLWxhYmVsPXt0KCdDb3B5Jyl9IHJvbGU9XCJidXR0b25cIiBjc3M9e2NzcyBgXG4gICAgICAgICAgJi5hbnRpY29uID4gKiB7XG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcbiAgICAgICAgICB9XG4gICAgICAgIGB9Lz59Lz4pO1xuZXhwb3J0IGNvbnN0IEZpbHRlcklucHV0ID0gKHsgb25DaGFuZ2VIYW5kbGVyLCBzaG91bGRGb2N1cyA9IGZhbHNlLCB9KSA9PiB7XG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gRm9jdXMgdGhlIGlucHV0IGVsZW1lbnQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50c1xuICAgICAgICBpZiAoaW5wdXRSZWYuY3VycmVudCAmJiBzaG91bGRGb2N1cykge1xuICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgICBjb25zdCBkZWJvdW5jZWRDaGFuZ2VIYW5kbGVyID0gZGVib3VuY2Uob25DaGFuZ2VIYW5kbGVyLCBTTE9XX0RFQk9VTkNFKTtcbiAgICByZXR1cm4gKDxJbnB1dCBwcmVmaXg9ezxJY29ucy5TZWFyY2hPdXRsaW5lZCBpY29uU2l6ZT1cImxcIi8+fSBwbGFjZWhvbGRlcj17dCgnU2VhcmNoJyl9IG9uQ2hhbmdlPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclRleHQgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBkZWJvdW5jZWRDaGFuZ2VIYW5kbGVyKGZpbHRlclRleHQpO1xuICAgICAgICB9fSBjc3M9e2NzcyBgXG4gICAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLmdyaWRVbml0ICogMn1weDtcbiAgICAgIGB9IHJlZj17aW5wdXRSZWZ9Lz4pO1xufTtcbnZhciBGb3JtYXRQaWNrZXJWYWx1ZTtcbihmdW5jdGlvbiAoRm9ybWF0UGlja2VyVmFsdWUpIHtcbiAgICBGb3JtYXRQaWNrZXJWYWx1ZVtcIkZvcm1hdHRlZFwiXSA9IFwiZm9ybWF0dGVkXCI7XG4gICAgRm9ybWF0UGlja2VyVmFsdWVbXCJPcmlnaW5hbFwiXSA9IFwib3JpZ2luYWxcIjtcbn0pKEZvcm1hdFBpY2tlclZhbHVlIHx8IChGb3JtYXRQaWNrZXJWYWx1ZSA9IHt9KSk7XG5jb25zdCBGb3JtYXRQaWNrZXIgPSAoeyBvbkNoYW5nZSwgdmFsdWUsIH0pID0+ICg8UmFkaW8uR3JvdXBXcmFwcGVyIHNwYWNlQ29uZmlnPXt7XG4gICAgICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgYWxpZ246ICdzdGFydCcsXG4gICAgICAgIHNpemU6IDE1LFxuICAgICAgICB3cmFwOiBmYWxzZSxcbiAgICB9fSBzaXplPVwibGFyZ2VcIiB2YWx1ZT17dmFsdWV9IG9uQ2hhbmdlPXtvbkNoYW5nZX0gb3B0aW9ucz17W1xuICAgICAgICB7IGxhYmVsOiB0KCdGb3JtYXR0ZWQgZGF0ZScpLCB2YWx1ZTogRm9ybWF0UGlja2VyVmFsdWUuRm9ybWF0dGVkIH0sXG4gICAgICAgIHsgbGFiZWw6IHQoJ09yaWdpbmFsIHZhbHVlJyksIHZhbHVlOiBGb3JtYXRQaWNrZXJWYWx1ZS5PcmlnaW5hbCB9LFxuICAgIF19Lz4pO1xuY29uc3QgRm9ybWF0UGlja2VyQ29udGFpbmVyID0gc3R5bGVkLmRpdiBgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgcGFkZGluZzogJHsoeyB0aGVtZSB9KSA9PiBgJHt0aGVtZS5ncmlkVW5pdCAqIDR9cHhgfTtcbmA7XG5jb25zdCBGb3JtYXRQaWNrZXJMYWJlbCA9IHN0eWxlZC5zcGFuIGBcbiAgZm9udC1zaXplOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgY29sb3I6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlfTtcbiAgbWFyZ2luLWJvdHRvbTogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdCAqIDJ9cHg7XG5gO1xuY29uc3QgRGF0YVRhYmxlVGVtcG9yYWxIZWFkZXJDZWxsID0gKHsgY29sdW1uTmFtZSwgb25UaW1lQ29sdW1uQ2hhbmdlLCBkYXRhc291cmNlSWQsIGlzT3JpZ2luYWxUaW1lQ29sdW1uLCB9KSA9PiB7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKGUpID0+IHtcbiAgICAgICAgb25UaW1lQ29sdW1uQ2hhbmdlKGNvbHVtbk5hbWUsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJsYXlDb250ZW50ID0gdXNlTWVtbygoKSA9PiBkYXRhc291cmNlSWQgPyAoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9uby1zdGF0aWMtZWxlbWVudC1pbnRlcmFjdGlvbnNcbiAgICA8Rm9ybWF0UGlja2VyQ29udGFpbmVyIG9uQ2xpY2s9e2UgPT4gZS5zdG9wUHJvcGFnYXRpb24oKX0+XG4gICAgICAgICAgey8qIGhhY2sgdG8gZGlzYWJsZSBjbGljayBwcm9wYWdhdGlvbiBmcm9tIHBvcG92ZXIgY29udGVudCB0byB0YWJsZSBoZWFkZXIsIHdoaWNoIHRyaWdnZXJzIHNvcnRpbmcgY29sdW1uICovfVxuICAgICAgICAgIDxGb3JtYXRQaWNrZXJMYWJlbD57dCgnQ29sdW1uIEZvcm1hdHRpbmcnKX08L0Zvcm1hdFBpY2tlckxhYmVsPlxuICAgICAgICAgIDxGb3JtYXRQaWNrZXIgb25DaGFuZ2U9e29uQ2hhbmdlfSB2YWx1ZT17aXNPcmlnaW5hbFRpbWVDb2x1bW5cbiAgICAgICAgICAgID8gRm9ybWF0UGlja2VyVmFsdWUuT3JpZ2luYWxcbiAgICAgICAgICAgIDogRm9ybWF0UGlja2VyVmFsdWUuRm9ybWF0dGVkfS8+XG4gICAgICAgIDwvRm9ybWF0UGlja2VyQ29udGFpbmVyPikgOiBudWxsLCBbZGF0YXNvdXJjZUlkLCBpc09yaWdpbmFsVGltZUNvbHVtbl0pO1xuICAgIHJldHVybiBkYXRhc291cmNlSWQgPyAoPHNwYW4+XG4gICAgICA8UG9wb3ZlciB0cmlnZ2VyPVwiY2xpY2tcIiBjb250ZW50PXtvdmVybGF5Q29udGVudH0gcGxhY2VtZW50PVwiYm90dG9tTGVmdFwiIGFycm93PXt7IHBvaW50QXRDZW50ZXI6IHRydWUgfX0+XG4gICAgICAgIDxJY29ucy5TZXR0aW5nT3V0bGluZWQgaWNvblNpemU9XCJtXCIgaWNvbkNvbG9yPXt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0MX0gY3NzPXt7IG1hcmdpblJpZ2h0OiBgJHt0aGVtZS5ncmlkVW5pdH1weGAgfX0gb25DbGljaz17ZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpfS8+XG4gICAgICA8L1BvcG92ZXI+XG4gICAgICB7Y29sdW1uTmFtZX1cbiAgICA8L3NwYW4+KSA6ICg8c3Bhbj57Y29sdW1uTmFtZX08L3NwYW4+KTtcbn07XG5leHBvcnQgY29uc3QgdXNlRmlsdGVyZWRUYWJsZURhdGEgPSAoZmlsdGVyVGV4dCwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHJvd3NBc1N0cmluZ3MgPSB1c2VNZW1vKCgpID0+IGRhdGE/Lm1hcCgocm93KSA9PiBPYmplY3QudmFsdWVzKHJvdykubWFwKHZhbHVlID0+IHZhbHVlID8gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogdCgnTi9BJykpKSA/PyBbXSwgW2RhdGFdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghZGF0YT8ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEuZmlsdGVyKChfLCBpbmRleCkgPT4gcm93c0FzU3RyaW5nc1tpbmRleF0uc29tZSh2YWx1ZSA9PiB2YWx1ZT8uaW5jbHVkZXMoZmlsdGVyVGV4dC50b0xvd2VyQ2FzZSgpKSkpO1xuICAgIH0sIFtkYXRhLCBmaWx0ZXJUZXh0LCByb3dzQXNTdHJpbmdzXSk7XG59O1xuY29uc3QgdGltZUZvcm1hdHRlciA9IGdldFRpbWVGb3JtYXR0ZXIoVGltZUZvcm1hdHMuREFUQUJBU0VfREFURVRJTUUpO1xuZXhwb3J0IGNvbnN0IHVzZVRhYmxlQ29sdW1ucyA9IChjb2xuYW1lcywgY29sdHlwZXMsIGRhdGEsIGRhdGFzb3VyY2VJZCwgaXNWaXNpYmxlLCBtb3JlQ29uZmlncywgYWxsb3dIVE1MKSA9PiB7XG4gICAgY29uc3QgW29yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbnMsIHNldE9yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbnNdID0gdXNlU3RhdGUoZ2V0VGltZUNvbHVtbnMoZGF0YXNvdXJjZUlkKSk7XG4gICAgY29uc3Qgb25UaW1lQ29sdW1uQ2hhbmdlID0gKGNvbHVtbk5hbWUsIGNvbHVtblR5cGUpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uVHlwZSA9PT0gRm9ybWF0UGlja2VyVmFsdWUuT3JpZ2luYWwgJiZcbiAgICAgICAgICAgICFvcmlnaW5hbEZvcm1hdHRlZFRpbWVDb2x1bW5zLmluY2x1ZGVzKGNvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xzID0gZ2V0VGltZUNvbHVtbnMoZGF0YXNvdXJjZUlkKTtcbiAgICAgICAgICAgIGNvbHMucHVzaChjb2x1bW5OYW1lKTtcbiAgICAgICAgICAgIHNldFRpbWVDb2x1bW5zKGRhdGFzb3VyY2VJZCwgY29scyk7XG4gICAgICAgICAgICBzZXRPcmlnaW5hbEZvcm1hdHRlZFRpbWVDb2x1bW5zKGNvbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbHVtblR5cGUgPT09IEZvcm1hdFBpY2tlclZhbHVlLkZvcm1hdHRlZCAmJlxuICAgICAgICAgICAgb3JpZ2luYWxGb3JtYXR0ZWRUaW1lQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW5OYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgY29scyA9IGdldFRpbWVDb2x1bW5zKGRhdGFzb3VyY2VJZCk7XG4gICAgICAgICAgICBjb2xzLnNwbGljZShjb2xzLmluZGV4T2YoY29sdW1uTmFtZSksIDEpO1xuICAgICAgICAgICAgc2V0VGltZUNvbHVtbnMoZGF0YXNvdXJjZUlkLCBjb2xzKTtcbiAgICAgICAgICAgIHNldE9yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbnMoY29scyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHNldE9yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbnMoZ2V0VGltZUNvbHVtbnMoZGF0YXNvdXJjZUlkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGF0YXNvdXJjZUlkLCBpc1Zpc2libGVdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBjb2xuYW1lcyAmJiBkYXRhPy5sZW5ndGhcbiAgICAgICAgPyBjb2xuYW1lc1xuICAgICAgICAgICAgLmZpbHRlcigoY29sdW1uKSA9PiBPYmplY3Qua2V5cyhkYXRhWzBdKS5pbmNsdWRlcyhjb2x1bW4pKVxuICAgICAgICAgICAgLm1hcCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sVHlwZSA9IGNvbHR5cGVzPy5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGRhdGFbMF1ba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbkluZGV4ID0gY29sVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLlRlbXBvcmFsXG4gICAgICAgICAgICAgICAgPyBvcmlnaW5hbEZvcm1hdHRlZFRpbWVDb2x1bW5zLmluZGV4T2Yoa2V5KVxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICBjb25zdCBpc09yaWdpbmFsVGltZUNvbHVtbiA9IG9yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbnMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gcmVhY3QtdGFibGUgcmVxdWlyZXMgYSBub24tZW1wdHkgaWQsIHRoZXJlZm9yZSB3ZSBpbnRyb2R1Y2UgYSBmYWxsYmFjayB2YWx1ZSBpbiBjYXNlIHRoZSBrZXkgaXMgZW1wdHlcbiAgICAgICAgICAgICAgICBpZDoga2V5IHx8IGluZGV4LFxuICAgICAgICAgICAgICAgIGFjY2Vzc29yOiAocm93KSA9PiByb3dba2V5XSxcbiAgICAgICAgICAgICAgICBIZWFkZXI6IGNvbFR5cGUgPT09IEdlbmVyaWNEYXRhVHlwZS5UZW1wb3JhbCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWx1ZSAhPT0gJ3N0cmluZycgPyAoPERhdGFUYWJsZVRlbXBvcmFsSGVhZGVyQ2VsbCBjb2x1bW5OYW1lPXtrZXl9IGRhdGFzb3VyY2VJZD17ZGF0YXNvdXJjZUlkfSBvblRpbWVDb2x1bW5DaGFuZ2U9e29uVGltZUNvbHVtbkNoYW5nZX0gaXNPcmlnaW5hbFRpbWVDb2x1bW49e2lzT3JpZ2luYWxUaW1lQ29sdW1ufS8+KSA6IChrZXkpLFxuICAgICAgICAgICAgICAgIENlbGw6ICh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQk9PTF9UUlVFX0RJU1BMQVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJPT0xfRkFMU0VfRElTUExBWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8Q2VsbE51bGw+e05VTExfRElTUExBWX08L0NlbGxOdWxsPjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLlRlbXBvcmFsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEZvcm1hdHRlZFRpbWVDb2x1bW5JbmRleCA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lRm9ybWF0dGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBhbGxvd0hUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzYWZlSHRtbFNwYW4odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4ubW9yZUNvbmZpZ3M/LltrZXldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXSwgW1xuICAgICAgICBjb2xuYW1lcyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29sdHlwZXMsXG4gICAgICAgIGRhdGFzb3VyY2VJZCxcbiAgICAgICAgbW9yZUNvbmZpZ3MsXG4gICAgICAgIG9yaWdpbmFsRm9ybWF0dGVkVGltZUNvbHVtbnMsXG4gICAgXSk7XG59O1xuIl19 */\"), onClick: (e) => e.stopPropagation() }) }\n    ),\n    columnName] }\n  ) : _jsx(\"span\", { children: columnName });\n};\nexport const useFilteredTableData = (filterText, data) => {\n  const rowsAsStrings = useMemo(() => {var _data$map;return (_data$map = data == null ? void 0 : data.map((row) => Object.values(row).map((value) => value ? value.toString().toLowerCase() : t('N/A')))) != null ? _data$map : [];}, [data]);\n  return useMemo(() => {\n    if (!(data != null && data.length)) {\n      return [];\n    }\n    return data.filter((_, index) => rowsAsStrings[index].some((value) => value == null ? void 0 : value.includes(filterText.toLowerCase())));\n  }, [data, filterText, rowsAsStrings]);\n};\nconst timeFormatter = getTimeFormatter(TimeFormats.DATABASE_DATETIME);\nexport const useTableColumns = (colnames, coltypes, data, datasourceId, isVisible, moreConfigs, allowHTML) => {\n  const [originalFormattedTimeColumns, setOriginalFormattedTimeColumns] = useState(getTimeColumns(datasourceId));\n  const onTimeColumnChange = (columnName, columnType) => {\n    if (!datasourceId) {\n      return;\n    }\n    if (columnType === FormatPickerValue.Original &&\n    !originalFormattedTimeColumns.includes(columnName)) {\n      const cols = getTimeColumns(datasourceId);\n      cols.push(columnName);\n      setTimeColumns(datasourceId, cols);\n      setOriginalFormattedTimeColumns(cols);\n    } else\n    if (columnType === FormatPickerValue.Formatted &&\n    originalFormattedTimeColumns.includes(columnName)) {\n      const cols = getTimeColumns(datasourceId);\n      cols.splice(cols.indexOf(columnName), 1);\n      setTimeColumns(datasourceId, cols);\n      setOriginalFormattedTimeColumns(cols);\n    }\n  };\n  useEffect(() => {\n    if (isVisible) {\n      setOriginalFormattedTimeColumns(getTimeColumns(datasourceId));\n    }\n  }, [datasourceId, isVisible]);\n  return useMemo(() => colnames && data != null && data.length ?\n  colnames.\n  filter((column) => Object.keys(data[0]).includes(column)).\n  map((key, index) => {\n    const colType = coltypes == null ? void 0 : coltypes[index];\n    const firstValue = data[0][key];\n    const originalFormattedTimeColumnIndex = colType === GenericDataType.Temporal ?\n    originalFormattedTimeColumns.indexOf(key) :\n    -1;\n    const isOriginalTimeColumn = originalFormattedTimeColumns.includes(key);\n    return {\n      // react-table requires a non-empty id, therefore we introduce a fallback value in case the key is empty\n      id: key || index,\n      accessor: (row) => row[key],\n      Header: colType === GenericDataType.Temporal &&\n      typeof firstValue !== 'string' ? _jsx(DataTableTemporalHeaderCell, { columnName: key, datasourceId: datasourceId, onTimeColumnChange: onTimeColumnChange, isOriginalTimeColumn: isOriginalTimeColumn }) : key,\n      Cell: ({ value }) => {\n        if (value === true) {\n          return BOOL_TRUE_DISPLAY;\n        }\n        if (value === false) {\n          return BOOL_FALSE_DISPLAY;\n        }\n        if (value === null) {\n          return _jsx(CellNull, { children: NULL_DISPLAY });\n        }\n        if (colType === GenericDataType.Temporal &&\n        originalFormattedTimeColumnIndex === -1 &&\n        typeof value === 'number') {\n          return timeFormatter(value);\n        }\n        if (typeof value === 'string' && allowHTML) {\n          return safeHtmlSpan(value);\n        }\n        return String(value);\n      },\n      ...(moreConfigs == null ? void 0 : moreConfigs[key])\n    };\n  }) :\n  [], [\n  colnames,\n  data,\n  coltypes,\n  datasourceId,\n  moreConfigs,\n  originalFormattedTimeColumns]\n  );\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}