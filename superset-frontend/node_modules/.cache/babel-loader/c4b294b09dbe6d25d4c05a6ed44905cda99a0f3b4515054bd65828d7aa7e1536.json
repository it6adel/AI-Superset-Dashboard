{"ast":null,"code":"import _mapKeys from \"lodash/mapKeys\";import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { nanoid } from 'nanoid';\nimport rison from 'rison';\nimport {\n  FeatureFlag,\n  SupersetClient,\n  t,\n  isFeatureEnabled,\n  COMMON_ERR_MESSAGES,\n  getClientErrorObject } from\n'@superset-ui/core';\n\n\nimport { now } from 'src/utils/dates';\nimport {\n  addDangerToast as addDangerToastAction,\n  addInfoToast as addInfoToastAction,\n  addSuccessToast as addSuccessToastAction,\n  addWarningToast as addWarningToastAction } from\n'src/components/MessageToasts/actions';\nimport { LOG_ACTIONS_SQLLAB_FETCH_FAILED_QUERY } from 'src/logger/LogUtils';\nimport getBootstrapData from 'src/utils/getBootstrapData';\nimport { logEvent } from 'src/logger/actions';\nimport { newQueryTabName } from '../utils/newQueryTabName';\nimport getInitialState from '../reducers/getInitialState';\nimport { rehydratePersistedState } from '../utils/reduxStateToLocalStorageHelper';\n\nexport const RESET_STATE = 'RESET_STATE';\nexport const ADD_QUERY_EDITOR = 'ADD_QUERY_EDITOR';\nexport const UPDATE_QUERY_EDITOR = 'UPDATE_QUERY_EDITOR';\nexport const QUERY_EDITOR_SAVED = 'QUERY_EDITOR_SAVED';\nexport const CLONE_QUERY_TO_NEW_TAB = 'CLONE_QUERY_TO_NEW_TAB';\nexport const REMOVE_QUERY_EDITOR = 'REMOVE_QUERY_EDITOR';\nexport const MERGE_TABLE = 'MERGE_TABLE';\nexport const REMOVE_TABLES = 'REMOVE_TABLES';\nexport const END_QUERY = 'END_QUERY';\nexport const REMOVE_QUERY = 'REMOVE_QUERY';\nexport const EXPAND_TABLE = 'EXPAND_TABLE';\nexport const COLLAPSE_TABLE = 'COLLAPSE_TABLE';\nexport const QUERY_EDITOR_SETDB = 'QUERY_EDITOR_SETDB';\nexport const QUERY_EDITOR_SET_CATALOG = 'QUERY_EDITOR_SET_CATALOG';\nexport const QUERY_EDITOR_SET_SCHEMA = 'QUERY_EDITOR_SET_SCHEMA';\nexport const QUERY_EDITOR_SET_TITLE = 'QUERY_EDITOR_SET_TITLE';\nexport const QUERY_EDITOR_SET_AUTORUN = 'QUERY_EDITOR_SET_AUTORUN';\nexport const QUERY_EDITOR_SET_SQL = 'QUERY_EDITOR_SET_SQL';\nexport const QUERY_EDITOR_SET_CURSOR_POSITION =\n'QUERY_EDITOR_SET_CURSOR_POSITION';\nexport const QUERY_EDITOR_SET_QUERY_LIMIT = 'QUERY_EDITOR_SET_QUERY_LIMIT';\nexport const QUERY_EDITOR_SET_TEMPLATE_PARAMS =\n'QUERY_EDITOR_SET_TEMPLATE_PARAMS';\nexport const QUERY_EDITOR_SET_SELECTED_TEXT = 'QUERY_EDITOR_SET_SELECTED_TEXT';\nexport const QUERY_EDITOR_SET_FUNCTION_NAMES =\n'QUERY_EDITOR_SET_FUNCTION_NAMES';\nexport const QUERY_EDITOR_PERSIST_HEIGHT = 'QUERY_EDITOR_PERSIST_HEIGHT';\nexport const QUERY_EDITOR_TOGGLE_LEFT_BAR = 'QUERY_EDITOR_TOGGLE_LEFT_BAR';\nexport const MIGRATE_QUERY_EDITOR = 'MIGRATE_QUERY_EDITOR';\nexport const MIGRATE_TAB_HISTORY = 'MIGRATE_TAB_HISTORY';\nexport const MIGRATE_TABLE = 'MIGRATE_TABLE';\nexport const MIGRATE_QUERY = 'MIGRATE_QUERY';\n\nexport const SET_DATABASES = 'SET_DATABASES';\nexport const SET_ACTIVE_QUERY_EDITOR = 'SET_ACTIVE_QUERY_EDITOR';\nexport const LOAD_QUERY_EDITOR = 'LOAD_QUERY_EDITOR';\nexport const SET_TABLES = 'SET_TABLES';\nexport const SET_ACTIVE_SOUTHPANE_TAB = 'SET_ACTIVE_SOUTHPANE_TAB';\nexport const REFRESH_QUERIES = 'REFRESH_QUERIES';\nexport const SET_USER_OFFLINE = 'SET_USER_OFFLINE';\nexport const RUN_QUERY = 'RUN_QUERY';\nexport const START_QUERY = 'START_QUERY';\nexport const STOP_QUERY = 'STOP_QUERY';\nexport const REQUEST_QUERY_RESULTS = 'REQUEST_QUERY_RESULTS';\nexport const QUERY_SUCCESS = 'QUERY_SUCCESS';\nexport const QUERY_FAILED = 'QUERY_FAILED';\nexport const CLEAR_INACTIVE_QUERIES = 'CLEAR_INACTIVE_QUERIES';\nexport const CLEAR_QUERY_RESULTS = 'CLEAR_QUERY_RESULTS';\nexport const REMOVE_DATA_PREVIEW = 'REMOVE_DATA_PREVIEW';\nexport const CHANGE_DATA_PREVIEW_ID = 'CHANGE_DATA_PREVIEW_ID';\n\nexport const COST_ESTIMATE_STARTED = 'COST_ESTIMATE_STARTED';\nexport const COST_ESTIMATE_RETURNED = 'COST_ESTIMATE_RETURNED';\nexport const COST_ESTIMATE_FAILED = 'COST_ESTIMATE_FAILED';\n\nexport const CREATE_DATASOURCE_STARTED = 'CREATE_DATASOURCE_STARTED';\nexport const CREATE_DATASOURCE_SUCCESS = 'CREATE_DATASOURCE_SUCCESS';\nexport const CREATE_DATASOURCE_FAILED = 'CREATE_DATASOURCE_FAILED';\n\nexport const SET_EDITOR_TAB_LAST_UPDATE = 'SET_EDITOR_TAB_LAST_UPDATE';\nexport const SET_LAST_UPDATED_ACTIVE_TAB = 'SET_LAST_UPDATED_ACTIVE_TAB';\nexport const CLEAR_DESTROYED_QUERY_EDITOR = 'CLEAR_DESTROYED_QUERY_EDITOR';\n\nexport const addInfoToast = addInfoToastAction;\nexport const addSuccessToast = addSuccessToastAction;\nexport const addDangerToast = addDangerToastAction;\nexport const addWarningToast = addWarningToastAction;\n\nexport const CtasEnum = {\n  Table: 'TABLE',\n  View: 'VIEW'\n};\nconst ERR_MSG_CANT_LOAD_QUERY = t(\"The query couldn't be loaded\");\n\n// a map of SavedQuery field names to the different names used client-side,\n// because for now making the names consistent is too complicated\n// so it might as well only happen in one place\nconst queryClientMapping = {\n  id: 'remoteId',\n  db_id: 'dbId',\n  label: 'name',\n  template_parameters: 'templateParams'\n};\nconst queryServerMapping = _invert(queryClientMapping);\n\n// uses a mapping like those above to convert object key names to another style\nconst fieldConverter = (mapping) => (obj) =>\n_mapKeys(obj, (value, key) => key in mapping ? mapping[key] : key);\n\nexport const convertQueryToServer = fieldConverter(queryServerMapping);\nexport const convertQueryToClient = fieldConverter(queryClientMapping);\n\nexport function getUpToDateQuery(rootState, queryEditor, key) {\n  const {\n    sqlLab: { unsavedQueryEditor, queryEditors }\n  } = rootState;\n  const id = key != null ? key : queryEditor.id;\n  return {\n    id,\n    ...queryEditors.find((qe) => qe.id === id),\n    ...(id === unsavedQueryEditor.id && unsavedQueryEditor)\n  };\n}\n\nexport function resetState(data) {\n  return (dispatch, getState) => {\n    const { common } = getState();\n    const initialState = getInitialState({\n      ...getBootstrapData(),\n      common,\n      ...data\n    });\n\n    dispatch({\n      type: RESET_STATE,\n      sqlLabInitialState: initialState.sqlLab\n    });\n    rehydratePersistedState(dispatch, initialState);\n  };\n}\n\nexport function updateQueryEditor(alterations) {\n  return { type: UPDATE_QUERY_EDITOR, alterations };\n}\n\nexport function setEditorTabLastUpdate(timestamp) {\n  return { type: SET_EDITOR_TAB_LAST_UPDATE, timestamp };\n}\n\nexport function scheduleQuery(query) {\n  return (dispatch) =>\n  SupersetClient.post({\n    endpoint: '/api/v1/saved_query/',\n    jsonPayload: query,\n    stringify: false\n  }).\n  then(() =>\n  dispatch(\n    addSuccessToast(\n      t(\n        'Your query has been scheduled. To see details of your query, navigate to Saved queries'\n      )\n    )\n  )\n  ).\n  catch(() =>\n  dispatch(addDangerToast(t('Your query could not be scheduled')))\n  );\n}\n\nexport function estimateQueryCost(queryEditor) {\n  return (dispatch, getState) => {\n    const { dbId, catalog, schema, sql, selectedText, templateParams } =\n    getUpToDateQuery(getState(), queryEditor);\n    const requestSql = selectedText || sql;\n\n    const postPayload = {\n      database_id: dbId,\n      catalog,\n      schema,\n      sql: requestSql,\n      template_params: JSON.parse(templateParams || '{}')\n    };\n\n    return Promise.all([\n    dispatch({ type: COST_ESTIMATE_STARTED, query: queryEditor }),\n    SupersetClient.post({\n      endpoint: '/api/v1/sqllab/estimate/',\n      body: JSON.stringify(postPayload),\n      headers: { 'Content-Type': 'application/json' }\n    }).\n    then(({ json }) =>\n    dispatch({ type: COST_ESTIMATE_RETURNED, query: queryEditor, json })\n    ).\n    catch((response) =>\n    getClientErrorObject(response).then((error) => {\n      const message =\n      error.error ||\n      error.statusText ||\n      t('Failed at retrieving results');\n      return dispatch({\n        type: COST_ESTIMATE_FAILED,\n        query: queryEditor,\n        error: message\n      });\n    })\n    )]\n    );\n  };\n}\n\nexport function clearInactiveQueries(interval) {\n  return { type: CLEAR_INACTIVE_QUERIES, interval };\n}\n\nexport function startQuery(query, runPreviewOnly) {\n  Object.assign(query, {\n    id: query.id ? query.id : nanoid(11),\n    progress: 0,\n    startDttm: now(),\n    state: query.runAsync ? 'pending' : 'running',\n    cached: false\n  });\n  return { type: START_QUERY, query, runPreviewOnly };\n}\n\nexport function querySuccess(query, results) {\n  return { type: QUERY_SUCCESS, query, results };\n}\n\nexport function queryFailed(query, msg, link, errors) {\n  return function (dispatch) {\n    const eventData = {\n      has_err: true,\n      start_offset: query.startDttm,\n      ts: new Date().getTime()\n    };\n    errors == null ? void 0 : errors.forEach(({ error_type: errorType, extra }) => {var _extra$issue_codes;\n      const messages = (extra == null ? void 0 : (_extra$issue_codes = extra.issue_codes) == null ? void 0 : _extra$issue_codes.map(({ message }) => message)) || [\n      errorType];\n\n      messages.forEach((message) => {\n        dispatch(\n          logEvent(LOG_ACTIONS_SQLLAB_FETCH_FAILED_QUERY, {\n            ...eventData,\n            error_type: errorType,\n            error_details: message\n          })\n        );\n      });\n    });\n\n    dispatch({ type: QUERY_FAILED, query, msg, link, errors });\n  };\n}\n\nexport function stopQuery(query) {\n  return { type: STOP_QUERY, query };\n}\n\nexport function clearQueryResults(query) {\n  return { type: CLEAR_QUERY_RESULTS, query };\n}\n\nexport function removeDataPreview(table) {\n  return { type: REMOVE_DATA_PREVIEW, table };\n}\n\nexport function requestQueryResults(query) {\n  return { type: REQUEST_QUERY_RESULTS, query };\n}\n\nexport function fetchQueryResults(query, displayLimit, timeoutInMs) {\n  return function (dispatch, getState) {var _getState$common$conf, _getState$common;\n    const { SQLLAB_QUERY_RESULT_TIMEOUT } = (_getState$common$conf = (_getState$common = getState().common) == null ? void 0 : _getState$common.conf) != null ? _getState$common$conf : {};\n    dispatch(requestQueryResults(query));\n\n    const queryParams = rison.encode({\n      key: query.resultsKey,\n      rows: displayLimit || null\n    });\n    const timeout = timeoutInMs != null ? timeoutInMs : SQLLAB_QUERY_RESULT_TIMEOUT;\n    const controller = new AbortController();\n    return SupersetClient.get({\n      endpoint: `/api/v1/sqllab/results/?q=${queryParams}`,\n      parseMethod: 'json-bigint',\n      ...(timeout && { timeout, signal: controller.signal })\n    }).\n    then(({ json }) => dispatch(querySuccess(query, json))).\n    catch((response) => {\n      controller.abort();\n      getClientErrorObject(response).then((error) => {\n        const message =\n        error.error ||\n        error.statusText ||\n        t('Failed at retrieving results');\n\n        return dispatch(\n          queryFailed(query, message, error.link, error.errors)\n        );\n      });\n    });\n  };\n}\n\nexport function runQuery(query, runPreviewOnly) {\n  return function (dispatch) {\n    dispatch(startQuery(query, runPreviewOnly));\n    const postPayload = {\n      client_id: query.id,\n      database_id: query.dbId,\n      json: true,\n      runAsync: query.runAsync,\n      catalog: query.catalog,\n      schema: query.schema,\n      sql: query.sql,\n      sql_editor_id: query.sqlEditorId,\n      tab: query.tab,\n      tmp_table_name: query.tempTable,\n      select_as_cta: query.ctas,\n      ctas_method: query.ctas_method,\n      templateParams: query.templateParams,\n      queryLimit: query.queryLimit,\n      expand_data: true\n    };\n\n    const search = window.location.search || '';\n    return SupersetClient.post({\n      endpoint: `/api/v1/sqllab/execute/${search}`,\n      body: JSON.stringify(postPayload),\n      headers: { 'Content-Type': 'application/json' },\n      parseMethod: 'json-bigint'\n    }).\n    then(({ json }) => {\n      if (!query.runAsync) {\n        dispatch(querySuccess(query, json));\n      }\n    }).\n    catch((response) =>\n    getClientErrorObject(response).then((error) => {\n      let message =\n      error.error ||\n      error.message ||\n      error.statusText ||\n      t('Unknown error');\n      if (message.includes('CSRF token')) {\n        message = t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT);\n      }\n      dispatch(queryFailed(query, message, error.link, error.errors));\n    })\n    );\n  };\n}\n\nexport function runQueryFromSqlEditor(\ndatabase,\nqueryEditor,\ndefaultQueryLimit,\ntempTable,\nctas,\nctasMethod)\n{\n  return function (dispatch, getState) {\n    const qe = getUpToDateQuery(getState(), queryEditor, queryEditor.id);\n    const query = {\n      dbId: qe.dbId,\n      sql: qe.selectedText || qe.sql,\n      sqlEditorId: qe.id,\n      tab: qe.name,\n      catalog: qe.catalog,\n      schema: qe.schema,\n      tempTable,\n      templateParams: qe.templateParams,\n      queryLimit: qe.queryLimit || defaultQueryLimit,\n      runAsync: database ? database.allow_run_async : false,\n      ctas,\n      ctas_method: ctasMethod,\n      updateTabState: !qe.selectedText\n    };\n    dispatch(runQuery(query));\n  };\n}\n\nexport function reRunQuery(query) {\n  // run Query with a new id\n  return function (dispatch) {\n    dispatch(runQuery({ ...query, id: nanoid(11) }));\n  };\n}\n\nexport function postStopQuery(query) {\n  return function (dispatch) {\n    return SupersetClient.post({\n      endpoint: '/api/v1/query/stop',\n      body: JSON.stringify({ client_id: query.id }),\n      headers: { 'Content-Type': 'application/json' }\n    }).\n    then(() => dispatch(stopQuery(query))).\n    then(() => dispatch(addSuccessToast(t('Query was stopped.')))).\n    catch(() => dispatch(addDangerToast(t('Failed to stop query.'))));\n  };\n}\n\nexport function setDatabases(databases) {\n  return { type: SET_DATABASES, databases };\n}\n\nfunction migrateTable(table, queryEditorId, dispatch) {\n  return SupersetClient.post({\n    endpoint: encodeURI('/tableschemaview/'),\n    postPayload: { table: { ...table, queryEditorId } }\n  }).\n  then(({ json }) => {\n    const newTable = {\n      ...table,\n      id: json.id,\n      queryEditorId\n    };\n    return dispatch({ type: MIGRATE_TABLE, oldTable: table, newTable });\n  }).\n  catch(() =>\n  dispatch(\n    addWarningToast(\n      t(\n        'Unable to migrate table schema state to backend. Superset will retry ' +\n        'later. Please contact your administrator if this problem persists.'\n      )\n    )\n  )\n  );\n}\n\nfunction migrateQuery(queryId, queryEditorId, dispatch) {\n  return SupersetClient.post({\n    endpoint: encodeURI(`/tabstateview/${queryEditorId}/migrate_query`),\n    postPayload: { queryId }\n  }).\n  then(() => dispatch({ type: MIGRATE_QUERY, queryId, queryEditorId })).\n  catch(() =>\n  dispatch(\n    addWarningToast(\n      t(\n        'Unable to migrate query state to backend. Superset will retry later. ' +\n        'Please contact your administrator if this problem persists.'\n      )\n    )\n  )\n  );\n}\n\n/**\n * Persist QueryEditor from local storage to backend tab state.\n * This ensures that when new tabs are created, query editors are\n * asynchronously stored in local storage and periodically synchronized\n * with the backend.\n * When switching to persistence mode, the QueryEditors previously\n * stored in local storage will also be synchronized to the backend\n * through syncQueryEditor.\n */\nexport function syncQueryEditor(queryEditor) {\n  return function (dispatch, getState) {\n    const { tables, queries } = getState().sqlLab;\n    const localStorageTables = tables.filter(\n      (table) => table.inLocalStorage && table.queryEditorId === queryEditor.id\n    );\n    const localStorageQueries = Object.values(queries).filter(\n      (query) => query.inLocalStorage && query.sqlEditorId === queryEditor.id\n    );\n    return SupersetClient.post({\n      endpoint: '/tabstateview/',\n      postPayload: { queryEditor }\n    }).\n    then(({ json }) => {\n      const newQueryEditor = {\n        ...queryEditor,\n        id: json.id.toString(),\n        inLocalStorage: false,\n        loaded: true\n      };\n      dispatch({\n        type: MIGRATE_QUERY_EDITOR,\n        oldQueryEditor: queryEditor,\n        newQueryEditor\n      });\n      dispatch({\n        type: MIGRATE_TAB_HISTORY,\n        oldId: queryEditor.id,\n        newId: newQueryEditor.id\n      });\n      return Promise.all([\n      ...localStorageTables.map((table) =>\n      migrateTable(table, newQueryEditor.id, dispatch)\n      ),\n      ...localStorageQueries.map((query) =>\n      migrateQuery(query.id, newQueryEditor.id, dispatch)\n      )]\n      );\n    }).\n    catch(() =>\n    dispatch(\n      addWarningToast(\n        t(\n          'Unable to migrate query editor state to backend. Superset will retry ' +\n          'later. Please contact your administrator if this problem persists.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function addQueryEditor(queryEditor) {\n  const newQueryEditor = {\n    ...queryEditor,\n    id: nanoid(11),\n    loaded: true,\n    inLocalStorage: true\n  };\n  return {\n    type: ADD_QUERY_EDITOR,\n    queryEditor: newQueryEditor\n  };\n}\n\nexport function addNewQueryEditor() {\n  return function (dispatch, getState) {\n    const {\n      sqlLab: { queryEditors, tabHistory, unsavedQueryEditor, databases },\n      common\n    } = getState();\n    const defaultDbId = common.conf.SQLLAB_DEFAULT_DBID;\n    const activeQueryEditor = queryEditors.find(\n      (qe) => qe.id === tabHistory[tabHistory.length - 1]\n    );\n    const dbIds = Object.values(databases).map((database) => database.id);\n    const firstDbId = dbIds.length > 0 ? Math.min(...dbIds) : undefined;\n    const { dbId, catalog, schema, queryLimit, autorun } = {\n      ...queryEditors[0],\n      ...activeQueryEditor,\n      ...(unsavedQueryEditor.id === (activeQueryEditor == null ? void 0 : activeQueryEditor.id) &&\n      unsavedQueryEditor)\n    };\n    const warning = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n    '' :\n    t(\n      '-- Note: Unless you save your query, these tabs will NOT persist if you clear your cookies or change browsers.\\n\\n'\n    );\n\n    const name = newQueryTabName(\n      (queryEditors == null ? void 0 : queryEditors.map((qe) => ({\n        ...qe,\n        ...(qe.id === unsavedQueryEditor.id && unsavedQueryEditor)\n      }))) || []\n    );\n\n    return dispatch(\n      addQueryEditor({\n        dbId: dbId || defaultDbId || firstDbId,\n        catalog: catalog != null ? catalog : null,\n        schema: schema != null ? schema : null,\n        autorun: autorun != null ? autorun : false,\n        sql: `${warning}SELECT ...`,\n        queryLimit: queryLimit || common.conf.DEFAULT_SQLLAB_LIMIT,\n        name\n      })\n    );\n  };\n}\n\nexport function cloneQueryToNewTab(query, autorun) {\n  return function (dispatch, getState) {\n    const state = getState();\n    const { queryEditors, unsavedQueryEditor, tabHistory } = state.sqlLab;\n    const sourceQueryEditor = {\n      ...queryEditors.find((qe) => qe.id === tabHistory[tabHistory.length - 1]),\n      ...(tabHistory[tabHistory.length - 1] === unsavedQueryEditor.id &&\n      unsavedQueryEditor)\n    };\n    const queryEditor = {\n      name: t('Copy of %s', sourceQueryEditor.name),\n      dbId: query.dbId ? query.dbId : null,\n      catalog: query.catalog ? query.catalog : null,\n      schema: query.schema ? query.schema : null,\n      autorun,\n      sql: query.sql,\n      queryLimit: sourceQueryEditor.queryLimit,\n      maxRow: sourceQueryEditor.maxRow,\n      templateParams: sourceQueryEditor.templateParams\n    };\n    return dispatch(addQueryEditor(queryEditor));\n  };\n}\n\nexport function setLastUpdatedActiveTab(queryEditorId) {\n  return {\n    type: SET_LAST_UPDATED_ACTIVE_TAB,\n    queryEditorId\n  };\n}\n\nexport function setActiveQueryEditor(queryEditor) {\n  return {\n    type: SET_ACTIVE_QUERY_EDITOR,\n    queryEditor\n  };\n}\n\nexport function switchQueryEditor(goBackward = false) {\n  return function (dispatch, getState) {\n    const { sqlLab } = getState();\n    const { queryEditors, tabHistory } = sqlLab;\n    const qeid = tabHistory[tabHistory.length - 1];\n    const currentIndex = queryEditors.findIndex((qe) => qe.id === qeid);\n    const nextIndex = goBackward ?\n    currentIndex - 1 + queryEditors.length :\n    currentIndex + 1;\n    const newQueryEditor = queryEditors[nextIndex % queryEditors.length];\n\n    dispatch(setActiveQueryEditor(newQueryEditor));\n  };\n}\n\nexport function loadQueryEditor(queryEditor) {\n  return { type: LOAD_QUERY_EDITOR, queryEditor };\n}\n\nexport function setTables(tableSchemas) {\n  const tables = tableSchemas.\n  filter((tableSchema) => tableSchema.description !== null).\n  map((tableSchema) => {\n    const {\n      columns,\n      selectStar,\n      primaryKey,\n      foreignKeys,\n      indexes,\n      dataPreviewQueryId\n    } = tableSchema.description;\n    return {\n      dbId: tableSchema.database_id,\n      queryEditorId: tableSchema.tab_state_id.toString(),\n      catalog: tableSchema.catalog,\n      schema: tableSchema.schema,\n      name: tableSchema.table,\n      expanded: tableSchema.expanded,\n      id: tableSchema.id,\n      dataPreviewQueryId,\n      columns,\n      selectStar,\n      primaryKey,\n      foreignKeys,\n      indexes,\n      isMetadataLoading: false,\n      isExtraMetadataLoading: false\n    };\n  });\n  return { type: SET_TABLES, tables };\n}\n\nexport function fetchQueryEditor(queryEditor, displayLimit) {\n  return function (dispatch) {\n    SupersetClient.get({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`)\n    }).\n    then(({ json }) => {var _json$latest_query, _json$saved_query;\n      const loadedQueryEditor = {\n        id: json.id.toString(),\n        loaded: true,\n        name: json.label,\n        sql: json.sql,\n        selectedText: null,\n        latestQueryId: (_json$latest_query = json.latest_query) == null ? void 0 : _json$latest_query.id,\n        autorun: json.autorun,\n        dbId: json.database_id,\n        templateParams: json.template_params,\n        catalog: json.catalog,\n        schema: json.schema,\n        queryLimit: json.query_limit,\n        remoteId: (_json$saved_query = json.saved_query) == null ? void 0 : _json$saved_query.id,\n        hideLeftBar: json.hide_left_bar\n      };\n      dispatch(loadQueryEditor(loadedQueryEditor));\n      dispatch(setTables(json.table_schemas || []));\n      if (json.latest_query && json.latest_query.resultsKey) {\n        dispatch(fetchQueryResults(json.latest_query, displayLimit));\n      }\n    }).\n    catch((response) => {\n      if (response.status !== 404) {\n        return dispatch(\n          addDangerToast(t('An error occurred while fetching tab state'))\n        );\n      }\n      return dispatch({ type: REMOVE_QUERY_EDITOR, queryEditor });\n    });\n  };\n}\n\nexport function setActiveSouthPaneTab(tabId) {\n  return { type: SET_ACTIVE_SOUTHPANE_TAB, tabId };\n}\n\nexport function toggleLeftBar(queryEditor) {\n  const hideLeftBar = !queryEditor.hideLeftBar;\n  return {\n    type: QUERY_EDITOR_TOGGLE_LEFT_BAR,\n    queryEditor,\n    hideLeftBar\n  };\n}\n\nexport function clearDestoryedQueryEditor(queryEditorId) {\n  return { type: CLEAR_DESTROYED_QUERY_EDITOR, queryEditorId };\n}\n\nexport function removeQueryEditor(queryEditor) {\n  return { type: REMOVE_QUERY_EDITOR, queryEditor };\n}\n\nexport function removeAllOtherQueryEditors(queryEditor) {\n  return function (dispatch, getState) {var _sqlLab$queryEditors;\n    const { sqlLab } = getState();\n    (_sqlLab$queryEditors = sqlLab.queryEditors) == null ? void 0 : _sqlLab$queryEditors.forEach((otherQueryEditor) => {\n      if (otherQueryEditor.id !== queryEditor.id) {\n        dispatch(removeQueryEditor(otherQueryEditor));\n      }\n    });\n  };\n}\n\nexport function removeQuery(query) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n    SupersetClient.delete({\n      endpoint: encodeURI(\n        `/tabstateview/${query.sqlEditorId}/query/${query.id}`\n      )\n    }) :\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: REMOVE_QUERY, query })).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'An error occurred while removing query. Please contact your administrator.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function queryEditorSetDb(queryEditor, dbId) {\n  return { type: QUERY_EDITOR_SETDB, queryEditor, dbId };\n}\n\nexport function queryEditorSetCatalog(queryEditor, catalog) {\n  return {\n    type: QUERY_EDITOR_SET_CATALOG,\n    queryEditor: queryEditor || {},\n    catalog\n  };\n}\n\nexport function queryEditorSetSchema(queryEditor, schema) {\n  return {\n    type: QUERY_EDITOR_SET_SCHEMA,\n    queryEditor: queryEditor || {},\n    schema\n  };\n}\n\nexport function queryEditorSetAutorun(queryEditor, autorun) {\n  return { type: QUERY_EDITOR_SET_AUTORUN, queryEditor, autorun };\n}\n\nexport function queryEditorSetTitle(queryEditor, name, id) {\n  return {\n    type: QUERY_EDITOR_SET_TITLE,\n    queryEditor: { ...queryEditor, id },\n    name\n  };\n}\n\nexport function saveQuery(query, clientId) {\n  const { id, ...payload } = convertQueryToServer(query);\n\n  return (dispatch) =>\n  SupersetClient.post({\n    endpoint: '/api/v1/saved_query/',\n    jsonPayload: convertQueryToServer(payload)\n  }).\n  then((result) => {\n    const savedQuery = convertQueryToClient({\n      id: result.json.id,\n      ...result.json.result\n    });\n    dispatch({\n      type: QUERY_EDITOR_SAVED,\n      query,\n      clientId,\n      result: savedQuery\n    });\n    dispatch(queryEditorSetTitle(query, query.name, clientId));\n    return savedQuery;\n  }).\n  catch(() =>\n  dispatch(addDangerToast(t('Your query could not be saved')))\n  );\n}\n\nexport const addSavedQueryToTabState =\n(queryEditor, savedQuery) => (dispatch) => {\n  const sync = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n  SupersetClient.put({\n    endpoint: `/tabstateview/${queryEditor.id}`,\n    postPayload: { saved_query_id: savedQuery.remoteId }\n  }) :\n  Promise.resolve();\n\n  return sync.\n  catch(() => {\n    dispatch(addDangerToast(t('Your query was not properly saved')));\n  }).\n  then(() => {\n    dispatch(addSuccessToast(t('Your query was saved')));\n  });\n};\n\nexport function updateSavedQuery(query, clientId) {\n  const { id, ...payload } = convertQueryToServer(query);\n\n  return (dispatch) =>\n  SupersetClient.put({\n    endpoint: `/api/v1/saved_query/${query.remoteId}`,\n    jsonPayload: convertQueryToServer(payload)\n  }).\n  then(() => {\n    dispatch(addSuccessToast(t('Your query was updated')));\n    dispatch(queryEditorSetTitle(query, query.name, clientId));\n  }).\n  catch((e) => {\n    const message = t('Your query could not be updated');\n    // eslint-disable-next-line no-console\n    console.error(message, e);\n    dispatch(addDangerToast(message));\n  }).\n  then(() => dispatch(updateQueryEditor(query)));\n}\n\nexport function queryEditorSetSql(queryEditor, sql, queryId) {\n  return { type: QUERY_EDITOR_SET_SQL, queryEditor, sql, queryId };\n}\n\nexport function queryEditorSetCursorPosition(queryEditor, position) {\n  return { type: QUERY_EDITOR_SET_CURSOR_POSITION, queryEditor, position };\n}\n\nexport function queryEditorSetAndSaveSql(targetQueryEditor, sql, queryId) {\n  return function (dispatch, getState) {\n    const queryEditor = getUpToDateQuery(getState(), targetQueryEditor);\n    // saved query and set tab state use this action\n    dispatch(queryEditorSetSql(queryEditor, sql, queryId));\n    if (isFeatureEnabled(FeatureFlag.SqllabBackendPersistence)) {\n      return SupersetClient.put({\n        endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n        postPayload: { sql, latest_query_id: queryId }\n      }).catch(() =>\n      dispatch(\n        addDangerToast(\n          t(\n            'An error occurred while storing your query in the backend. To ' +\n            'avoid losing your changes, please save your query using the ' +\n            '\"Save Query\" button.'\n          )\n        )\n      )\n      );\n    }\n    return Promise.resolve();\n  };\n}\n\nexport function formatQuery(queryEditor) {\n  return function (dispatch, getState) {\n    const { sql } = getUpToDateQuery(getState(), queryEditor);\n    return SupersetClient.post({\n      endpoint: `/api/v1/sqllab/format_sql/`,\n      // TODO (betodealmeida): pass engine as a parameter for better formatting\n      body: JSON.stringify({ sql }),\n      headers: { 'Content-Type': 'application/json' }\n    }).then(({ json }) => {\n      dispatch(queryEditorSetSql(queryEditor, json.result));\n    });\n  };\n}\n\nexport function queryEditorSetQueryLimit(queryEditor, queryLimit) {\n  return {\n    type: QUERY_EDITOR_SET_QUERY_LIMIT,\n    queryEditor,\n    queryLimit\n  };\n}\n\nexport function queryEditorSetTemplateParams(queryEditor, templateParams) {\n  return {\n    type: QUERY_EDITOR_SET_TEMPLATE_PARAMS,\n    queryEditor,\n    templateParams\n  };\n}\n\nexport function queryEditorSetSelectedText(queryEditor, sql) {\n  return { type: QUERY_EDITOR_SET_SELECTED_TEXT, queryEditor, sql };\n}\n\nexport function mergeTable(table, query, prepend) {\n  return { type: MERGE_TABLE, table, query, prepend };\n}\n\nexport function addTable(queryEditor, tableName, catalogName, schemaName) {\n  return function (dispatch, getState) {\n    const { dbId } = getUpToDateQuery(getState(), queryEditor, queryEditor.id);\n    const table = {\n      dbId,\n      queryEditorId: queryEditor.id,\n      catalog: catalogName,\n      schema: schemaName,\n      name: tableName\n    };\n    dispatch(\n      mergeTable({\n        ...table,\n        id: nanoid(11),\n        expanded: true\n      })\n    );\n  };\n}\n\nexport function runTablePreviewQuery(newTable, runPreviewOnly) {\n  return function (dispatch, getState) {\n    const {\n      sqlLab: { databases }\n    } = getState();\n    const database = databases[newTable.dbId];\n    const { dbId, catalog, schema } = newTable;\n\n    if (database && !database.disable_data_preview) {var _newTable$previewQuer;\n      const dataPreviewQuery = {\n        id: (_newTable$previewQuer = newTable.previewQueryId) != null ? _newTable$previewQuer : nanoid(11),\n        dbId,\n        catalog,\n        schema,\n        sql: newTable.selectStar,\n        tableName: newTable.name,\n        sqlEditorId: null,\n        tab: '',\n        runAsync: database.allow_run_async,\n        ctas: false,\n        isDataPreview: true\n      };\n      if (runPreviewOnly) {\n        return dispatch(runQuery(dataPreviewQuery, runPreviewOnly));\n      }\n      return Promise.all([\n      dispatch(\n        mergeTable(\n          {\n            id: newTable.id,\n            dbId: newTable.dbId,\n            catalog: newTable.catalog,\n            schema: newTable.schema,\n            name: newTable.name,\n            queryEditorId: newTable.queryEditorId,\n            dataPreviewQueryId: dataPreviewQuery.id\n          },\n          dataPreviewQuery\n        )\n      ),\n      dispatch(runQuery(dataPreviewQuery))]\n      );\n    }\n    return Promise.resolve();\n  };\n}\n\nexport function syncTable(table, tableMetadata) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n    SupersetClient.post({\n      endpoint: encodeURI('/tableschemaview/'),\n      postPayload: { table: { ...tableMetadata, ...table } }\n    }) :\n    Promise.resolve({ json: { id: table.id } });\n\n    return sync.\n    then(({ json: resultJson }) => {\n      const newTable = { ...table, id: `${resultJson.id}` };\n      dispatch(\n        mergeTable({\n          ...newTable,\n          expanded: true,\n          initialized: true\n        })\n      );\n    }).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'An error occurred while fetching table metadata. ' +\n          'Please contact your administrator.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function changeDataPreviewId(oldQueryId, newQuery) {\n  return { type: CHANGE_DATA_PREVIEW_ID, oldQueryId, newQuery };\n}\n\nexport function reFetchQueryResults(query) {\n  return function (dispatch) {\n    const newQuery = {\n      id: nanoid(),\n      dbId: query.dbId,\n      sql: query.sql,\n      tableName: query.tableName,\n      sqlEditorId: null,\n      tab: '',\n      runAsync: false,\n      ctas: false,\n      queryLimit: query.queryLimit,\n      isDataPreview: query.isDataPreview\n    };\n    dispatch(runQuery(newQuery));\n    dispatch(changeDataPreviewId(query.id, newQuery));\n  };\n}\n\nexport function expandTable(table) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n    SupersetClient.post({\n      endpoint: encodeURI(`/tableschemaview/${table.id}/expanded`),\n      postPayload: { expanded: true }\n    }) :\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: EXPAND_TABLE, table })).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'An error occurred while expanding the table schema. ' +\n          'Please contact your administrator.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function collapseTable(table) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n    SupersetClient.post({\n      endpoint: encodeURI(`/tableschemaview/${table.id}/expanded`),\n      postPayload: { expanded: false }\n    }) :\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: COLLAPSE_TABLE, table })).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'An error occurred while collapsing the table schema. ' +\n          'Please contact your administrator.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function removeTables(tables) {\n  return function (dispatch) {var _tables$filter;\n    const tablesToRemove = (_tables$filter = tables == null ? void 0 : tables.filter(Boolean)) != null ? _tables$filter : [];\n    const sync = isFeatureEnabled(FeatureFlag.SqllabBackendPersistence) ?\n    Promise.all(\n      tablesToRemove.map((table) =>\n      table.initialized ?\n      SupersetClient.delete({\n        endpoint: encodeURI(`/tableschemaview/${table.id}`)\n      }) :\n      Promise.resolve()\n      )\n    ) :\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: REMOVE_TABLES, tables: tablesToRemove })).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'An error occurred while removing the table schema. ' +\n          'Please contact your administrator.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function refreshQueries(alteredQueries) {\n  return { type: REFRESH_QUERIES, alteredQueries };\n}\n\nexport function setUserOffline(offline) {\n  return { type: SET_USER_OFFLINE, offline };\n}\n\nexport function persistEditorHeight(queryEditor, northPercent, southPercent) {\n  return {\n    type: QUERY_EDITOR_PERSIST_HEIGHT,\n    queryEditor,\n    northPercent,\n    southPercent\n  };\n}\n\nexport function popPermalink(key) {\n  return function (dispatch) {\n    return SupersetClient.get({ endpoint: `/api/v1/sqllab/permalink/${key}` }).\n    then(({ json }) =>\n    dispatch(\n      addQueryEditor({\n        name: json.name ? json.name : t('Shared query'),\n        dbId: json.dbId ? parseInt(json.dbId, 10) : null,\n        catalog: json.catalog ? json.catalog : null,\n        schema: json.schema ? json.schema : null,\n        autorun: json.autorun ? json.autorun : false,\n        sql: json.sql ? json.sql : 'SELECT ...',\n        templateParams: json.templateParams\n      })\n    )\n    ).\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\n\nexport function popStoredQuery(urlId) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/sqllab/permalink/kv:${urlId}`\n    }).\n    then(({ json }) =>\n    dispatch(\n      addQueryEditor({\n        name: json.name ? json.name : t('Shared query'),\n        dbId: json.dbId ? parseInt(json.dbId, 10) : null,\n        catalog: json.catalog ? json.catalog : null,\n        schema: json.schema ? json.schema : null,\n        autorun: json.autorun ? json.autorun : false,\n        sql: json.sql ? json.sql : 'SELECT ...',\n        templateParams: json.templateParams\n      })\n    )\n    ).\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\nexport function popSavedQuery(saveQueryId) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/saved_query/${saveQueryId}`\n    }).\n    then(({ json }) => {\n      const queryEditorProps = {\n        ...convertQueryToClient(json.result),\n        loaded: true,\n        autorun: false\n      };\n      const tmpAdaptedProps = {\n        name: queryEditorProps.name,\n        dbId: queryEditorProps.database.id,\n        catalog: queryEditorProps.catalog,\n        schema: queryEditorProps.schema,\n        sql: queryEditorProps.sql,\n        templateParams: queryEditorProps.templateParams,\n        remoteId: queryEditorProps.remoteId\n      };\n      return dispatch(addQueryEditor(tmpAdaptedProps));\n    }).\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\nexport function popQuery(queryId) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/query/${queryId}`\n    }).\n    then(({ json }) => {\n      const queryData = json.result;\n      const queryEditorProps = {\n        dbId: queryData.database.id,\n        catalog: queryData.catalog,\n        schema: queryData.schema,\n        sql: queryData.sql,\n        name: t('Copy of %s', queryData.tab_name),\n        autorun: false\n      };\n      return dispatch(addQueryEditor(queryEditorProps));\n    }).\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\nexport function popDatasourceQuery(datasourceKey, sql) {\n  return function (dispatch) {\n    const QUERY_TEXT = t('Query');\n    const datasetId = datasourceKey.split('__')[0];\n\n    const queryParams = rison.encode({\n      keys: ['none'],\n      columns: ['name', 'schema', 'database.id', 'select_star']\n    });\n\n    return SupersetClient.get({\n      endpoint: `/api/v1/dataset/${datasetId}?q=${queryParams}`\n    }).\n    then(({ json }) =>\n    dispatch(\n      addQueryEditor({\n        name: `${QUERY_TEXT} ${json.result.name}`,\n        dbId: json.result.database.id,\n        schema: json.result.schema,\n        autorun: sql !== undefined,\n        sql: sql || json.result.select_star\n      })\n    )\n    ).\n    catch(() =>\n    dispatch(addDangerToast(t(\"The datasource couldn't be loaded\")))\n    );\n  };\n}\nexport function createDatasourceStarted() {\n  return { type: CREATE_DATASOURCE_STARTED };\n}\nexport function createDatasourceSuccess(data) {\n  const datasource = `${data.id}__table`;\n  return { type: CREATE_DATASOURCE_SUCCESS, datasource };\n}\nexport function createDatasourceFailed(err) {\n  return { type: CREATE_DATASOURCE_FAILED, err };\n}\n\nexport function createDatasource(vizOptions) {\n  return (dispatch) => {\n    dispatch(createDatasourceStarted());\n    const { dbId, catalog, schema, datasourceName, sql } = vizOptions;\n    return SupersetClient.post({\n      endpoint: '/api/v1/dataset/',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        database: dbId,\n        catalog,\n        schema,\n        sql,\n        table_name: datasourceName,\n        is_managed_externally: false,\n        external_url: null\n      })\n    }).\n    then(({ json }) => {\n      dispatch(createDatasourceSuccess(json));\n\n      return Promise.resolve(json);\n    }).\n    catch((error) => {\n      getClientErrorObject(error).then((e) => {\n        dispatch(addDangerToast(e.error));\n      });\n      dispatch(\n        createDatasourceFailed(\n          t('An error occurred while creating the data source')\n        )\n      );\n\n      return Promise.reject();\n    });\n  };\n}\n\nexport function createCtasDatasource(vizOptions) {\n  return (dispatch) => {\n    dispatch(createDatasourceStarted());\n    return SupersetClient.post({\n      endpoint: '/api/v1/dataset/get_or_create/',\n      jsonPayload: vizOptions\n    }).\n    then(({ json }) => {\n      dispatch(createDatasourceSuccess(json.result));\n\n      return json.result;\n    }).\n    catch(() => {\n      const errorMsg = t('An error occurred while creating the data source');\n      dispatch(createDatasourceFailed(errorMsg));\n      return Promise.reject(new Error(errorMsg));\n    });\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}