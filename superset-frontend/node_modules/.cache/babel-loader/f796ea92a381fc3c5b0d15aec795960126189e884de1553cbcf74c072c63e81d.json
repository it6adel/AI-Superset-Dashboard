{"ast":null,"code":"/* [LICENSE TBD] */\n/* eslint-disable */\nexport default function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')'\n    );\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n      this,\n      [\n      'render',\n      'resize',\n      'highlight',\n      'brush',\n      'brushend',\n      'axesreorder'].\n      concat(d3.keys(__))\n    ),\n    w = function () {\n      return __.width - __.margin.right - __.margin.left;\n    },\n    h = function () {\n      return __.height - __.margin.top - __.margin.bottom;\n    },\n    flags = {\n      brushable: false,\n      reorderable: false,\n      axes: false,\n      interactive: false,\n      debug: false\n    },\n    xscale = d3.scale.ordinal(),\n    yscale = {},\n    dragging = {},\n    line = d3.svg.line(),\n    axis = d3.svg.axis().orient('left').ticks(5),\n    g, // groups for axes, brushes\n    ctx = {},\n    canvas = {},\n    clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n          domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n        scales.\n        map(function (p, i) {\n          return yscale[p].domain();\n        }).\n        reduce(function (a, b) {\n          return a.concat(b);\n        })\n      );\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n          d3.extent(__.data, function (d) {\n            return +d[k];\n          })\n        );\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n      $V([\n      centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n      centroids[0].e(2)]\n      )\n    );\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n      $V([\n      centroids[cols - 1].e(1) +\n      a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n      centroids[cols - 1].e(2)]\n      )\n    );\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n        cps[i].e(1),\n        cps[i].e(2),\n        cps[i + 1].e(1),\n        cps[i + 1].e(2),\n        cps[i + 2].e(1),\n        cps[i + 2].e(2)\n      );\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n        \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\"\n      );\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p])\n        );\n      } else {\n        ctx.lineTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p])\n        );\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n    pc,\n    axis,\n    'ticks',\n    'orient',\n    'tickValues',\n    'tickSubdivide',\n    'tickSize',\n    'tickPadding',\n    'tickFormat'\n  );\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n      'transform',\n      'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'\n    );\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n      'transform',\n      'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'\n    );\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n      d3.behavior.\n      drag().\n      on('dragstart', function (d) {\n        dragging[d] = this.__origin__ = xscale(d);\n      }).\n      on('drag', function (d) {\n        dragging[d] = Math.min(\n          w(),\n          Math.max(0, this.__origin__ += d3.event.dx)\n        );\n        __.dimensions.sort(function (a, b) {\n          return position(a) - position(b);\n        });\n        xscale.domain(__.dimensions);\n        pc.render();\n        g.attr('transform', function (d) {\n          return 'translate(' + position(d) + ')';\n        });\n      }).\n      on('dragend', function (d) {\n        // Let's see if the order has changed and send out an event if so.\n        var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n        while ((elem = elem.previousElementSibling) != null) ++i;\n        if (i !== j) {\n          events.axesreorder.call(pc, __.dimensions);\n          // We now also want to reorder the actual dom elements that represent\n          // the axes. That is, the g.dimension elements. If we don't do this,\n          // we get a weird and confusing transition when updateAxes is called.\n          // This is due to the fact that, initially the nth g.dimension element\n          // represents the nth axis. However, after a manual reordering,\n          // without reordering the dom elements, the nth dom elements no longer\n          // necessarily represents the nth axis.\n          //\n          // i is the original index of the dom element\n          // j is the new index of the dom element\n          if (i > j) {\n            // Element moved left\n            parent.insertBefore(this, parent.children[j - 1]);\n          } else {\n            // Element moved right\n            if (j + 1 < parent.children.length) {\n              parent.insertBefore(this, parent.children[j + 1]);\n            } else {\n              parent.appendChild(this);\n            }\n          }\n        }\n\n        delete this.__origin__;\n        delete dragging[d];\n        d3.select(this).\n        transition().\n        attr('transform', 'translate(' + xscale(d) + ')');\n        pc.render();\n      })\n    );\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    }\n  };\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        }\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n      strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n        id = strum.dims.i,\n        points = [strum.p1, strum.p2],\n        line = svg.selectAll('line#strum-' + id).data([strum]),\n        circles = svg.selectAll('circle#strum-' + id).data(points),\n        drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n          Math.max(strum.minX + 1, ev.x),\n          strum.maxX\n        );\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n          Math.max(strum.minX + 1, ev.x - __.margin.left),\n          strum.maxX\n        );\n        strum.p2[1] = Math.min(\n          Math.max(strum.minY, ev.y - __.margin.top),\n          strum.maxY\n        );\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n        p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n        m1 = 1 - width / p1[0],\n        b1 = p1[1] * (1 - m1),\n        m2 = 1 - width / p2[0],\n        b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n          y = p[1],\n          y1 = m1 * x + b1,\n          y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n        brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n          test = containmentTest(strum, strums.width(id)),\n          d1 = strum.dims.left,\n          d2 = strum.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n        svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')'\n      );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      }\n    };\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n      strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n        id = arc.dims.i,\n        points = [arc.p2, arc.p3],\n        line = svg.selectAll('line#arc-' + id).data([\n        { p1: arc.p1, p2: arc.p2 },\n        { p1: arc.p1, p2: arc.p3 }]\n        ),\n        circles = svg.selectAll('circle#arc-' + id).data(points),\n        drag = d3.behavior.drag(),\n        path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n          angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n          Math.max(arc.minX + 1, ev.x - __.margin.left),\n          arc.maxX\n        );\n        arc.p2[1] = Math.min(\n          Math.max(arc.minY, ev.y - __.margin.top),\n          arc.maxY\n        );\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n        brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n          test = containmentTest(arc),\n          d1 = arc.dims.left,\n          d2 = arc.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          a = arcs.width(id),\n          b = y1(d[d1]) - y2(d[d2]),\n          c = hypothenuse(a, b),\n          angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n        svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n          b = p1[1] - p2[1],\n          c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n          b = arc.p1[1] - arc.p2[1],\n          c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')'\n      );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')'\n    );\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n    _rate = 10, // number of calls per frame\n    _clear = function () {}, // clearing function\n    _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}