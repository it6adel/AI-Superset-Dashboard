{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useState, useEffect, useMemo, useCallback } from 'react';\nimport { css, isFeatureEnabled, FeatureFlag, styled, SupersetClient, t, VizType } from '@superset-ui/core';\nimport rison from 'rison';\nimport { useSingleViewResource } from 'src/views/CRUD/hooks';\nimport { InputNumber } from 'src/components/Input';\nimport { Switch } from 'src/components/Switch';\nimport Modal from 'src/components/Modal';\nimport Collapse from 'src/components/Collapse';\nimport TimezoneSelector from 'src/components/TimezoneSelector';\nimport { propertyComparator } from 'src/components/Select/utils';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport { AntdCheckbox, AsyncSelect, Select, TreeSelect } from 'src/components';\nimport TextAreaControl from 'src/explore/components/controls/TextAreaControl';\nimport { useCommonConf } from 'src/features/databases/state';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport { NotificationMethodOption, Sections, ContentType } from 'src/features/alerts/types';\nimport { useSelector } from 'react-redux';\nimport Icons from 'src/components/Icons';\nimport NumberInput from './components/NumberInput';\nimport { AlertReportCronScheduler } from './components/AlertReportCronScheduler';\nimport { NotificationMethod } from './components/NotificationMethod';\nimport ValidatedPanelHeader from './components/ValidatedPanelHeader';\nimport StyledPanel from './components/StyledPanel';\nimport { buildErrorTooltipMessage } from './buildErrorTooltipMessage';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst TIMEOUT_MIN = 1;\nconst TEXT_BASED_VISUALIZATION_TYPES = [\nVizType.PivotTable,\n'table',\nVizType.PairedTTest];\n\nconst DEFAULT_WORKING_TIMEOUT = 3600;\nconst DEFAULT_CRON_VALUE = '0 0 * * *'; // every day\nconst DEFAULT_RETENTION = 90;\nconst EMAIL_REGEX = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\nconst DEFAULT_NOTIFICATION_METHODS = [\nNotificationMethodOption.Email];\n\nconst DEFAULT_NOTIFICATION_FORMAT = 'PNG';\nconst DEFAULT_EXTRA_DASHBOARD_OPTIONS = {\n  dashboard: {\n    anchor: ''\n  }\n};\nconst CONDITIONS = [\n{\n  label: t('< (Smaller than)'),\n  value: '<'\n},\n{\n  label: t('> (Larger than)'),\n  value: '>'\n},\n{\n  label: t('<= (Smaller or equal)'),\n  value: '<='\n},\n{\n  label: t('>= (Larger or equal)'),\n  value: '>='\n},\n{\n  label: t('== (Is equal)'),\n  value: '=='\n},\n{\n  label: t('!= (Is not equal)'),\n  value: '!='\n},\n{\n  label: t('Not null'),\n  value: 'not null'\n}];\n\nconst RETENTION_OPTIONS = [\n{\n  label: t('None'),\n  value: 0\n},\n{\n  label: t('30 days'),\n  value: 30\n},\n{\n  label: t('60 days'),\n  value: 60\n},\n{\n  label: t('90 days'),\n  value: 90\n}];\n\nconst CONTENT_TYPE_OPTIONS = [\n{\n  label: t('Dashboard'),\n  value: 'dashboard'\n},\n{\n  label: t('Chart'),\n  value: 'chart'\n}];\n\nconst FORMAT_OPTIONS = {\n  pdf: {\n    label: t('Send as PDF'),\n    value: 'PDF'\n  },\n  png: {\n    label: t('Send as PNG'),\n    value: 'PNG'\n  },\n  csv: {\n    label: t('Send as CSV'),\n    value: 'CSV'\n  },\n  txt: {\n    label: t('Send as text'),\n    value: 'TEXT'\n  }\n};\n// Apply to final text input components of each collapse panel\nconst noMarginBottom = css`\n  margin-bottom: 0;\n`;\n/*\nHeight of modal body defined here, total width defined at component invocation as antd prop.\n */\nconst StyledModal = styled(Modal)`\n  .antd5-modal-body {\n    height: 720px;\n  }\n\n  .control-label {\n    margin-top: ${({ theme }) => theme.gridUnit}px;\n  }\n\n  .ant-collapse > .ant-collapse-item {\n    border-bottom: none;\n  }\n\n  .inline-container {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    &.wrap {\n      flex-wrap: wrap;\n    }\n\n    > div {\n      flex: 1 1 auto;\n    }\n  }\n`;\nconst StyledTreeSelect = styled(TreeSelect)`\n  width: 100%;\n`;\nconst StyledSwitchContainer = styled.div`\n  display: flex;\n  align-items: center;\n  margin-top: 10px;\n\n  .switch-label {\n    margin-left: 10px;\n  }\n`;\nexport const StyledInputContainer = styled.div`\n  ${({ theme }) => css`\n    flex: 1;\n    margin-top: 0px;\n    margin-bottom: ${theme.gridUnit * 4}px;\n\n    input::-webkit-outer-spin-button,\n    input::-webkit-inner-spin-button {\n      -webkit-appearance: none;\n      margin: 0;\n    }\n    input[type='number'] {\n      -moz-appearance: textfield;\n    }\n\n    .helper {\n      display: block;\n      color: ${theme.colors.grayscale.base};\n      font-size: ${theme.typography.sizes.s}px;\n      padding: ${theme.gridUnit}px 0;\n      text-align: left;\n    }\n\n    .required {\n      margin-left: ${theme.gridUnit / 2}px;\n      color: ${theme.colors.error.base};\n    }\n\n    .input-container {\n      display: flex;\n      align-items: center;\n\n      > div {\n        width: 100%;\n      }\n\n      label {\n        display: flex;\n        margin-right: ${theme.gridUnit * 2}px;\n      }\n\n      i {\n        margin: 0 ${theme.gridUnit}px;\n      }\n    }\n\n    input,\n    textarea {\n      flex: 1 1 auto;\n    }\n\n    input[disabled] {\n      color: ${theme.colors.grayscale.base};\n    }\n\n    textarea {\n      height: 300px;\n      resize: none;\n    }\n\n    input::placeholder,\n    textarea::placeholder {\n      color: ${theme.colors.grayscale.light1};\n    }\n\n    textarea,\n    input[type='text'],\n    input[type='number'] {\n      padding: ${theme.gridUnit}px ${theme.gridUnit * 2}px;\n      border-style: none;\n      border: 1px solid ${theme.colors.grayscale.light2};\n      border-radius: ${theme.gridUnit}px;\n\n      &[name='description'] {\n        flex: 1 1 auto;\n      }\n    }\n\n    .input-label {\n      margin-left: 10px;\n    }\n  `}\n`;\nconst StyledCheckbox = styled(AntdCheckbox)`\n  margin-top: ${({ theme }) => theme.gridUnit * 0}px;\n`;\nconst StyledTooltip = styled(InfoTooltipWithTrigger)`\n  margin-left: ${({ theme }) => theme.gridUnit}px;\n`;\n// Notification Method components\nconst StyledNotificationAddButton = styled.div`\n  ${({ theme }) => css`\n    color: ${theme.colors.primary.dark1};\n    cursor: pointer;\n\n    i {\n      margin-right: ${theme.gridUnit * 2}px;\n    }\n\n    &.disabled {\n      color: ${theme.colors.grayscale.light1};\n      cursor: default;\n    }\n  `}\n`;\nconst StyledNotificationMethodWrapper = styled.div`\n  .inline-container .input-container {\n    margin-left: 0;\n  }\n`;\nconst inputSpacer = (theme) => css`\n  margin-right: ${theme.gridUnit * 3}px;\n`;\nexport const TRANSLATIONS = {\n  // Panel titles\n  GENERAL_TITLE: t('General information'),\n  ALERT_CONDITION_TITLE: t('Alert condition'),\n  ALERT_CONTENTS_TITLE: t('Alert contents'),\n  REPORT_CONTENTS_TITLE: t('Report contents'),\n  SCHEDULE_TITLE: t('Schedule'),\n  NOTIFICATION_TITLE: t('Notification method'),\n  // Error text\n  NAME_ERROR_TEXT: t('name'),\n  OWNERS_ERROR_TEXT: t('owners'),\n  CONTENT_ERROR_TEXT: t('content type'),\n  DATABASE_ERROR_TEXT: t('database'),\n  SQL_ERROR_TEXT: t('sql'),\n  ALERT_CONDITION_ERROR_TEXT: t('alert condition'),\n  CRONTAB_ERROR_TEXT: t('crontab'),\n  WORKING_TIMEOUT_ERROR_TEXT: t('working timeout'),\n  RECIPIENTS_ERROR_TEXT: t('recipients'),\n  EMAIL_SUBJECT_ERROR_TEXT: t('email subject'),\n  EMAIL_VALIDATION_ERROR_TEXT: t('invalid email'),\n  ERROR_TOOLTIP_MESSAGE: t('Not all required fields are complete. Please provide the following:')\n};\nconst NotificationMethodAdd = ({ status = 'active', onClick }) => {\n  if (status === 'hidden') {\n    return null;\n  }\n  const checkStatus = () => {\n    if (status !== 'disabled') {\n      onClick();\n    }\n  };\n  return _jsxs(StyledNotificationAddButton, { className: status, onClick: checkStatus, children: [\n    _jsx(Icons.PlusOutlined, { iconSize: \"m\", css: (theme) => ({\n        margin: `auto ${theme.gridUnit * 2}px auto 0`,\n        verticalAlign: 'middle'\n      }) }),\n    status === 'active' ?\n    t('Add another notification method') :\n    t('Add delivery method')] }\n  );\n};\nconst AlertReportModal = ({ addDangerToast, onAdd, onHide, show, alert = null, isReport = false, addSuccessToast }) => {var _currentAlert$databas2, _currentAlert$databas3, _currentAlert$validat5, _currentAlert$validat6, _currentAlert$chart3, _currentAlert$chart4, _currentAlert$dashboa3, _currentAlert$dashboa4, _currentAlert$extra2, _currentAlert$extra2$;\n  const currentUser = useSelector((state) => state.user);\n  // Check config for alternate notification methods setting\n  const conf = useCommonConf();\n  const allowedNotificationMethods = (conf == null ? void 0 : conf.ALERT_REPORTS_NOTIFICATION_METHODS) || DEFAULT_NOTIFICATION_METHODS;\n  const [disableSave, setDisableSave] = useState(true);\n  const [currentAlert, setCurrentAlert] = useState();\n  const [isHidden, setIsHidden] = useState(true);\n  const [contentType, setContentType] = useState('dashboard');\n  const [reportFormat, setReportFormat] = useState(DEFAULT_NOTIFICATION_FORMAT);\n  const [forceScreenshot, setForceScreenshot] = useState(false);\n  const [isScreenshot, setIsScreenshot] = useState(false);\n  useEffect(() => {\n    setIsScreenshot(reportFormat === 'PNG');\n  }, [reportFormat]);\n  // Dropdown options\n  const [conditionNotNull, setConditionNotNull] = useState(false);\n  const [sourceOptions, setSourceOptions] = useState([]);\n  const [dashboardOptions, setDashboardOptions] = useState([]);\n  const [chartOptions, setChartOptions] = useState([]);\n  const [tabOptions, setTabOptions] = useState([]);\n  // Validation\n  const [validationStatus, setValidationStatus] = useState({\n    [Sections.General]: {\n      hasErrors: false,\n      name: TRANSLATIONS.GENERAL_TITLE,\n      errors: []\n    },\n    [Sections.Content]: {\n      hasErrors: false,\n      name: isReport ?\n      TRANSLATIONS.REPORT_CONTENTS_TITLE :\n      TRANSLATIONS.ALERT_CONTENTS_TITLE,\n      errors: []\n    },\n    [Sections.Alert]: {\n      hasErrors: false,\n      name: TRANSLATIONS.ALERT_CONDITION_TITLE,\n      errors: []\n    },\n    [Sections.Schedule]: {\n      hasErrors: false,\n      name: TRANSLATIONS.SCHEDULE_TITLE,\n      errors: []\n    },\n    [Sections.Notification]: {\n      hasErrors: false,\n      name: TRANSLATIONS.NOTIFICATION_TITLE,\n      errors: []\n    }\n  });\n  const [errorTooltipMessage, setErrorTooltipMessage] = useState('');\n  const updateValidationStatus = (section, errors) => {\n    setValidationStatus((currentValidationData) => ({\n      ...currentValidationData,\n      [section]: {\n        hasErrors: errors.length > 0,\n        name: currentValidationData[section].name,\n        errors\n      }\n    }));\n  };\n  // Chart metadata\n  const [chartVizType, setChartVizType] = useState('');\n  const reportOrAlert = isReport ? 'report' : 'alert';\n  const isEditMode = alert !== null;\n  const formatOptionEnabled = isFeatureEnabled(FeatureFlag.AlertsAttachReports) || isReport;\n  const tabsEnabled = isFeatureEnabled(FeatureFlag.AlertReportTabs);\n  const [notificationAddState, setNotificationAddState] = useState('active');\n  const [notificationSettings, setNotificationSettings] = useState([]);\n  const [emailSubject, setEmailSubject] = useState('');\n  const [emailError, setEmailError] = useState(false);\n  const onNotificationAdd = () => {\n    setNotificationSettings([\n    ...notificationSettings,\n    {\n      recipients: '',\n      // options shown in the newly added notification method\n      options: allowedNotificationMethods.filter(\n        // are filtered such that\n        (option) =>\n        // options are not included\n        !notificationSettings.reduce(\n          // when it exists in previous notificationSettings\n          (accum, setting) => accum || option === setting.method, false))\n    }]\n    );\n    setNotificationAddState(notificationSettings.length === allowedNotificationMethodsCount ?\n    'hidden' :\n    'disabled');\n  };\n  const { ALERT_REPORTS_DEFAULT_WORKING_TIMEOUT, ALERT_REPORTS_DEFAULT_CRON_VALUE, ALERT_REPORTS_DEFAULT_RETENTION } = useSelector((state) => {var _state$common, _conf$ALERT_REPORTS_D, _conf$ALERT_REPORTS_D2, _conf$ALERT_REPORTS_D3;\n    const conf = (_state$common = state.common) == null ? void 0 : _state$common.conf;\n    return {\n      ALERT_REPORTS_DEFAULT_WORKING_TIMEOUT: (_conf$ALERT_REPORTS_D = conf == null ? void 0 : conf.ALERT_REPORTS_DEFAULT_WORKING_TIMEOUT) != null ? _conf$ALERT_REPORTS_D : DEFAULT_WORKING_TIMEOUT,\n      ALERT_REPORTS_DEFAULT_CRON_VALUE: (_conf$ALERT_REPORTS_D2 = conf == null ? void 0 : conf.ALERT_REPORTS_DEFAULT_CRON_VALUE) != null ? _conf$ALERT_REPORTS_D2 : DEFAULT_CRON_VALUE,\n      ALERT_REPORTS_DEFAULT_RETENTION: (_conf$ALERT_REPORTS_D3 = conf == null ? void 0 : conf.ALERT_REPORTS_DEFAULT_RETENTION) != null ? _conf$ALERT_REPORTS_D3 : DEFAULT_RETENTION\n    };\n  });\n  const defaultAlert = {\n    active: true,\n    creation_method: 'alerts_reports',\n    crontab: ALERT_REPORTS_DEFAULT_CRON_VALUE,\n    extra: DEFAULT_EXTRA_DASHBOARD_OPTIONS,\n    log_retention: ALERT_REPORTS_DEFAULT_RETENTION,\n    working_timeout: ALERT_REPORTS_DEFAULT_WORKING_TIMEOUT,\n    name: '',\n    owners: [],\n    recipients: [],\n    sql: '',\n    email_subject: '',\n    validator_config_json: {},\n    validator_type: '',\n    force_screenshot: false,\n    grace_period: undefined\n  };\n  const updateNotificationSetting = (index, setting) => {\n    const settings = [...notificationSettings];\n    settings[index] = setting;\n    // if you've changed notification method -> remove trailing methods\n    if (notificationSettings[index].method !== setting.method) {\n      notificationSettings[index] = setting;\n      setNotificationSettings(notificationSettings.filter((_, idx) => idx <= index));\n      if (notificationSettings.length - 1 > index) {\n        setNotificationAddState('active');\n      }\n      if (setting.method !== undefined && notificationAddState !== 'hidden') {\n        setNotificationAddState('active');\n      }\n    } else\n    {\n      setNotificationSettings(settings);\n    }\n  };\n  const removeNotificationSetting = (index) => {\n    const settings = notificationSettings.slice();\n    settings.splice(index, 1);\n    setNotificationSettings(settings);\n    setNotificationAddState('active');\n  };\n  const updateAnchorState = (value) => {\n    setCurrentAlert((currentAlertData) => {var _currentAlertData$ext;\n      const dashboardState = currentAlertData == null ? void 0 : (_currentAlertData$ext = currentAlertData.extra) == null ? void 0 : _currentAlertData$ext.dashboard;\n      const extra = {\n        dashboard: {\n          ...dashboardState,\n          anchor: value\n        }\n      };\n      return {\n        ...currentAlertData,\n        extra\n      };\n    });\n  };\n  // Alert fetch logic\n  const { state: { loading, resource, error: fetchError }, fetchResource, createResource, updateResource, clearError } = useSingleViewResource('report', t('report'), addDangerToast);\n  // Functions\n  const hide = () => {\n    clearError();\n    setIsHidden(true);\n    onHide();\n    setNotificationSettings([]);\n    setCurrentAlert({ ...defaultAlert });\n    setNotificationAddState('active');\n  };\n  const onSave = () => {var _currentAlert$chart, _currentAlert$dashboa, _currentAlert$databas;\n    // Notification Settings\n    const recipients = [];\n    notificationSettings.forEach((setting) => {\n      if (setting.method && setting.recipients.length) {\n        recipients.push({\n          recipient_config_json: {\n            target: setting.recipients,\n            ccTarget: setting.cc,\n            bccTarget: setting.bcc\n          },\n          type: setting.method\n        });\n      }\n    });\n    const shouldEnableForceScreenshot = contentType === ContentType.Chart && !isReport;\n    const data = {\n      ...currentAlert,\n      type: isReport ? 'Report' : 'Alert',\n      force_screenshot: shouldEnableForceScreenshot || forceScreenshot,\n      validator_type: conditionNotNull ? 'not null' : 'operator',\n      validator_config_json: conditionNotNull ?\n      {} :\n      currentAlert == null ? void 0 : currentAlert.validator_config_json,\n      chart: contentType === ContentType.Chart ? currentAlert == null ? void 0 : (_currentAlert$chart = currentAlert.chart) == null ? void 0 : _currentAlert$chart.value : null,\n      dashboard: contentType === ContentType.Dashboard ?\n      currentAlert == null ? void 0 : (_currentAlert$dashboa = currentAlert.dashboard) == null ? void 0 : _currentAlert$dashboa.value :\n      null,\n      custom_width: isScreenshot ? currentAlert == null ? void 0 : currentAlert.custom_width : undefined,\n      database: currentAlert == null ? void 0 : (_currentAlert$databas = currentAlert.database) == null ? void 0 : _currentAlert$databas.value,\n      owners: ((currentAlert == null ? void 0 : currentAlert.owners) || []).map((owner) => owner.value || owner.id),\n      recipients,\n      report_format: reportFormat || DEFAULT_NOTIFICATION_FORMAT,\n      extra: contentType === ContentType.Dashboard ? currentAlert == null ? void 0 : currentAlert.extra : {}\n    };\n    if (data.recipients && !data.recipients.length) {\n      delete data.recipients;\n    }\n    data.context_markdown = 'string';\n    if (isEditMode) {\n      // Edit\n      if (currentAlert != null && currentAlert.id) {\n        const update_id = currentAlert.id;\n        delete data.id;\n        delete data.created_by;\n        delete data.last_eval_dttm;\n        delete data.last_state;\n        delete data.last_value;\n        delete data.last_value_row_json;\n        updateResource(update_id, data).then((response) => {\n          if (!response) {\n            return;\n          }\n          addSuccessToast(t('%s updated', data.type));\n          if (onAdd) {\n            onAdd();\n          }\n          hide();\n        });\n      }\n    } else\n    if (currentAlert) {\n      // Create\n      createResource(data).then((response) => {\n        if (!response) {\n          return;\n        }\n        addSuccessToast(t('%s updated', data.type));\n        if (onAdd) {\n          onAdd(response);\n        }\n        hide();\n      });\n    }\n  };\n  // Fetch data to populate form dropdowns\n  const loadOwnerOptions = useMemo(() => (input = '', page, pageSize) => {\n    const query = rison.encode({\n      filter: input,\n      page,\n      page_size: pageSize\n    });\n    return SupersetClient.get({\n      endpoint: `/api/v1/report/related/created_by?q=${query}`\n    }).then((response) => ({\n      data: response.json.result.map((item) => ({\n        value: item.value,\n        label: item.text\n      })),\n      totalCount: response.json.count\n    }));\n  }, []);\n  const getSourceData = useCallback((db) => {\n    const database = db || (currentAlert == null ? void 0 : currentAlert.database);\n    if (!database || database.label) {\n      return null;\n    }\n    let result;\n    // Cycle through source options to find the selected option\n    sourceOptions.forEach((source) => {\n      if (source.value === database.value || source.value === database.id) {\n        result = source;\n      }\n    });\n    return result;\n  }, [currentAlert == null ? void 0 : currentAlert.database, sourceOptions]);\n  // Updating alert/report state\n  const updateAlertState = (name, value) => {\n    setCurrentAlert((currentAlertData) => ({\n      ...currentAlertData,\n      [name]: value\n    }));\n  };\n  const loadSourceOptions = useMemo(() => (input = '', page, pageSize) => {\n    const query = rison.encode({\n      filter: input,\n      page,\n      page_size: pageSize\n    });\n    return SupersetClient.get({\n      endpoint: `/api/v1/report/related/database?q=${query}`\n    }).then((response) => {\n      const list = response.json.result.map((item) => ({\n        value: item.value,\n        label: item.text\n      }));\n      setSourceOptions(list);\n      return { data: list, totalCount: response.json.count };\n    });\n  }, []);\n  const dashboard = currentAlert == null ? void 0 : currentAlert.dashboard;\n  useEffect(() => {\n    if (!tabsEnabled)\n    return;\n    if (dashboard != null && dashboard.value) {\n      SupersetClient.get({\n        endpoint: `/api/v1/dashboard/${dashboard.value}/tabs`\n      }).\n      then((response) => {var _currentAlert$extra, _currentAlert$extra$d;\n        const { tab_tree: tabTree, all_tabs: allTabs } = response.json.result;\n        const allTabsWithOrder = tabTree.map((tab) => tab.value);\n        // Only show all tabs when there are more than one tab\n        if (allTabsWithOrder.length > 1) {\n          tabTree.push({\n            title: 'All Tabs',\n            // select tree only works with string value\n            value: JSON.stringify(allTabsWithOrder)\n          });\n        }\n        setTabOptions(tabTree);\n        const anchor = currentAlert == null ? void 0 : (_currentAlert$extra = currentAlert.extra) == null ? void 0 : (_currentAlert$extra$d = _currentAlert$extra.dashboard) == null ? void 0 : _currentAlert$extra$d.anchor;\n        if (anchor) {\n          try {\n            const parsedAnchor = JSON.parse(anchor);\n            if (Array.isArray(parsedAnchor)) {\n              // Check if all elements in parsedAnchor list are in allTabs\n              const isValidSubset = parsedAnchor.every((tab) => tab in allTabs);\n              if (!isValidSubset) {\n                updateAnchorState(undefined);\n              }\n            } else\n            {\n              throw new Error('Parsed value is not an array');\n            }\n          }\n          catch (error) {\n            if (!(anchor in allTabs)) {\n              updateAnchorState(undefined);\n            }\n          }\n        }\n      }).\n      catch(() => {\n        addDangerToast(t('There was an error retrieving dashboard tabs.'));\n      });\n    }\n  }, [dashboard, tabsEnabled, currentAlert == null ? void 0 : currentAlert.extra, addDangerToast]);\n  const databaseLabel = (currentAlert == null ? void 0 : currentAlert.database) && !currentAlert.database.label;\n  useEffect(() => {\n    // Find source if current alert has one set\n    if (databaseLabel) {\n      updateAlertState('database', getSourceData());\n    }\n  }, [databaseLabel, getSourceData]);\n  const loadDashboardOptions = useMemo(() => (input = '', page, pageSize) => {\n    const query = rison.encode_uri({\n      filter: input,\n      page,\n      page_size: pageSize\n    });\n    return SupersetClient.get({\n      endpoint: `/api/v1/report/related/dashboard?q=${query}`\n    }).then((response) => {\n      const list = response.json.result.map((item) => ({\n        value: item.value,\n        label: item.text\n      }));\n      setDashboardOptions(list);\n      return { data: list, totalCount: response.json.count };\n    });\n  }, []);\n  const getDashboardData = (db) => {\n    const dashboard = db || (currentAlert == null ? void 0 : currentAlert.dashboard);\n    if (!dashboard || dashboard.label) {\n      return null;\n    }\n    let result;\n    // Cycle through dashboard options to find the selected option\n    dashboardOptions.forEach((dash) => {\n      if (dash.value === dashboard.value || dash.value === dashboard.id) {\n        result = dash;\n      }\n    });\n    return result;\n  };\n  const getChartData = useCallback((chartData) => {\n    const chart = chartData || (currentAlert == null ? void 0 : currentAlert.chart);\n    if (!chart || chart.label) {\n      return null;\n    }\n    let result;\n    // Cycle through chart options to find the selected option\n    chartOptions.forEach((slice) => {\n      if (slice.value === chart.value || slice.value === chart.id) {\n        result = slice;\n      }\n    });\n    return result;\n  }, [chartOptions, currentAlert == null ? void 0 : currentAlert.chart]);\n  const noChartLabel = (currentAlert == null ? void 0 : currentAlert.chart) && !(currentAlert != null && currentAlert.chart.label);\n  useEffect(() => {\n    // Find source if current alert has one set\n    if (noChartLabel) {\n      updateAlertState('chart', getChartData());\n    }\n  }, [getChartData, noChartLabel]);\n  const loadChartOptions = useMemo(() => (input = '', page, pageSize) => {\n    const query = rison.encode_uri({\n      filter: input,\n      page,\n      page_size: pageSize\n    });\n    return SupersetClient.get({\n      endpoint: `/api/v1/report/related/chart?q=${query}`\n    }).then((response) => {\n      const list = response.json.result.map((item) => ({\n        value: item.value,\n        label: item.text\n      }));\n      setChartOptions(list);\n      return { data: list, totalCount: response.json.count };\n    });\n  }, []);\n  const getChartVisualizationType = (chart) => SupersetClient.get({\n    endpoint: `/api/v1/chart/${chart.value}`\n  }).then((response) => setChartVizType(response.json.result.viz_type));\n  const updateEmailSubject = () => {var _currentAlert$chart2, _currentAlert$dashboa2;\n    const chartLabel = currentAlert == null ? void 0 : (_currentAlert$chart2 = currentAlert.chart) == null ? void 0 : _currentAlert$chart2.label;\n    const dashboardLabel = currentAlert == null ? void 0 : (_currentAlert$dashboa2 = currentAlert.dashboard) == null ? void 0 : _currentAlert$dashboa2.label;\n    if (!(currentAlert != null && currentAlert.name)) {\n      setEmailSubject('');\n      return;\n    }\n    switch (contentType) {\n      case ContentType.Chart:\n        setEmailSubject(`${currentAlert == null ? void 0 : currentAlert.name}: ${chartLabel || ''}`);\n        break;\n      case ContentType.Dashboard:\n        setEmailSubject(`${currentAlert == null ? void 0 : currentAlert.name}: ${dashboardLabel || ''}`);\n        break;\n      default:\n        setEmailSubject('');\n    }\n  };\n  // Handle input/textarea updates\n  const onInputChange = (event) => {\n    const { target: { type, value, name } } = event;\n    const parsedValue = type === 'number' ? parseInt(value, 10) || null : value;\n    updateAlertState(name, parsedValue);\n    if (name === 'name') {\n      updateEmailSubject();\n    }\n  };\n  const onCustomWidthChange = (value) => {\n    const numValue = value === null ||\n    value === undefined ||\n    typeof value === 'string' && Number.isNaN(Number(value)) ?\n    null :\n    Number(value);\n    updateAlertState('custom_width', numValue);\n  };\n  const onTimeoutVerifyChange = (event) => {\n    const { target } = event;\n    const value = +target.value;\n    // Need to make sure grace period is not lower than TIMEOUT_MIN\n    if (value === 0) {\n      updateAlertState(target.name, undefined);\n    } else\n    {\n      updateAlertState(target.name, value ? Math.max(value, TIMEOUT_MIN) : value);\n    }\n  };\n  const onSQLChange = (value) => {\n    updateAlertState('sql', value || '');\n  };\n  const onOwnersChange = (value) => {\n    updateAlertState('owners', value || []);\n  };\n  const onSourceChange = (value) => {\n    updateAlertState('database', value || []);\n  };\n  const onDashboardChange = (dashboard) => {\n    updateAlertState('dashboard', dashboard || undefined);\n    updateAlertState('chart', null);\n    if (tabsEnabled) {\n      setTabOptions([]);\n      updateAnchorState('');\n    }\n  };\n  const onChartChange = (chart) => {\n    getChartVisualizationType(chart);\n    updateAlertState('chart', chart || undefined);\n    updateAlertState('dashboard', null);\n  };\n  const onActiveSwitch = (checked) => {\n    updateAlertState('active', checked);\n  };\n  const onConditionChange = (op) => {var _currentAlert$validat;\n    setConditionNotNull(op === 'not null');\n    const config = {\n      op,\n      threshold: currentAlert ? (_currentAlert$validat =\n      currentAlert.validator_config_json) == null ? void 0 : _currentAlert$validat.threshold :\n      undefined\n    };\n    updateAlertState('validator_config_json', config);\n  };\n  const onThresholdChange = (event) => {var _currentAlert$validat2;\n    const { target } = event;\n    const config = {\n      op: currentAlert ? (_currentAlert$validat2 = currentAlert.validator_config_json) == null ? void 0 : _currentAlert$validat2.op : undefined,\n      threshold: target.value\n    };\n    updateAlertState('validator_config_json', config);\n  };\n  const onLogRetentionChange = (retention) => {\n    updateAlertState('log_retention', retention);\n  };\n  const onTimezoneChange = (timezone) => {\n    updateAlertState('timezone', timezone);\n  };\n  const onContentTypeChange = (value) => {\n    // When switch content type, reset force_screenshot to false\n    setForceScreenshot(false);\n    setContentType(value);\n  };\n  const onFormatChange = (value) => {\n    setReportFormat(value);\n  };\n  const onForceScreenshotChange = (event) => {\n    setForceScreenshot(event.target.checked);\n  };\n  // Make sure notification settings has the required info\n  const checkNotificationSettings = () => {\n    if (!notificationSettings.length) {\n      return false;\n    }\n    let hasInfo = false;\n    notificationSettings.forEach((setting) => {var _setting$recipients;\n      if (!!setting.method && (_setting$recipients = setting.recipients) != null && _setting$recipients.length) {\n        hasInfo = true;\n      }\n    });\n    return hasInfo;\n  };\n  const checkEmailFormat = () => {\n    if (!notificationSettings.length) {\n      return true;\n    }\n    const validateEmails = (emails) => {\n      if (!emails)\n      return true; // No emails to validate\n      return emails.\n      split(/[,;]/).\n      every((email) => EMAIL_REGEX.test(email.trim()));\n    };\n    // Use array method to check conditions\n    return notificationSettings.every((setting) => {\n      if (!!setting.method && setting.method === 'Email') {var _setting$recipients2;\n        return (!((_setting$recipients2 = setting.recipients) != null && _setting$recipients2.length) || validateEmails(setting.recipients)) && (\n        !setting.cc || validateEmails(setting.cc)) && (\n        !setting.bcc || validateEmails(setting.bcc));\n      }\n      return true; // Non-Email methods are considered valid\n    });\n  };\n  const validateGeneralSection = () => {var _currentAlert$name, _currentAlert$owners;\n    const errors = [];\n    if (!(currentAlert != null && (_currentAlert$name = currentAlert.name) != null && _currentAlert$name.length)) {\n      errors.push(TRANSLATIONS.NAME_ERROR_TEXT);\n    }\n    if (!(currentAlert != null && (_currentAlert$owners = currentAlert.owners) != null && _currentAlert$owners.length)) {\n      errors.push(TRANSLATIONS.OWNERS_ERROR_TEXT);\n    }\n    updateValidationStatus(Sections.General, errors);\n  };\n  const validateContentSection = () => {\n    const errors = [];\n    if (!(contentType === ContentType.Dashboard && !!(currentAlert != null && currentAlert.dashboard) ||\n    contentType === ContentType.Chart && !!(currentAlert != null && currentAlert.chart))) {\n      errors.push(TRANSLATIONS.CONTENT_ERROR_TEXT);\n    }\n    updateValidationStatus(Sections.Content, errors);\n  };\n  const validateAlertSection = () => {var _currentAlert$sql, _currentAlert$validat3, _currentAlert$validat4;\n    const errors = [];\n    if (!(currentAlert != null && currentAlert.database)) {\n      errors.push(TRANSLATIONS.DATABASE_ERROR_TEXT);\n    }\n    if (!(currentAlert != null && (_currentAlert$sql = currentAlert.sql) != null && _currentAlert$sql.length)) {\n      errors.push(TRANSLATIONS.SQL_ERROR_TEXT);\n    }\n    if (!((conditionNotNull || !!(currentAlert != null && (_currentAlert$validat3 = currentAlert.validator_config_json) != null && _currentAlert$validat3.op)) && (\n    conditionNotNull ||\n    (currentAlert == null ? void 0 : (_currentAlert$validat4 = currentAlert.validator_config_json) == null ? void 0 : _currentAlert$validat4.threshold) !== undefined))) {\n      errors.push(TRANSLATIONS.ALERT_CONDITION_ERROR_TEXT);\n    }\n    updateValidationStatus(Sections.Alert, errors);\n  };\n  const validateScheduleSection = () => {var _currentAlert$crontab;\n    const errors = [];\n    if (!(currentAlert != null && (_currentAlert$crontab = currentAlert.crontab) != null && _currentAlert$crontab.length)) {\n      errors.push(TRANSLATIONS.CRONTAB_ERROR_TEXT);\n    }\n    if (!(currentAlert != null && currentAlert.working_timeout)) {\n      errors.push(TRANSLATIONS.WORKING_TIMEOUT_ERROR_TEXT);\n    }\n    updateValidationStatus(Sections.Schedule, errors);\n  };\n  const validateNotificationSection = () => {\n    const errors = [];\n    const hasErrors = !checkNotificationSettings();\n    if (hasErrors) {\n      errors.push(TRANSLATIONS.RECIPIENTS_ERROR_TEXT);\n    } else\n    {\n      // Check for email format errors\n      const hasValidationErrors = !checkEmailFormat();\n      if (hasValidationErrors) {\n        errors.push(TRANSLATIONS.EMAIL_VALIDATION_ERROR_TEXT);\n      }\n    }\n    if (emailError) {\n      errors.push(TRANSLATIONS.EMAIL_SUBJECT_ERROR_TEXT);\n    }\n    // Update validation status with combined errors\n    updateValidationStatus(Sections.Notification, errors);\n  };\n  const validateAll = () => {\n    validateGeneralSection();\n    validateContentSection();\n    if (!isReport)\n    validateAlertSection();\n    validateScheduleSection();\n    validateNotificationSection();\n  };\n  const enforceValidation = () => {\n    const sections = [\n    Sections.General,\n    Sections.Content,\n    isReport ? undefined : Sections.Alert,\n    Sections.Schedule,\n    Sections.Notification];\n\n    const hasErrors = sections.some((section) => section && validationStatus[section].hasErrors);\n    const tooltip = hasErrors ? buildErrorTooltipMessage(validationStatus) : '';\n    setErrorTooltipMessage(tooltip);\n    setDisableSave(hasErrors);\n  };\n  // Initialize\n  useEffect(() => {\n    if (isEditMode && (\n    !(currentAlert != null && currentAlert.id) || (alert == null ? void 0 : alert.id) !== currentAlert.id || isHidden && show)) {\n      if ((alert == null ? void 0 : alert.id) !== null && !loading && !fetchError) {\n        const id = alert.id || 0;\n        fetchResource(id);\n      }\n    } else\n    if (!isEditMode && (\n    !currentAlert || currentAlert.id || isHidden && show)) {\n      setCurrentAlert({\n        ...defaultAlert,\n        owners: currentUser ?\n        [\n        {\n          value: currentUser.userId,\n          label: `${currentUser.firstName} ${currentUser.lastName}`\n        }] :\n\n        []\n      });\n      setNotificationSettings([\n      {\n        recipients: '',\n        cc: '',\n        bcc: '',\n        options: allowedNotificationMethods,\n        method: NotificationMethodOption.Email\n      }]\n      );\n      setNotificationAddState('active');\n    }\n  }, [alert]);\n  useEffect(() => {\n    if (resource) {\n      // Add notification settings\n      const settings = (resource.recipients || []).map((setting) => {\n        const config = typeof setting.recipient_config_json === 'string' ?\n        JSON.parse(setting.recipient_config_json) :\n        {};\n        return {\n          method: setting.type,\n          // @ts-ignore: Type not assignable\n          recipients: config.target || setting.recipient_config_json,\n          options: allowedNotificationMethods,\n          cc: config.ccTarget || '',\n          bcc: config.bccTarget || ''\n        };\n      });\n      setNotificationSettings(settings);\n      setNotificationAddState(settings.length === allowedNotificationMethods.length ?\n      'hidden' :\n      'active');\n      setContentType(resource.chart ? ContentType.Chart : ContentType.Dashboard);\n      setReportFormat(resource.report_format || DEFAULT_NOTIFICATION_FORMAT);\n      const validatorConfig = typeof resource.validator_config_json === 'string' ?\n      JSON.parse(resource.validator_config_json) :\n      resource.validator_config_json;\n      setConditionNotNull(resource.validator_type === 'not null');\n      if (resource.chart) {\n        setChartVizType(resource.chart.viz_type);\n      }\n      setForceScreenshot(resource.force_screenshot);\n      setCurrentAlert({\n        ...resource,\n        chart: resource.chart ?\n        getChartData(resource.chart) || {\n          value: resource.chart.id,\n          label: resource.chart.slice_name\n        } :\n        undefined,\n        dashboard: resource.dashboard ?\n        getDashboardData(resource.dashboard) || {\n          value: resource.dashboard.id,\n          label: resource.dashboard.dashboard_title\n        } :\n        undefined,\n        database: resource.database ?\n        getSourceData(resource.database) || {\n          value: resource.database.id,\n          label: resource.database.database_name\n        } :\n        undefined,\n        owners: ((alert == null ? void 0 : alert.owners) || []).map((owner) => ({\n          value: owner.value || owner.id,\n          label: owner.label ||\n          `${owner.first_name} ${owner.last_name}`\n        })),\n        // @ts-ignore: Type not assignable\n        validator_config_json: resource.validator_type === 'not null' ?\n        {\n          op: 'not null'\n        } :\n        validatorConfig\n      });\n    }\n  }, [resource]);\n  // Validation\n  const currentAlertSafe = currentAlert || {};\n  useEffect(() => {\n    validateAll();\n    updateEmailSubject();\n  }, [\n  currentAlertSafe.name,\n  currentAlertSafe.owners,\n  currentAlertSafe.database,\n  currentAlertSafe.sql,\n  currentAlertSafe.validator_config_json,\n  currentAlertSafe.crontab,\n  currentAlertSafe.working_timeout,\n  currentAlertSafe.dashboard,\n  currentAlertSafe.chart,\n  contentType,\n  notificationSettings,\n  conditionNotNull,\n  emailError]\n  );\n  useEffect(() => {\n    enforceValidation();\n  }, [validationStatus]);\n  const allowedNotificationMethodsCount = useMemo(() => allowedNotificationMethods.reduce((accum, setting) => {\n    if (accum.some((nm) => nm.includes('slack')) &&\n    setting.toLowerCase().includes('slack')) {\n      return accum;\n    }\n    return [...accum, setting.toLowerCase()];\n  }, []).length, [allowedNotificationMethods]);\n  // Show/hide\n  if (isHidden && show) {\n    setIsHidden(false);\n  }\n  const getTitleText = () => {\n    let titleText;\n    switch (true) {\n      case isEditMode && isReport:\n        titleText = t('Edit Report');\n        break;\n      case isEditMode:\n        titleText = t('Edit Alert');\n        break;\n      case isReport:\n        titleText = t('Add Report');\n        break;\n      default:\n        titleText = t('Add Alert');\n        break;\n    }\n    return titleText;\n  };\n  const handleErrorUpdate = (hasError) => {\n    setEmailError(hasError);\n  };\n  return _jsx(StyledModal, { className: \"no-content-padding\", responsive: true, disablePrimaryButton: disableSave, primaryTooltipMessage: errorTooltipMessage, onHandledPrimaryAction: onSave, onHide: hide, primaryButtonName: isEditMode ? t('Save') : t('Add'), show: show, width: \"500px\", centered: true, title: _jsx(\"h4\", { children: getTitleText() }), children:\n    _jsxs(Collapse, { expandIconPosition: \"right\", defaultActiveKey: \"general\", accordion: true, css: css`\n          border: 'none';\n        `, children: [\n      _jsx(StyledPanel, { header: _jsx(ValidatedPanelHeader, { title: TRANSLATIONS.GENERAL_TITLE, subtitle: t('Set up basic details, such as name and description.'), validateCheckStatus: !validationStatus[Sections.General].hasErrors, testId: \"general-information-panel\" }), children:\n        _jsxs(\"div\", { className: \"header-section\", children: [\n          _jsxs(StyledInputContainer, { children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              isReport ? t('Report name') : t('Alert name'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(\"input\", { type: \"text\", name: \"name\", value: currentAlert ? currentAlert.name : '', placeholder: isReport ? t('Enter report name') : t('Enter alert name'), onChange: onInputChange }) }\n            )] }\n          ),\n          _jsxs(StyledInputContainer, { children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              t('Owners'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(AsyncSelect, { ariaLabel: t('Owners'), allowClear: true, name: \"owners\", mode: \"multiple\", placeholder: t('Select owners'), value: (currentAlert == null ? void 0 : currentAlert.owners) || [], options: loadOwnerOptions, onChange: onOwnersChange }) }\n            )] }\n          ),\n          _jsxs(StyledInputContainer, { children: [\n            _jsx(\"div\", { className: \"control-label\", children: t('Description') }),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(\"input\", { type: \"text\", name: \"description\", value: currentAlert ? currentAlert.description || '' : '', placeholder: t('Include description to be sent with %s', reportOrAlert), onChange: onInputChange }) }\n            )] }\n          ),\n          _jsxs(StyledSwitchContainer, { children: [\n            _jsx(Switch, { checked: currentAlert ? currentAlert.active : false, defaultChecked: true, onChange: onActiveSwitch }),\n            _jsx(\"div\", { className: \"switch-label\", children:\n              isReport ? t('Report is active') : t('Alert is active') }\n            )] }\n          )] }\n        ) }, \"general\"\n      ),\n      !isReport && _jsxs(StyledPanel, { header: _jsx(ValidatedPanelHeader, { title: TRANSLATIONS.ALERT_CONDITION_TITLE, subtitle: t('Define the database, SQL query, and triggering conditions for alert.'), validateCheckStatus: !validationStatus[Sections.Alert].hasErrors, testId: \"alert-condition-panel\" }), children: [\n        _jsxs(StyledInputContainer, { children: [\n          _jsxs(\"div\", { className: \"control-label\", children: [\n            t('Database'),\n            _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n          ),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(AsyncSelect, { ariaLabel: t('Database'), name: \"source\", placeholder: t('Select database'), value: currentAlert != null && (_currentAlert$databas2 = currentAlert.database) != null && _currentAlert$databas2.label &&\n              currentAlert != null && (_currentAlert$databas3 = currentAlert.database) != null && _currentAlert$databas3.value ?\n              {\n                value: currentAlert.database.value,\n                label: currentAlert.database.label\n              } :\n              undefined, options: loadSourceOptions, onChange: onSourceChange }) }\n          )] }\n        ),\n        _jsxs(StyledInputContainer, { children: [\n          _jsxs(\"div\", { className: \"control-label\", children: [\n            t('SQL Query'),\n            _jsx(StyledTooltip, { tooltip: t('The result of this query must be a value capable of numeric interpretation e.g. 1, 1.0, or \"1\" (compatible with Python\\'s float() function).') }),\n            _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n          ),\n          _jsx(TextAreaControl, { name: \"sql\", language: \"sql\", offerEditInModal: false, minLines: 15, maxLines: 15, onChange: onSQLChange, readOnly: false, initialValue: resource == null ? void 0 : resource.sql }, currentAlert == null ? void 0 : currentAlert.id)] }\n        ),\n        _jsxs(\"div\", { className: \"inline-container wrap\", children: [\n          _jsxs(StyledInputContainer, { css: noMarginBottom, children: [\n            _jsxs(\"div\", { className: \"control-label\", css: inputSpacer, children: [\n              t('Trigger Alert If...'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(Select, { ariaLabel: t('Condition'), onChange: onConditionChange, placeholder: t('Condition'), value: (currentAlert == null ? void 0 : (_currentAlert$validat5 = currentAlert.validator_config_json) == null ? void 0 : _currentAlert$validat5.op) || undefined, options: CONDITIONS, css: inputSpacer }) }\n            )] }\n          ),\n          _jsxs(StyledInputContainer, { css: noMarginBottom, children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              t('Value'), ' ',\n              !conditionNotNull && _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(\"input\", { type: \"number\", name: \"threshold\", disabled: conditionNotNull, value: (currentAlert == null ? void 0 : (_currentAlert$validat6 = currentAlert.validator_config_json) == null ? void 0 : _currentAlert$validat6.threshold) !==\n                undefined && !conditionNotNull ?\n                currentAlert.validator_config_json.threshold :\n                '', placeholder: t('Value'), onChange: onThresholdChange }) }\n            )] }\n          )] }\n        )] }, \"condition\"\n      ),\n      _jsxs(StyledPanel, { header: _jsx(ValidatedPanelHeader, { title: isReport ?\n          TRANSLATIONS.REPORT_CONTENTS_TITLE :\n          TRANSLATIONS.ALERT_CONTENTS_TITLE, subtitle: t('Customize data source, filters, and layout.'), validateCheckStatus: !validationStatus[Sections.Content].hasErrors, testId: \"contents-panel\" }), children: [\n        _jsxs(StyledInputContainer, { children: [\n          _jsxs(\"div\", { className: \"control-label\", children: [\n            t('Content type'),\n            _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n          ),\n          _jsx(Select, { ariaLabel: t('Select content type'), onChange: onContentTypeChange, value: contentType, options: CONTENT_TYPE_OPTIONS, placeholder: t('Select content type') })] }\n        ),\n        _jsx(StyledInputContainer, { children:\n          contentType === ContentType.Chart ? _jsxs(_Fragment, { children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              t('Select chart'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(AsyncSelect, { ariaLabel: t('Chart'), name: \"chart\", value: currentAlert != null && (_currentAlert$chart3 = currentAlert.chart) != null && _currentAlert$chart3.label && currentAlert != null && (_currentAlert$chart4 = currentAlert.chart) != null && _currentAlert$chart4.value ?\n              {\n                value: currentAlert.chart.value,\n                label: currentAlert.chart.label\n              } :\n              undefined, options: loadChartOptions, onChange: onChartChange, placeholder: t('Select chart to use') })] }\n          ) : _jsxs(_Fragment, { children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              t('Select dashboard'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(AsyncSelect, { ariaLabel: t('Dashboard'), name: \"dashboard\", value: currentAlert != null && (_currentAlert$dashboa3 = currentAlert.dashboard) != null && _currentAlert$dashboa3.label &&\n              currentAlert != null && (_currentAlert$dashboa4 = currentAlert.dashboard) != null && _currentAlert$dashboa4.value ?\n              {\n                value: currentAlert.dashboard.value,\n                label: currentAlert.dashboard.label\n              } :\n              undefined, options: loadDashboardOptions, onChange: onDashboardChange, placeholder: t('Select dashboard to use') })] }\n          ) }\n        ),\n        _jsx(StyledInputContainer, { css: ['PDF', 'TEXT', 'CSV'].includes(reportFormat) && noMarginBottom, children:\n          formatOptionEnabled && _jsxs(_Fragment, { children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              t('Content format'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(Select, { ariaLabel: t('Select format'), onChange: onFormatChange, value: reportFormat, options: contentType === ContentType.Dashboard ?\n              ['pdf', 'png'].map((key) => FORMAT_OPTIONS[key]) :\n              /* If chart is of text based viz type: show text\n              format option */\n              TEXT_BASED_VISUALIZATION_TYPES.includes(chartVizType) ?\n              Object.values(FORMAT_OPTIONS) :\n              ['pdf', 'png', 'csv'].map((key) => FORMAT_OPTIONS[key]), placeholder: t('Select format') })] }\n          ) }\n        ),\n        tabsEnabled && contentType === ContentType.Dashboard && _jsx(StyledInputContainer, { children:\n          _jsxs(_Fragment, { children: [\n            _jsx(\"div\", { className: \"control-label\", children: t('Select tab') }),\n            _jsx(StyledTreeSelect, { disabled: (tabOptions == null ? void 0 : tabOptions.length) === 0, treeData: tabOptions, value: currentAlert == null ? void 0 : (_currentAlert$extra2 = currentAlert.extra) == null ? void 0 : (_currentAlert$extra2$ = _currentAlert$extra2.dashboard) == null ? void 0 : _currentAlert$extra2$.anchor, onSelect: updateAnchorState, placeholder: t('Select a tab') })] }\n          ) }\n        ),\n        isScreenshot && _jsxs(StyledInputContainer, { css: !isReport && contentType === ContentType.Chart && noMarginBottom, children: [\n          _jsx(\"div\", { className: \"control-label\", children: t('Screenshot width') }),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(InputNumber, { type: \"number\", name: \"custom_width\", value: (currentAlert == null ? void 0 : currentAlert.custom_width) || undefined, min: 600, max: 2400, placeholder: t('Input custom width in pixels'), onChange: onCustomWidthChange }) }\n          )] }\n        ),\n        (isReport || contentType === ContentType.Dashboard) && _jsx(\"div\", { className: \"inline-container\", children:\n          _jsx(StyledCheckbox, { className: \"checkbox\", checked: forceScreenshot, onChange: onForceScreenshotChange, children:\n            t('Ignore cache when generating report') }\n          ) }\n        )] }, \"contents\"\n      ),\n      _jsxs(StyledPanel, { header: _jsx(ValidatedPanelHeader, { title: TRANSLATIONS.SCHEDULE_TITLE, subtitle: t('Define delivery schedule, timezone, and frequency settings.'), validateCheckStatus: !validationStatus[Sections.Schedule].hasErrors, testId: \"schedule-panel\" }), children: [\n        _jsx(AlertReportCronScheduler, { value: (currentAlert == null ? void 0 : currentAlert.crontab) || '', onChange: (newVal) => updateAlertState('crontab', newVal) }),\n        _jsxs(StyledInputContainer, { children: [\n          _jsxs(\"div\", { className: \"control-label\", children: [\n            t('Timezone'), \" \", _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n          ),\n          _jsx(TimezoneSelector, { onTimezoneChange: onTimezoneChange, timezone: currentAlert == null ? void 0 : currentAlert.timezone, minWidth: \"100%\" })] }\n        ),\n        _jsxs(StyledInputContainer, { children: [\n          _jsxs(\"div\", { className: \"control-label\", children: [\n            t('Log retention'),\n            _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n          ),\n          _jsx(\"div\", { className: \"input-container\", children:\n            _jsx(Select, { ariaLabel: t('Log retention'), placeholder: t('Log retention'), onChange: onLogRetentionChange, value: currentAlert == null ? void 0 : currentAlert.log_retention, options: RETENTION_OPTIONS, sortComparator: propertyComparator('value') }) }\n          )] }\n        ),\n        _jsx(StyledInputContainer, { css: noMarginBottom, children:\n          isReport ? _jsxs(_Fragment, { children: [\n            _jsxs(\"div\", { className: \"control-label\", children: [\n              t('Working timeout'),\n              _jsx(\"span\", { className: \"required\", children: \"*\" })] }\n            ),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(NumberInput, { min: 1, name: \"working_timeout\", value: (currentAlert == null ? void 0 : currentAlert.working_timeout) || '', placeholder: t('Time in seconds'), onChange: onTimeoutVerifyChange, timeUnit: t('seconds') }) }\n            )] }\n          ) : _jsxs(_Fragment, { children: [\n            _jsx(\"div\", { className: \"control-label\", children: t('Grace period') }),\n            _jsx(\"div\", { className: \"input-container\", children:\n              _jsx(NumberInput, { min: 1, name: \"grace_period\", value: (currentAlert == null ? void 0 : currentAlert.grace_period) || '', placeholder: t('Time in seconds'), onChange: onTimeoutVerifyChange, timeUnit: t('seconds') }) }\n            )] }\n          ) }\n        )] }, \"schedule\"\n      ),\n      _jsxs(StyledPanel, { header: _jsx(ValidatedPanelHeader, { title: TRANSLATIONS.NOTIFICATION_TITLE, subtitle: t('Choose notification method and recipients.'), validateCheckStatus: !validationStatus[Sections.Notification].hasErrors, testId: \"notification-method-panel\" }), children: [\n        notificationSettings.map((notificationSetting, i) => _jsx(StyledNotificationMethodWrapper, { children:\n          _jsx(NotificationMethod, { setting: notificationSetting, index: i, onUpdate: updateNotificationSetting, onRemove: removeNotificationSetting, onInputChange: onInputChange, email_subject: (currentAlert == null ? void 0 : currentAlert.email_subject) || '', defaultSubject: emailSubject || '', setErrorSubject: handleErrorUpdate }, `NotificationMethod-${i}`) }\n        )),\n\n        // Prohibit 'add notification method' button if only one present\n        allowedNotificationMethodsCount > notificationSettings.length && _jsx(NotificationMethodAdd, { status: notificationAddState, onClick: onNotificationAdd })] }, \"notification\"\n      )] }\n    ) }\n  );\n};\nexport default withToasts(AlertReportModal);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}