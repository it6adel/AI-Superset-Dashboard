{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getMetricLabel, tooltipHtml } from '@superset-ui/core';\nimport { extent as d3Extent } from 'd3-array';\nimport { DEFAULT_FORM_DATA as DEFAULT_GRAPH_FORM_DATA } from './types';\nimport { DEFAULT_GRAPH_SERIES_OPTION } from './constants';\nimport { getChartPadding, getColtypesMapping, getLegendProps, sanitizeHtml } from '../utils/series';\nimport { getDefaultTooltip } from '../utils/tooltip';\nfunction verifyEdgeSymbol(symbol) {\n  if (symbol === 'none' || symbol === 'circle' || symbol === 'arrow') {\n    return symbol;\n  }\n  return 'none';\n}\nfunction parseEdgeSymbol(symbols) {\n  const [start, end] = (symbols || '').split(',');\n  return [verifyEdgeSymbol(start), verifyEdgeSymbol(end)];\n}\n/**\n * Emphasized edge width with a min and max.\n */\nfunction getEmphasizedEdgeWidth(width) {\n  return Math.max(5, Math.min(width * 2, 20));\n}\n/**\n * Normalize node size, edge width, and apply label visibility thresholds.\n */\nfunction normalizeStyles(nodes, links, { baseNodeSize, baseEdgeWidth, showSymbolThreshold }) {\n  const minNodeSize = baseNodeSize * 0.5;\n  const maxNodeSize = baseNodeSize * 2;\n  const minEdgeWidth = baseEdgeWidth * 0.5;\n  const maxEdgeWidth = baseEdgeWidth * 2;\n  const [nodeMinValue, nodeMaxValue] = d3Extent(nodes, (x) => x.value);\n  const nodeSpread = nodeMaxValue - nodeMinValue;\n  nodes.forEach((node) => {\n    // eslint-disable-next-line no-param-reassign\n    node.symbolSize =\n    ((node.value - nodeMinValue) / nodeSpread * maxNodeSize || 0) +\n    minNodeSize;\n    // eslint-disable-next-line no-param-reassign\n    node.label = {\n      ...node.label,\n      show: showSymbolThreshold ? node.value > showSymbolThreshold : true\n    };\n  });\n  const [linkMinValue, linkMaxValue] = d3Extent(links, (x) => x.value);\n  const linkSpread = linkMaxValue - linkMinValue;\n  links.forEach((link) => {\n    const lineWidth = (link.value - linkMinValue) / linkSpread * maxEdgeWidth ||\n    0 + minEdgeWidth;\n    // eslint-disable-next-line no-param-reassign\n    link.lineStyle.width = lineWidth;\n    // eslint-disable-next-line no-param-reassign\n    link.emphasis.lineStyle = {\n      ...link.emphasis.lineStyle,\n      width: getEmphasizedEdgeWidth(lineWidth)\n    };\n    // eslint-disable-next-line no-param-reassign\n    link.select.lineStyle = {\n      ...link.select.lineStyle,\n      width: getEmphasizedEdgeWidth(lineWidth * 0.8),\n      opacity: 1\n    };\n  });\n}\nfunction getKeyByValue(object, value) {\n  return Object.keys(object).find((key) => object[key] === value);\n}\nfunction getCategoryName(columnName, name) {\n  if (name === false) {\n    return `${columnName}: false`;\n  }\n  if (name === true) {\n    return `${columnName}: true`;\n  }\n  if (name == null) {\n    return 'N/A';\n  }\n  return String(name);\n}\nexport default function transformProps(chartProps) {\n  const { width, height, formData, queriesData, hooks, inContextMenu, filterState, emitCrossFilters, theme } = chartProps;\n  const data = queriesData[0].data || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { source, target, sourceCategory, targetCategory, colorScheme, metric = '', layout, roam, draggable, selectedMode, showSymbolThreshold, edgeLength, gravity, repulsion, friction, legendMargin, legendOrientation, legendType, showLegend, baseEdgeWidth, baseNodeSize, edgeSymbol, sliceId } = { ...DEFAULT_GRAPH_FORM_DATA, ...formData };\n  const refs = {};\n  const metricLabel = getMetricLabel(metric);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const firstColor = colorFn.range()[0];\n  const nodes = {};\n  const categories = new Set();\n  const echartNodes = [];\n  const echartLinks = [];\n  /**\n   * Get the node id of an existing node,\n   * or create a new node if it doesn't exist.\n   */\n  function getOrCreateNode(name, col, category, color) {\n    if (!(name in nodes)) {\n      nodes[name] = echartNodes.length;\n      echartNodes.push({\n        id: String(nodes[name]),\n        name,\n        col,\n        value: 0,\n        category,\n        select: DEFAULT_GRAPH_SERIES_OPTION.select,\n        tooltip: {\n          ...getDefaultTooltip(refs),\n          ...DEFAULT_GRAPH_SERIES_OPTION.tooltip\n        },\n        itemStyle: { color }\n      });\n    }\n    const node = echartNodes[nodes[name]];\n    if (category) {\n      categories.add(category);\n      // category may be empty when one of `sourceCategory`\n      // or `targetCategory` is not set.\n      if (!node.category) {\n        node.category = category;\n      }\n    }\n    return node;\n  }\n  data.forEach((link) => {\n    const value = link[metricLabel];\n    if (!value) {\n      return;\n    }\n    const sourceName = link[source];\n    const targetName = link[target];\n    const sourceCategoryName = sourceCategory ?\n    getCategoryName(sourceCategory, link[sourceCategory]) :\n    undefined;\n    const targetCategoryName = targetCategory ?\n    getCategoryName(targetCategory, link[targetCategory]) :\n    undefined;\n    const sourceNodeColor = sourceCategoryName ?\n    colorFn(sourceCategoryName) :\n    firstColor;\n    const targetNodeColor = targetCategoryName ?\n    colorFn(targetCategoryName) :\n    firstColor;\n    const sourceNode = getOrCreateNode(sourceName, source, sourceCategoryName, sourceNodeColor);\n    const targetNode = getOrCreateNode(targetName, target, targetCategoryName, targetNodeColor);\n    sourceNode.value += value;\n    targetNode.value += value;\n    echartLinks.push({\n      source: sourceNode.id,\n      target: targetNode.id,\n      value,\n      lineStyle: {\n        color: sourceNodeColor\n      },\n      emphasis: {},\n      select: {}\n    });\n  });\n  normalizeStyles(echartNodes, echartLinks, {\n    showSymbolThreshold,\n    baseEdgeWidth,\n    baseNodeSize\n  });\n  const categoryList = [...categories];\n  const series = [\n  {\n    zoom: DEFAULT_GRAPH_SERIES_OPTION.zoom,\n    type: 'graph',\n    categories: categoryList.map((c) => ({\n      name: c,\n      itemStyle: {\n        color: colorFn(c, sliceId)\n      }\n    })),\n    layout,\n    force: {\n      ...DEFAULT_GRAPH_SERIES_OPTION.force,\n      edgeLength,\n      gravity,\n      repulsion,\n      friction\n    },\n    circular: DEFAULT_GRAPH_SERIES_OPTION.circular,\n    data: echartNodes,\n    links: echartLinks,\n    roam,\n    draggable,\n    edgeSymbol: parseEdgeSymbol(edgeSymbol),\n    edgeSymbolSize: baseEdgeWidth * 2,\n    selectedMode,\n    ...getChartPadding(showLegend, legendOrientation, legendMargin),\n    animation: DEFAULT_GRAPH_SERIES_OPTION.animation,\n    label: DEFAULT_GRAPH_SERIES_OPTION.label,\n    lineStyle: DEFAULT_GRAPH_SERIES_OPTION.lineStyle,\n    emphasis: DEFAULT_GRAPH_SERIES_OPTION.emphasis\n  }];\n\n  const echartOptions = {\n    animationDuration: DEFAULT_GRAPH_SERIES_OPTION.animationDuration,\n    animationEasing: DEFAULT_GRAPH_SERIES_OPTION.animationEasing,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      formatter: (params) => {\n        const source = sanitizeHtml(getKeyByValue(nodes, Number(params.data.source)));\n        const target = sanitizeHtml(getKeyByValue(nodes, Number(params.data.target)));\n        const title = `${source} > ${target}`;\n        return tooltipHtml([[metricLabel, `${params.value}`]], title);\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: categoryList\n    },\n    series\n  };\n  const { onContextMenu, setDataMask } = hooks;\n  return {\n    width,\n    height,\n    formData,\n    echartOptions,\n    onContextMenu,\n    setDataMask,\n    filterState,\n    refs,\n    emitCrossFilters,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}