{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";import _kebabCase from \"lodash/kebabCase\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { isValidElement, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { ensureIsArray, t, styled, getChartControlPanelRegistry, DatasourceType, css, useTheme, isDefined, NO_TIME_RANGE, usePrevious } from '@superset-ui/core';\nimport { isCustomControlItem, isTemporalColumn, sections } from '@superset-ui/chart-controls';\nimport { useSelector } from 'react-redux';\nimport { rgba } from 'emotion-rgba';\n\nimport Collapse from 'src/components/Collapse';\nimport Tabs from 'src/components/Tabs';\nimport { PluginContext } from 'src/components/DynamicPlugins';\nimport Loading from 'src/components/Loading';\nimport Modal from 'src/components/Modal';\nimport { getSectionsToRender } from 'src/explore/controlUtils';\nimport { Tooltip } from 'src/components/Tooltip';\nimport Icons from 'src/components/Icons';\nimport ControlRow from './ControlRow';\nimport Control from './Control';\nimport { ExploreAlert } from './ExploreAlert';\nimport { RunQueryButton } from './RunQueryButton';\nimport { Operators } from '../constants';\nimport { Clauses } from './controls/FilterControl/types';\nimport StashFormDataContainer from './StashFormDataContainer';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst { confirm } = Modal;\nconst iconStyles = css`\n  &.anticon {\n    font-size: unset;\n    .anticon {\n      line-height: unset;\n      vertical-align: unset;\n    }\n  }\n`;\nconst actionButtonsContainerStyles = (theme) => css`\n  display: flex;\n  position: sticky;\n  bottom: 0;\n  flex-direction: column;\n  align-items: center;\n  padding: ${theme.gridUnit * 4}px;\n  z-index: 999;\n  background: linear-gradient(\n    ${rgba(theme.colors.grayscale.light5, 0)},\n    ${theme.colors.grayscale.light5} ${theme.opacity.mediumLight}\n  );\n\n  & > button {\n    min-width: 156px;\n  }\n`;\nconst Styles = styled.div`\n  position: relative;\n  height: 100%;\n  width: 100%;\n\n  // Resizable add overflow-y: auto as a style to this div\n  // To override it, we need to use !important\n  overflow: visible !important;\n  #controlSections {\n    height: 100%;\n    overflow: visible;\n  }\n  .nav-tabs {\n    flex: 0 0 1;\n  }\n  .tab-content {\n    overflow: auto;\n    flex: 1 1 100%;\n  }\n  .Select__menu {\n    max-width: 100%;\n  }\n  .type-label {\n    margin-right: ${({ theme }) => theme.gridUnit * 3}px;\n    width: ${({ theme }) => theme.gridUnit * 7}px;\n    display: inline-block;\n    text-align: center;\n    font-weight: ${({ theme }) => theme.typography.weights.bold};\n  }\n`;\nconst ControlPanelsTabs = styled(Tabs)`\n  ${({ theme, fullWidth }) => css`\n    height: 100%;\n    overflow: visible;\n    .ant-tabs-nav {\n      margin-bottom: 0;\n    }\n    .ant-tabs-nav-list {\n      width: ${fullWidth ? '100%' : '50%'};\n    }\n    .ant-tabs-tabpane {\n      height: 100%;\n    }\n    .ant-tabs-content-holder {\n      padding-top: ${theme.gridUnit * 4}px;\n    }\n\n    .ant-collapse-ghost > .ant-collapse-item {\n      &:not(:last-child) {\n        border-bottom: 1px solid ${theme.colors.grayscale.light3};\n      }\n\n      & > .ant-collapse-header {\n        font-size: ${theme.typography.sizes.s}px;\n      }\n\n      & > .ant-collapse-content > .ant-collapse-content-box {\n        padding-bottom: 0;\n        font-size: ${theme.typography.sizes.s}px;\n      }\n    }\n  `}\n`;\nconst isTimeSection = (section) => !!section.label && sections.legacyTimeseriesTime.label === section.label;\nconst hasTimeColumn = (datasource) => {var _datasource$columns;return datasource == null ? void 0 : (_datasource$columns = datasource.columns) == null ? void 0 : _datasource$columns.some((c) => c.is_dttm);};\nconst sectionsToExpand = (sections, datasource) =>\n// avoid expanding time section if datasource doesn't include time column\nsections.reduce((acc, section) => (section.expanded || !section.label) && (\n!isTimeSection(section) || hasTimeColumn(datasource)) ?\n[...acc, String(section.label)] :\nacc, []);\nfunction getState(vizType, datasource, datasourceType) {\n  const querySections = [];\n  const customizeSections = [];\n  getSectionsToRender(vizType, datasourceType).forEach((section) => {\n    // if at least one control in the section is not `renderTrigger`\n    // or asks to be displayed at the Data tab\n    if (section.tabOverride === 'data' ||\n    section.controlSetRows.some((rows) => rows.some((control) => control &&\n    typeof control === 'object' &&\n    'config' in control &&\n    control.config && (\n    !control.config.renderTrigger ||\n    control.config.tabOverride === 'data')))) {\n      querySections.push(section);\n    } else\n    if (section.controlSetRows.length > 0) {\n      customizeSections.push(section);\n    }\n  });\n  const expandedQuerySections = sectionsToExpand(querySections, datasource);\n  const expandedCustomizeSections = sectionsToExpand(customizeSections, datasource);\n  return {\n    expandedQuerySections,\n    expandedCustomizeSections,\n    querySections,\n    customizeSections\n  };\n}\nfunction useResetOnChangeRef(initialValue, resetOnChangeValue) {\n  const value = useRef(initialValue());\n  const prevResetOnChangeValue = useRef(resetOnChangeValue);\n  if (prevResetOnChangeValue.current !== resetOnChangeValue) {\n    value.current = initialValue();\n    prevResetOnChangeValue.current = resetOnChangeValue;\n  }\n  return value;\n}\nexport const ControlPanelsContainer = (props) => {var _props$exploreState$d3, _props$exploreState$d4;\n  const { colors } = useTheme();\n  const pluginContext = useContext(PluginContext);\n  const prevState = usePrevious(props.exploreState);\n  const prevDatasource = usePrevious(props.exploreState.datasource);\n  const prevChartStatus = usePrevious(props.chart.chartStatus);\n  const [showDatasourceAlert, setShowDatasourceAlert] = useState(false);\n  const containerRef = useRef(null);\n  const controlsTransferred = useSelector((state) => state.explore.controlsTransferred);\n  const defaultTimeFilter = useSelector((state) => {var _state$common, _state$common$conf;return ((_state$common = state.common) == null ? void 0 : (_state$common$conf = _state$common.conf) == null ? void 0 : _state$common$conf.DEFAULT_TIME_FILTER) || NO_TIME_RANGE;});\n  const { form_data, actions } = props;\n  const { setControlValue } = actions;\n  const { x_axis, adhoc_filters } = form_data;\n  const previousXAxis = usePrevious(x_axis);\n  useEffect(() => {\n    if (x_axis &&\n    x_axis !== previousXAxis &&\n    isTemporalColumn(x_axis, props.exploreState.datasource)) {\n      const noFilter = !(adhoc_filters != null && adhoc_filters.find((filter) => filter.expressionType === 'SIMPLE' &&\n      filter.operator === Operators.TemporalRange &&\n      filter.subject === x_axis));\n      if (noFilter) {\n        confirm({\n          title: t('The X-axis is not on the filters list'),\n          content: t(`The X-axis is not on the filters list which will prevent it from being used in\n            time range filters in dashboards. Would you like to add it to the filters list?`),\n          onOk: () => {\n            setControlValue('adhoc_filters', [\n            ...(adhoc_filters || []),\n            {\n              clause: Clauses.Where,\n              subject: x_axis,\n              operator: Operators.TemporalRange,\n              comparator: defaultTimeFilter,\n              expressionType: 'SIMPLE'\n            }]\n            );\n          }\n        });\n      }\n    }\n  }, [\n  x_axis,\n  adhoc_filters,\n  setControlValue,\n  defaultTimeFilter,\n  previousXAxis,\n  props.exploreState.datasource]\n  );\n  useEffect(() => {\n    let shouldUpdateControls = false;\n    const removeDatasourceWarningFromControl = (value) => {\n      if (typeof value === 'object' &&\n      isDefined(value) &&\n      'datasourceWarning' in value &&\n      value.datasourceWarning === true) {\n        shouldUpdateControls = true;\n        return { ...value, datasourceWarning: false };\n      }\n      return value;\n    };\n    if (props.chart.chartStatus === 'success' &&\n    prevChartStatus !== 'success') {\n      controlsTransferred == null ? void 0 : controlsTransferred.forEach((controlName) => {var _ensureIsArray;\n        shouldUpdateControls = false;\n        if (!isDefined(props.controls[controlName])) {\n          return;\n        }\n        const alteredControls = Array.isArray(props.controls[controlName].value) ? (_ensureIsArray =\n        ensureIsArray(props.controls[controlName].value)) == null ? void 0 : _ensureIsArray.map(removeDatasourceWarningFromControl) :\n        removeDatasourceWarningFromControl(props.controls[controlName].value);\n        if (shouldUpdateControls) {\n          props.actions.setControlValue(controlName, alteredControls);\n        }\n      });\n    }\n  }, [\n  controlsTransferred,\n  prevChartStatus,\n  props.actions,\n  props.chart.chartStatus,\n  props.controls]\n  );\n  useEffect(() => {var _props$exploreState$d, _props$exploreState$d2;\n    if (prevDatasource &&\n    prevDatasource.type !== DatasourceType.Query && (\n    ((_props$exploreState$d = props.exploreState.datasource) == null ? void 0 : _props$exploreState$d.id) !== prevDatasource.id ||\n    ((_props$exploreState$d2 = props.exploreState.datasource) == null ? void 0 : _props$exploreState$d2.type) !== prevDatasource.type)) {var _containerRef$current;\n      setShowDatasourceAlert(true);\n      (_containerRef$current = containerRef.current) == null ? void 0 : _containerRef$current.scrollTo(0, 0);\n    }\n  }, [(_props$exploreState$d3 =\n  props.exploreState.datasource) == null ? void 0 : _props$exploreState$d3.id, (_props$exploreState$d4 =\n  props.exploreState.datasource) == null ? void 0 : _props$exploreState$d4.type,\n  prevDatasource]\n  );\n  const { expandedQuerySections, expandedCustomizeSections, querySections, customizeSections } = useMemo(() => getState(form_data.viz_type, props.exploreState.datasource, props.datasource_type), [props.exploreState.datasource, form_data.viz_type, props.datasource_type]);\n  const resetTransferredControls = useCallback(() => {\n    ensureIsArray(props.exploreState.controlsTransferred).forEach((controlName) => props.actions.setControlValue(controlName, props.controls[controlName].default));\n  }, [props.actions, props.exploreState.controlsTransferred, props.controls]);\n  const handleClearFormClick = useCallback(() => {\n    resetTransferredControls();\n    setShowDatasourceAlert(false);\n  }, [resetTransferredControls]);\n  const handleContinueClick = useCallback(() => {\n    setShowDatasourceAlert(false);\n  }, []);\n  const shouldRecalculateControlState = ({ name, config }) => {\n    const { controls, chart, exploreState } = props;\n    return Boolean(config.shouldMapStateToProps == null ? void 0 : config.shouldMapStateToProps(prevState || exploreState, exploreState, controls[name], chart));\n  };\n  const renderControl = ({ name, config }) => {\n    const { controls, chart, exploreState } = props;\n    const { visibility, hidden, disableStash, ...restConfig } = config;\n    // If the control item is not an object, we have to look up the control data from\n    // the centralized controls file.\n    // When it is an object we read control data straight from `config` instead\n    const controlData = {\n      ...restConfig,\n      ...controls[name],\n      ...(shouldRecalculateControlState({ name, config }) ?\n      config == null ? void 0 : config.mapStateToProps == null ? void 0 : config.mapStateToProps(exploreState, controls[name], chart) :\n      // for other controls, `mapStateToProps` is already run in\n      // controlUtils/getControlState.ts\n      undefined),\n      name\n    };\n    const { validationErrors, label: baseLabel, description: baseDescription, ...restProps } = controlData;\n    const isVisible = visibility ?\n    visibility.call(config, props, controlData) :\n    undefined;\n    const isHidden = typeof hidden === 'function' ?\n    hidden.call(config, props, controlData) :\n    hidden;\n    const label = typeof baseLabel === 'function' ?\n    baseLabel(exploreState, controls[name], chart) :\n    baseLabel;\n    const description = typeof baseDescription === 'function' ?\n    baseDescription(exploreState, controls[name], chart) :\n    baseDescription;\n    if (name.includes('adhoc_filters')) {\n      restProps.canDelete = (valueToBeDeleted, values) => {var _controls$time_range;\n        const isTemporalRange = (filter) => filter.operator === Operators.TemporalRange;\n        if (!(controls != null && (_controls$time_range = controls.time_range) != null && _controls$time_range.value) && isTemporalRange(valueToBeDeleted)) {\n          const count = values.filter(isTemporalRange).length;\n          if (count === 1) {\n            // if temporal filter's value is \"No filter\", prevent deletion\n            // otherwise reset the value to \"No filter\"\n            if (valueToBeDeleted.comparator === defaultTimeFilter) {\n              return t(`You cannot delete the last temporal filter as it's used for time range filters in dashboards.`);\n            }\n            props.actions.setControlValue(name, values.map((val) => {\n              if (_isEqual(val, valueToBeDeleted)) {\n                return {\n                  ...val,\n                  comparator: defaultTimeFilter\n                };\n              }\n              return val;\n            }));\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    return _jsx(StashFormDataContainer, { shouldStash: isVisible === false && disableStash !== true, fieldNames: [name], children:\n      _jsx(Control, { name: name, label: label, description: description, validationErrors: validationErrors, actions: props.actions, isVisible: isVisible, hidden: isHidden, ...restProps }, `control-${name}`) }, `control-container-${name}`\n    );\n  };\n  const sectionHasHadNoErrors = useResetOnChangeRef(() => ({}), form_data.viz_type);\n  const renderControlPanelSection = (section) => {\n    const { controls } = props;\n    const { label, description, visibility } = section;\n    // Section label can be a ReactNode but in some places we want to\n    // have a string ID. Using forced type conversion for now,\n    // should probably add a `id` field to sections in the future.\n    const sectionId = String(label);\n    const isVisible = (visibility == null ? void 0 : visibility.call(this, props, controls)) !== false;\n    const hasErrors = section.controlSetRows.some((rows) => rows.some((item) => {\n      const controlName = typeof item === 'string' ?\n      item :\n      item && 'name' in item ?\n      item.name :\n      null;\n      return controlName &&\n      controlName in controls &&\n      controls[controlName].validationErrors &&\n      controls[controlName].validationErrors.length > 0;\n    }));\n    if (!hasErrors) {\n      sectionHasHadNoErrors.current[sectionId] = true;\n    }\n    const errorColor = sectionHasHadNoErrors.current[sectionId] ?\n    colors.error.base :\n    colors.warning.base;\n    const PanelHeader = () => _jsxs(\"span\", { children: [\n      _jsx(\"span\", { css: (theme) => css`\n            font-size: ${theme.typography.sizes.m}px;\n            line-height: 1.3;\n            font-weight: ${theme.typography.weights.medium};\n          `, children:\n        label }\n      ), ' ',\n      description && _jsx(Tooltip, { id: sectionId, title: description, children:\n        _jsx(Icons.InfoCircleOutlined, { css: iconStyles }) }\n      ),\n      hasErrors && _jsx(Tooltip, { id: `${_kebabCase('validation-errors')}-tooltip`, title: t('This section contains validation errors'), children:\n        _jsx(Icons.InfoCircleOutlined, { css: css`\n                ${iconStyles};\n                color: ${errorColor};\n              ` }) }\n      )] }\n    );\n    return _jsxs(_Fragment, { children: [\n      _jsx(StashFormDataContainer, { shouldStash: !isVisible, fieldNames: section.controlSetRows.\n        flat().\n        map((item) => item && typeof item === 'object' ?\n        'name' in item ?\n        item.name :\n        '' :\n        String(item || '')).\n        filter(Boolean) }, `sectionId-${sectionId}`),\n      isVisible && _jsx(Collapse.Panel, { css: (theme) => css`\n              margin-bottom: 0;\n              box-shadow: none;\n\n              &:last-child {\n                padding-bottom: ${theme.gridUnit * 16}px;\n                border-bottom: 0;\n              }\n\n              .panel-body {\n                margin-left: ${theme.gridUnit * 4}px;\n                padding-bottom: 0;\n              }\n\n              span.label {\n                display: inline-block;\n              }\n              ${!section.label &&\n        `\n          .ant-collapse-header {\n            display: none;\n          }\n        `}\n            `, header: _jsx(PanelHeader, {}), children:\n        section.controlSetRows.map((controlSets, i) => {\n          const renderedControls = controlSets.\n          map((controlItem) => {\n            if (!controlItem) {\n              // When the item is invalid\n              return null;\n            }\n            if (/*#__PURE__*/isValidElement(controlItem)) {\n              // When the item is a React element\n              return controlItem;\n            }\n            if (isCustomControlItem(controlItem) &&\n            controlItem.name !== 'datasource') {\n              return renderControl(controlItem);\n            }\n            return null;\n          }).\n          filter((x) => x !== null);\n          // don't show the row if it is empty\n          if (renderedControls.length === 0) {\n            return null;\n          }\n          return _jsx(ControlRow, { controls: renderedControls }, `controlsetrow-${i}`);\n        }) }, sectionId\n      )] }\n    );\n  };\n  const hasControlsTransferred = ensureIsArray(props.exploreState.controlsTransferred).length > 0;\n  const DatasourceAlert = useCallback(() => hasControlsTransferred ? _jsx(ExploreAlert, { title: t('Keep control settings?'), bodyText: t(\"You've changed datasets. Any controls with data (columns, metrics) that match this new dataset have been retained.\"), primaryButtonAction: handleContinueClick, secondaryButtonAction: handleClearFormClick, primaryButtonText: t('Continue'), secondaryButtonText: t('Clear form'), type: \"info\" }) : _jsx(ExploreAlert, { title: t('No form settings were maintained'), bodyText: t('We were unable to carry over any controls when switching to this new dataset.'), primaryButtonAction: handleContinueClick, primaryButtonText: t('Continue'), type: \"warning\" }), [handleClearFormClick, handleContinueClick, hasControlsTransferred]);\n  const dataTabHasHadNoErrors = useResetOnChangeRef(() => false, form_data.viz_type);\n  const dataTabTitle = useMemo(() => {\n    if (!props.errorMessage) {\n      dataTabHasHadNoErrors.current = true;\n    }\n    const errorColor = dataTabHasHadNoErrors.current ?\n    colors.error.base :\n    colors.warning.base;\n    return _jsxs(_Fragment, { children: [\n      _jsx(\"span\", { children: t('Data') }),\n      props.errorMessage && _jsxs(\"span\", { css: (theme) => css`\n              margin-left: ${theme.gridUnit * 2}px;\n            `, children: [\n        ' ',\n        _jsx(Tooltip, { id: \"query-error-tooltip\", placement: \"right\", title: props.errorMessage, children:\n          _jsx(Icons.ExclamationCircleOutlined, { css: css`\n                  ${iconStyles};\n                  color: ${errorColor};\n                ` }) }\n        )] }\n      )] }\n    );\n  }, [\n  colors.error.base,\n  colors.warning.base,\n  dataTabHasHadNoErrors,\n  props.errorMessage]\n  );\n  const controlPanelRegistry = getChartControlPanelRegistry();\n  if (!controlPanelRegistry.has(form_data.viz_type) && pluginContext.loading) {\n    return _jsx(Loading, {});\n  }\n  const showCustomizeTab = customizeSections.length > 0;\n  return _jsxs(Styles, { ref: containerRef, children: [\n    _jsxs(ControlPanelsTabs, { id: \"controlSections\", fullWidth: showCustomizeTab, allowOverflow: false, children: [\n      _jsx(Tabs.TabPane, { tab: dataTabTitle, children:\n        _jsxs(Collapse, { defaultActiveKey: expandedQuerySections, expandIconPosition: \"right\", ghost: true, children: [\n          showDatasourceAlert && _jsx(DatasourceAlert, {}),\n          querySections.map(renderControlPanelSection)] }\n        ) }, \"query\"\n      ),\n      showCustomizeTab && _jsx(Tabs.TabPane, { tab: t('Customize'), children:\n        _jsx(Collapse, { defaultActiveKey: expandedCustomizeSections, expandIconPosition: \"right\", ghost: true, children:\n          customizeSections.map(renderControlPanelSection) }\n        ) }, \"display\"\n      )] }\n    ),\n    _jsx(\"div\", { css: actionButtonsContainerStyles, children:\n      _jsx(RunQueryButton, { onQuery: props.onQuery, onStop: props.onStop, errorMessage: props.errorMessage, loading: props.chart.chartStatus === 'loading', isNewChart: !props.chart.queriesResponse, canStopQuery: props.canStopQuery, chartIsStale: props.chartIsStale }) }\n    )] }\n  );\n};\nexport default ControlPanelsContainer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}