{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { util } from 'echarts';\nimport { isZoomConfigsFixed, isZoomConfigsLinear } from './typeguards';\n/**\n * Compute the position for a drag graphic.\n *\n * @param param0 configuration\n * @param param0.chart The eChart instance.\n * @param param0.x The x value of the data item.\n * @param param0.y The y value of the data item.\n * @param param0.barWidth The width of the bar.\n * @param param0.add True, if barWidth should be added. False, if barWidth should be subtracted.\n * @returns\n */\nexport const getDragGraphicPosition = ({ chart, x, y, barWidth, add }) => {\n  const valuePosition = chart.convertToPixel('grid', [x, y]);\n  const xPos = Math.round(valuePosition[0]);\n  let yPos = valuePosition[1] - barWidth / 2;\n  if (add) {\n    yPos = valuePosition[1] + barWidth / 2;\n  }\n  return [xPos, yPos];\n};\n/**\n * Create a single drag graphic with drag handler.\n * @param param0 configuration\n * @param param0.dataItem The data item to create the graphic for.\n * @param param0.dataItemIndex The index of the height/width value in the item.\n * @param param0.dataIndex The index of the dataItem in the data.\n * @param param0.onDrag Callback for dragging the bar.\n * @param param0.barWidth The width of the bar.\n * @param param0.chart The eChart instance.\n * @param param0.add True, if barWidth should be added for positioning. False, if barWidth should be subtracted.\n * @returns eChart Option for a drag graphic.\n */\nexport const createDragGraphicOption = ({ dataItem, dataItemIndex, dataIndex, onDrag, barWidth, chart, add }) => {\n  const position = getDragGraphicPosition({\n    chart,\n    x: dataItem[dataItemIndex],\n    y: dataItem[2],\n    barWidth,\n    add\n  });\n  return {\n    type: 'circle',\n    shape: {\n      // The radius of the circle.\n      r: barWidth / 4\n    },\n    x: position[0],\n    y: position[1],\n    invisible: false,\n    style: {\n      // eslint-disable-next-line theme-colors/no-literal-colors\n      fill: '#ffffff',\n      // eslint-disable-next-line theme-colors/no-literal-colors\n      stroke: '#aaa'\n    },\n    cursor: 'ew-resize',\n    draggable: 'horizontal',\n    // Give a big z value, which makes the circle cover the symbol\n    // in bar series.\n    z: 100,\n    // Util method `util.curry` (from echarts) is used here to generate a\n    // new function the same as `onDrag`, except that the\n    // first parameter is fixed to be the `dataIndex` here.\n    ondrag: util.curry(onDrag, dataIndex)\n  };\n};\n/**\n * Create a drag graphic with dragHandler for each bar.\n *\n * @param param0 configuration\n * @param param0.data The eChart data.\n * @param param0.onWidthDrag Callback for dragging width bars.\n * @param param0.onHeightDrag Callback for dragging height bars.\n * @param param0.barWidth The width of a single bar.\n * @param param0.chart The eChart instance.\n * @returns List of eChart options for the drag graphics.\n */\nexport const createDragGraphicOptions = ({ data, onWidthDrag, onHeightDrag, barWidth, chart }) => {\n  const graphics = [];\n  data.forEach((dataItem, dataIndex) => {\n    const widthGraphic = createDragGraphicOption({\n      dataItem,\n      dataIndex,\n      barWidth,\n      chart,\n      dataItemIndex: 0,\n      onDrag: onWidthDrag,\n      add: false\n    });\n    graphics.push(widthGraphic);\n    const heightGraphic = createDragGraphicOption({\n      dataItem,\n      dataIndex,\n      barWidth,\n      chart,\n      dataItemIndex: 1,\n      onDrag: onHeightDrag,\n      add: true\n    });\n    graphics.push(heightGraphic);\n  });\n  return graphics;\n};\n/**\n * Convert ZoomConfigs to eChart data.\n *\n * @param zoomConfigs The config to convert.\n * @returns eChart data representing the zoom configs.\n */\nexport const zoomConfigsToData = (zoomConfigs) => Object.keys(zoomConfigs).\nmap((k) => parseInt(k, 10)).\nmap((k) => [zoomConfigs[k].width, zoomConfigs[k].height, k]);\n/**\n * Convert eChart data to ZoomConfigs.\n *\n * @param data The eChart data to convert.\n * @returns ZoomConfigs representing the eChart data.\n */\nexport const dataToZoomConfigs = (data) => data.reduce((prev, cur) => {\n  // eslint-disable-next-line no-param-reassign\n  prev[cur[2]] = { width: cur[0], height: cur[1] };\n  return prev;\n}, {});\nexport const MAX_ZOOM_LEVEL = 28;\nexport const MIN_ZOOM_LEVEL = 0;\n/**\n * Compute values for all zoom levels with fixed shape.\n *\n * @param zoomConfigsFixed The config to base the computation upon.\n * @returns The computed values for each zoom level.\n */\nconst computeFixedConfigValues = (zoomConfigsFixed) => {\n  const values = {};\n  for (let i = MIN_ZOOM_LEVEL; i <= MAX_ZOOM_LEVEL; i += 1) {\n    const width = Math.round(zoomConfigsFixed.configs.width);\n    const height = Math.round(zoomConfigsFixed.configs.height);\n    values[i] = {\n      width: width > 0 ? width : 0,\n      height: height > 0 ? height : 0\n    };\n  }\n  return values;\n};\n/**\n * Compute values for all zoom levels with linear shape.\n *\n * @param zoomConfigsLinear The config to base the computation upon.\n * @returns The computed values for each zoom level.\n */\nconst computeLinearConfigValues = (zoomConfigsLinear) => {\n  const values = {};\n  for (let i = MIN_ZOOM_LEVEL; i <= MAX_ZOOM_LEVEL; i += 1) {\n    const aspectRatio = zoomConfigsLinear.configs.height / zoomConfigsLinear.configs.width;\n    const width = Math.round(zoomConfigsLinear.configs.width -\n    (zoomConfigsLinear.configs.zoom - i) * zoomConfigsLinear.configs.slope);\n    const height = Math.round(aspectRatio * width);\n    values[i] = {\n      width: width > 0 ? width : 0,\n      height: height > 0 ? height : 0\n    };\n  }\n  return values;\n};\n/**\n * Compute values for all zoom levels with exponential shape.\n *\n * @param zoomConfigsExp The config to base the computation upon.\n * @returns The computed values for each zoom level.\n */\nconst computeExpConfigValues = (zoomConfigsExp) => {\n  const values = {};\n  const x = Math.pow(zoomConfigsExp.configs.width, 1 / zoomConfigsExp.configs.exponent);\n  for (let i = MIN_ZOOM_LEVEL; i <= MAX_ZOOM_LEVEL; i += 1) {\n    const aspectRatio = zoomConfigsExp.configs.height / zoomConfigsExp.configs.width;\n    const width = Math.round(Math.pow(x - (zoomConfigsExp.configs.zoom - i), zoomConfigsExp.configs.exponent));\n    const height = Math.round(aspectRatio * width);\n    values[i] = {\n      width: width > 0 ? width : 0,\n      height: height > 0 ? height : 0\n    };\n  }\n  return values;\n};\n/**\n * Compute values for all zoom levels.\n *\n * @param zoomConfigs The config to base the computation upon.\n * @returns The computed values for each zoom level.\n */\nexport const computeConfigValues = (zoomConfigs) => {\n  if (isZoomConfigsFixed(zoomConfigs)) {\n    return computeFixedConfigValues(zoomConfigs);\n  }\n  if (isZoomConfigsLinear(zoomConfigs)) {\n    return computeLinearConfigValues(zoomConfigs);\n  }\n  return computeExpConfigValues(zoomConfigs);\n};\n/**\n * Convert ZoomConfigs to ZoomConfigsFixed.\n *\n * @param baseConfig The base config.\n * @returns The converted config.\n */\nexport const toFixedConfig = (baseConfig) => {\n  const zoomConfigFixed = {\n    type: 'FIXED',\n    configs: {\n      zoom: baseConfig.zoom,\n      width: baseConfig.width,\n      height: baseConfig.height\n    },\n    values: {}\n  };\n  zoomConfigFixed.values = computeFixedConfigValues(zoomConfigFixed);\n  return zoomConfigFixed;\n};\n/**\n * Convert ZoomConfigs to ZoomConfigsLinear.\n *\n * @param baseConfig The base config.\n * @returns The converted config.\n */\nexport const toLinearConfig = (baseConfig) => {\n  const zoomConfigsLinear = {\n    type: 'LINEAR',\n    configs: {\n      zoom: baseConfig.zoom,\n      width: baseConfig.width,\n      height: baseConfig.height,\n      slope: baseConfig.slope\n    },\n    values: {}\n  };\n  zoomConfigsLinear.values = computeLinearConfigValues(zoomConfigsLinear);\n  return zoomConfigsLinear;\n};\n/**\n * Convert ZoomConfigs to ZoomConfigsExp.\n *\n * @param baseConfig The base config.\n * @returns The converted config.\n */\nexport const toExpConfig = (baseConfig) => {\n  const zoomConfigExp = {\n    type: 'EXP',\n    configs: {\n      zoom: baseConfig.zoom,\n      width: baseConfig.width,\n      height: baseConfig.height,\n      exponent: baseConfig.exponent\n    },\n    values: {}\n  };\n  zoomConfigExp.values = computeExpConfigValues(zoomConfigExp);\n  return zoomConfigExp;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}