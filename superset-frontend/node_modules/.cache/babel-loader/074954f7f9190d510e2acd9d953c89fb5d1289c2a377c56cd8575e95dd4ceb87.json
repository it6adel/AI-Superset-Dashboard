{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\n/* eslint prefer-const: 2 */\nimport { nanoid } from 'nanoid';\nimport { SupersetClient } from '@superset-ui/core';\n\nimport { safeStringify } from '../utils/safeStringify';\nimport { LOG_EVENT } from '../logger/actions';\nimport { LOG_EVENT_TYPE_TIMING } from '../logger/LogUtils';\nimport DebouncedMessageQueue from '../utils/DebouncedMessageQueue';\n\nconst LOG_ENDPOINT = '/superset/log/?explode=events';\nconst sendBeacon = (events) => {\n  if (events.length <= 0) {\n    return;\n  }\n\n  let endpoint = LOG_ENDPOINT;\n  const { source, source_id } = events[0];\n  // backend logs treat these request params as first-class citizens\n  if (source === 'dashboard') {\n    endpoint += `&dashboard_id=${source_id}`;\n  } else if (source === 'slice') {\n    endpoint += `&slice_id=${source_id}`;\n  }\n\n  if (navigator.sendBeacon) {\n    const formData = new FormData();\n    formData.append('events', safeStringify(events));\n    if (SupersetClient.getGuestToken()) {\n      // if we have a guest token, we need to send it for auth via the form\n      formData.append('guest_token', SupersetClient.getGuestToken());\n    }\n    navigator.sendBeacon(endpoint, formData);\n  } else {\n    SupersetClient.post({\n      endpoint,\n      postPayload: { events },\n      parseMethod: null\n    });\n  }\n};\n\n// beacon API has data size limit = 2^16.\n// assume avg each log entry has 2^6 characters\nconst MAX_EVENTS_PER_REQUEST = 1024;\nconst logMessageQueue = new DebouncedMessageQueue({\n  callback: sendBeacon,\n  sizeThreshold: MAX_EVENTS_PER_REQUEST,\n  delayThreshold: 1000\n});\nlet lastEventId = 0;\nconst loggerMiddleware = (store) => (next) => (action) => {var _window, _window$location, _dashboardLayout$pres;\n  if (action.type !== LOG_EVENT) {\n    return next(action);\n  }\n\n  const { dashboardInfo, explore, impressionId, dashboardLayout, sqlLab } =\n  store.getState();\n  let logMetadata = {\n    impression_id: impressionId,\n    version: 'v2'\n  };\n  const { eventName } = action.payload;\n  let { eventData = {} } = action.payload;\n\n  const path = eventData.path || ((_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href);\n\n  if (dashboardInfo != null && dashboardInfo.id && path != null && path.includes('/dashboard/')) {\n    logMetadata = {\n      source: 'dashboard',\n      source_id: dashboardInfo.id,\n      dashboard_id: dashboardInfo.id,\n      ...logMetadata\n    };\n  } else if (explore != null && explore.slice) {\n    logMetadata = {\n      source: 'explore',\n      source_id: explore.slice ? explore.slice.slice_id : 0,\n      ...(explore.slice.slice_id && { slice_id: explore.slice.slice_id }),\n      ...logMetadata\n    };\n  } else if (path != null && path.includes('/sqllab/')) {\n    const editor = sqlLab.queryEditors.find(\n      ({ id }) => id === sqlLab.tabHistory.slice(-1)[0]\n    );\n    logMetadata = {\n      source: 'sqlLab',\n      source_id: editor == null ? void 0 : editor.id,\n      db_id: editor == null ? void 0 : editor.dbId,\n      schema: editor == null ? void 0 : editor.schema\n    };\n  }\n\n  eventData = {\n    ...logMetadata,\n    ts: new Date().getTime(),\n    event_name: eventName,\n    ...eventData\n  };\n  if (LOG_EVENT_TYPE_TIMING.has(eventName)) {\n    eventData = {\n      ...eventData,\n      event_type: 'timing',\n      trigger_event: lastEventId\n    };\n  } else {\n    lastEventId = nanoid();\n    eventData = {\n      ...eventData,\n      event_type: 'user',\n      event_id: lastEventId,\n      visibility: document.visibilityState\n    };\n  }\n\n  if (eventData.target_id && dashboardLayout != null && (_dashboardLayout$pres = dashboardLayout.present) != null && _dashboardLayout$pres[eventData.target_id]) {\n    const { meta } = dashboardLayout.present[eventData.target_id];\n    // chart name or tab/header text\n    eventData.target_name = meta.chartId ? meta.sliceName : meta.text;\n  }\n\n  logMessageQueue.append(eventData);\n  return eventData;\n};\n\nexport default loggerMiddleware;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}