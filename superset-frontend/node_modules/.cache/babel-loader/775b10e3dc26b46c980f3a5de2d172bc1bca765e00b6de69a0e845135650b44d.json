{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/sort-prop-types */\nimport d3 from 'd3';\nimport PropTypes from 'prop-types';\nimport { extent as d3Extent } from 'd3-array';\nimport {\n  getSequentialSchemeRegistry,\n  CategoricalColorNamespace } from\n'@superset-ui/core';\nimport Datamap from 'datamaps/dist/datamaps.world.min';\nimport { ColorBy } from './utils';\n\nconst propTypes = {\n  data: PropTypes.arrayOf(\n    PropTypes.shape({\n      country: PropTypes.string,\n      latitude: PropTypes.number,\n      longitude: PropTypes.number,\n      name: PropTypes.string,\n      m1: PropTypes.number,\n      m2: PropTypes.number\n    })\n  ),\n  height: PropTypes.number,\n  maxBubbleSize: PropTypes.number,\n  showBubbles: PropTypes.bool,\n  linearColorScheme: PropTypes.string,\n  color: PropTypes.string,\n  colorScheme: PropTypes.string,\n  setDataMask: PropTypes.func,\n  onContextMenu: PropTypes.func,\n  emitCrossFilters: PropTypes.bool,\n  formatter: PropTypes.object\n};\n\nfunction WorldMap(element, props) {var _filterState$selected;\n  const {\n    countryFieldtype,\n    entity,\n    data,\n    width,\n    height,\n    maxBubbleSize,\n    showBubbles,\n    linearColorScheme,\n    color,\n    colorBy,\n    colorScheme,\n    sliceId,\n    theme,\n    onContextMenu,\n    setDataMask,\n    inContextMenu,\n    filterState,\n    emitCrossFilters,\n    formatter\n  } = props;\n  const div = d3.select(element);\n  div.classed('superset-legacy-chart-world-map', true);\n  div.selectAll('*').remove();\n\n  // Ignore XXX's to get better normalization\n  const filteredData = data.filter((d) => d.country && d.country !== 'XXX');\n\n  const extRadius = d3.extent(filteredData, (d) => Math.sqrt(d.m2));\n  const radiusScale = d3.scale.\n  linear().\n  domain([extRadius[0], extRadius[1]]).\n  range([1, maxBubbleSize]);\n\n  let processedData;\n  let colorFn;\n  if (colorBy === ColorBy.Country) {\n    colorFn = CategoricalColorNamespace.getScale(colorScheme);\n\n    processedData = filteredData.map((d) => ({\n      ...d,\n      radius: radiusScale(Math.sqrt(d.m2)),\n      fillColor: colorFn(d.name, sliceId)\n    }));\n  } else {\n    colorFn = getSequentialSchemeRegistry().\n    get(linearColorScheme).\n    createLinearScale(d3Extent(filteredData, (d) => d.m1));\n\n    processedData = filteredData.map((d) => ({\n      ...d,\n      radius: radiusScale(Math.sqrt(d.m2)),\n      fillColor: colorFn(d.m1)\n    }));\n  }\n\n  const mapData = {};\n  processedData.forEach((d) => {\n    mapData[d.country] = d;\n  });\n\n  const getCrossFilterDataMask = (source) => {var _mapData$key, _mapData$key2;\n    const selected = Object.values(filterState.selectedValues || {});\n    const key = source.id || source.country;\n    const country =\n    countryFieldtype === 'name' ? (_mapData$key = mapData[key]) == null ? void 0 : _mapData$key.name : (_mapData$key2 = mapData[key]) == null ? void 0 : _mapData$key2.country;\n\n    if (!country) {\n      return undefined;\n    }\n\n    let values;\n    if (selected.includes(key)) {\n      values = [];\n    } else {\n      values = [country];\n    }\n\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: values.length ?\n          [\n          {\n            col: entity,\n            op: 'IN',\n            val: values\n          }] :\n\n          []\n        },\n        filterState: {\n          value: values.length ? values : null,\n          selectedValues: values.length ? [key] : null\n        }\n      },\n      isCurrentValueSelected: selected.includes(key)\n    };\n  };\n\n  const handleClick = (source) => {var _getCrossFilterDataMa;\n    if (!emitCrossFilters) {\n      return;\n    }\n    const pointerEvent = d3.event;\n    pointerEvent.preventDefault();\n    getCrossFilterDataMask(source);\n\n    const dataMask = (_getCrossFilterDataMa = getCrossFilterDataMask(source)) == null ? void 0 : _getCrossFilterDataMa.dataMask;\n    if (dataMask) {\n      setDataMask(dataMask);\n    }\n  };\n\n  const handleContextMenu = (source) => {var _mapData$key3, _mapData$key4;\n    const pointerEvent = d3.event;\n    pointerEvent.preventDefault();\n    const key = source.id || source.country;\n    const val =\n    countryFieldtype === 'name' ? (_mapData$key3 = mapData[key]) == null ? void 0 : _mapData$key3.name : (_mapData$key4 = mapData[key]) == null ? void 0 : _mapData$key4.country;\n    let drillToDetailFilters;\n    let drillByFilters;\n    if (val) {\n      drillToDetailFilters = [\n      {\n        col: entity,\n        op: '==',\n        val,\n        formattedVal: val\n      }];\n\n      drillByFilters = [\n      {\n        col: entity,\n        op: '==',\n        val\n      }];\n\n    }\n    onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n      drillToDetail: drillToDetailFilters,\n      crossFilter: getCrossFilterDataMask(source),\n      drillBy: { filters: drillByFilters, groupbyFieldName: 'entity' }\n    });\n  };\n\n  const map = new Datamap({\n    element,\n    width,\n    height,\n    data: processedData,\n    fills: {\n      defaultFill: theme.colors.grayscale.light2\n    },\n    geographyConfig: {\n      popupOnHover: !inContextMenu,\n      highlightOnHover: !inContextMenu,\n      borderWidth: 1,\n      borderColor: theme.colors.grayscale.light5,\n      highlightBorderColor: theme.colors.grayscale.light5,\n      highlightFillColor: color,\n      highlightBorderWidth: 1,\n      popupTemplate: (geo, d) =>\n      `<div class=\"hoverinfo\"><strong>${d.name}</strong><br>${formatter(\n        d.m1\n      )}</div>`\n    },\n    bubblesConfig: {\n      borderWidth: 1,\n      borderOpacity: 1,\n      borderColor: color,\n      popupOnHover: !inContextMenu,\n      radius: null,\n      popupTemplate: (geo, d) =>\n      `<div class=\"hoverinfo\"><strong>${d.name}</strong><br>${formatter(\n        d.m2\n      )}</div>`,\n      fillOpacity: 0.5,\n      animate: true,\n      highlightOnHover: !inContextMenu,\n      highlightFillColor: color,\n      highlightBorderColor: theme.colors.grayscale.dark2,\n      highlightBorderWidth: 2,\n      highlightBorderOpacity: 1,\n      highlightFillOpacity: 0.85,\n      exitDelay: 100,\n      key: JSON.stringify\n    },\n    done: (datamap) => {\n      datamap.svg.\n      selectAll('.datamaps-subunit').\n      on('contextmenu', handleContextMenu).\n      on('click', handleClick);\n    }\n  });\n\n  map.updateChoropleth(mapData);\n\n  if (showBubbles) {\n    map.bubbles(processedData);\n    div.\n    selectAll('circle.datamaps-bubble').\n    style('fill', color).\n    style('stroke', color).\n    on('contextmenu', handleContextMenu).\n    on('click', handleClick);\n  }\n\n  if (((_filterState$selected = filterState.selectedValues) == null ? void 0 : _filterState$selected.length) > 0) {\n    d3.selectAll('path.datamaps-subunit').\n    filter(\n      (countryFeature) =>\n      !filterState.selectedValues.includes(countryFeature.id)\n    ).\n    style('fill-opacity', theme.opacity.mediumLight);\n\n    // hack to ensure that the clicked country's color is preserved\n    // sometimes the fill color would get default grey value after applying cross filter\n    filterState.selectedValues.forEach((value) => {var _mapData$value;\n      d3.select(`path.datamaps-subunit.${value}`).style(\n        'fill', (_mapData$value =\n        mapData[value]) == null ? void 0 : _mapData$value.fillColor\n      );\n    });\n  }\n}\n\nWorldMap.displayName = 'WorldMap';\nWorldMap.propTypes = propTypes;\n\nexport default WorldMap;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}