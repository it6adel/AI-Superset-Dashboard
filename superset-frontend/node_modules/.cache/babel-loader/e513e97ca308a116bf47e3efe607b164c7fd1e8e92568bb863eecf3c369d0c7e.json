{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE)\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = []\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  Object.entries(tabScopes).every(\n    ([key, { scope }]) => scope && scope.length && key === scope[0]\n  ))\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope =\n    getImmuneChartIdsFromTabsNotInScope({\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, ({ scope }) => scope)\n    });\n    const immuneChartIdsFromTabsInScope = _flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune\n    );\n    const immuneCharts = [\n    ...new Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope]\n    )];\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length\n  );\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n      immuneChartSiblings\n    )\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren.\n  filter(\n    ({ value }) => filterId !== value && !checkedChartIds.includes(value)\n  ).\n  map(({ value }) => value);\n  const tabScopes = _flow(\n    _keyBy((child) => child.value),\n    _mapValues((child) =>\n    traverse({\n      currentNode: child,\n      filterId,\n      checkedChartIds\n    })\n    )\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  chartChildren.some(({ value }) => checkedChartIds.includes(value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune)\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = []\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds\n    });\n  }\n\n  return {};\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}