{"ast":null,"code":"import _range from \"lodash/range\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getMetricLabel, getColumnLabel, getValueFormatter, tooltipHtml } from '@superset-ui/core';\n\nimport { parseNumbersList } from '../utils/controls';\nimport { DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA } from './types';\nimport { defaultGaugeSeriesOption, INTERVAL_GAUGE_SERIES_OPTION, OFFSETS, FONT_SIZE_MULTIPLIERS } from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getColtypesMapping } from '../utils/series';\nexport const getIntervalBoundsAndColors = (intervals, intervalColorIndices, colorFn, min, max) => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  }\n  catch (error) {\n    intervalBoundsNonNormalized = [];\n    intervalColorIndicesArray = [];\n  }\n  const intervalBounds = intervalBoundsNonNormalized.map((bound) => (bound - min) / (max - min));\n  const intervalColors = intervalColorIndicesArray.map((ind) => colorFn.colors[(ind - 1) % colorFn.colors.length]);\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\nconst calculateAxisLineWidth = (data, fontSize, overlap) => overlap ? fontSize : data.length * fontSize;\nconst calculateMin = (data) => 2 * Math.min(...data.map((d) => d.value).concat([0]));\nconst calculateMax = (data) => 2 * Math.max(...data.map((d) => d.value).concat([0]));\nexport default function transformProps(chartProps) {var _queriesData$, _gaugeSeriesOptions$s, _gaugeSeriesOptions$s2, _gaugeSeriesOptions$a, _gaugeSeriesOptions$a2, _gaugeSeriesOptions$a3, _gaugeSeriesOptions$a4, _gaugeSeriesOptions$d;\n  const { width, height, formData, queriesData, hooks, filterState, theme, emitCrossFilters, datasource } = chartProps;\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { groupby, metric, minVal, maxVal, colorScheme, fontSize, numberFormat, currencyFormat, animation, showProgress, overlap, roundCap, showAxisTick, showSplitLine, splitNumber, startAngle, endAngle, showPointer, intervals, intervalColorIndices, valueFormatter, sliceId } = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs = {};\n  const data = ((_queriesData$ = queriesData[0]) == null ? void 0 : _queriesData$.data) || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat, currencyFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value) => valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle = FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle = FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const transformedData = data.map((data_point, index) => {\n    const name = groupbyLabels.\n    map((column) => `${verboseMap[column] || column}: ${data_point[column]}`).\n    join(', ');\n    const colorLabel = groupbyLabels.map((col) => data_point[col]);\n    columnsLabelMap.set(name, groupbyLabels.map((col) => data_point[col]));\n    let item = {\n      value: data_point[metricLabel],\n      name,\n      itemStyle: {\n        color: colorFn(colorLabel, sliceId)\n      },\n      title: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`],\n\n        fontSize\n      },\n      detail: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle +\n        OFFSETS.titleFromCenter +\n        detailOffsetFromTitle}%`],\n\n        fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize\n      }\n    };\n    if (filterState.selectedValues &&\n    !filterState.selectedValues.includes(name)) {\n      item = {\n        ...item,\n        itemStyle: {\n          color: colorFn(index, sliceId),\n          opacity: OpacityEnum.SemiTransparent\n        },\n        detail: {\n          show: false\n        },\n        title: {\n          show: false\n        }\n      };\n    }\n    return item;\n  });\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const min = minVal != null ? minVal : calculateMin(transformedData);\n  const max = maxVal != null ? maxVal : calculateMax(transformedData);\n  const axisLabels = _range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(...axisLabels.map((label) => numberFormatter(label).length).concat([1]));\n  const intervalBoundsAndColors = getIntervalBoundsAndColors(intervals, intervalColorIndices, colorFn, min, max);\n  const splitLineDistance = axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance = FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n  fontSize *\n  FONT_SIZE_MULTIPLIERS.axisLabelLength *\n  axisLabelLength + (\n  showSplitLine ? splitLineLength : 0) + (\n  showAxisTick ? axisTickLength : 0) +\n  OFFSETS.ticksFromLine -\n  axisLineWidth;\n  const axisTickDistance = axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize\n  };\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: (_gaugeSeriesOptions$s = gaugeSeriesOptions.splitLine) == null ? void 0 : (_gaugeSeriesOptions$s2 = _gaugeSeriesOptions$s.lineStyle) == null ? void 0 : _gaugeSeriesOptions$s2.color\n    }\n  };\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: (_gaugeSeriesOptions$a = gaugeSeriesOptions.axisLine) == null ? void 0 : (_gaugeSeriesOptions$a2 = _gaugeSeriesOptions$a.lineStyle) == null ? void 0 : _gaugeSeriesOptions$a2.color\n    }\n  };\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: (_gaugeSeriesOptions$a3 = gaugeSeriesOptions.axisLabel) == null ? void 0 : _gaugeSeriesOptions$a3.color\n  };\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: (_gaugeSeriesOptions$a4 = gaugeSeriesOptions.axisTick) == null ? void 0 : _gaugeSeriesOptions$a4.lineStyle\n  };\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value) => formatValue(value),\n    color: (_gaugeSeriesOptions$d = gaugeSeriesOptions.detail) == null ? void 0 : _gaugeSeriesOptions$d.color\n  };\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params) => {\n      const { name, value } = params;\n      return tooltipHtml([[metricLabel, formatValue(value)]], name);\n    }\n  };\n  let pointer;\n  if (intervalBoundsAndColors.length) {var _INTERVAL_GAUGE_SERIE, _INTERVAL_GAUGE_SERIE2, _INTERVAL_GAUGE_SERIE3, _INTERVAL_GAUGE_SERIE4, _INTERVAL_GAUGE_SERIE5, _INTERVAL_GAUGE_SERIE6;\n    splitLine.lineStyle.color = (_INTERVAL_GAUGE_SERIE =\n    INTERVAL_GAUGE_SERIES_OPTION.splitLine) == null ? void 0 : (_INTERVAL_GAUGE_SERIE2 = _INTERVAL_GAUGE_SERIE.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE2.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION == null ? void 0 : (_INTERVAL_GAUGE_SERIE3 = INTERVAL_GAUGE_SERIES_OPTION.axisTick) == null ? void 0 : (_INTERVAL_GAUGE_SERIE4 = _INTERVAL_GAUGE_SERIE3.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE4.\n    color;\n    axisLabel.color = (_INTERVAL_GAUGE_SERIE5 = INTERVAL_GAUGE_SERIES_OPTION.axisLabel) == null ? void 0 : _INTERVAL_GAUGE_SERIE5.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: (_INTERVAL_GAUGE_SERIE6 = INTERVAL_GAUGE_SERIES_OPTION.pointer) == null ? void 0 : _INTERVAL_GAUGE_SERIE6.itemStyle\n    };\n  } else\n  {\n    pointer = {\n      show: showPointer,\n      showAbove: false\n    };\n  }\n  const series = [\n  {\n    type: 'gauge',\n    startAngle,\n    endAngle,\n    min,\n    max,\n    progress,\n    animation,\n    axisLine: axisLine,\n    splitLine,\n    splitNumber,\n    axisLabel,\n    axisTick,\n    pointer,\n    detail,\n    // @ts-ignore\n    tooltip,\n    radius: Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n    center: ['50%', '55%'],\n    data: transformedData\n  }];\n\n  const echartOptions = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item'\n    },\n    series\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}