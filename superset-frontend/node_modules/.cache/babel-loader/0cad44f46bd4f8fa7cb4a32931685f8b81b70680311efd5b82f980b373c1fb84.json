{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { toQueryString } from 'src/utils/urlUtils';\nimport { api } from './queryApi';\nimport { useSchemas } from './schemas';\nconst tableApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    tables: builder.query({\n      providesTags: ['Tables'],\n      query: ({ dbId, catalog, schema, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId != null ? dbId : 'undefined'}/tables/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n          schema_name: schema ? encodeURIComponent(schema) : '',\n          ...(catalog && { catalog_name: catalog })\n        },\n        transformResponse: ({ json }) => ({\n          options: json.result,\n          hasMore: json.count > json.result.length\n        })\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId, schema } }) => ({\n        dbId,\n        schema\n      })\n    }),\n    tableMetadata: builder.query({\n      providesTags: (result) => result ?\n      [\n      { type: 'TableMetadatas', id: result.name },\n      { type: 'TableMetadatas', id: 'LIST' }] :\n\n      [{ type: 'TableMetadatas', id: 'LIST' }],\n      query: ({ dbId, catalog, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_metadata/${toQueryString({\n          name: table,\n          catalog,\n          schema\n        })}`,\n        transformResponse: ({ json }) => json\n      })\n    }),\n    tableExtendedMetadata: builder.query({\n      query: ({ dbId, catalog, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_metadata/extra/${toQueryString({ name: table, catalog, schema })}`,\n        transformResponse: ({ json }) => json\n      }),\n      providesTags: (result, error, { table }) => [\n      { type: 'TableMetadatas', id: table }]\n\n    })\n  })\n});\nexport const { useLazyTablesQuery, useTablesQuery, useLazyTableMetadataQuery, useLazyTableExtendedMetadataQuery, useTableMetadataQuery, useTableExtendedMetadataQuery, endpoints: tableEndpoints, util: tableApiUtil } = tableApi;\nexport function useTables(options) {\n  const { dbId, catalog, schema, onSuccess, onError } = options || {};\n  const isMountedRef = useRef(false);\n  const { currentData: schemaOptions, isFetching } = useSchemas({\n    dbId,\n    catalog: catalog || undefined\n  });\n  const schemaOptionsMap = useMemo(() => new Set(schemaOptions == null ? void 0 : schemaOptions.map(({ value }) => value)), [schemaOptions]);\n  const enabled = Boolean(dbId && schema && !isFetching && schemaOptionsMap.has(schema));\n  const result = useTablesQuery({ dbId, catalog, schema, forceRefresh: false }, {\n    skip: !enabled\n  });\n  const [trigger] = useLazyTablesQuery();\n  const handleOnSuccess = useEffectEvent((data, isRefetched) => {\n    onSuccess == null ? void 0 : onSuccess(data, isRefetched);\n  });\n  const handleOnError = useEffectEvent((error) => {\n    onError == null ? void 0 : onError(error);\n  });\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, catalog, schema, forceRefresh: true }).then(({ isSuccess, isError, data, error }) => {\n        if (isSuccess && data) {\n          handleOnSuccess(data, true);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      });\n    }\n  }, [dbId, catalog, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const { requestId, isSuccess, isError, isFetching, currentData, error, originalArgs } = result;\n      if (!(originalArgs != null && originalArgs.forceRefresh) && requestId && !isFetching) {\n        if (isSuccess && currentData) {\n          handleOnSuccess(currentData, false);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      }\n    } else\n    {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n  return {\n    ...result,\n    refetch\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}