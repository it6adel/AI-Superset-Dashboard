{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useEffect, useState } from 'react';\nimport FormItem from 'src/components/Form/FormItem';\nimport { Select } from 'src/components';\nimport { isFeatureEnabled, FeatureFlag, isDefined, styled, SupersetClient, t } from '@superset-ui/core';\nimport { Operators, OPERATORS_OPTIONS, HAVING_OPERATORS, MULTI_OPERATORS, CUSTOM_OPERATORS, DISABLE_INPUT_OPERATORS, OPERATOR_ENUM_TO_OPERATOR_TYPE } from 'src/explore/constants';\nimport FilterDefinitionOption from 'src/explore/components/controls/MetricControl/FilterDefinitionOption';\nimport { Tooltip } from 'src/components/Tooltip';\nimport { Input } from 'src/components/Input';\nimport { optionLabel } from 'src/utils/common';\nimport { isTemporalColumn } from '@superset-ui/chart-controls';\nimport useAdvancedDataTypes from './useAdvancedDataTypes';\nimport { useDatePickerInAdhocFilter } from '../utils';\nimport { useDefaultTimeFilter } from '../../DateFilterControl/utils';\nimport { Clauses, ExpressionTypes } from '../types';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst StyledInput = styled(Input)`\n  margin-bottom: ${({ theme }) => theme.gridUnit * 4}px;\n`;\nexport const StyledFormItem = styled(FormItem)`\n  &.ant-row.ant-form-item {\n    margin: 0;\n  }\n`;\nconst SelectWithLabel = styled(Select)`\n  .ant-select-selector::after {\n    content: ${({ labelText }) => labelText || '\\\\A0'};\n    display: inline-block;\n    white-space: nowrap;\n    color: ${({ theme }) => theme.colors.grayscale.light1};\n    width: max-content;\n  }\n`;\nexport const useSimpleTabFilterProps = (props) => {\n  const defaultTimeFilter = useDefaultTimeFilter();\n  const isOperatorRelevant = (operator, subject) => {var _props$datasource$col;\n    const column = (_props$datasource$col = props.datasource.columns) == null ? void 0 : _props$datasource$col.find((col) => col.column_name === subject);\n    const isColumnBoolean = !!column && (column.type === 'BOOL' || column.type === 'BOOLEAN');\n    const isColumnNumber = !!column && (column.type === 'INT' || column.type === 'INTEGER');\n    const isColumnFunction = !!column && !!column.expression;\n    if (operator && operator === Operators.LatestPartition) {\n      const { partitionColumn } = props;\n      return partitionColumn && subject && subject === partitionColumn;\n    }\n    if (operator && operator === Operators.TemporalRange) {\n      // hide the TEMPORAL_RANGE operator\n      return false;\n    }\n    if (operator === Operators.IsTrue || operator === Operators.IsFalse) {\n      return isColumnBoolean || isColumnNumber || isColumnFunction;\n    }\n    if (isColumnBoolean) {\n      return operator === Operators.IsNull || operator === Operators.IsNotNull;\n    }\n    return props.adhocFilter.clause !== Clauses.Having ||\n    HAVING_OPERATORS.indexOf(operator) !== -1;\n  };\n  const onSubjectChange = (id) => {\n    const option = props.options.find((option) => 'column_name' in option && option.column_name === id ||\n    'optionName' in option && option.optionName === id);\n    let subject = '';\n    let clause;\n    // infer the new clause based on what subject was selected.\n    if (option && 'column_name' in option) {\n      subject = option.column_name;\n      clause = Clauses.Where;\n    } else\n    if (option && 'saved_metric_name' in option) {\n      subject = option.saved_metric_name;\n      clause = Clauses.Having;\n    } else\n    if (option != null && option.label) {\n      subject = option.label;\n      clause = Clauses.Having;\n    }\n    let { operator, operatorId, comparator } = props.adhocFilter;\n    operator =\n    operator && operatorId && isOperatorRelevant(operatorId, subject) ?\n    OPERATOR_ENUM_TO_OPERATOR_TYPE[operatorId].operation :\n    null;\n    if (!isDefined(operator)) {\n      // if operator is `null`, use the `IN` and reset the comparator.\n      operator = Operators.In;\n      operatorId = Operators.In;\n      comparator = undefined;\n    }\n    if (isTemporalColumn(id, props.datasource)) {\n      subject = id;\n      operator = Operators.TemporalRange;\n      operatorId = Operators.TemporalRange;\n      comparator = defaultTimeFilter;\n    }\n    props.onChange(props.adhocFilter.duplicateWith({\n      subject,\n      clause,\n      operator,\n      expressionType: ExpressionTypes.Simple,\n      operatorId,\n      comparator\n    }));\n  };\n  const onOperatorChange = (operatorId) => {\n    const currentComparator = props.adhocFilter.comparator;\n    let newComparator;\n    // convert between list of comparators and individual comparators\n    // (e.g. `in ('North America', 'Africa')` to `== 'North America'`)\n    if (MULTI_OPERATORS.has(operatorId)) {\n      newComparator = Array.isArray(currentComparator) ?\n      currentComparator :\n      [currentComparator].filter((element) => element);\n    } else\n    {\n      newComparator = Array.isArray(currentComparator) ?\n      currentComparator[0] :\n      currentComparator;\n    }\n    if (operatorId && CUSTOM_OPERATORS.has(operatorId)) {\n      props.onChange(props.adhocFilter.duplicateWith({\n        subject: props.adhocFilter.subject,\n        clause: Clauses.Where,\n        operatorId,\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[operatorId].operation,\n        expressionType: ExpressionTypes.Sql,\n        datasource: props.datasource\n      }));\n    } else\n    {\n      props.onChange(props.adhocFilter.duplicateWith({\n        operatorId,\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[operatorId].operation,\n        comparator: newComparator,\n        expressionType: ExpressionTypes.Simple\n      }));\n    }\n  };\n  const onComparatorChange = (comparator) => {\n    props.onChange(props.adhocFilter.duplicateWith({\n      comparator,\n      expressionType: ExpressionTypes.Simple\n    }));\n  };\n  const clearOperator = () => {\n    props.onChange(props.adhocFilter.duplicateWith({\n      operatorId: undefined,\n      operator: undefined\n    }));\n  };\n  const onDatePickerChange = (columnName, timeRange) => {\n    props.onChange(props.adhocFilter.duplicateWith({\n      subject: columnName,\n      operator: Operators.TemporalRange,\n      comparator: timeRange,\n      expressionType: ExpressionTypes.Simple\n    }));\n  };\n  return {\n    onSubjectChange,\n    onOperatorChange,\n    onComparatorChange,\n    isOperatorRelevant,\n    clearOperator,\n    onDatePickerChange\n  };\n};\nconst AdhocFilterEditPopoverSimpleTabContent = (props) => {var _props$operators, _props$operators2;\n  const { onSubjectChange, onOperatorChange, isOperatorRelevant, onComparatorChange, onDatePickerChange } = useSimpleTabFilterProps(props);\n  const [suggestions, setSuggestions] = useState([]);\n  const [comparator, setComparator] = useState(props.adhocFilter.comparator);\n  const [loadingComparatorSuggestions, setLoadingComparatorSuggestions] = useState(false);\n  const { advancedDataTypesState, subjectAdvancedDataType, fetchAdvancedDataTypeValueCallback, fetchSubjectAdvancedDataType } = useAdvancedDataTypes(props.validHandler);\n  // TODO: This does not need to exist, just use the advancedTypeOperatorList list\n  const isOperatorRelevantWrapper = (operator, subject) => subjectAdvancedDataType ?\n  isOperatorRelevant(operator, subject) &&\n  advancedDataTypesState.advancedDataTypeOperatorList.includes(operator) :\n  isOperatorRelevant(operator, subject);\n  const onInputComparatorChange = (event) => {\n    const { value } = event.target;\n    setComparator(value);\n    onComparatorChange(value);\n  };\n  const renderSubjectOptionLabel = (option) => _jsx(FilterDefinitionOption, { option: option });\n  const getOptionsRemaining = () => {\n    // if select is multi/value is array, we show the options not selected\n    const valuesFromSuggestionsLength = Array.isArray(comparator) ?\n    comparator.filter((v) => suggestions.includes(v)).length :\n    0;\n    return suggestions ? suggestions.length - valuesFromSuggestionsLength : 0;\n  };\n  const createSuggestionsPlaceholder = () => {\n    const optionsRemaining = getOptionsRemaining();\n    const placeholder = t('%s option(s)', optionsRemaining);\n    return optionsRemaining ? placeholder : '';\n  };\n  const handleSubjectChange = (subject) => {\n    setComparator(undefined);\n    onSubjectChange(subject);\n  };\n  let columns = props.options;\n  const { subject, operator, operatorId } = props.adhocFilter;\n  const subjectSelectProps = {\n    ariaLabel: t('Select subject'),\n    value: subject != null ? subject : undefined,\n    onChange: handleSubjectChange,\n    notFoundContent: t('No such column found. To filter on a metric, try the Custom SQL tab.'),\n    autoFocus: !subject,\n    placeholder: ''\n  };\n  subjectSelectProps.placeholder =\n  props.adhocFilter.clause === Clauses.Where ?\n  t('%s column(s)', columns.length) :\n  t('To filter on a metric, use Custom SQL tab.');\n  columns = props.options.filter((option) => 'column_name' in option && option.column_name);\n  const operatorSelectProps = {\n    placeholder: t('%s operator(s)', ((_props$operators = props.operators) != null ? _props$operators : OPERATORS_OPTIONS).filter((op) => isOperatorRelevantWrapper(op, subject)).length),\n    value: operatorId,\n    onChange: onOperatorChange,\n    autoFocus: !!subjectSelectProps.value && !operator,\n    ariaLabel: t('Select operator')\n  };\n  const shouldFocusComparator = !!subjectSelectProps.value && !!operatorSelectProps.value;\n  const comparatorSelectProps = {\n    allowClear: true,\n    allowNewOptions: true,\n    ariaLabel: t('Comparator option'),\n    mode: MULTI_OPERATORS.has(operatorId) ?\n    'multiple' :\n    'single',\n    loading: loadingComparatorSuggestions,\n    value: comparator,\n    onChange: onComparatorChange,\n    notFoundContent: t('Type a value here'),\n    disabled: DISABLE_INPUT_OPERATORS.includes(operatorId),\n    placeholder: createSuggestionsPlaceholder(),\n    autoFocus: shouldFocusComparator\n  };\n  const labelText = comparator && comparator.length > 0 && createSuggestionsPlaceholder();\n  const datePicker = useDatePickerInAdhocFilter({\n    columnName: props.adhocFilter.subject,\n    timeRange: props.adhocFilter.operator === Operators.TemporalRange ?\n    props.adhocFilter.comparator :\n    undefined,\n    datasource: props.datasource,\n    onChange: onDatePickerChange\n  });\n  useEffect(() => {\n    const refreshComparatorSuggestions = () => {\n      const { datasource } = props;\n      const col = props.adhocFilter.subject;\n      const having = props.adhocFilter.clause === Clauses.Having;\n      if (col && datasource && datasource.filter_select && !having) {\n        const controller = new AbortController();\n        const { signal } = controller;\n        if (loadingComparatorSuggestions) {\n          controller.abort();\n        }\n        setLoadingComparatorSuggestions(true);\n        SupersetClient.get({\n          signal,\n          endpoint: `/api/v1/datasource/${datasource.type}/${datasource.id}/column/${col}/values/`\n        }).\n        then(({ json }) => {\n          setSuggestions(json.result.map((suggestion) => ({\n            value: suggestion,\n            label: optionLabel(suggestion)\n          })));\n          setLoadingComparatorSuggestions(false);\n        }).\n        catch(() => {\n          setSuggestions([]);\n          setLoadingComparatorSuggestions(false);\n        });\n      }\n    };\n    if (!datePicker) {\n      refreshComparatorSuggestions();\n    }\n  }, [props.adhocFilter.subject]);\n  useEffect(() => {\n    if (isFeatureEnabled(FeatureFlag.EnableAdvancedDataTypes)) {\n      fetchSubjectAdvancedDataType(props);\n    }\n  }, [props.adhocFilter.subject]);\n  useEffect(() => {\n    if (isFeatureEnabled(FeatureFlag.EnableAdvancedDataTypes)) {\n      fetchAdvancedDataTypeValueCallback(comparator === undefined ? '' : comparator, advancedDataTypesState, subjectAdvancedDataType);\n    }\n  }, [comparator, subjectAdvancedDataType, fetchAdvancedDataTypeValueCallback]);\n  useEffect(() => {\n    if (isFeatureEnabled(FeatureFlag.EnableAdvancedDataTypes)) {\n      setComparator(props.adhocFilter.comparator);\n    }\n  }, [props.adhocFilter.comparator]);\n  // another name for columns, just for following previous naming.\n  const subjectComponent = _jsx(Select, { css: (theme) => ({\n      marginTop: theme.gridUnit * 4,\n      marginBottom: theme.gridUnit * 4\n    }), options: columns.map((column) => ({\n      value: 'column_name' in column && column.column_name ||\n      'optionName' in column && column.optionName ||\n      '',\n      label: 'saved_metric_name' in column && column.saved_metric_name ||\n      'column_name' in column && column.column_name ||\n      'label' in column && column.label,\n      key: 'id' in column && column.id ||\n      'optionName' in column && column.optionName ||\n      undefined,\n      customLabel: renderSubjectOptionLabel(column)\n    })), ...subjectSelectProps });\n  const operatorsAndOperandComponent = _jsxs(_Fragment, { children: [\n    _jsx(Select, { css: (theme) => ({ marginBottom: theme.gridUnit * 4 }), options: ((_props$operators2 = props.operators) != null ? _props$operators2 : OPERATORS_OPTIONS).\n      filter((op) => isOperatorRelevantWrapper(op, subject)).\n      map((option, index) => ({\n        value: option,\n        label: OPERATOR_ENUM_TO_OPERATOR_TYPE[option].display,\n        key: option,\n        order: index\n      })), ...operatorSelectProps }),\n    MULTI_OPERATORS.has(operatorId) || suggestions.length > 0 ? _jsx(Tooltip, { title: advancedDataTypesState.errorMessage ||\n      advancedDataTypesState.parsedAdvancedDataType, children:\n      _jsx(SelectWithLabel, { labelText: labelText, options: suggestions, ...comparatorSelectProps }) }\n    ) : _jsx(Tooltip, { title: advancedDataTypesState.errorMessage ||\n      advancedDataTypesState.parsedAdvancedDataType, children:\n      _jsx(StyledInput, { name: \"filter-value\", ref: (ref) => {\n          if (ref && shouldFocusComparator) {\n            ref.focus();\n          }\n        }, onChange: onInputComparatorChange, value: comparator, placeholder: t('Filter value (case sensitive)'), disabled: DISABLE_INPUT_OPERATORS.includes(operatorId) }) }\n    )] }\n  );\n  return _jsxs(_Fragment, { children: [\n    subjectComponent,\n    datePicker != null ? datePicker : operatorsAndOperandComponent] }\n  );\n};\nexport default AdhocFilterEditPopoverSimpleTabContent;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}