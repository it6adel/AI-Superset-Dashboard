{"ast":null,"code":"import _pick from \"lodash/pick\";import _omit from \"lodash/omit\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ensureIsArray } from '@superset-ui/core';\n\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/components/Chart/chartAction';\nimport { getControlsState } from 'src/explore/store';\nimport {\n  getControlConfig,\n  getControlStateFromControlConfig,\n  getControlValuesCompatibleWithDatasource,\n  StandardizedFormData } from\n'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\nimport { HYDRATE_EXPLORE } from '../actions/hydrateExplore';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState\n      };\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred\n      };\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true\n      };\n    },\n    [actions.START_METADATA_LOADING]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true\n      };\n    },\n    [actions.STOP_METADATA_LOADING]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: false\n      };\n    },\n    [actions.SYNC_DATASOURCE_METADATA]() {\n      return {\n        ...state,\n        datasource: action.datasource\n      };\n    },\n    [actions.UPDATE_FORM_DATA_BY_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      const { prevDatasource, newDatasource } = action;\n      const controls = { ...state.controls };\n      const controlsTransferred = [];\n\n      if (\n      prevDatasource.id !== newDatasource.id ||\n      prevDatasource.type !== newDatasource.type)\n      {\n        newFormData.datasource = newDatasource.uid;\n      }\n      // reset control values for column/metric related controls\n      Object.entries(controls).forEach(([controlName, controlState]) => {\n        if (\n        // for direct column select controls\n        controlState.valueKey === 'column_name' ||\n        // for all other controls\n        'savedMetrics' in controlState ||\n        'columns' in controlState ||\n        'options' in controlState && !Array.isArray(controlState.options))\n        {\n          newFormData[controlName] = getControlValuesCompatibleWithDatasource(\n            newDatasource,\n            controlState,\n            controlState.value\n          );\n          if (\n          ensureIsArray(newFormData[controlName]).length > 0 &&\n          newFormData[controlName] !== controls[controlName].default)\n          {\n            controlsTransferred.push(controlName);\n          }\n        }\n      });\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.newDatasource\n      };\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData),\n        controlsTransferred\n      };\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true\n      };\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const { controlName, value, validationErrors } = action;\n      let new_form_data = { ...state.form_data, [controlName]: value };\n      const old_metrics_data = state.form_data.metrics;\n      const new_column_config = state.form_data.column_config;\n\n      const vizType = new_form_data.viz_type;\n\n      // if the controlName is metrics, and the metric column name is updated,\n      // need to update column config as well to keep the previous config.\n      if (controlName === 'metrics' && old_metrics_data && new_column_config) {\n        value.forEach((item, index) => {var _old_metrics_data$ind, _old_metrics_data$ind2;\n          const itemExist = old_metrics_data.some(\n            (oldItem) => (oldItem == null ? void 0 : oldItem.label) === (item == null ? void 0 : item.label)\n          );\n\n          if (\n          !itemExist &&\n          (item == null ? void 0 : item.label) !== ((_old_metrics_data$ind = old_metrics_data[index]) == null ? void 0 : _old_metrics_data$ind.label) &&\n          !!new_column_config[(_old_metrics_data$ind2 = old_metrics_data[index]) == null ? void 0 : _old_metrics_data$ind2.label])\n          {\n            new_column_config[item.label] =\n            new_column_config[old_metrics_data[index].label];\n\n            delete new_column_config[old_metrics_data[index].label];\n          }\n        });\n        new_form_data.column_config = new_column_config;\n      }\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not exist in current controls,\n      const controlConfig =\n      state.controls[action.controlName] ||\n      getControlConfig(action.controlName, vizType) ||\n      null;\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value)\n      };\n\n      const column_config = {\n        ...state.controls.column_config,\n        ...(new_column_config && { value: new_column_config })\n      };\n\n      const newState = {\n        ...state,\n        controls: {\n          ...state.controls,\n          ...(controlConfig && { [controlName]: control }),\n          ...(controlName === 'metrics' && { column_config })\n        }\n      };\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach((controlName) => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n              newState.controls[controlName],\n              newState,\n              newState.controls[controlName].value\n            )\n          };\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach((err) => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const isVizSwitch =\n      action.controlName === 'viz_type' &&\n      action.value !== state.controls.viz_type.value;\n      let currentControlsState = state.controls;\n      if (isVizSwitch) {\n        // get StandardizedFormData from source form_data\n        const sfd = new StandardizedFormData(state.form_data);\n        const transformed = sfd.transform(action.value, state);\n        new_form_data = transformed.formData;\n        currentControlsState = transformed.controlsState;\n      }\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          ...(controlConfig && {\n            [action.controlName]: {\n              ...control,\n              validationErrors: errors\n            }\n          }),\n          ...rerenderedControls\n        }\n      };\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData)\n      };\n    },\n    [actions.SET_FORM_DATA]() {\n      return {\n        ...state,\n        form_data: action.formData\n      };\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName\n      };\n    },\n    [actions.SET_SAVE_ACTION]() {\n      return {\n        ...state,\n        saveAction: action.saveAction\n      };\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite\n      };\n    },\n    [actions.SET_STASH_FORM_DATA]() {\n      const { form_data, hiddenFormData } = state;\n      const { fieldNames, isHidden } = action;\n      if (isHidden) {\n        return {\n          ...state,\n          hiddenFormData: {\n            ...hiddenFormData,\n            ..._pick(form_data, fieldNames)\n          },\n          form_data: _omit(form_data, fieldNames)\n        };\n      }\n\n      const restoredField = _pick(hiddenFormData, fieldNames);\n      return Object.keys(restoredField).length === 0 ?\n      state :\n      {\n        ...state,\n        form_data: {\n          ...form_data,\n          ...restoredField\n        },\n        hiddenFormData: _omit(hiddenFormData, fieldNames)\n      };\n    },\n    [actions.SLICE_UPDATED]() {var _action$slice$slice_n;\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n          owners: action.slice.owners ?\n          action.slice.owners.map((owner) => owner.value) :\n          null\n        },\n        sliceName: (_action$slice$slice_n = action.slice.slice_name) != null ? _action$slice$slice_n : state.sliceName,\n        metadata: {\n          ...state.metadata,\n          owners: action.slice.owners ?\n          action.slice.owners.map((owner) => owner.label) :\n          null\n        }\n      };\n    },\n    [actions.SET_FORCE_QUERY]() {\n      return {\n        ...state,\n        force: action.force\n      };\n    },\n    [HYDRATE_EXPLORE]() {\n      return {\n        ...action.data.explore\n      };\n    }\n  };\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}