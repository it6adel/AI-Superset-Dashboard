{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { chart } from 'src/components/Chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport { findPermission } from 'src/utils/findPermission';\nimport {\n  canUserEditDashboard,\n  canUserSaveAsDashboard } from\n'src/dashboard/util/permissionUtils';\nimport {\n  getCrossFiltersConfiguration,\n  isCrossFiltersEnabled } from\n'src/dashboard/util/crossFilters';\nimport {\n  DASHBOARD_HEADER_ID,\n  GRID_DEFAULT_CHART_WIDTH,\n  GRID_COLUMN_COUNT,\n  DASHBOARD_ROOT_ID } from\n'src/dashboard/util/constants';\nimport {\n  DASHBOARD_HEADER_TYPE,\n  CHART_TYPE,\n  ROW_TYPE } from\n'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { ResourceStatus } from 'src/hooks/apiResources/apiResources';\nimport extractUrlParams from '../util/extractUrlParams';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport { FilterBarOrientation } from '../types';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard =\n({ history, dashboard, charts, dataMask, activeTabs }) =>\n(dispatch, getState) => {\n  const { user, common, dashboardState } = getState();\n  const { metadata, position_data: positionData } = dashboard;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  charts.forEach((chart) => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n\n  // new dash: position_json could be {} or null\n  const layout =\n  positionData && Object.keys(positionData).length > 0 ?\n  positionData :\n  getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach((layoutComponent) => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  const slicesFromExploreCount = new Map();\n\n  charts.forEach((slice) => {\n    const key = slice.slice_id;\n    const formData = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams\n      }\n    };\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data: applyDefaultFormData(formData)\n    };\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime()\n    };\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {var _slicesFromExploreCou;\n      if (\n      newSlicesContainerWidth === 0 ||\n      newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT)\n      {\n        newSlicesContainer = newComponentFactory(\n          ROW_TYPE,\n          (parent.parents || []).slice()\n        );\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n        CHART_TYPE,\n        {\n          chartId: slice.slice_id\n        },\n        (newSlicesContainer.parents || []).slice()\n      );\n\n      const count = ((_slicesFromExploreCou = slicesFromExploreCount.get(slice.slice_id)) != null ? _slicesFromExploreCou : 0) + 1;\n      chartHolder.id = `${CHART_TYPE}-explore-${slice.slice_id}-${count}`;\n      slicesFromExploreCount.set(slice.slice_id, count);\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n\n  // make sure that parents tree is built\n  if (\n  Object.values(layout).some(\n    (element) => element.id !== DASHBOARD_ROOT_ID && !element.parents\n  ))\n  {\n    updateComponentParentsList({\n      currentComponent: layout[DASHBOARD_ROOT_ID],\n      layout\n    });\n  }\n\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout\n  });\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboard.dashboard_title\n    }\n  };\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: []\n  };\n\n  // Searches for a focused_chart parameter in the URL to automatically focus a chart\n  const focusedChartId = getUrlParam(URL_PARAMS.dashboardFocusedChart);\n  let focusedChartLayoutId;\n  if (focusedChartId) {\n    // Converts focused_chart to dashboard layout id\n    const found = Object.values(dashboardLayout.present).find(\n      (element) => {var _element$meta;return ((_element$meta = element.meta) == null ? void 0 : _element$meta.chartId) === focusedChartId;}\n    );\n    focusedChartLayoutId = found == null ? void 0 : found.id;\n    // Removes the focused_chart parameter from the URL\n    const params = new URLSearchParams(window.location.search);\n    params.delete(URL_PARAMS.dashboardFocusedChart.name);\n    history.replace({\n      search: params.toString()\n    });\n  }\n\n  // find direct link component and path from root\n  const directLinkComponentId = focusedChartLayoutId || getLocationHash();\n  let directPathToChild = dashboardState.directPathToChild || [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: (metadata == null ? void 0 : metadata.native_filter_configuration) || []\n  });\n\n  const { chartConfiguration, globalChartConfiguration } =\n  getCrossFiltersConfiguration(\n    dashboardLayout.present,\n    metadata,\n    chartQueries\n  );\n  metadata.chart_configuration = chartConfiguration;\n  metadata.global_chart_configuration = globalChartConfiguration;\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboard, user);\n  const crossFiltersEnabled = isCrossFiltersEnabled(\n    metadata.cross_filters_enabled\n  );\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboard,\n        metadata,\n        userId: user.userId ? String(user.userId) : null, // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: canUserSaveAsDashboard(dashboard, user),\n        dash_share_perm: findPermission(\n          'can_share_dashboard',\n          'Superset',\n          roles\n        ),\n        superset_can_explore: findPermission(\n          'can_explore',\n          'Superset',\n          roles\n        ),\n        superset_can_share: findPermission(\n          'can_share_chart',\n          'Superset',\n          roles\n        ),\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common == null ? void 0 : common.flash_messages,\n          conf: common == null ? void 0 : common.conf\n        },\n        filterBarOrientation:\n        metadata.filter_bar_orientation || FilterBarOrientation.Vertical,\n        crossFiltersEnabled\n      },\n      dataMask,\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        preselectNativeFilters: getUrlParam(URL_PARAMS.nativeFilters),\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: (metadata == null ? void 0 : metadata.expanded_slices) || {},\n        refreshFrequency: (metadata == null ? void 0 : metadata.refresh_frequency) || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboard.css || '',\n        colorNamespace: (metadata == null ? void 0 : metadata.color_namespace) || null,\n        colorScheme: (metadata == null ? void 0 : metadata.color_scheme) || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboard.published,\n        hasUnsavedChanges: false,\n        dashboardIsSaving: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboard.changed_on,\n        isRefreshing: false,\n        isFiltersRefreshing: false,\n        activeTabs: activeTabs || (dashboardState == null ? void 0 : dashboardState.activeTabs) || [],\n        datasetsStatus:\n        (dashboardState == null ? void 0 : dashboardState.datasetsStatus) || ResourceStatus.Loading\n      },\n      dashboardLayout\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}