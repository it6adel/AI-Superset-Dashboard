{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { extractTimegrain, getNumberFormatter, NumberFormats, GenericDataType, getMetricLabel, getXAxisLabel, getValueFormatter, t, tooltipHtml } from '@superset-ui/core';\nimport { graphic } from 'echarts/core';\nimport { getDateFormatter, parseMetricValue } from '../utils';\nimport { getDefaultTooltip } from '../../utils/tooltip';\nconst formatPercentChange = getNumberFormatter(NumberFormats.PERCENT_SIGNED_1_POINT);\nexport default function transformProps(chartProps) {var _chartProps$datasourc, _metricEntry;\n  const { width, height, queriesData, formData, rawFormData, theme, hooks, inContextMenu, datasource: { currencyFormats = {}, columnFormats = {} } } = chartProps;\n  const { colorPicker, compareLag: compareLag_, compareSuffix = '', timeFormat, headerFontSize, metric = 'value', showTimestamp, showTrendLine, startYAxisAtZero, subheader = '', subheaderFontSize, forceTimestampFormatting, yAxisFormat, currencyFormat, timeRangeFixed } = formData;\n  const granularity = extractTimegrain(rawFormData);\n  const { data = [], colnames = [], coltypes = [], from_dttm: fromDatetime, to_dttm: toDatetime } = queriesData[0];\n  const refs = {};\n  const metricName = getMetricLabel(metric);\n  const compareLag = Number(compareLag_) || 0;\n  let formattedSubheader = subheader;\n  const { r, g, b } = colorPicker;\n  const mainColor = `rgb(${r}, ${g}, ${b})`;\n  const xAxisLabel = getXAxisLabel(rawFormData);\n  let trendLineData;\n  let percentChange = 0;\n  let bigNumber = data.length === 0 ? null : data[0][metricName];\n  let timestamp = data.length === 0 ? null : data[0][xAxisLabel];\n  let bigNumberFallback;\n  const metricColtypeIndex = colnames.findIndex((name) => name === metricName);\n  const metricColtype = metricColtypeIndex > -1 ? coltypes[metricColtypeIndex] : null;\n  if (data.length > 0) {\n    const sortedData = data.\n    map((d) => [d[xAxisLabel], parseMetricValue(d[metricName])])\n    // sort in time descending order\n    .sort((a, b) => a[0] !== null && b[0] !== null ? b[0] - a[0] : 0);\n    bigNumber = sortedData[0][1];\n    timestamp = sortedData[0][0];\n    if (bigNumber === null) {\n      bigNumberFallback = sortedData.find((d) => d[1] !== null);\n      bigNumber = bigNumberFallback ? bigNumberFallback[1] : null;\n      timestamp = bigNumberFallback ? bigNumberFallback[0] : null;\n    }\n    if (compareLag > 0) {\n      const compareIndex = compareLag;\n      if (compareIndex < sortedData.length) {\n        const compareValue = sortedData[compareIndex][1];\n        // compare values must both be non-nulls\n        if (bigNumber !== null && compareValue !== null) {\n          percentChange = compareValue ?\n          (bigNumber - compareValue) / Math.abs(compareValue) :\n          0;\n          formattedSubheader = `${formatPercentChange(percentChange)} ${compareSuffix}`;\n        }\n      }\n    }\n    sortedData.reverse();\n    // @ts-ignore\n    trendLineData = showTrendLine ? sortedData : undefined;\n  }\n  let className = '';\n  if (percentChange > 0) {\n    className = 'positive';\n  } else\n  if (percentChange < 0) {\n    className = 'negative';\n  }\n  let metricEntry;\n  if ((_chartProps$datasourc = chartProps.datasource) != null && _chartProps$datasourc.metrics) {\n    metricEntry = chartProps.datasource.metrics.find((metricEntry) => metricEntry.metric_name === metric);\n  }\n  const formatTime = getDateFormatter(timeFormat, granularity, (_metricEntry = metricEntry) == null ? void 0 : _metricEntry.d3format);\n  const numberFormatter = getValueFormatter(metric, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const headerFormatter = metricColtype === GenericDataType.Temporal ||\n  metricColtype === GenericDataType.String ||\n  forceTimestampFormatting ?\n  formatTime :\n  numberFormatter;\n  if (trendLineData && timeRangeFixed && fromDatetime) {\n    const toDatetimeOrToday = toDatetime != null ? toDatetime : Date.now();\n    if (!trendLineData[0][0] || trendLineData[0][0] > fromDatetime) {\n      trendLineData.unshift([fromDatetime, null]);\n    }\n    if (!trendLineData[trendLineData.length - 1][0] ||\n    trendLineData[trendLineData.length - 1][0] < toDatetimeOrToday) {\n      trendLineData.push([toDatetimeOrToday, null]);\n    }\n  }\n  const echartOptions = trendLineData ?\n  {\n    series: [\n    {\n      data: trendLineData,\n      type: 'line',\n      smooth: true,\n      symbol: 'circle',\n      symbolSize: 10,\n      showSymbol: false,\n      color: mainColor,\n      areaStyle: {\n        color: new graphic.LinearGradient(0, 0, 0, 1, [\n        {\n          offset: 0,\n          color: mainColor\n        },\n        {\n          offset: 1,\n          color: theme.colors.grayscale.light5\n        }]\n        )\n      }\n    }],\n\n    xAxis: {\n      min: trendLineData[0][0],\n      max: trendLineData[trendLineData.length - 1][0],\n      show: false,\n      type: 'value'\n    },\n    yAxis: {\n      scale: !startYAxisAtZero,\n      show: false\n    },\n    grid: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'axis',\n      formatter: (params) => tooltipHtml([\n      [\n      metricName,\n      params[0].data[1] === null ?\n      t('N/A') :\n      headerFormatter.format(params[0].data[1])]],\n\n      formatTime(params[0].data[0]))\n    },\n    aria: {\n      enabled: true,\n      label: {\n        description: `Big number visualization ${subheader}`\n      }\n    }\n  } :\n  {};\n  const { onContextMenu } = hooks;\n  return {\n    width,\n    height,\n    bigNumber,\n    // @ts-ignore\n    bigNumberFallback,\n    className,\n    headerFormatter,\n    formatTime,\n    formData,\n    headerFontSize,\n    subheaderFontSize,\n    mainColor,\n    showTimestamp,\n    showTrendLine,\n    startYAxisAtZero,\n    subheader: formattedSubheader,\n    timestamp,\n    trendLineData,\n    echartOptions,\n    onContextMenu,\n    xValueFormatter: formatTime,\n    refs\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}