{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /* eslint-disable camelcase */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ColumnOption, D3_TIME_FORMAT_OPTIONS, defineSavedMetrics, getStandardizedControls, QueryModeLabel, sections, sharedControls } from '@superset-ui/chart-controls';\nimport { ensureIsArray, GenericDataType, isAdhocColumn, isPhysicalColumn, QueryMode, SMART_DATE_ID, t } from '@superset-ui/core';\n\nimport { PAGE_SIZE_OPTIONS } from './consts';\nimport { ColorSchemeEnum } from './types';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nfunction getQueryMode(controls) {var _controls$query_mode, _controls$all_columns;\n  const mode = controls == null ? void 0 : (_controls$query_mode = controls.query_mode) == null ? void 0 : _controls$query_mode.value;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = controls == null ? void 0 : (_controls$all_columns = controls.all_columns) == null ? void 0 : _controls$all_columns.value;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\n/**\n * Visibility check\n */\nfunction isQueryMode(mode) {\n  return ({ controls }) => getQueryMode(controls) === mode;\n}\nconst isAggMode = isQueryMode(QueryMode.Aggregate);\nconst isRawMode = isQueryMode(QueryMode.Raw);\nconst validateAggControlValues = (controls, values) => {\n  const areControlsEmpty = values.every((val) => ensureIsArray(val).length === 0);\n  return areControlsEmpty && isAggMode({ controls }) ?\n  [t('Group By, Metrics or Percentage Metrics must have a value')] :\n  [];\n};\nconst queryMode = {\n  type: 'RadioButtonControl',\n  label: t('Query mode'),\n  default: null,\n  options: [\n  [QueryMode.Aggregate, QueryModeLabel[QueryMode.Aggregate]],\n  [QueryMode.Raw, QueryModeLabel[QueryMode.Raw]]],\n\n  mapStateToProps: ({ controls }) => ({ value: getQueryMode(controls) }),\n  rerender: ['all_columns', 'groupby', 'metrics', 'percent_metrics']\n};\nconst allColumnsControl = {\n  ...sharedControls.groupby,\n  label: t('Columns'),\n  description: t('Columns to display'),\n  multi: true,\n  freeForm: true,\n  allowAll: true,\n  commaChoosesOption: false,\n  optionRenderer: (c) => _jsx(ColumnOption, { showType: true, column: c }),\n  valueRenderer: (c) => _jsx(ColumnOption, { column: c }),\n  valueKey: 'column_name',\n  mapStateToProps: ({ datasource, controls }, controlState) => ({\n    options: (datasource == null ? void 0 : datasource.columns) || [],\n    queryMode: getQueryMode(controls),\n    externalValidationErrors: isRawMode({ controls }) && ensureIsArray(controlState == null ? void 0 : controlState.value).length === 0 ?\n    [t('must have a value')] :\n    []\n  }),\n  visibility: isRawMode,\n  resetOnHide: false\n};\nconst percentMetricsControl = {\n  ...sharedControls.metrics,\n  label: t('Percentage metrics'),\n  description: t('Select one or many metrics to display, that will be displayed in the percentages of total. ' +\n  'Percentage metrics will be calculated only from data within the row limit. ' +\n  'You can use an aggregation function on a column or write custom SQL to create a percentage metric.'),\n  visibility: isAggMode,\n  resetOnHide: false,\n  mapStateToProps: ({ datasource, controls }, controlState) => {var _controls$groupby, _controls$metrics;return {\n      columns: (datasource == null ? void 0 : datasource.columns) || [],\n      savedMetrics: defineSavedMetrics(datasource),\n      datasource,\n      datasourceType: datasource == null ? void 0 : datasource.type,\n      queryMode: getQueryMode(controls),\n      externalValidationErrors: validateAggControlValues(controls, [(_controls$groupby =\n      controls.groupby) == null ? void 0 : _controls$groupby.value, (_controls$metrics =\n      controls.metrics) == null ? void 0 : _controls$metrics.value,\n      controlState == null ? void 0 : controlState.value]\n      )\n    };},\n  rerender: ['groupby', 'metrics'],\n  default: [],\n  validators: []\n};\n/**\n * Generate comparison column names for a given column.\n */\nconst generateComparisonColumns = (colname) => [\n`${t('Main')} ${colname}`,\n`# ${colname}`,\n`△ ${colname}`,\n`% ${colname}`];\n\n/**\n * Generate column types for the comparison columns.\n */\nconst generateComparisonColumnTypes = (count) => Array(count).fill(GenericDataType.Numeric);\nconst processComparisonColumns = (columns, suffix) => columns.\nmap((col) => {\n  if (!col.label.includes(suffix)) {\n    return [\n    {\n      label: `${t('Main')} ${col.label}`,\n      value: `${t('Main')} ${col.value}`\n    },\n    {\n      label: `# ${col.label}`,\n      value: `# ${col.value}`\n    },\n    {\n      label: `△ ${col.label}`,\n      value: `△ ${col.value}`\n    },\n    {\n      label: `% ${col.label}`,\n      value: `% ${col.value}`\n    }];\n\n  }\n  return [];\n}).\nflat();\nconst config = {\n  controlPanelSections: [\n  {\n    label: t('Query'),\n    expanded: true,\n    controlSetRows: [\n    [\n    {\n      name: 'query_mode',\n      config: queryMode\n    }],\n\n    [\n    {\n      name: 'groupby',\n      override: {\n        visibility: isAggMode,\n        resetOnHide: false,\n        mapStateToProps: (state, controlState) => {var _sharedControls$group, _originalMapStateToPr, _controls$metrics2, _controls$percent_met;\n          const { controls } = state;\n          const originalMapStateToProps = sharedControls == null ? void 0 : (_sharedControls$group = sharedControls.groupby) == null ? void 0 : _sharedControls$group.mapStateToProps;\n          const newState = (_originalMapStateToPr = originalMapStateToProps == null ? void 0 : originalMapStateToProps(state, controlState)) != null ? _originalMapStateToPr : {};\n          newState.externalValidationErrors = validateAggControlValues(controls, [(_controls$metrics2 =\n          controls.metrics) == null ? void 0 : _controls$metrics2.value, (_controls$percent_met =\n          controls.percent_metrics) == null ? void 0 : _controls$percent_met.value,\n          controlState.value]\n          );\n          return newState;\n        },\n        rerender: ['metrics', 'percent_metrics']\n      }\n    }],\n\n    [\n    {\n      name: 'time_grain_sqla',\n      config: {\n        ...sharedControls.time_grain_sqla,\n        visibility: ({ controls }) => {var _controls$groupby2;\n          const dttmLookup = Object.fromEntries(ensureIsArray(controls == null ? void 0 : (_controls$groupby2 = controls.groupby) == null ? void 0 : _controls$groupby2.options).map((option) => [\n          option.column_name,\n          option.is_dttm]\n          ));\n          return ensureIsArray(controls == null ? void 0 : controls.groupby.value).\n          map((selection) => {\n            if (isAdhocColumn(selection)) {\n              return true;\n            }\n            if (isPhysicalColumn(selection)) {\n              return !!dttmLookup[selection];\n            }\n            return false;\n          }).\n          some(Boolean);\n        }\n      }\n    },\n    'temporal_columns_lookup'],\n\n    [\n    {\n      name: 'metrics',\n      override: {\n        validators: [],\n        visibility: isAggMode,\n        resetOnHide: false,\n        mapStateToProps: ({ controls, datasource, form_data }, controlState) => {var _datasource$columns$, _datasource$columns, _controls$groupby3, _controls$percent_met2;return {\n            columns: datasource != null && (_datasource$columns$ = datasource.columns[0]) != null && _datasource$columns$.hasOwnProperty('filterable') ?\n            datasource == null ? void 0 : (_datasource$columns = datasource.columns) == null ? void 0 : _datasource$columns.filter((c) => c.filterable) :\n            datasource == null ? void 0 : datasource.columns,\n            savedMetrics: defineSavedMetrics(datasource),\n            // current active adhoc metrics\n            selectedMetrics: form_data.metrics || (\n            form_data.metric ? [form_data.metric] : []),\n            datasource,\n            externalValidationErrors: validateAggControlValues(controls, [(_controls$groupby3 =\n            controls.groupby) == null ? void 0 : _controls$groupby3.value, (_controls$percent_met2 =\n            controls.percent_metrics) == null ? void 0 : _controls$percent_met2.value,\n            controlState.value]\n            )\n          };},\n        rerender: ['groupby', 'percent_metrics']\n      }\n    },\n    {\n      name: 'all_columns',\n      config: allColumnsControl\n    }],\n\n    [\n    {\n      name: 'percent_metrics',\n      config: percentMetricsControl\n    }],\n\n    ['adhoc_filters'],\n    [\n    {\n      name: 'timeseries_limit_metric',\n      override: {\n        visibility: isAggMode,\n        resetOnHide: false\n      }\n    },\n    {\n      name: 'order_by_cols',\n      config: {\n        type: 'SelectControl',\n        label: t('Ordering'),\n        description: t('Order results by selected columns'),\n        multi: true,\n        default: [],\n        mapStateToProps: ({ datasource }) => ({\n          choices: datasource != null && datasource.hasOwnProperty('order_by_choices') ?\n          datasource == null ? void 0 : datasource.order_by_choices :\n          (datasource == null ? void 0 : datasource.columns) || []\n        }),\n        visibility: isRawMode,\n        resetOnHide: false\n      }\n    }],\n\n    [\n    {\n      name: 'server_pagination',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Server pagination'),\n        description: t('Enable server side pagination of results (experimental feature)'),\n        default: false\n      }\n    }],\n\n    [\n    {\n      name: 'row_limit',\n      override: {\n        default: 1000,\n        visibility: ({ controls }) => {var _controls$server_pagi;return !(controls != null && (_controls$server_pagi = controls.server_pagination) != null && _controls$server_pagi.value);}\n      }\n    },\n    {\n      name: 'server_page_length',\n      config: {\n        type: 'SelectControl',\n        freeForm: true,\n        label: t('Server Page Length'),\n        default: 10,\n        choices: PAGE_SIZE_OPTIONS,\n        description: t('Rows per page, 0 means no pagination'),\n        visibility: ({ controls }) => {var _controls$server_pagi2;return Boolean(controls == null ? void 0 : (_controls$server_pagi2 = controls.server_pagination) == null ? void 0 : _controls$server_pagi2.value);}\n      }\n    }],\n\n    [\n    {\n      name: 'order_desc',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Sort descending'),\n        default: true,\n        description: t('If enabled, this control sorts the results/values descending, otherwise it sorts the results ascending.'),\n        visibility: isAggMode,\n        resetOnHide: false\n      }\n    }],\n\n    [\n    {\n      name: 'show_totals',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Show summary'),\n        default: false,\n        description: t('Show total aggregations of selected metrics. Note that row limit does not apply to the result.'),\n        visibility: isAggMode,\n        resetOnHide: false\n      }\n    }]]\n\n\n  },\n  {\n    label: t('Options'),\n    expanded: true,\n    controlSetRows: [\n    [\n    {\n      name: 'table_timestamp_format',\n      config: {\n        type: 'SelectControl',\n        freeForm: true,\n        label: t('Timestamp format'),\n        default: SMART_DATE_ID,\n        renderTrigger: true,\n        clearable: false,\n        choices: D3_TIME_FORMAT_OPTIONS,\n        description: t('D3 time format for datetime columns')\n      }\n    }],\n\n    [\n    {\n      name: 'page_length',\n      config: {\n        type: 'SelectControl',\n        freeForm: true,\n        renderTrigger: true,\n        label: t('Page length'),\n        default: null,\n        choices: PAGE_SIZE_OPTIONS,\n        description: t('Rows per page, 0 means no pagination'),\n        visibility: ({ controls }) => {var _controls$server_pagi3;return !(controls != null && (_controls$server_pagi3 = controls.server_pagination) != null && _controls$server_pagi3.value);}\n      }\n    },\n    null],\n\n    [\n    {\n      name: 'include_search',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Search box'),\n        renderTrigger: true,\n        default: false,\n        description: t('Whether to include a client-side search box')\n      }\n    }],\n\n    [\n    {\n      name: 'allow_rearrange_columns',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Allow columns to be rearranged'),\n        renderTrigger: true,\n        default: false,\n        description: t(\"Allow end user to drag-and-drop column headers to rearrange them. Note their changes won't persist for the next time they open the chart.\"),\n        visibility: ({ controls }) => {var _controls$time_compar;return _isEmpty(controls == null ? void 0 : (_controls$time_compar = controls.time_compare) == null ? void 0 : _controls$time_compar.value);}\n      }\n    }],\n\n    [\n    {\n      name: 'allow_render_html',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Render columns in HTML format'),\n        renderTrigger: true,\n        default: true,\n        description: t('Renders table cells as HTML when applicable. For example, HTML <a> tags will be rendered as hyperlinks.')\n      }\n    }],\n\n    [\n    {\n      name: 'column_config',\n      config: {\n        type: 'ColumnConfigControl',\n        label: t('Customize columns'),\n        description: t('Further customize how to display each column'),\n        width: 400,\n        height: 320,\n        renderTrigger: true,\n        shouldMapStateToProps() {\n          return true;\n        },\n        mapStateToProps(explore, _, chart) {var _explore$controls, _explore$controls$tim, _chart$queriesRespons, _chart$queriesRespons2;\n          const timeComparisonStatus = !!(explore != null && (_explore$controls = explore.controls) != null && (_explore$controls$tim = _explore$controls.time_compare) != null && _explore$controls$tim.value);\n          const { colnames: _colnames, coltypes: _coltypes } = (_chart$queriesRespons = chart == null ? void 0 : (_chart$queriesRespons2 = chart.queriesResponse) == null ? void 0 : _chart$queriesRespons2[0]) != null ? _chart$queriesRespons : {};\n          let colnames = _colnames || [];\n          let coltypes = _coltypes || [];\n          if (timeComparisonStatus) {\n            /**\n             * Replace numeric columns with sets of comparison columns.\n             */\n            const updatedColnames = [];\n            const updatedColtypes = [];\n            colnames.forEach((colname, index) => {\n              if (coltypes[index] === GenericDataType.Numeric) {\n                updatedColnames.push(...generateComparisonColumns(colname));\n                updatedColtypes.push(...generateComparisonColumnTypes(4));\n              } else\n              {\n                updatedColnames.push(colname);\n                updatedColtypes.push(coltypes[index]);\n              }\n            });\n            colnames = updatedColnames;\n            coltypes = updatedColtypes;\n          }\n          return {\n            columnsPropsObject: { colnames, coltypes }\n          };\n        }\n      }\n    }]]\n\n\n  },\n  {\n    label: t('Visual formatting'),\n    expanded: true,\n    controlSetRows: [\n    [\n    {\n      name: 'show_cell_bars',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Show Cell bars'),\n        renderTrigger: true,\n        default: true,\n        description: t('Whether to display a bar chart background in table columns')\n      }\n    }],\n\n    [\n    {\n      name: 'align_pn',\n      config: {\n        type: 'CheckboxControl',\n        label: t('Align +/-'),\n        renderTrigger: true,\n        default: false,\n        description: t('Whether to align background charts with both positive and negative values at 0')\n      }\n    }],\n\n    [\n    {\n      name: 'color_pn',\n      config: {\n        type: 'CheckboxControl',\n        label: t('add colors to cell bars for +/-'),\n        renderTrigger: true,\n        default: true,\n        description: t('Whether to colorize numeric values by whether they are positive or negative')\n      }\n    }],\n\n    [\n    {\n      name: 'comparison_color_enabled',\n      config: {\n        type: 'CheckboxControl',\n        label: t('basic conditional formatting'),\n        renderTrigger: true,\n        visibility: ({ controls }) => {var _controls$time_compar2;return !_isEmpty(controls == null ? void 0 : (_controls$time_compar2 = controls.time_compare) == null ? void 0 : _controls$time_compar2.value);},\n        default: false,\n        description: t('This will be applied to the whole table. Arrows (↑ and ↓) will be added to ' +\n        'main columns for increase and decrease. Basic conditional formatting can be ' +\n        'overwritten by conditional formatting below.')\n      }\n    }],\n\n    [\n    {\n      name: 'comparison_color_scheme',\n      config: {\n        type: 'SelectControl',\n        label: t('color type'),\n        default: ColorSchemeEnum.Green,\n        renderTrigger: true,\n        choices: [\n        [ColorSchemeEnum.Green, 'Green for increase, red for decrease'],\n        [ColorSchemeEnum.Red, 'Red for increase, green for decrease']],\n\n        visibility: ({ controls }) => {var _controls$time_compar3, _controls$comparison_;return !_isEmpty(controls == null ? void 0 : (_controls$time_compar3 = controls.time_compare) == null ? void 0 : _controls$time_compar3.value) &&\n          Boolean(controls == null ? void 0 : (_controls$comparison_ = controls.comparison_color_enabled) == null ? void 0 : _controls$comparison_.value);},\n        description: t('Adds color to the chart symbols based on the positive or ' +\n        'negative change from the comparison value.')\n      }\n    }],\n\n    [\n    {\n      name: 'conditional_formatting',\n      config: {\n        type: 'ConditionalFormattingControl',\n        renderTrigger: true,\n        label: t('Custom Conditional Formatting'),\n        extraColorChoices: [\n        {\n          value: ColorSchemeEnum.Green,\n          label: t('Green for increase, red for decrease')\n        },\n        {\n          value: ColorSchemeEnum.Red,\n          label: t('Red for increase, green for decrease')\n        }],\n\n        description: t('Apply conditional color formatting to numeric columns'),\n        shouldMapStateToProps() {\n          return true;\n        },\n        mapStateToProps(explore, _, chart) {var _explore$datasource, _explore$datasource2, _explore$datasource$c, _explore$datasource3, _chart$queriesRespons3, _chart$queriesRespons4, _explore$controls2, _explore$controls2$ti, _ensureIsArray$, _explore$controls3, _explore$controls3$ti;\n          const verboseMap = explore != null && (_explore$datasource = explore.datasource) != null && _explore$datasource.hasOwnProperty('verbose_map') ?\n          explore == null ? void 0 : (_explore$datasource2 = explore.datasource) == null ? void 0 : _explore$datasource2.verbose_map : (_explore$datasource$c =\n          explore == null ? void 0 : (_explore$datasource3 = explore.datasource) == null ? void 0 : _explore$datasource3.columns) != null ? _explore$datasource$c : {};\n          const chartStatus = chart == null ? void 0 : chart.chartStatus;\n          const { colnames, coltypes } = (_chart$queriesRespons3 = chart == null ? void 0 : (_chart$queriesRespons4 = chart.queriesResponse) == null ? void 0 : _chart$queriesRespons4[0]) != null ? _chart$queriesRespons3 : {};\n          const numericColumns = Array.isArray(colnames) && Array.isArray(coltypes) ?\n          colnames.\n          filter((colname, index) => coltypes[index] === GenericDataType.Numeric).\n          map((colname) => {var _verboseMap$colname;return {\n              value: colname,\n              label: Array.isArray(verboseMap) ?\n              colname : (_verboseMap$colname =\n              verboseMap[colname]) != null ? _verboseMap$colname : colname\n            };}) :\n          [];\n          const columnOptions = explore != null && (_explore$controls2 = explore.controls) != null && (_explore$controls2$ti = _explore$controls2.time_compare) != null && _explore$controls2$ti.value ?\n          processComparisonColumns(numericColumns || [], ((_ensureIsArray$ = ensureIsArray(explore == null ? void 0 : (_explore$controls3 = explore.controls) == null ? void 0 : (_explore$controls3$ti = _explore$controls3.time_compare) == null ? void 0 : _explore$controls3$ti.value)[0]) == null ? void 0 : _ensureIsArray$.toString()) || '') :\n          numericColumns;\n          return {\n            removeIrrelevantConditions: chartStatus === 'success',\n            columnOptions,\n            verboseMap\n          };\n        }\n      }\n    }]]\n\n\n  },\n  {\n    ...sections.timeComparisonControls({\n      multi: false,\n      showCalculationType: false,\n      showFullChoices: false\n    }),\n    visibility: isAggMode\n  }],\n\n  formDataOverrides: (formData) => ({\n    ...formData,\n    metrics: getStandardizedControls().popAllMetrics(),\n    groupby: getStandardizedControls().popAllColumns()\n  })\n};\nexport default config;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}