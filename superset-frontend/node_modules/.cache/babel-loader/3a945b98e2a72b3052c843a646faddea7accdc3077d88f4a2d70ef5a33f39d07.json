{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /* eslint-disable camelcase */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * This file exports all controls available for use in chart plugins internal to Superset.\n * It is not recommended to use the controls here for any third-party plugins.\n *\n * While the React components located in `controls/components` represent different\n * types of controls (CheckboxControl, SelectControl, TextControl, ...), the controls here\n * represent instances of control types, that can be reused across visualization types.\n *\n * When controls are reused across viz types, their values are carried over as a user\n * changes the chart types.\n *\n * While the keys defined in the control itself get passed to the controlType as props,\n * here's a list of the keys that are common to all controls, and as a result define the\n * control interface.\n */\n\nimport { t, getCategoricalSchemeRegistry, getSequentialSchemeRegistry, legacyValidateInteger, ComparisonType, ensureIsArray, isDefined, NO_TIME_RANGE, validateMaxValue } from '@superset-ui/core';\nimport { formatSelectOptions, displayTimeRelatedControls, getColorControlsProps, D3_FORMAT_OPTIONS, D3_FORMAT_DOCS, D3_TIME_FORMAT_OPTIONS, D3_TIME_FORMAT_DOCS, DEFAULT_TIME_FORMAT, DEFAULT_NUMBER_FORMAT } from '../utils';\nimport { DEFAULT_MAX_ROW, TIME_FILTER_LABELS } from '../constants';\nimport { dndAdhocFilterControl, dndAdhocMetricControl, dndAdhocMetricsControl, dndGranularitySqlaControl, dndSortByControl, dndSecondaryMetricControl, dndSizeControl, dndXControl, dndYControl, dndColumnsControl, dndEntityControl, dndGroupByControl, dndSeriesControl, dndAdhocMetricControl2, dndXAxisControl } from './dndControls';\nconst categoricalSchemeRegistry = getCategoricalSchemeRegistry();\nconst sequentialSchemeRegistry = getSequentialSchemeRegistry();\nexport const PRIMARY_COLOR = { r: 0, g: 122, b: 135, a: 1 };\nconst ROW_LIMIT_OPTIONS = [10, 50, 100, 250, 500, 1000, 5000, 10000, 50000];\nconst SERIES_LIMITS = [5, 10, 25, 50, 100, 500];\nconst appContainer = document.getElementById('app');\nconst { user } = JSON.parse((appContainer == null ? void 0 : appContainer.getAttribute('data-bootstrap')) || '{}');\nconst datasourceControl = {\n  type: 'DatasourceControl',\n  label: t('Datasource'),\n  default: null,\n  description: null,\n  mapStateToProps: ({ datasource, form_data }) => ({\n    datasource,\n    form_data,\n    user\n  })\n};\nconst viz_type = {\n  type: 'VizTypeControl',\n  label: t('Visualization Type'),\n  default: 'table',\n  description: t('The type of visualization to display')\n};\nconst color_picker = {\n  type: 'ColorPickerControl',\n  label: t('Fixed Color'),\n  description: t('Use this to define a static color for all circles'),\n  default: PRIMARY_COLOR,\n  renderTrigger: true\n};\nconst linear_color_scheme = {\n  type: 'ColorSchemeControl',\n  label: t('Linear Color Scheme'),\n  choices: () => sequentialSchemeRegistry.values().map((value) => [\n  value.id,\n  value.label]\n  ),\n  default: sequentialSchemeRegistry.getDefaultKey(),\n  clearable: false,\n  description: '',\n  renderTrigger: true,\n  schemes: () => sequentialSchemeRegistry.getMap(),\n  isLinear: true,\n  mapStateToProps: (state) => getColorControlsProps(state)\n};\nconst granularity = {\n  type: 'SelectControl',\n  freeForm: true,\n  label: TIME_FILTER_LABELS.granularity,\n  default: 'one day',\n  choices: [\n  [null, t('all')],\n  ['PT5S', t('5 seconds')],\n  ['PT30S', t('30 seconds')],\n  ['PT1M', t('1 minute')],\n  ['PT5M', t('5 minutes')],\n  ['PT30M', t('30 minutes')],\n  ['PT1H', t('1 hour')],\n  ['PT6H', t('6 hour')],\n  ['P1D', t('1 day')],\n  ['P7D', t('7 days')],\n  ['P1W', t('week')],\n  ['week_starting_sunday', t('week starting Sunday')],\n  ['week_ending_saturday', t('week ending Saturday')],\n  ['P1M', t('month')],\n  ['P3M', t('quarter')],\n  ['P1Y', t('year')]],\n\n  description: t('The time granularity for the visualization. Note that you ' +\n  'can type and use simple natural language as in `10 seconds`, ' +\n  '`1 day` or `56 weeks`')\n};\nconst time_grain_sqla = {\n  type: 'SelectControl',\n  label: TIME_FILTER_LABELS.time_grain_sqla,\n  placeholder: t('None'),\n  initialValue: (control, state) => {var _state$form_data, _state$form_data2;\n    if (!isDefined(state)) {\n      // If a chart is in a Dashboard, the ControlPanelState is empty.\n      return control.value;\n    }\n    // If a chart is a new one that isn't saved, metadata is null. In this\n    // case we want to default P1D. If the chart has been saved, we want\n    // to use whichever value was chosen, either nothing or valid a time grain.\n    return state != null && state.metadata || 'time_grain_sqla' in ((_state$form_data = state == null ? void 0 : state.form_data) != null ? _state$form_data : {}) ?\n    state == null ? void 0 : (_state$form_data2 = state.form_data) == null ? void 0 : _state$form_data2.time_grain_sqla :\n    'P1D';\n  },\n  description: t('Select a time grain for the visualization. The ' +\n  'grain is the time interval represented by a ' +\n  'single point on the chart.'),\n  mapStateToProps: ({ datasource }) => ({\n    choices: (datasource == null ? void 0 : datasource.time_grain_sqla) || []\n  }),\n  visibility: displayTimeRelatedControls\n};\nconst time_range = {\n  type: 'DateFilterControl',\n  freeForm: true,\n  label: TIME_FILTER_LABELS.time_range,\n  default: NO_TIME_RANGE,\n  description: t('This control filters the whole chart based on the selected time range. All relative times, e.g. \"Last month\", ' +\n  '\"Last 7 days\", \"now\", etc. are evaluated on the server using the server\\'s ' +\n  'local time (sans timezone). All tooltips and placeholder times are expressed ' +\n  'in UTC (sans timezone). The timestamps are then evaluated by the database ' +\n  \"using the engine's local timezone. Note one can explicitly set the timezone \" +\n  'per the ISO 8601 format if specifying either the start and/or end time.')\n};\nconst row_limit = {\n  type: 'SelectControl',\n  freeForm: true,\n  label: t('Row limit'),\n  clearable: false,\n  mapStateToProps: (state) => {var _state$common, _state$common$conf;return { maxValue: state == null ? void 0 : (_state$common = state.common) == null ? void 0 : (_state$common$conf = _state$common.conf) == null ? void 0 : _state$common$conf.SQL_MAX_ROW };},\n  validators: [\n  legacyValidateInteger,\n  (v, state) => validateMaxValue(v, (state == null ? void 0 : state.maxValue) || DEFAULT_MAX_ROW)],\n\n  default: 10000,\n  choices: formatSelectOptions(ROW_LIMIT_OPTIONS),\n  description: t('Limits the number of the rows that are computed in the query that is the source of the data used for this chart.')\n};\nconst order_desc = {\n  type: 'CheckboxControl',\n  label: t('Sort Descending'),\n  default: true,\n  description: t('If enabled, this control sorts the results/values descending, otherwise it sorts the results ascending.'),\n  visibility: ({ controls }) => Boolean((controls == null ? void 0 : controls.timeseries_limit_metric.value) &&\n  !_isEmpty(controls == null ? void 0 : controls.timeseries_limit_metric.value))\n};\nconst limit = {\n  type: 'SelectControl',\n  freeForm: true,\n  label: t('Series limit'),\n  placeholder: t('None'),\n  validators: [legacyValidateInteger],\n  choices: formatSelectOptions(SERIES_LIMITS),\n  clearable: true,\n  description: t('Limits the number of series that get displayed. A joined subquery (or an extra phase ' +\n  'where subqueries are not supported) is applied to limit the number of series that get ' +\n  'fetched and rendered. This feature is useful when grouping by high cardinality ' +\n  'column(s) though does increase the query complexity and cost.')\n};\nconst series_limit = {\n  type: 'SelectControl',\n  freeForm: true,\n  label: t('Series limit'),\n  placeholder: t('None'),\n  validators: [legacyValidateInteger],\n  choices: formatSelectOptions(SERIES_LIMITS),\n  description: t('Limits the number of series that get displayed. A joined subquery (or an extra phase ' +\n  'where subqueries are not supported) is applied to limit the number of series that get ' +\n  'fetched and rendered. This feature is useful when grouping by high cardinality ' +\n  'column(s) though does increase the query complexity and cost.')\n};\nconst y_axis_format = {\n  type: 'SelectControl',\n  freeForm: true,\n  label: t('Y Axis Format'),\n  renderTrigger: true,\n  default: DEFAULT_NUMBER_FORMAT,\n  choices: D3_FORMAT_OPTIONS,\n  description: D3_FORMAT_DOCS,\n  tokenSeparators: ['\\n', '\\t', ';'],\n  filterOption: ({ data: option }, search) => option.label.includes(search) || option.value.includes(search),\n  mapStateToProps: (state) => {var _state$controls, _state$controls$compa;\n    const isPercentage = ((_state$controls = state.controls) == null ? void 0 : (_state$controls$compa = _state$controls.comparison_type) == null ? void 0 : _state$controls$compa.value) === ComparisonType.Percentage;\n    return {\n      choices: isPercentage ?\n      D3_FORMAT_OPTIONS.filter((option) => option[0].includes('%')) :\n      D3_FORMAT_OPTIONS\n    };\n  }\n};\nconst currency_format = {\n  type: 'CurrencyControl',\n  label: t('Currency format'),\n  renderTrigger: true\n};\nconst x_axis_time_format = {\n  type: 'SelectControl',\n  freeForm: true,\n  label: t('Time format'),\n  renderTrigger: true,\n  default: DEFAULT_TIME_FORMAT,\n  choices: D3_TIME_FORMAT_OPTIONS,\n  description: D3_TIME_FORMAT_DOCS,\n  filterOption: ({ data: option }, search) => option.label.includes(search) || option.value.includes(search)\n};\nconst color_scheme = {\n  type: 'ColorSchemeControl',\n  label: t('Color Scheme'),\n  default: categoricalSchemeRegistry.getDefaultKey(),\n  renderTrigger: true,\n  choices: () => categoricalSchemeRegistry.keys().map((s) => [s, s]),\n  description: t('The color scheme for rendering chart'),\n  schemes: () => categoricalSchemeRegistry.getMap(),\n  mapStateToProps: (state) => getColorControlsProps(state)\n};\nconst time_shift_color = {\n  type: 'CheckboxControl',\n  label: t('Match time shift color with original series'),\n  default: true,\n  renderTrigger: true,\n  description: t('When unchecked, colors from the selected color scheme will be used for time shifted series'),\n  visibility: ({ controls }) => {var _controls$time_compar, _controls$time_compar2;return Boolean((controls == null ? void 0 : (_controls$time_compar = controls.time_compare) == null ? void 0 : _controls$time_compar.value) && !_isEmpty(controls == null ? void 0 : (_controls$time_compar2 = controls.time_compare) == null ? void 0 : _controls$time_compar2.value));}\n};\nconst truncate_metric = {\n  type: 'CheckboxControl',\n  label: t('Truncate Metric'),\n  default: true,\n  description: t('Whether to truncate metrics')\n};\nconst show_empty_columns = {\n  type: 'CheckboxControl',\n  label: t('Show empty columns'),\n  default: true,\n  description: t('Show empty columns')\n};\nconst temporal_columns_lookup = {\n  type: 'HiddenControl',\n  initialValue: (control, state) => {var _state$datasource;return Object.fromEntries(ensureIsArray(state == null ? void 0 : (_state$datasource = state.datasource) == null ? void 0 : _state$datasource.columns).\n    filter((option) => option.is_dttm).\n    map((option) => {var _option$column_name;return [(_option$column_name = option.column_name) != null ? _option$column_name : option.name, option.is_dttm];}));}\n};\nconst sort_by_metric = {\n  type: 'CheckboxControl',\n  label: t('Sort by metric'),\n  description: t('Whether to sort results by the selected metric in descending order.')\n};\nexport default {\n  metrics: dndAdhocMetricsControl,\n  metric: dndAdhocMetricControl,\n  datasource: datasourceControl,\n  viz_type,\n  color_picker,\n  metric_2: dndAdhocMetricControl2,\n  linear_color_scheme,\n  secondary_metric: dndSecondaryMetricControl,\n  groupby: dndGroupByControl,\n  columns: dndColumnsControl,\n  granularity,\n  granularity_sqla: dndGranularitySqlaControl,\n  time_grain_sqla,\n  time_range,\n  row_limit,\n  limit,\n  timeseries_limit_metric: dndSortByControl,\n  orderby: dndSortByControl,\n  order_desc,\n  series: dndSeriesControl,\n  entity: dndEntityControl,\n  x: dndXControl,\n  y: dndYControl,\n  size: dndSizeControl,\n  y_axis_format,\n  x_axis_time_format,\n  adhoc_filters: dndAdhocFilterControl,\n  color_scheme,\n  time_shift_color,\n  series_columns: dndColumnsControl,\n  series_limit,\n  series_limit_metric: dndSortByControl,\n  legacy_order_by: dndSortByControl,\n  truncate_metric,\n  x_axis: dndXAxisControl,\n  show_empty_columns,\n  temporal_columns_lookup,\n  currency_format,\n  sort_by_metric\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}