{"ast":null,"code":"import _cloneDeep from \"lodash/cloneDeep\"; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport CategoricalColorScale from './CategoricalColorScale';\nimport getCategoricalSchemeRegistry from './CategoricalSchemeRegistrySingleton';\nimport stringifyAndTrim from './stringifyAndTrim';\nexport default class CategoricalColorNamespace {\n\n\n\n  constructor(name) {this.name = void 0;this.forcedItems = void 0;this.scales = void 0;\n    this.name = name;\n    this.scales = {};\n    this.forcedItems = {};\n  }\n  /**\n   * A new CategoricalColorScale instance is created for each chart.\n   *\n   * @param colorScheme - the color scheme to use\n   * @returns a new instance of a color scale\n   */\n  getScale(colorScheme) {var _ref, _scheme$colors;\n    const id = (_ref = colorScheme != null ? colorScheme : getCategoricalSchemeRegistry().getDefaultKey()) != null ? _ref : '';\n    const scheme = getCategoricalSchemeRegistry().get(id);\n    return new CategoricalColorScale((_scheme$colors = scheme == null ? void 0 : scheme.colors) != null ? _scheme$colors : [], this.forcedItems, colorScheme);\n  }\n  /**\n   * Enforce specific color for given value\n   * This will apply across all color scales\n   * in this namespace.\n   * @param {*} value value\n   * @param {*} forcedColor color\n   */\n  setColor(value, forcedColor) {\n    this.forcedItems[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n  resetColors() {\n    this.forcedItems = {};\n  }\n  resetColorsForLabels(labels = []) {\n    const updatedForcedItems = _cloneDeep(this.forcedItems);\n    labels.forEach((label) => {\n      if (updatedForcedItems.hasOwnProperty(label)) {\n        delete updatedForcedItems[label];\n      }\n    });\n    this.forcedItems = { ...updatedForcedItems };\n  }\n}\nconst namespaces = {};\nexport const DEFAULT_NAMESPACE = 'GLOBAL';\nexport function getNamespace(name = DEFAULT_NAMESPACE) {\n  const instance = namespaces[name];\n  if (instance) {\n    return instance;\n  }\n  const newInstance = new CategoricalColorNamespace(name);\n  namespaces[name] = newInstance;\n  return newInstance;\n}\nexport function getColor(value, colorScheme, namespace) {\n  return getNamespace(namespace).getScale(colorScheme).getColor(value);\n}\n/*\n  Returns a new scale instance within the same namespace.\n  Especially useful when a chart is booting for the first time\n\n  @param scheme - the applied color scheme\n  @param namespace - the namespace\n*/\nexport function getScale(colorScheme, namespace) {\n  return getNamespace(namespace).getScale(colorScheme);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}