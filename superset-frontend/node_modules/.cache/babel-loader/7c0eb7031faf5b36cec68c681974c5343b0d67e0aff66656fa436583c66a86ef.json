{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint no-undef: 'error' */\n/* eslint no-param-reassign: [\"error\", { \"props\": false }] */\nimport {\n  FeatureFlag,\n  isDefined,\n  SupersetClient,\n  t,\n  isFeatureEnabled,\n  getClientErrorObject } from\n'@superset-ui/core';\nimport { getControlsState } from 'src/explore/store';\nimport {\n  getAnnotationJsonUrl,\n  getExploreUrl,\n  getLegacyEndpointType,\n  buildV1ChartDataPayload,\n  getQuerySettings,\n  getChartDataUri } from\n'src/explore/exploreUtils';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport { logEvent } from 'src/logger/actions';\nimport { Logger, LOG_ACTIONS_LOAD_CHART } from 'src/logger/LogUtils';\nimport { allowCrossDomain as domainShardingEnabled } from 'src/utils/hostNamesConfig';\nimport { updateDataMask } from 'src/dataMask/actions';\nimport { waitForAsyncData } from 'src/middleware/asyncEvent';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { extendedDayjs } from 'src/utils/dates';\n\nexport const CHART_UPDATE_STARTED = 'CHART_UPDATE_STARTED';\nexport function chartUpdateStarted(queryController, latestQueryFormData, key) {\n  return {\n    type: CHART_UPDATE_STARTED,\n    queryController,\n    latestQueryFormData,\n    key\n  };\n}\n\nexport const CHART_UPDATE_SUCCEEDED = 'CHART_UPDATE_SUCCEEDED';\nexport function chartUpdateSucceeded(queriesResponse, key) {\n  return { type: CHART_UPDATE_SUCCEEDED, queriesResponse, key };\n}\n\nexport const CHART_UPDATE_STOPPED = 'CHART_UPDATE_STOPPED';\nexport function chartUpdateStopped(key) {\n  return { type: CHART_UPDATE_STOPPED, key };\n}\n\nexport const CHART_UPDATE_FAILED = 'CHART_UPDATE_FAILED';\nexport function chartUpdateFailed(queriesResponse, key) {\n  return { type: CHART_UPDATE_FAILED, queriesResponse, key };\n}\n\nexport const CHART_RENDERING_FAILED = 'CHART_RENDERING_FAILED';\nexport function chartRenderingFailed(error, key, stackTrace) {\n  return { type: CHART_RENDERING_FAILED, error, key, stackTrace };\n}\n\nexport const CHART_RENDERING_SUCCEEDED = 'CHART_RENDERING_SUCCEEDED';\nexport function chartRenderingSucceeded(key) {\n  return { type: CHART_RENDERING_SUCCEEDED, key };\n}\n\nexport const REMOVE_CHART = 'REMOVE_CHART';\nexport function removeChart(key) {\n  return { type: REMOVE_CHART, key };\n}\n\nexport const ANNOTATION_QUERY_SUCCESS = 'ANNOTATION_QUERY_SUCCESS';\nexport function annotationQuerySuccess(annotation, queryResponse, key) {\n  return { type: ANNOTATION_QUERY_SUCCESS, annotation, queryResponse, key };\n}\n\nexport const ANNOTATION_QUERY_STARTED = 'ANNOTATION_QUERY_STARTED';\nexport function annotationQueryStarted(annotation, queryController, key) {\n  return { type: ANNOTATION_QUERY_STARTED, annotation, queryController, key };\n}\n\nexport const ANNOTATION_QUERY_FAILED = 'ANNOTATION_QUERY_FAILED';\nexport function annotationQueryFailed(annotation, queryResponse, key) {\n  return { type: ANNOTATION_QUERY_FAILED, annotation, queryResponse, key };\n}\n\nexport const DYNAMIC_PLUGIN_CONTROLS_READY = 'DYNAMIC_PLUGIN_CONTROLS_READY';\nexport const dynamicPluginControlsReady = () => (dispatch, getState) => {\n  const state = getState();\n  const controlsState = getControlsState(\n    state.explore,\n    state.explore.form_data\n  );\n  dispatch({\n    type: DYNAMIC_PLUGIN_CONTROLS_READY,\n    key: controlsState.slice_id.value,\n    controlsState\n  });\n};\n\nconst legacyChartDataRequest = async (\nformData,\nresultFormat,\nresultType,\nforce,\nmethod = 'POST',\nrequestParams = {},\nparseMethod) =>\n{\n  const endpointType = getLegacyEndpointType({ resultFormat, resultType });\n  const allowDomainSharding =\n  // eslint-disable-next-line camelcase\n  domainShardingEnabled && (requestParams == null ? void 0 : requestParams.dashboard_id);\n  const url = getExploreUrl({\n    formData,\n    endpointType,\n    force,\n    allowDomainSharding,\n    method,\n    requestParams: requestParams.dashboard_id ?\n    { dashboard_id: requestParams.dashboard_id } :\n    {}\n  });\n  const querySettings = {\n    ...requestParams,\n    url,\n    postPayload: { form_data: formData },\n    parseMethod\n  };\n\n  return SupersetClient.post(querySettings).then(({ json, response }) => (\n  // Make the legacy endpoint return a payload that corresponds to the\n  // V1 chart data endpoint response signature.\n  {\n    response,\n    json: { result: [json] }\n  })\n  );\n};\n\nconst v1ChartDataRequest = async (\nformData,\nresultFormat,\nresultType,\nforce,\nrequestParams,\nsetDataMask,\nownState,\nparseMethod) =>\n{\n  const payload = buildV1ChartDataPayload({\n    formData,\n    resultType,\n    resultFormat,\n    force,\n    setDataMask,\n    ownState\n  });\n\n  // The dashboard id is added to query params for tracking purposes\n  const { slice_id: sliceId } = formData;\n  const { dashboard_id: dashboardId } = requestParams;\n\n  const qs = {};\n  if (sliceId !== undefined) qs.form_data = `{\"slice_id\":${sliceId}}`;\n  if (dashboardId !== undefined) qs.dashboard_id = dashboardId;\n  if (force) qs.force = force;\n\n  const allowDomainSharding =\n  // eslint-disable-next-line camelcase\n  domainShardingEnabled && (requestParams == null ? void 0 : requestParams.dashboard_id);\n  const url = getChartDataUri({\n    path: '/api/v1/chart/data',\n    qs,\n    allowDomainSharding\n  }).toString();\n\n  const querySettings = {\n    ...requestParams,\n    url,\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(payload),\n    parseMethod\n  };\n\n  return SupersetClient.post(querySettings);\n};\n\nexport async function getChartDataRequest({\n  formData,\n  setDataMask = () => {},\n  resultFormat = 'json',\n  resultType = 'full',\n  force = false,\n  method = 'POST',\n  requestParams = {},\n  ownState = {}\n}) {\n  let querySettings = {\n    ...requestParams\n  };\n\n  if (domainShardingEnabled) {\n    querySettings = {\n      ...querySettings,\n      mode: 'cors',\n      credentials: 'include'\n    };\n  }\n  const [useLegacyApi, parseMethod] = getQuerySettings(formData);\n  if (useLegacyApi) {\n    return legacyChartDataRequest(\n      formData,\n      resultFormat,\n      resultType,\n      force,\n      method,\n      querySettings,\n      parseMethod\n    );\n  }\n  return v1ChartDataRequest(\n    formData,\n    resultFormat,\n    resultType,\n    force,\n    querySettings,\n    setDataMask,\n    ownState,\n    parseMethod\n  );\n}\n\nexport function runAnnotationQuery({\n  annotation,\n  timeout,\n  formData,\n  key,\n  isDashboardRequest = false,\n  force = false\n}) {\n  return function (dispatch, getState) {var _fd$annotation_layers;\n    const { charts, common } = getState();\n    const sliceKey = key || Object.keys(charts)[0];\n    const queryTimeout = timeout || common.conf.SUPERSET_WEBSERVER_TIMEOUT;\n\n    // make a copy of formData, not modifying original formData\n    const fd = {\n      ...(formData || charts[sliceKey].latestQueryFormData)\n    };\n\n    if (!annotation.sourceType) {\n      return Promise.resolve();\n    }\n\n    // In the original formData the `granularity` attribute represents the time grain (eg\n    // `P1D`), but in the request payload it corresponds to the name of the column where\n    // the time grain should be applied (eg, `Date`), so we need to move things around.\n    fd.time_grain_sqla = fd.time_grain_sqla || fd.granularity;\n    fd.granularity = fd.granularity_sqla;\n\n    const overridesKeys = Object.keys(annotation.overrides);\n    if (overridesKeys.includes('since') || overridesKeys.includes('until')) {\n      annotation.overrides = {\n        ...annotation.overrides,\n        time_range: null\n      };\n    }\n    const sliceFormData = Object.keys(annotation.overrides).reduce(\n      (d, k) => ({\n        ...d,\n        [k]: annotation.overrides[k] || fd[k]\n      }),\n      {}\n    );\n\n    if (!isDashboardRequest && fd) {\n      const hasExtraFilters = fd.extra_filters && fd.extra_filters.length > 0;\n      sliceFormData.extra_filters = hasExtraFilters ?\n      fd.extra_filters :\n      undefined;\n    }\n\n    const url = getAnnotationJsonUrl(annotation.value, force);\n    const controller = new AbortController();\n    const { signal } = controller;\n\n    dispatch(annotationQueryStarted(annotation, controller, sliceKey));\n\n    const annotationIndex = fd == null ? void 0 : (_fd$annotation_layers = fd.annotation_layers) == null ? void 0 : _fd$annotation_layers.findIndex(\n      (it) => it.name === annotation.name\n    );\n    if (annotationIndex >= 0) {\n      fd.annotation_layers[annotationIndex].overrides = sliceFormData;\n    }\n\n    return SupersetClient.post({\n      url,\n      signal,\n      timeout: queryTimeout * 1000,\n      headers: { 'Content-Type': 'application/json' },\n      jsonPayload: buildV1ChartDataPayload({\n        formData: fd,\n        force,\n        resultFormat: 'json',\n        resultType: 'full'\n      })\n    }).\n    then(({ json }) => {var _json$result, _json$result$, _json$result$$annotat;\n      const data = json == null ? void 0 : (_json$result = json.result) == null ? void 0 : (_json$result$ = _json$result[0]) == null ? void 0 : (_json$result$$annotat = _json$result$.annotation_data) == null ? void 0 : _json$result$$annotat[annotation.name];\n      return dispatch(annotationQuerySuccess(annotation, { data }, sliceKey));\n    }).\n    catch((response) =>\n    getClientErrorObject(response).then((err) => {\n      if (err.statusText === 'timeout') {\n        dispatch(\n          annotationQueryFailed(\n            annotation,\n            { error: 'Query timeout' },\n            sliceKey\n          )\n        );\n      } else if ((err.error || '').toLowerCase().includes('no data')) {\n        dispatch(annotationQuerySuccess(annotation, err, sliceKey));\n      } else if (err.statusText !== 'abort') {\n        dispatch(annotationQueryFailed(annotation, err, sliceKey));\n      }\n    })\n    );\n  };\n}\n\nexport const TRIGGER_QUERY = 'TRIGGER_QUERY';\nexport function triggerQuery(value = true, key) {\n  return { type: TRIGGER_QUERY, value, key };\n}\n\n// this action is used for forced re-render without fetch data\nexport const RENDER_TRIGGERED = 'RENDER_TRIGGERED';\nexport function renderTriggered(value, key) {\n  return { type: RENDER_TRIGGERED, value, key };\n}\n\nexport const UPDATE_QUERY_FORM_DATA = 'UPDATE_QUERY_FORM_DATA';\nexport function updateQueryFormData(value, key) {\n  return { type: UPDATE_QUERY_FORM_DATA, value, key };\n}\n\n// in the sql lab -> explore flow, user can inline edit chart title,\n// then the chart will be assigned a new slice_id\nexport const UPDATE_CHART_ID = 'UPDATE_CHART_ID';\nexport function updateChartId(newId, key = 0) {\n  return { type: UPDATE_CHART_ID, newId, key };\n}\n\nexport const ADD_CHART = 'ADD_CHART';\nexport function addChart(chart, key) {\n  return { type: ADD_CHART, chart, key };\n}\n\nexport function handleChartDataResponse(response, json, useLegacyApi) {\n  if (isFeatureEnabled(FeatureFlag.GlobalAsyncQueries)) {\n    // deal with getChartDataRequest transforming the response data\n    const result = 'result' in json ? json.result : json;\n    switch (response.status) {\n      case 200:\n        // Query results returned synchronously, meaning query was already cached.\n        return Promise.resolve(result);\n      case 202:\n        // Query is running asynchronously and we must await the results\n        if (useLegacyApi) {\n          return waitForAsyncData(result[0]);\n        }\n        return waitForAsyncData(result);\n      default:\n        throw new Error(\n          `Received unexpected response status (${response.status}) while fetching chart data`\n        );\n    }\n  }\n  return json.result;\n}\n\nexport function exploreJSON(\nformData,\nforce = false,\ntimeout,\nkey,\ndashboardId,\nownState)\n{\n  return async (dispatch, getState) => {\n    const logStart = Logger.getTimestamp();\n    const controller = new AbortController();\n    const queryTimeout =\n    timeout || getState().common.conf.SUPERSET_WEBSERVER_TIMEOUT;\n\n    const requestParams = {\n      signal: controller.signal,\n      timeout: queryTimeout * 1000\n    };\n    if (dashboardId) requestParams.dashboard_id = dashboardId;\n\n    const setDataMask = (dataMask) => {\n      dispatch(updateDataMask(formData.slice_id, dataMask));\n    };\n    const chartDataRequest = getChartDataRequest({\n      setDataMask,\n      formData,\n      resultFormat: 'json',\n      resultType: 'full',\n      force,\n      method: 'POST',\n      requestParams,\n      ownState\n    });\n\n    dispatch(chartUpdateStarted(controller, formData, key));\n\n    const [useLegacyApi] = getQuerySettings(formData);\n    const chartDataRequestCaught = chartDataRequest.\n    then(({ response, json }) =>\n    handleChartDataResponse(response, json, useLegacyApi)\n    ).\n    then((queriesResponse) => {\n      queriesResponse.forEach((resultItem) =>\n      dispatch(\n        logEvent(LOG_ACTIONS_LOAD_CHART, {\n          slice_id: key,\n          applied_filters: resultItem.applied_filters,\n          is_cached: resultItem.is_cached,\n          force_refresh: force,\n          row_count: resultItem.rowcount,\n          datasource: formData.datasource,\n          start_offset: logStart,\n          ts: new Date().getTime(),\n          duration: Logger.getTimestamp() - logStart,\n          has_extra_filters:\n          formData.extra_filters && formData.extra_filters.length > 0,\n          viz_type: formData.viz_type,\n          data_age: resultItem.is_cached ?\n          extendedDayjs(new Date()).diff(\n            extendedDayjs.utc(resultItem.cached_dttm)\n          ) :\n          null\n        })\n      )\n      );\n      return dispatch(chartUpdateSucceeded(queriesResponse, key));\n    }).\n    catch((response) => {\n      if (isFeatureEnabled(FeatureFlag.GlobalAsyncQueries)) {\n        return dispatch(chartUpdateFailed([response], key));\n      }\n\n      const appendErrorLog = (errorDetails, isCached) => {\n        dispatch(\n          logEvent(LOG_ACTIONS_LOAD_CHART, {\n            slice_id: key,\n            has_err: true,\n            is_cached: isCached,\n            error_details: errorDetails,\n            datasource: formData.datasource,\n            start_offset: logStart,\n            ts: new Date().getTime(),\n            duration: Logger.getTimestamp() - logStart\n          })\n        );\n      };\n      if (response.name === 'AbortError') {\n        appendErrorLog('abort');\n        return dispatch(chartUpdateStopped(key));\n      }\n      return getClientErrorObject(response).then((parsedResponse) => {\n        if (response.statusText === 'timeout') {\n          appendErrorLog('timeout');\n        } else {\n          appendErrorLog(parsedResponse.error, parsedResponse.is_cached);\n        }\n        return dispatch(chartUpdateFailed([parsedResponse], key));\n      });\n    });\n\n    // only retrieve annotations when calling the legacy API\n    const annotationLayers = useLegacyApi ?\n    formData.annotation_layers || [] :\n    [];\n    const isDashboardRequest = dashboardId > 0;\n\n    return Promise.all([\n    chartDataRequestCaught,\n    dispatch(triggerQuery(false, key)),\n    dispatch(updateQueryFormData(formData, key)),\n    ...annotationLayers.map((annotation) =>\n    dispatch(\n      runAnnotationQuery({\n        annotation,\n        timeout,\n        formData,\n        key,\n        isDashboardRequest,\n        force\n      })\n    )\n    )]\n    );\n  };\n}\n\nexport const POST_CHART_FORM_DATA = 'POST_CHART_FORM_DATA';\nexport function postChartFormData(\nformData,\nforce = false,\ntimeout,\nkey,\ndashboardId,\nownState)\n{\n  return exploreJSON(formData, force, timeout, key, dashboardId, ownState);\n}\n\nexport function redirectSQLLab(formData, history) {\n  return (dispatch) => {\n    getChartDataRequest({ formData, resultFormat: 'json', resultType: 'query' }).\n    then(({ json }) => {\n      const redirectUrl = '/sqllab/';\n      const payload = {\n        datasourceKey: formData.datasource,\n        sql: json.result[0].query\n      };\n      if (history) {\n        history.push({\n          pathname: redirectUrl,\n          state: {\n            requestedQuery: payload\n          }\n        });\n      } else {\n        SupersetClient.postForm(redirectUrl, {\n          form_data: safeStringify(payload)\n        });\n      }\n    }).\n    catch(() =>\n    dispatch(addDangerToast(t('An error occurred while loading the SQL')))\n    );\n  };\n}\n\nexport function refreshChart(chartKey, force, dashboardId) {\n  return (dispatch, getState) => {var _getState$dataMask$ch;\n    const chart = (getState().charts || {})[chartKey];\n    const timeout =\n    getState().dashboardInfo.common.conf.SUPERSET_WEBSERVER_TIMEOUT;\n\n    if (\n    !chart.latestQueryFormData ||\n    Object.keys(chart.latestQueryFormData).length === 0)\n    {\n      return;\n    }\n    dispatch(\n      postChartFormData(\n        chart.latestQueryFormData,\n        force,\n        timeout,\n        chart.id,\n        dashboardId, (_getState$dataMask$ch =\n        getState().dataMask[chart.id]) == null ? void 0 : _getState$dataMask$ch.ownState\n      )\n    );\n  };\n}\n\nexport const getDatasourceSamples = async (\ndatasourceType,\ndatasourceId,\nforce,\njsonPayload,\nperPage,\npage) =>\n{\n  try {\n    const searchParams = {\n      force,\n      datasource_type: datasourceType,\n      datasource_id: datasourceId\n    };\n\n    if (isDefined(perPage) && isDefined(page)) {\n      searchParams.per_page = perPage;\n      searchParams.page = page;\n    }\n\n    const response = await SupersetClient.post({\n      endpoint: '/datasource/samples',\n      jsonPayload,\n      searchParams,\n      parseMethod: 'json-bigint'\n    });\n\n    return response.json.result;\n  } catch (err) {\n    const clientError = await getClientErrorObject(err);\n    throw new Error(\n      clientError.message || clientError.error || t('Sorry, an error occurred'),\n      { cause: err }\n    );\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}