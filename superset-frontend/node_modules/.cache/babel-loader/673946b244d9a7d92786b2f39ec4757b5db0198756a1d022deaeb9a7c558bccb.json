{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { memo, useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react';\nimport { css, t } from '@superset-ui/core';\nimport { Tooltip } from 'src/components/Tooltip';\nimport { useResizeDetector } from 'react-resize-detector';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst titleStyles = (theme) => css`\n  display: flex;\n  font-size: ${theme.typography.sizes.xl}px;\n  font-weight: ${theme.typography.weights.bold};\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n\n  & .dynamic-title,\n  & .dynamic-title-input {\n    display: inline-block;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  & .dynamic-title {\n    cursor: default;\n  }\n  & .dynamic-title-input {\n    border: none;\n    padding: 0;\n    outline: none;\n\n    &::placeholder {\n      color: ${theme.colors.grayscale.light1};\n    }\n  }\n\n  & .input-sizer {\n    position: absolute;\n    left: -9999px;\n    display: inline-block;\n    white-space: pre;\n  }\n`;\nexport const DynamicEditableTitle = /*#__PURE__*/memo(({ title, placeholder, onSave, canEdit, label }) => {\n  const [isEditing, setIsEditing] = useState(false);\n  const [currentTitle, setCurrentTitle] = useState(title || '');\n  const contentRef = useRef(null);\n  const [showTooltip, setShowTooltip] = useState(false);\n  const { width: inputWidth, ref: sizerRef } = useResizeDetector();\n  const { width: containerWidth, ref: containerRef } = useResizeDetector({\n    refreshMode: 'debounce'\n  });\n  useEffect(() => {\n    setCurrentTitle(title);\n  }, [title]);\n  useEffect(() => {\n    if (isEditing && contentRef != null && contentRef.current) {\n      contentRef.current.focus();\n      // move cursor and scroll to the end\n      if (contentRef.current.setSelectionRange) {\n        const { length } = contentRef.current.value;\n        contentRef.current.setSelectionRange(length, length);\n        contentRef.current.scrollLeft = contentRef.current.scrollWidth;\n      }\n    }\n  }, [isEditing]);\n  // a trick to make the input grow when user types text\n  // we make additional span component, place it somewhere out of view and copy input\n  // then we can measure the width of that span to resize the input element\n  useLayoutEffect(() => {\n    if (sizerRef != null && sizerRef.current) {\n      sizerRef.current.textContent = currentTitle || placeholder;\n    }\n  }, [currentTitle, placeholder, sizerRef]);\n  useEffect(() => {\n    if (contentRef.current &&\n    contentRef.current.scrollWidth > contentRef.current.clientWidth) {\n      setShowTooltip(true);\n    } else\n    {\n      setShowTooltip(false);\n    }\n  }, [inputWidth, containerWidth]);\n  const handleClick = useCallback(() => {\n    if (!canEdit || isEditing) {\n      return;\n    }\n    setIsEditing(true);\n  }, [canEdit, isEditing]);\n  const handleBlur = useCallback(() => {\n    if (!canEdit) {\n      return;\n    }\n    const formattedTitle = currentTitle.trim();\n    setCurrentTitle(formattedTitle);\n    if (title !== formattedTitle) {\n      onSave(formattedTitle);\n    }\n    setIsEditing(false);\n  }, [canEdit, currentTitle, onSave, title]);\n  const handleChange = useCallback((ev) => {\n    if (!canEdit || !isEditing) {\n      return;\n    }\n    setCurrentTitle(ev.target.value);\n  }, [canEdit, isEditing]);\n  const handleKeyPress = useCallback((ev) => {\n    if (!canEdit) {\n      return;\n    }\n    if (ev.key === 'Enter') {var _contentRef$current;\n      ev.preventDefault();\n      (_contentRef$current = contentRef.current) == null ? void 0 : _contentRef$current.blur();\n    }\n  }, [canEdit]);\n  return _jsxs(\"div\", { css: titleStyles, ref: containerRef, children: [\n    _jsx(Tooltip, { id: \"title-tooltip\", title: showTooltip && currentTitle && !isEditing ? currentTitle : null, children:\n      canEdit ? _jsx(\"input\", { className: \"dynamic-title-input\", \"aria-label\": label != null ? label : t('Title'), ref: contentRef, onChange: handleChange, onBlur: handleBlur, onClick: handleClick, onKeyPress: handleKeyPress, placeholder: placeholder, value: currentTitle, css: css`\n                cursor: ${isEditing ? 'text' : 'pointer'};\n\n                ${inputWidth &&\n        inputWidth > 0 &&\n        css`\n                  width: ${inputWidth + 1}px;\n                `}\n              ` }) : _jsx(\"span\", { className: \"dynamic-title\", \"aria-label\": label != null ? label : t('Title'), ref: contentRef, children:\n        currentTitle }\n      ) }\n    ),\n    _jsx(\"span\", { ref: sizerRef, className: \"input-sizer\", \"aria-hidden\": true, tabIndex: -1 })] }\n  );\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}