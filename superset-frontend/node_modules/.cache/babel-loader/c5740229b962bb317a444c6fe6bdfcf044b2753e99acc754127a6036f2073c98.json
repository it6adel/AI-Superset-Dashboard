{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, NO_TIME_RANGE, t, validateNonEmpty } from '@superset-ui/core';\nimport { getTemporalColumns } from '../utils';\nconst getAxisLabel = (formData) => (formData == null ? void 0 : formData.orientation) === 'horizontal' ?\n{ label: t('Y-axis'), description: t('Dimension to use on y-axis.') } :\n{ label: t('X-axis'), description: t('Dimension to use on x-axis.') };\nexport const xAxisMixin = {\n  label: (state) => getAxisLabel(state == null ? void 0 : state.form_data).label,\n  multi: false,\n  description: (state) => getAxisLabel(state == null ? void 0 : state.form_data).description,\n  validators: [validateNonEmpty],\n  initialValue: (control, state) => {var _state$form_data, _state$form_data2;\n    if (state != null && (_state$form_data = state.form_data) != null && _state$form_data.granularity_sqla &&\n    !((_state$form_data2 = state.form_data) != null && _state$form_data2.x_axis) &&\n    !(control != null && control.value)) {\n      return state.form_data.granularity_sqla;\n    }\n    return undefined;\n  },\n  default: undefined\n};\nexport const temporalColumnMixin = {\n  isTemporal: true,\n  mapStateToProps: ({ datasource }) => {\n    const payload = getTemporalColumns(datasource);\n    return {\n      options: payload.temporalColumns,\n      default: payload.defaultTemporalColumn\n    };\n  }\n};\nexport const datePickerInAdhocFilterMixin = {\n  initialValue: (control, state) => {var _state$controls, _state$controls$time_, _state$form_data3, _state$form_data4;\n    // skip initialValue if\n    // 1) the time_range control is present (this is the case for legacy charts)\n    // 2) there was a time filter in adhoc filters\n    if (state != null && (_state$controls = state.controls) != null && (_state$controls$time_ = _state$controls.time_range) != null && _state$controls$time_.value ||\n    ensureIsArray(control.value).findIndex((flt) => (flt == null ? void 0 : flt.operator) === 'TEMPORAL_RANGE') > -1) {\n      return undefined;\n    }\n    // should migrate original granularity_sqla and time_range into adhoc filter\n    // 1) granularity_sqla and time_range are existed\n    if (state != null && (_state$form_data3 = state.form_data) != null && _state$form_data3.granularity_sqla && state != null && (_state$form_data4 = state.form_data) != null && _state$form_data4.time_range) {\n      return [\n      ...ensureIsArray(control.value),\n      {\n        clause: 'WHERE',\n        subject: state.form_data.granularity_sqla,\n        operator: 'TEMPORAL_RANGE',\n        comparator: state.form_data.time_range,\n        expressionType: 'SIMPLE'\n      }];\n\n    }\n    // should apply the default time filter into adhoc filter\n    // 1) temporal column is existed in current datasource\n    const temporalColumn = (state == null ? void 0 : state.datasource) &&\n    getTemporalColumns(state.datasource).defaultTemporalColumn;\n    if (temporalColumn) {var _state$common, _state$common$conf;\n      return [\n      ...ensureIsArray(control.value),\n      {\n        clause: 'WHERE',\n        subject: temporalColumn,\n        operator: 'TEMPORAL_RANGE',\n        comparator: (state == null ? void 0 : (_state$common = state.common) == null ? void 0 : (_state$common$conf = _state$common.conf) == null ? void 0 : _state$common$conf.DEFAULT_TIME_FILTER) || NO_TIME_RANGE,\n        expressionType: 'SIMPLE'\n      }];\n\n    }\n    return undefined;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}