{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { PureComponent } from 'react';\nimport { nanoid } from 'nanoid';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport { t, styled } from '@superset-ui/core';\nimport Button from 'src/components/Button';\nimport Icons from 'src/components/Icons';\nimport Fieldset from './Fieldset';\nimport { recurseReactClone } from './utils';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";import { createElement as _createElement } from \"@emotion/react\";\nvar SortOrder;\n(function (SortOrder) {\n  SortOrder[SortOrder[\"Asc\"] = 1] = \"Asc\";\n  SortOrder[SortOrder[\"Desc\"] = 2] = \"Desc\";\n  SortOrder[SortOrder[\"Unsorted\"] = 0] = \"Unsorted\";\n})(SortOrder || (SortOrder = {}));\nfunction createCollectionArray(collection) {\n  return Object.keys(collection).map((k) => collection[k]);\n}\nfunction createKeyedCollection(arr) {\n  const collectionArray = arr.map((o) => ({\n    ...o,\n    id: o.id || nanoid()\n  }));\n  const collection = {};\n  collectionArray.forEach((o) => {\n    collection[o.id] = o;\n  });\n  return {\n    collection,\n    collectionArray\n  };\n}\nconst CrudTableWrapper = styled.div`\n  ${({ stickyHeader }) => stickyHeader &&\n`\n      height: 350px;\n      overflow-y: auto;\n      overflow-x: auto;\n\n      .table {\n        min-width: 800px;\n      }\n      thead th {\n        background: #fff;\n        position: sticky;\n        top: 0;\n        z-index: 9;\n        min\n      }\n    `}\n  ${({ theme }) => `\n    th span {\n      vertical-align: ${theme.gridUnit * -2}px;\n    }\n    .text-right {\n      text-align: right;\n    }\n    .empty-collection {\n      padding: ${theme.gridUnit * 2 + 2}px;\n    }\n    .tiny-cell {\n      width: ${theme.gridUnit + 1}px;\n    }\n    i.fa-caret-down,\n    i.fa-caret-up {\n      width: ${theme.gridUnit + 1}px;\n    }\n    td.expanded {\n      border-top: 0;\n      padding: 0;\n    }\n  `}\n`;\nconst CrudButtonWrapper = styled.div`\n  text-align: right;\n  ${({ theme }) => `margin-bottom: ${theme.gridUnit * 2}px`}\n`;\nconst StyledButtonWrapper = styled.span`\n  ${({ theme }) => `\n    margin-top: ${theme.gridUnit * 3}px;\n    margin-left: ${theme.gridUnit * 3}px;\n    button>span>:first-of-type {\n      margin-right: 0;\n    }\n  `}\n`;\nexport default class CRUDCollection extends PureComponent {\n  constructor(props) {\n    super(props);\n    const { collection, collectionArray } = createKeyedCollection(props.collection);\n    this.state = {\n      expandedColumns: {},\n      collection,\n      collectionArray,\n      sortColumn: '',\n      sort: 0\n    };\n    this.renderItem = this.renderItem.bind(this);\n    this.onAddItem = this.onAddItem.bind(this);\n    this.renderExpandableSection = this.renderExpandableSection.bind(this);\n    this.getLabel = this.getLabel.bind(this);\n    this.onFieldsetChange = this.onFieldsetChange.bind(this);\n    this.renderTableBody = this.renderTableBody.bind(this);\n    this.changeCollection = this.changeCollection.bind(this);\n    this.sortColumn = this.sortColumn.bind(this);\n    this.renderSortIcon = this.renderSortIcon.bind(this);\n  }\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (nextProps.collection !== this.props.collection) {\n      const { collection, collectionArray } = createKeyedCollection(nextProps.collection);\n      this.setState({\n        collection,\n        collectionArray\n      });\n    }\n  }\n  onCellChange(id, col, val) {\n    this.changeCollection({\n      ...this.state.collection,\n      [id]: {\n        ...this.state.collection[id],\n        [col]: val\n      }\n    });\n  }\n  onAddItem() {\n    if (this.props.itemGenerator) {\n      let newItem = this.props.itemGenerator();\n      if (!newItem.id) {\n        newItem = { ...newItem, id: nanoid() };\n      }\n      this.changeCollection(this.state.collection, newItem);\n    }\n  }\n  onFieldsetChange(item) {\n    this.changeCollection({\n      ...this.state.collection,\n      [item.id]: item\n    });\n  }\n  getLabel(col) {\n    const { columnLabels } = this.props;\n    let label = columnLabels != null && columnLabels[col] ? columnLabels[col] : col;\n    if (label.startsWith('__')) {\n      // special label-free columns (ie: caret for expand, delete cross)\n      label = '';\n    }\n    return label;\n  }\n  getTooltip(col) {\n    const { columnLabelTooltips } = this.props;\n    return columnLabelTooltips == null ? void 0 : columnLabelTooltips[col];\n  }\n  changeCollection(collection, newItem) {\n    this.setState({ collection });\n    if (this.props.onChange) {\n      const collectionArray = this.state.collectionArray.\n      map((c) => collection[c.id])\n      // filter out removed items\n      .filter((c) => c !== undefined);\n      if (newItem) {\n        collectionArray.unshift(newItem);\n      }\n      this.props.onChange(collectionArray);\n    }\n  }\n  deleteItem(id) {\n    const newColl = { ...this.state.collection };\n    delete newColl[id];\n    this.changeCollection(newColl);\n  }\n  effectiveTableColumns() {\n    const { tableColumns, allowDeletes, expandFieldset } = this.props;\n    const cols = allowDeletes ?\n    tableColumns.concat(['__actions']) :\n    tableColumns;\n    return expandFieldset ? ['__expand'].concat(cols) : cols;\n  }\n  toggleExpand(id) {\n    this.onCellChange(id, '__expanded', false);\n    this.setState((prevState) => ({\n      expandedColumns: {\n        ...prevState.expandedColumns,\n        [id]: !prevState.expandedColumns[id]\n      }\n    }));\n  }\n  sortColumn(col, sort = SortOrder.Unsorted) {\n    const { sortColumns } = this.props;\n    // default sort logic sorting string, boolean and number\n    const compareSort = (m, n) => {\n      if (typeof m === 'string') {\n        return (m || ' ').localeCompare(n);\n      }\n      return m - n;\n    };\n    return () => {\n      if (sortColumns != null && sortColumns.includes(col)) {\n        // display in unsorted order if no sort specified\n        if (sort === SortOrder.Unsorted) {\n          const { collection } = createKeyedCollection(this.props.collection);\n          const collectionArray = createCollectionArray(collection);\n          this.setState({\n            collectionArray,\n            sortColumn: '',\n            sort\n          });\n          return;\n        }\n        // newly ordered collection\n        const sorted = [...this.state.collectionArray].sort((a, b) => compareSort(a[col], b[col]));\n        const newCollection = sort === SortOrder.Asc ? sorted : sorted.reverse();\n        this.setState((prevState) => ({\n          ...prevState,\n          collectionArray: newCollection,\n          sortColumn: col,\n          sort\n        }));\n      }\n    };\n  }\n  renderSortIcon(col) {\n    if (this.state.sortColumn === col && this.state.sort === SortOrder.Asc) {\n      return _jsx(Icons.SortAsc, { onClick: this.sortColumn(col, 2) });\n    }\n    if (this.state.sortColumn === col && this.state.sort === SortOrder.Desc) {\n      return _jsx(Icons.SortDesc, { onClick: this.sortColumn(col, 0) });\n    }\n    return _jsx(Icons.Sort, { onClick: this.sortColumn(col, 1) });\n  }\n  renderTH(col, sortColumns) {\n    const tooltip = this.getTooltip(col);\n    return _jsxs(\"th\", { className: \"no-wrap\", children: [\n      this.getLabel(col),\n      tooltip && _jsxs(_Fragment, { children: [\n        ' ',\n        _jsx(InfoTooltipWithTrigger, { label: t('description'), tooltip: tooltip })] }\n      ),\n      (sortColumns == null ? void 0 : sortColumns.includes(col)) && this.renderSortIcon(col)] }, col\n    );\n  }\n  renderHeaderRow() {\n    const cols = this.effectiveTableColumns();\n    const { allowDeletes, expandFieldset, extraButtons, sortColumns } = this.props;\n    return _jsx(\"thead\", { children:\n      _jsxs(\"tr\", { children: [\n        expandFieldset && _jsx(\"th\", { \"aria-label\": \"Expand\", className: \"tiny-cell\" }),\n        cols.map((col) => this.renderTH(col, sortColumns)),\n        extraButtons,\n        allowDeletes && _jsx(\"th\", { \"aria-label\": \"Delete\", className: \"tiny-cell\" }, \"delete-item\")] }\n      ) }\n    );\n  }\n  renderExpandableSection(item) {\n    const propsGenerator = () => ({ item, onChange: this.onFieldsetChange });\n    return recurseReactClone(this.props.expandFieldset, Fieldset, propsGenerator);\n  }\n  getCellProps(record, col) {var _this$props$itemCellP;\n    const cellPropsFn = (_this$props$itemCellP = this.props.itemCellProps) == null ? void 0 : _this$props$itemCellP[col];\n    const val = record[col];\n    return cellPropsFn ? cellPropsFn(val, this.getLabel(col), record) : {};\n  }\n  renderCell(record, col) {var _this$props$itemRende;\n    const renderer = (_this$props$itemRende = this.props.itemRenderers) == null ? void 0 : _this$props$itemRende[col];\n    const val = record[col];\n    const onChange = this.onCellChange.bind(this, record.id, col);\n    return renderer ? renderer(val, onChange, this.getLabel(col), record) : val;\n  }\n  renderItem(record) {\n    const { allowAddItem, allowDeletes, expandFieldset, tableColumns } = this.props;\n    /* eslint-disable no-underscore-dangle */\n    const isExpanded = !!this.state.expandedColumns[record.id] || record.__expanded;\n    let tds = [];\n    if (expandFieldset) {\n      tds.push(_jsx(\"td\", { className: \"expand\", children:\n        _jsx(\"i\", { role: \"button\", \"aria-label\": \"Toggle expand\", tabIndex: 0\n          // TODO: Remove fa-icon\n          // eslint-disable-next-line icons/no-fa-icons-usage\n          , className: `fa fa-caret-${isExpanded ? 'down' : 'right'} text-primary pointer`, onClick: this.toggleExpand.bind(this, record.id) }) }, \"__expand\"\n      ));\n    }\n    tds = tds.concat(tableColumns.map((col) => _createElement(\"td\", { ...this.getCellProps(record, col), key: col },\n    this.renderCell(record, col)\n    )));\n    if (allowAddItem) {\n      tds.push(_jsx(\"td\", { \"aria-label\": \"Add\" }, \"add\"));\n    }\n    if (allowDeletes) {\n      tds.push(_jsx(\"td\", { className: \"text-primary\", children:\n        _jsx(Icons.DeleteOutlined, { \"aria-label\": \"Delete item\", className: \"pointer\", role: \"button\", tabIndex: 0, onClick: this.deleteItem.bind(this, record.id), iconSize: \"l\" }) }, \"__actions\"\n      ));\n    }\n    const trs = [\n    _createElement(\"tr\", { className: \"row\", key: record.id },\n    tds\n    )];\n\n    if (isExpanded) {\n      trs.push(_jsx(\"tr\", { className: \"exp\", children:\n        _jsx(\"td\", { colSpan: this.effectiveTableColumns().length, className: \"expanded\", children:\n          _jsx(\"div\", { children: this.renderExpandableSection(record) }) }\n        ) }, `exp__${record.id}`\n      ));\n    }\n    return trs;\n  }\n  renderEmptyCell() {\n    return _jsx(\"tr\", { children:\n      _jsx(\"td\", { className: \"empty-collection\", children: this.props.emptyMessage }) }\n    );\n  }\n  renderTableBody() {\n    const data = this.state.collectionArray;\n    const content = data.length ?\n    data.map((d) => this.renderItem(d)) :\n    this.renderEmptyCell();\n    return _jsx(\"tbody\", { children: content });\n  }\n  render() {\n    return _jsxs(_Fragment, { children: [\n      _jsx(CrudButtonWrapper, { children:\n        this.props.allowAddItem && _jsx(StyledButtonWrapper, { children:\n          _jsxs(Button, { buttonSize: \"small\", buttonStyle: \"tertiary\", onClick: this.onAddItem, children: [\n            _jsx(Icons.PlusOutlined, { iconSize: \"m\" }),\n            t('Add item')] }\n          ) }\n        ) }\n      ),\n      _jsx(CrudTableWrapper, { className: \"CRUD\", stickyHeader: this.props.stickyHeader, children:\n        _jsxs(\"table\", { className: \"table\", children: [\n          this.renderHeaderRow(),\n          this.renderTableBody()] }\n        ) }\n      )] }\n    );\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}