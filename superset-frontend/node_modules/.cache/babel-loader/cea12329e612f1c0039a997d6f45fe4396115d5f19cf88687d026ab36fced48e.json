{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useEffect, useMemo, useState } from 'react';\nimport { getClientErrorObject, SupersetClient, t } from '@superset-ui/core';\nimport Modal from 'src/components/Modal';\nimport Button from 'src/components/Button';\nimport { Switch } from 'src/components/Switch';\nimport Collapse from 'src/components/Collapse';\nimport { AntdForm, AsyncSelect, Col, Row, Select, Upload } from 'src/components';\nimport Icons from 'src/components/Icons';\nimport { Input, InputNumber } from 'src/components/Input';\nimport rison from 'rison';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport { antdCollapseStyles, antDModalNoPaddingStyles, antDModalStyles, formStyles, StyledFormItem, StyledSwitchContainer } from './styles';\nimport ColumnsPreview from './ColumnsPreview';\nimport StyledFormItemWithTip from './StyledFormItemWithTip';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst CSVSpecificFields = [\n'delimiter',\n'skip_initial_space',\n'skip_blank_lines',\n'day_first',\n'column_data_types',\n'column_dates',\n'decimal_character',\n'null_values',\n'index_column',\n'header_row',\n'rows_to_read',\n'skip_rows'];\n\nconst ExcelSpecificFields = [\n'sheet_name',\n'column_dates',\n'decimal_character',\n'null_values',\n'index_column',\n'header_row',\n'rows_to_read',\n'skip_rows'];\n\nconst ColumnarSpecificFields = [];\nconst NonNullFields = ['rows_to_read', 'index_column'];\nconst AllSpecificFields = [\n...CSVSpecificFields,\n...ExcelSpecificFields,\n...ColumnarSpecificFields];\n\nconst UploadTypeToSpecificFields = {\n  csv: CSVSpecificFields,\n  excel: ExcelSpecificFields,\n  columnar: ColumnarSpecificFields\n};\nconst isFieldATypeSpecificField = (field, type) => UploadTypeToSpecificFields[type].includes(field);\nconst defaultUploadInfo = {\n  table_name: '',\n  schema: '',\n  sheet_name: undefined,\n  delimiter: ',',\n  already_exists: 'fail',\n  skip_initial_space: false,\n  skip_blank_lines: false,\n  day_first: false,\n  decimal_character: '.',\n  null_values: [],\n  header_row: '0',\n  rows_to_read: null,\n  skip_rows: '0',\n  column_dates: [],\n  index_column: null,\n  dataframe_index: false,\n  index_label: '',\n  columns_read: [],\n  column_data_types: ''\n};\n// Allowed extensions to accept for file upload, users can always override this\n// by selecting all file extensions on the OS file picker. Also \".txt\" will\n// allow all files to be selected.\nconst allowedExtensionsToAccept = {\n  csv: '.csv, .tsv',\n  excel: '.xls, .xlsx',\n  columnar: '.parquet, .zip'\n};\nconst extensionsToLabel = {\n  csv: 'CSV',\n  excel: 'Excel',\n  columnar: 'Columnar'\n};\nexport const validateUploadFileExtension = (file, allowedExtensions) => {\n  const extensionMatch = file.name.match(/.+\\.([^.]+)$/);\n  if (!extensionMatch) {\n    return false;\n  }\n  const fileType = extensionMatch[1].toLowerCase();\n  const lowerCaseAllowedExtensions = allowedExtensions.map((ext) => ext.toLowerCase());\n  return lowerCaseAllowedExtensions.includes(fileType);\n};\nconst SwitchContainer = ({ label, dataTest, children, ...switchProps }) => _jsxs(StyledSwitchContainer, { children: [\n  _jsx(Switch, { ...switchProps }),\n  _jsx(\"div\", { className: \"switch-label\", children: label }),\n  children] }\n);\nconst UploadDataModal = ({ addDangerToast, addSuccessToast, onHide, show, allowedExtensions, type = 'csv' }) => {\n  const [form] = AntdForm.useForm();\n  const [currentDatabaseId, setCurrentDatabaseId] = useState(0);\n  const [fileList, setFileList] = useState([]);\n  const [columns, setColumns] = useState([]);\n  const [sheetNames, setSheetNames] = useState([]);\n  const [sheetsColumnNames, setSheetsColumnNames] = useState({});\n  const [delimiter, setDelimiter] = useState(',');\n  const [isLoading, setIsLoading] = useState(false);\n  const [currentSchema, setCurrentSchema] = useState();\n  const [currentDataframeIndex, setCurrentDataframeIndex] = useState(false);\n  const [previewUploadedFile, setPreviewUploadedFile] = useState(true);\n  const [fileLoading, setFileLoading] = useState(false);\n  const createTypeToEndpointMap = (databaseId) => `/api/v1/database/${databaseId}/upload/`;\n  const nullValuesOptions = [\n  {\n    value: '\"\"',\n    label: 'Empty Strings \"\"'\n  },\n  {\n    value: 'None',\n    label: 'None'\n  },\n  {\n    value: 'nan',\n    label: 'nan'\n  },\n  {\n    value: 'null',\n    label: 'null'\n  },\n  {\n    value: 'N/A',\n    label: 'N/A'\n  }];\n\n  const delimiterOptions = [\n  {\n    value: ',',\n    label: 'Comma \",\"'\n  },\n  {\n    value: ';',\n    label: 'Semicolon \";\"'\n  },\n  {\n    value: '\\t',\n    label: 'Tab \"\\\\t\"'\n  },\n  {\n    value: '|',\n    label: 'Pipe'\n  }];\n\n  const tableAlreadyExistsOptions = [\n  {\n    value: 'fail',\n    label: 'Fail'\n  },\n  {\n    value: 'replace',\n    label: 'Replace'\n  },\n  {\n    value: 'append',\n    label: 'Append'\n  }];\n\n  const onChangePreviewUploadedFile = (value) => {\n    setPreviewUploadedFile(value);\n  };\n  const onChangeDatabase = (database) => {\n    setCurrentDatabaseId(database == null ? void 0 : database.value);\n    setCurrentSchema(undefined);\n    form.setFieldsValue({ schema: undefined });\n  };\n  const onChangeSchema = (schema) => {\n    setCurrentSchema(schema == null ? void 0 : schema.value);\n  };\n  const onChangeDelimiter = (value) => {\n    setDelimiter(value);\n  };\n  const clearModal = () => {\n    setFileList([]);\n    setColumns([]);\n    setCurrentSchema('');\n    setCurrentDatabaseId(0);\n    setSheetNames([]);\n    setIsLoading(false);\n    setDelimiter(',');\n    setPreviewUploadedFile(true);\n    setFileLoading(false);\n    setSheetsColumnNames({});\n    form.resetFields();\n  };\n  const loadDatabaseOptions = useMemo(() => (input = '', page, pageSize) => {\n    const query = rison.encode_uri({\n      filters: [\n      {\n        col: 'allow_file_upload',\n        opr: 'eq',\n        value: true\n      }],\n\n      page,\n      page_size: pageSize\n    });\n    return SupersetClient.get({\n      endpoint: `/api/v1/database/?q=${query}`\n    }).then((response) => {\n      const list = response.json.result.map((item) => ({\n        value: item.id,\n        label: item.database_name\n      }));\n      return { data: list, totalCount: response.json.count };\n    });\n  }, []);\n  const loadSchemaOptions = useMemo(() => (input = '', page, pageSize) => {\n    if (!currentDatabaseId) {\n      return Promise.resolve({ data: [], totalCount: 0 });\n    }\n    return SupersetClient.get({\n      endpoint: `/api/v1/database/${currentDatabaseId}/schemas/?q=(upload_allowed:!t)`\n    }).then((response) => {\n      const list = response.json.result.map((item) => ({\n        value: item,\n        label: item\n      }));\n      return { data: list, totalCount: response.json.count };\n    });\n  }, [currentDatabaseId]);\n  const loadFileMetadata = (file) => {\n    const fields = form.getFieldsValue();\n    const mergedValues = { ...defaultUploadInfo, ...fields };\n    const formData = new FormData();\n    formData.append('file', file);\n    if (type === 'csv') {\n      formData.append('delimiter', mergedValues.delimiter);\n    }\n    formData.append('type', type);\n    setFileLoading(true);\n    return SupersetClient.post({\n      endpoint: '/api/v1/database/upload_metadata/',\n      body: formData,\n      headers: { Accept: 'application/json' }\n    }).\n    then((response) => {\n      const { items } = response.json.result;\n      if (items && type !== 'excel') {\n        setColumns(items[0].column_names);\n      } else\n      {\n        const { allSheetNames, sheetColumnNamesMap } = items.reduce((acc, item) => {\n          acc.allSheetNames.push(item.sheet_name);\n          acc.sheetColumnNamesMap[item.sheet_name] = item.column_names;\n          return acc;\n        }, { allSheetNames: [], sheetColumnNamesMap: {} });\n        setColumns(items[0].column_names);\n        setSheetNames(allSheetNames);\n        form.setFieldsValue({ sheet_name: allSheetNames[0] });\n        setSheetsColumnNames(sheetColumnNamesMap);\n      }\n    }).\n    catch((response) => getClientErrorObject(response).then((error) => {\n      addDangerToast(error.error || 'Error');\n      setColumns([]);\n      form.setFieldsValue({ sheet_name: undefined });\n      setSheetNames([]);\n    })).\n    finally(() => {\n      setFileLoading(false);\n    });\n  };\n  const getAllFieldsNotInType = () => {\n    const specificFields = UploadTypeToSpecificFields[type] || [];\n    return [...AllSpecificFields].filter((field) => !specificFields.includes(field));\n  };\n  const appendFormData = (formData, data) => {\n    const allFieldsNotInType = getAllFieldsNotInType();\n    Object.entries(data).forEach(([key, value]) => {\n      if (!(allFieldsNotInType.includes(key) ||\n      NonNullFields.includes(key) && (\n      value === undefined || value === null))) {\n        formData.append(key, value);\n      }\n    });\n  };\n  const onClose = () => {\n    clearModal();\n    onHide();\n  };\n  const onFinish = () => {var _fileList$;\n    const fields = form.getFieldsValue();\n    delete fields.database;\n    fields.schema = currentSchema;\n    const mergedValues = { ...defaultUploadInfo, ...fields };\n    const formData = new FormData();\n    const file = (_fileList$ = fileList[0]) == null ? void 0 : _fileList$.originFileObj;\n    if (file) {\n      formData.append('file', file);\n    }\n    appendFormData(formData, mergedValues);\n    setIsLoading(true);\n    const endpoint = createTypeToEndpointMap(currentDatabaseId);\n    formData.append('type', type);\n    return SupersetClient.post({\n      endpoint,\n      body: formData,\n      headers: { Accept: 'application/json' }\n    }).\n    then(() => {\n      addSuccessToast(t('Data imported'));\n      setIsLoading(false);\n      onClose();\n    }).\n    catch((response) => getClientErrorObject(response).then((error) => {\n      addDangerToast(error.error || 'Error');\n    })).\n    finally(() => {\n      setIsLoading(false);\n    });\n  };\n  const onRemoveFile = (removedFile) => {\n    setFileList(fileList.filter((file) => file.uid !== removedFile.uid));\n    setColumns([]);\n    setSheetNames([]);\n    form.setFieldsValue({ sheet_name: undefined });\n    return false;\n  };\n  const onSheetNameChange = (value) => {var _sheetsColumnNames$va;\n    setColumns((_sheetsColumnNames$va = sheetsColumnNames[value]) != null ? _sheetsColumnNames$va : []);\n  };\n  const columnsToOptions = () => columns.map((column) => ({\n    value: column,\n    label: column\n  }));\n  const sheetNamesToOptions = () => sheetNames.map((sheetName) => ({\n    value: sheetName,\n    label: sheetName\n  }));\n  const onChangeFile = async (info) => {\n    setFileList([\n    {\n      ...info.file,\n      status: 'done'\n    }]\n    );\n    if (!previewUploadedFile) {\n      return;\n    }\n    await loadFileMetadata(info.file.originFileObj);\n  };\n  useEffect(() => {\n    if (columns.length > 0 &&\n    fileList[0].originFileObj &&\n    fileList[0].originFileObj instanceof File) {\n      if (!previewUploadedFile) {\n        return;\n      }\n      loadFileMetadata(fileList[0].originFileObj).then((r) => r);\n    }\n  }, [delimiter]);\n  const validateUpload = (_, value) => {\n    if (fileList.length === 0) {\n      return Promise.reject(t('Uploading a file is required'));\n    }\n    if (!validateUploadFileExtension(fileList[0], allowedExtensions)) {\n      return Promise.reject(t('Upload a file with a valid extension. Valid: [%s]', allowedExtensions.join(',')));\n    }\n    return Promise.resolve();\n  };\n  const validateDatabase = (_, value) => {\n    if (!currentDatabaseId) {\n      return Promise.reject(t('Selecting a database is required'));\n    }\n    return Promise.resolve();\n  };\n  const uploadTitles = {\n    csv: t('CSV upload'),\n    excel: t('Excel upload'),\n    columnar: t('Columnar upload')\n  };\n  const UploadTitle = () => {\n    const title = uploadTitles[type] || t('Upload');\n    return _jsx(\"h4\", { children: title });\n  };\n  return _jsx(Modal, { css: (theme) => [\n    antDModalNoPaddingStyles,\n    antDModalStyles(theme),\n    formStyles(theme)],\n    primaryButtonLoading: isLoading, name: \"database\", onHandledPrimaryAction: form.submit, onHide: onClose, width: \"500px\", primaryButtonName: \"Upload\", centered: true, show: show, title: _jsx(UploadTitle, {}), children:\n    _jsx(AntdForm, { form: form, onFinish: onFinish, layout: \"vertical\", initialValues: defaultUploadInfo, children:\n      _jsxs(Collapse, { expandIconPosition: \"right\", accordion: true, defaultActiveKey: \"general\", css: (theme) => antdCollapseStyles(theme), children: [\n        _jsxs(Collapse.Panel, { header: _jsxs(\"div\", { children: [\n            _jsx(\"h4\", { children: t('General information') }),\n            _jsx(\"p\", { className: \"helper\", children: t('Upload a file to a database.') })] }\n          ), children: [\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('%(label)s file', {\n                  label: extensionsToLabel[type]\n                }), name: \"file\", required: true, rules: [{ validator: validateUpload }], children:\n                _jsx(Upload, { name: \"modelFile\", id: \"modelFile\", accept: allowedExtensionsToAccept[type], fileList: fileList, onChange: onChangeFile, onRemove: onRemoveFile\n                  // upload is handled by hook\n                  , customRequest: () => {}, children:\n                  _jsx(Button, { \"aria-label\": t('Select'), icon: _jsx(Icons.UploadOutlined, {}), loading: fileLoading, children:\n                    t('Select') }\n                  ) }\n                ) }\n              ) }\n            ) }\n          ),\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { children:\n                _jsx(SwitchContainer, { label: t('Preview uploaded file'), dataTest: \"previewUploadedFile\", onChange: onChangePreviewUploadedFile, checked: previewUploadedFile }) }\n              ) }\n            ) }\n          ),\n          previewUploadedFile && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(ColumnsPreview, { columns: columns }) }\n            ) }\n          ),\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('Database'), required: true, name: \"database\", rules: [{ validator: validateDatabase }], children:\n                _jsx(AsyncSelect, { ariaLabel: t('Select a database'), options: loadDatabaseOptions, onChange: onChangeDatabase, allowClear: true, placeholder: t('Select a database to upload the file to') }) }\n              ) }\n            ) }\n          ),\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('Schema'), name: \"schema\", children:\n                _jsx(AsyncSelect, { ariaLabel: t('Select a schema'), options: loadSchemaOptions, onChange: onChangeSchema, allowClear: true, placeholder: t('Select a schema if the database supports this') }) }\n              ) }\n            ) }\n          ),\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('Table name'), name: \"table_name\", required: true, rules: [\n                { required: true, message: 'Table name is required' }], children:\n\n                _jsx(Input, { \"aria-label\": t('Table Name'), name: \"table_name\", type: \"text\", placeholder: t('Name of table to be created') }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('delimiter', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('Delimiter'), tip: t('Select a delimiter for this data'), name: \"delimiter\", children:\n                _jsx(Select, { ariaLabel: t('Choose a delimiter'), options: delimiterOptions, onChange: onChangeDelimiter, allowNewOptions: true }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('sheet_name', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('Sheet name'), name: \"sheet_name\", children:\n                _jsx(Select, { ariaLabel: t('Choose sheet name'), options: sheetNamesToOptions(), onChange: onSheetNameChange, allowNewOptions: true, placeholder: t('Select a sheet name from the uploaded file') }) }\n              ) }\n            ) }\n          )] }, \"general\"\n        ),\n        _jsxs(Collapse.Panel, { header: _jsxs(\"div\", { children: [\n            _jsx(\"h4\", { children: t('File settings') }),\n            _jsx(\"p\", { className: \"helper\", children:\n              t('Adjust how spaces, blank lines, null values are handled and other file wide settings.') }\n            )] }\n          ), children: [\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('If table already exists'), tip: t('What should happen if the table already exists'), name: \"already_exists\", children:\n                _jsx(Select, { ariaLabel: t('Choose already exists'), options: tableAlreadyExistsOptions, onChange: () => {} }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('column_dates', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('Columns to be parsed as dates'), name: \"column_dates\", children:\n                _jsx(Select, { ariaLabel: t('Choose columns to be parsed as dates'), mode: \"multiple\", options: columnsToOptions(), allowClear: true, allowNewOptions: true, placeholder: t('A comma separated list of columns that should be parsed as dates') }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('decimal_character', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('Decimal character'), tip: t('Character to interpret as decimal point'), name: \"decimal_character\", children:\n                _jsx(Input, { type: \"text\" }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('null_values', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('Null Values'), tip: t('Choose values that should be treated as null. Warning: Hive database supports only a single value'), name: \"null_values\", children:\n                _jsx(Select, { mode: \"multiple\", options: nullValuesOptions, allowClear: true, allowNewOptions: true }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('skip_initial_space', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { name: \"skip_initial_space\", children:\n                _jsx(SwitchContainer, { label: t('Skip spaces after delimiter'), dataTest: \"skipInitialSpace\" }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('skip_blank_lines', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { name: \"skip_blank_lines\", children:\n                _jsx(SwitchContainer, { label: t('Skip blank lines rather than interpreting them as Not A Number values'), dataTest: \"skipBlankLines\" }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('day_first', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { name: \"day_first\", children:\n                _jsx(SwitchContainer, { label: t('DD/MM format dates, international and European format'), dataTest: \"dayFirst\" }) }\n              ) }\n            ) }\n          )] }, \"2\"\n        ),\n        _jsxs(Collapse.Panel, { header: _jsxs(\"div\", { children: [\n            _jsx(\"h4\", { children: t('Columns') }),\n            _jsx(\"p\", { className: \"helper\", children:\n              t('Adjust column settings such as specifying the columns to read, how duplicates are handled, column data types, and more.') }\n            )] }\n          ), children: [\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { label: t('Columns to read'), name: \"columns_read\", children:\n                _jsx(Select, { ariaLabel: t('Choose columns to read'), mode: \"multiple\", options: columnsToOptions(), allowClear: true, allowNewOptions: true, placeholder: t('List of the column names that should be read') }) }\n              ) }\n            ) }\n          ),\n          isFieldATypeSpecificField('column_data_types', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('Column data types'), tip: t('A dictionary with column names and their data types if you need to change the defaults. Example: {\"user_id\":\"int\"}. Check Python\\'s Pandas library for supported data types.'), name: \"column_data_types\", children:\n                _jsx(Input, { \"aria-label\": t('Column data types'), type: \"text\" }) }\n              ) }\n            ) }\n          ),\n          _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItem, { name: \"dataframe_index\", children:\n                _jsx(SwitchContainer, { label: t('Create dataframe index'), dataTest: \"dataFrameIndex\", onChange: setCurrentDataframeIndex }) }\n              ) }\n            ) }\n          ),\n          currentDataframeIndex &&\n          isFieldATypeSpecificField('index_column', type) && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('Index column'), tip: t('Column to use as the index of the dataframe. If None is given, Index label is used.'), name: \"index_column\", children:\n                _jsx(Select, { ariaLabel: t('Choose index column'), options: columns.map((column) => ({\n                    value: column,\n                    label: column\n                  })), allowClear: true, allowNewOptions: true }) }\n              ) }\n            ) }\n          ),\n          currentDataframeIndex && _jsx(Row, { children:\n            _jsx(Col, { span: 24, children:\n              _jsx(StyledFormItemWithTip, { label: t('Index label'), tip: t(\"Label for the index column. Don't use an existing column name.\"), name: \"index_label\", children:\n                _jsx(Input, { \"aria-label\": t('Index label'), type: \"text\" }) }\n              ) }\n            ) }\n          )] }, \"3\"\n        ),\n        isFieldATypeSpecificField('header_row', type) &&\n        isFieldATypeSpecificField('rows_to_read', type) &&\n        isFieldATypeSpecificField('skip_rows', type) && _jsx(Collapse.Panel, { header: _jsxs(\"div\", { children: [\n            _jsx(\"h4\", { children: t('Rows') }),\n            _jsx(\"p\", { className: \"helper\", children:\n              t('Set header rows and the number of rows to read or skip.') }\n            )] }\n          ), children:\n          _jsxs(Row, { children: [\n            _jsx(Col, { span: 8, children:\n              _jsx(StyledFormItemWithTip, { label: t('Header row'), tip: t('Row containing the headers to use as column names (0 is first line of data).'), name: \"header_row\", rules: [\n                { required: true, message: 'Header row is required' }], children:\n\n                _jsx(InputNumber, { \"aria-label\": t('Header row'), type: \"text\", min: 0 }) }\n              ) }\n            ),\n            _jsx(Col, { span: 8, children:\n              _jsx(StyledFormItemWithTip, { label: t('Rows to read'), tip: t('Number of rows of file to read. Leave empty (default) to read all rows'), name: \"rows_to_read\", children:\n                _jsx(InputNumber, { \"aria-label\": t('Rows to read'), min: 1 }) }\n              ) }\n            ),\n            _jsx(Col, { span: 8, children:\n              _jsx(StyledFormItemWithTip, { label: t('Skip rows'), tip: t('Number of rows to skip at start of file.'), name: \"skip_rows\", rules: [\n                { required: true, message: 'Skip rows is required' }], children:\n\n                _jsx(InputNumber, { \"aria-label\": t('Skip rows'), min: 0 }) }\n              ) }\n            )] }\n          ) }, \"4\"\n        )] }\n      ) }\n    ) }\n  );\n};\nexport default withToasts(UploadDataModal);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}