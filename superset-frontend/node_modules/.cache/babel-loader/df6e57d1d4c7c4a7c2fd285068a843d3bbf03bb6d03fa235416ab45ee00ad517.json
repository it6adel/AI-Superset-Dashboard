{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { memo, Fragment, useEffect, useCallback, useMemo, useRef, useState } from 'react';\nimport { css, t, isNativeFilterWithDataMask } from '@superset-ui/core';\nimport { createHtmlPortalNode, InPortal, OutPortal } from 'react-reverse-portal';\nimport { useSelector } from 'react-redux';\nimport { useDashboardHasTabs, useSelectFiltersInScope } from 'src/dashboard/components/nativeFilters/state';\nimport { FilterBarOrientation } from 'src/dashboard/types';\nimport DropdownContainer from 'src/components/DropdownContainer';\nimport Icons from 'src/components/Icons';\nimport { useChartIds } from 'src/dashboard/util/charts/useChartIds';\nimport { useChartLayoutItems } from 'src/dashboard/util/useChartLayoutItems';\nimport { FiltersOutOfScopeCollapsible } from '../FiltersOutOfScopeCollapsible';\nimport { useFilterControlFactory } from '../useFilterControlFactory';\nimport { FiltersDropdownContent } from '../FiltersDropdownContent';\nimport crossFiltersSelector from '../CrossFilters/selectors';\nimport CrossFilter from '../CrossFilters/CrossFilter';\nimport { useFilterOutlined } from '../useFilterOutlined';\nimport { useChartsVerboseMaps } from '../utils';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst FilterControls = ({ dataMaskSelected, onFilterSelectionChange }) => {\n  const filterBarOrientation = useSelector(({ dashboardInfo }) => dashboardInfo.filterBarOrientation);\n  const { outlinedFilterId, lastUpdated } = useFilterOutlined();\n  const [overflowedIds, setOverflowedIds] = useState([]);\n  const popoverRef = useRef(null);\n  const dataMask = useSelector((state) => state.dataMask);\n  const chartIds = useChartIds();\n  const chartLayoutItems = useChartLayoutItems();\n  const verboseMaps = useChartsVerboseMaps();\n  const selectedCrossFilters = useMemo(() => crossFiltersSelector({\n    dataMask,\n    chartIds,\n    chartLayoutItems,\n    verboseMaps\n  }), [chartIds, chartLayoutItems, dataMask, verboseMaps]);\n  const { filterControlFactory, filtersWithValues } = useFilterControlFactory(dataMaskSelected, onFilterSelectionChange);\n  const portalNodes = useMemo(() => {\n    const nodes = new Array(filtersWithValues.length);\n    for (let i = 0; i < filtersWithValues.length; i += 1) {\n      nodes[i] = createHtmlPortalNode();\n    }\n    return nodes;\n  }, [filtersWithValues.length]);\n  const filterIds = new Set(filtersWithValues.map((item) => item.id));\n  const [filtersInScope, filtersOutOfScope] = useSelectFiltersInScope(filtersWithValues);\n  const hasRequiredFirst = useMemo(() => filtersWithValues.some((filter) => filter.requiredFirst), [filtersWithValues]);\n  const dashboardHasTabs = useDashboardHasTabs();\n  const showCollapsePanel = dashboardHasTabs && filtersWithValues.length > 0;\n  const renderer = useCallback(({ id }, index) => {\n    const filterIndex = filtersWithValues.findIndex((f) => f.id === id);\n    const key = index != null ? index : id;\n    return (\n      // Empty text node is to ensure there's always an element preceding\n      // the OutPortal, otherwise react-reverse-portal crashes\n      _jsxs(Fragment, { children: [\n        '' /* eslint-disable-line react/jsx-curly-brace-presence */,\n        _jsx(OutPortal, { node: portalNodes[filterIndex], inView: true })] }, key\n      ));\n  }, [filtersWithValues, portalNodes]);\n  const renderVerticalContent = useCallback(() => _jsxs(_Fragment, { children: [\n    filtersInScope.map(renderer),\n    showCollapsePanel && _jsx(FiltersOutOfScopeCollapsible, { filtersOutOfScope: filtersOutOfScope, forceRender: hasRequiredFirst, hasTopMargin: filtersInScope.length > 0, renderer: renderer })] }\n  ), [\n  filtersInScope,\n  renderer,\n  showCollapsePanel,\n  filtersOutOfScope,\n  hasRequiredFirst]\n  );\n  const overflowedFiltersInScope = useMemo(() => filtersInScope.filter(({ id }) => overflowedIds == null ? void 0 : overflowedIds.includes(id)), [filtersInScope, overflowedIds]);\n  const overflowedCrossFilters = useMemo(() => selectedCrossFilters.filter(({ emitterId, name }) => overflowedIds == null ? void 0 : overflowedIds.includes(`${name}${emitterId}`)), [overflowedIds, selectedCrossFilters]);\n  const activeOverflowedFiltersInScope = useMemo(() => {\n    const activeOverflowedFilters = overflowedFiltersInScope.filter((filter) => isNativeFilterWithDataMask(filter));\n    return [...activeOverflowedFilters, ...overflowedCrossFilters];\n  }, [overflowedCrossFilters, overflowedFiltersInScope]);\n  const rendererCrossFilter = useCallback((crossFilter, orientation, last) => _jsx(CrossFilter, { filter: crossFilter, orientation: orientation, last: filtersInScope.length > 0 &&\n    `${last.name}${last.emitterId}` ===\n    `${crossFilter.name}${crossFilter.emitterId}` }), [filtersInScope.length]);\n  const items = useMemo(() => {\n    const crossFilters = selectedCrossFilters.map((c) => ({\n      // a combination of filter name and chart id to account\n      // for multiple cross filters from the same chart in the future\n      id: `${c.name}${c.emitterId}`,\n      element: rendererCrossFilter(c, FilterBarOrientation.Horizontal, selectedCrossFilters.at(-1))\n    }));\n    const nativeFiltersInScope = filtersInScope.map((filter, index) => ({\n      id: filter.id,\n      element: _jsx(\"div\", { className: \"filter-item-wrapper\", css: css`\n            flex-shrink: 0;\n          `, children:\n        renderer(filter, index) }\n      )\n    }));\n    return [...crossFilters, ...nativeFiltersInScope];\n  }, [filtersInScope, renderer, rendererCrossFilter, selectedCrossFilters]);\n  const renderHorizontalContent = useCallback(() => _jsx(\"div\", { css: (theme) => css`\n          padding: 0 ${theme.gridUnit * 4}px;\n          min-width: 0;\n          flex: 1;\n        `, children:\n    _jsx(DropdownContainer, { items: items, dropdownTriggerIcon: _jsx(Icons.FilterOutlined, { css: css`\n                && {\n                  margin-right: -4px;\n                  display: flex;\n                }\n              ` }), dropdownTriggerText: t('More filters'), dropdownTriggerCount: activeOverflowedFiltersInScope.length, dropdownTriggerTooltip: activeOverflowedFiltersInScope.length === 0 ?\n      t('No applied filters') :\n      t('Applied filters: %s', activeOverflowedFiltersInScope.\n      map((filter) => filter.name).\n      join(', ')), dropdownContent: overflowedFiltersInScope.length ||\n      overflowedCrossFilters.length ||\n      filtersOutOfScope.length && showCollapsePanel ?\n      () => _jsx(FiltersDropdownContent, { overflowedCrossFilters: overflowedCrossFilters, filtersInScope: overflowedFiltersInScope, filtersOutOfScope: filtersOutOfScope, renderer: renderer, rendererCrossFilter: rendererCrossFilter, showCollapsePanel: showCollapsePanel, forceRenderOutOfScope: hasRequiredFirst }) :\n      undefined, forceRender: hasRequiredFirst, ref: popoverRef, onOverflowingStateChange: ({ overflowed: nextOverflowedIds }) => {\n        if (nextOverflowedIds.length !== overflowedIds.length ||\n        overflowedIds.reduce((a, b, i) => a || b !== nextOverflowedIds[i], false)) {\n          setOverflowedIds(nextOverflowedIds);\n        }\n      } }) }\n  ), [\n  items,\n  activeOverflowedFiltersInScope,\n  overflowedFiltersInScope,\n  overflowedCrossFilters,\n  filtersOutOfScope,\n  showCollapsePanel,\n  renderer,\n  rendererCrossFilter,\n  hasRequiredFirst,\n  overflowedIds]\n  );\n  const overflowedByIndex = useMemo(() => {\n    const filtersOutOfScopeIds = new Set(filtersOutOfScope.map(({ id }) => id));\n    const overflowedFiltersInScopeIds = new Set(overflowedFiltersInScope.map(({ id }) => id));\n    return filtersWithValues.map((filter) => filtersOutOfScopeIds.has(filter.id) ||\n    overflowedFiltersInScopeIds.has(filter.id));\n  }, [filtersOutOfScope, filtersWithValues, overflowedFiltersInScope]);\n  useEffect(() => {\n    if (outlinedFilterId && overflowedIds.includes(outlinedFilterId)) {var _popoverRef$current;\n      popoverRef == null ? void 0 : (_popoverRef$current = popoverRef.current) == null ? void 0 : _popoverRef$current.open();\n    }\n  }, [outlinedFilterId, lastUpdated, popoverRef, overflowedIds]);\n  return _jsxs(_Fragment, { children: [\n    portalNodes.\n    filter((node, index) => filterIds.has(filtersWithValues[index].id)).\n    map((node, index) => _jsx(InPortal, { node: node, children:\n      filterControlFactory(index, filterBarOrientation, overflowedByIndex[index]) }, filtersWithValues[index].id\n    )),\n    filterBarOrientation === FilterBarOrientation.Vertical &&\n    renderVerticalContent(),\n    filterBarOrientation === FilterBarOrientation.Horizontal &&\n    renderHorizontalContent()] }\n  );\n};\nexport default /*#__PURE__*/memo(FilterControls);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}