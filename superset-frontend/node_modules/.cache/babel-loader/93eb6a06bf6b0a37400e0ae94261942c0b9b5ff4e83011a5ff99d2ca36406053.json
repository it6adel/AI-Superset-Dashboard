{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\n\nimport { SupersetClient, getClientErrorObject, ensureIsArray } from '@superset-ui/core';\nexport const SEPARATOR = ' : ';\nexport const buildTimeRangeString = (since, until) => `${since}${SEPARATOR}${until}`;\nconst formatDateEndpoint = (dttm, isStart) => dttm.replace('T00:00:00', '') || (isStart ? '-∞' : '∞');\nexport const formatTimeRange = (timeRange, columnPlaceholder = 'col') => {\n  const splitDateRange = timeRange.split(SEPARATOR);\n  if (splitDateRange.length === 1)\n  return timeRange;\n  return `${formatDateEndpoint(splitDateRange[0], true)} ≤ ${columnPlaceholder} < ${formatDateEndpoint(splitDateRange[1])}`;\n};\nexport const formatTimeRangeComparison = (initialTimeRange, shiftedTimeRange, columnPlaceholder = 'col') => {\n  const splitInitialDateRange = initialTimeRange.split(SEPARATOR);\n  const splitShiftedDateRange = shiftedTimeRange.split(SEPARATOR);\n  return `${columnPlaceholder}: ${formatDateEndpoint(splitInitialDateRange[0], true)} to ${formatDateEndpoint(splitInitialDateRange[1])} vs\n  ${formatDateEndpoint(splitShiftedDateRange[0], true)} to ${formatDateEndpoint(splitShiftedDateRange[1])}`;\n};\nexport const fetchTimeRange = async (timeRange, columnPlaceholder = 'col', shifts) => {\n  let query;\n  let endpoint;\n  if (!_isEmpty(shifts)) {\n    const timeRanges = ensureIsArray(shifts).map((shift) => ({\n      timeRange,\n      shift\n    }));\n    query = rison.encode_uri([{ timeRange }, ...timeRanges]);\n    endpoint = `/api/v1/time_range/?q=${query}`;\n  } else\n  {\n    query = rison.encode_uri(timeRange);\n    endpoint = `/api/v1/time_range/?q=${query}`;\n  }\n  try {var _response$json3;\n    const response = await SupersetClient.get({ endpoint });\n    if (_isEmpty(shifts)) {var _response$json, _response$json$result, _response$json2, _response$json2$resul;\n      const timeRangeString = buildTimeRangeString((response == null ? void 0 : (_response$json = response.json) == null ? void 0 : (_response$json$result = _response$json.result[0]) == null ? void 0 : _response$json$result.since) || '', (response == null ? void 0 : (_response$json2 = response.json) == null ? void 0 : (_response$json2$resul = _response$json2.result[0]) == null ? void 0 : _response$json2$resul.until) || '');\n      return {\n        value: formatTimeRange(timeRangeString, columnPlaceholder)\n      };\n    }\n    const timeRanges = response == null ? void 0 : (_response$json3 = response.json) == null ? void 0 : _response$json3.result.map((result) => buildTimeRangeString(result.since, result.until));\n    return {\n      value: timeRanges.\n      slice(1).\n      map((timeRange) => formatTimeRangeComparison(timeRanges[0], timeRange, columnPlaceholder))\n    };\n  }\n  catch (response) {\n    const clientError = await getClientErrorObject(response);\n    return {\n      error: clientError.message || clientError.error || response.statusText\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}