{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  SupersetClient,\n  getTimeFormatter,\n  TimeFormats,\n  ensureIsArray } from\n'@superset-ui/core';\n\n// ATTENTION: If you change any constants, make sure to also change constants.py\n\nexport const EMPTY_STRING = '<empty string>';\nexport const NULL_STRING = '<NULL>';\nexport const TRUE_STRING = 'TRUE';\nexport const FALSE_STRING = 'FALSE';\n\n// dayjs time format strings\nexport const SHORT_DATE = 'MMM D, YYYY';\nexport const SHORT_TIME = 'h:m a';\n\nconst DATETIME_FORMATTER = getTimeFormatter(TimeFormats.DATABASE_DATETIME);\n\nexport function storeQuery(query) {\n  return SupersetClient.post({\n    endpoint: '/kv/store/',\n    postPayload: { data: query }\n  }).then((response) => {\n    const baseUrl = window.location.origin + window.location.pathname;\n    const url = `${baseUrl}?id=${response.json.id}`;\n    return url;\n  });\n}\n\nexport function optionLabel(opt) {\n  if (opt === null) {\n    return NULL_STRING;\n  }\n  if (opt === '') {\n    return EMPTY_STRING;\n  }\n  if (opt === true) {\n    return TRUE_STRING;\n  }\n  if (opt === false) {\n    return FALSE_STRING;\n  }\n  if (typeof opt !== 'string' && opt.toString) {\n    return opt.toString();\n  }\n  return opt;\n}\n\nexport function optionValue(opt) {\n  if (opt === null) {\n    return NULL_STRING;\n  }\n  return opt;\n}\n\nexport function optionFromValue(opt) {\n  // From a list of options, handles special values & labels\n  return { value: optionValue(opt), label: optionLabel(opt) };\n}\n\nfunction getColumnName(column) {\n  return column.name || column;\n}\n\nexport function prepareCopyToClipboardTabularData(data, columns) {\n  let result = columns.length ?\n  `${columns.map(getColumnName).join('\\t')}\\n` :\n  '';\n  for (let i = 0; i < data.length; i += 1) {\n    const row = {};\n    for (let j = 0; j < columns.length; j += 1) {\n      // JavaScript does not maintain the order of a mixed set of keys (i.e integers and strings)\n      // the below function orders the keys based on the column names.\n      const key = getColumnName(columns[j]);\n      if (key in data[i]) {\n        row[j] = data[i][key];\n      } else {\n        row[j] = data[i][parseFloat(key)];\n      }\n    }\n    result += `${Object.values(row).join('\\t')}\\n`;\n  }\n  return result;\n}\n\nexport function applyFormattingToTabularData(data, timeFormattedColumns) {\n  if (\n  !data ||\n  data.length === 0 ||\n  ensureIsArray(timeFormattedColumns).length === 0)\n  {\n    return data;\n  }\n\n  return data.map((row) => ({\n    ...row,\n    /* eslint-disable no-underscore-dangle */\n    ...timeFormattedColumns.reduce((acc, colName) => {\n      if (row[colName] !== null && row[colName] !== undefined) {\n        acc[colName] = DATETIME_FORMATTER(row[colName]);\n      }\n      return acc;\n    }, {})\n  }));\n}\n\nexport const noOp = () => undefined;\n\n// Detects the user's OS through the browser\nexport const detectOS = () => {\n  const { appVersion } = navigator;\n\n  // Leveraging this condition because of stackOverflow\n  // https://stackoverflow.com/questions/11219582/how-to-detect-my-browser-version-and-operating-system-using-javascript\n  if (appVersion.includes('Win')) return 'Windows';\n  if (appVersion.includes('Mac')) return 'MacOS';\n  if (appVersion.includes('X11')) return 'UNIX';\n  if (appVersion.includes('Linux')) return 'Linux';\n\n  return 'Unknown OS';\n};\n\nexport const isSafari = () => {\n  const { userAgent } = navigator;\n\n  return userAgent && /^((?!chrome|android).)*safari/i.test(userAgent);\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}