{"ast":null,"code":"import { getChartKey } from 'src/explore/exploreUtils';\nimport { getControlsState } from 'src/explore/store';\nimport { ensureIsArray, getCategoricalSchemeRegistry, getColumnLabel, getSequentialSchemeRegistry, NO_TIME_RANGE, VizType } from '@superset-ui/core';\nimport { getFormDataFromControls, applyMapStateToPropsToControl } from 'src/explore/controlUtils';\nimport { getDatasourceUid } from 'src/utils/getDatasourceUid';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { URL_PARAMS } from 'src/constants';\nimport { findPermission } from 'src/utils/findPermission';\nvar ColorSchemeType;\n(function (ColorSchemeType) {\n  ColorSchemeType[\"CATEGORICAL\"] = \"CATEGORICAL\";\n  ColorSchemeType[\"SEQUENTIAL\"] = \"SEQUENTIAL\";\n})(ColorSchemeType || (ColorSchemeType = {}));\nexport const HYDRATE_EXPLORE = 'HYDRATE_EXPLORE';\nexport const hydrateExplore = ({ form_data, slice, dataset, metadata, saveAction = null }) => (dispatch, getState) => {var _sliceEntities$slices, _initialFormData$grou;\n  const { user, datasources, charts, sliceEntities, common, explore } = getState();\n  const sliceId = getUrlParam(URL_PARAMS.sliceId);\n  const dashboardId = getUrlParam(URL_PARAMS.dashboardId);\n  const fallbackSlice = sliceId ? sliceEntities == null ? void 0 : (_sliceEntities$slices = sliceEntities.slices) == null ? void 0 : _sliceEntities$slices[sliceId] : null;\n  const initialSlice = slice != null ? slice : fallbackSlice;\n  const initialFormData = form_data != null ? form_data : initialSlice == null ? void 0 : initialSlice.form_data;\n  if (!initialFormData.viz_type) {\n    const defaultVizType = (common == null ? void 0 : common.conf.DEFAULT_VIZ_TYPE) || VizType.Table;\n    initialFormData.viz_type =\n    getUrlParam(URL_PARAMS.vizType) || defaultVizType;\n  }\n  if (!initialFormData.time_range) {var _common$conf;\n    initialFormData.time_range =\n    (common == null ? void 0 : (_common$conf = common.conf) == null ? void 0 : _common$conf.DEFAULT_TIME_FILTER) || NO_TIME_RANGE;\n  }\n  if (initialFormData.include_time &&\n  initialFormData.granularity_sqla &&\n  !((_initialFormData$grou = initialFormData.groupby) != null && _initialFormData$grou.some((col) => getColumnLabel(col) ===\n  getColumnLabel(initialFormData.granularity_sqla)))) {\n    initialFormData.groupby = [\n    initialFormData.granularity_sqla,\n    ...ensureIsArray(initialFormData.groupby)];\n\n    initialFormData.granularity_sqla = undefined;\n  }\n  if (dashboardId) {\n    initialFormData.dashboardId = dashboardId;\n  }\n  const initialDatasource = dataset;\n  const initialExploreState = {\n    form_data: initialFormData,\n    slice: initialSlice,\n    datasource: initialDatasource\n  };\n  const initialControls = getControlsState(initialExploreState, initialFormData);\n  const colorSchemeKey = initialControls.color_scheme && 'color_scheme';\n  const linearColorSchemeKey = initialControls.linear_color_scheme && 'linear_color_scheme';\n  // if the selected color scheme does not exist anymore\n  // fallbacks and selects the available default one\n  const verifyColorScheme = (type) => {\n    const schemes = type === 'CATEGORICAL' ?\n    getCategoricalSchemeRegistry() :\n    getSequentialSchemeRegistry();\n    const key = type === 'CATEGORICAL' ? colorSchemeKey : linearColorSchemeKey;\n    const registryDefaultScheme = schemes.defaultKey;\n    const defaultScheme = type === 'CATEGORICAL' ? 'supersetColors' : 'superset_seq_1';\n    const currentScheme = initialFormData[key];\n    const colorSchemeExists = !!schemes.get(currentScheme, true);\n    if (currentScheme && !colorSchemeExists) {\n      initialControls[key].value = registryDefaultScheme || defaultScheme;\n    }\n  };\n  if (colorSchemeKey)\n  verifyColorScheme(ColorSchemeType.CATEGORICAL);\n  if (linearColorSchemeKey)\n  verifyColorScheme(ColorSchemeType.SEQUENTIAL);\n  const exploreState = {\n    // note this will add `form_data` to state,\n    // which will be manipulable by future reducers.\n    can_add: findPermission('can_write', 'Chart', user == null ? void 0 : user.roles),\n    can_download: findPermission('can_csv', 'Superset', user == null ? void 0 : user.roles),\n    can_overwrite: ensureIsArray(slice == null ? void 0 : slice.owners).includes(user == null ? void 0 : user.userId),\n    isDatasourceMetaLoading: false,\n    isStarred: false,\n    triggerRender: false,\n    // duplicate datasource in exploreState - it's needed by getControlsState\n    datasource: initialDatasource,\n    // Initial control state will skip `control.mapStateToProps`\n    // because `bootstrapData.controls` is undefined.\n    controls: initialControls,\n    form_data: initialFormData,\n    slice: initialSlice,\n    controlsTransferred: explore.controlsTransferred,\n    standalone: getUrlParam(URL_PARAMS.standalone),\n    force: getUrlParam(URL_PARAMS.force),\n    metadata,\n    saveAction,\n    common\n  };\n  // apply initial mapStateToProps for all controls, must execute AFTER\n  // bootstrapState has initialized `controls`. Order of execution is not\n  // guaranteed, so controls shouldn't rely on each other's mapped state.\n  Object.entries(exploreState.controls).forEach(([key, controlState]) => {\n    exploreState.controls[key] = applyMapStateToPropsToControl(controlState, exploreState);\n  });\n  const sliceFormData = initialSlice ?\n  getFormDataFromControls(initialControls) :\n  null;\n  const chartKey = getChartKey(initialExploreState);\n  const chart = {\n    id: chartKey,\n    chartAlert: null,\n    chartStatus: null,\n    chartStackTrace: null,\n    chartUpdateEndTime: null,\n    chartUpdateStartTime: 0,\n    latestQueryFormData: getFormDataFromControls(exploreState.controls),\n    sliceFormData,\n    queryController: null,\n    queriesResponse: null,\n    triggerQuery: false,\n    lastRendered: 0\n  };\n  return dispatch({\n    type: HYDRATE_EXPLORE,\n    data: {\n      charts: {\n        ...charts,\n        [chartKey]: chart\n      },\n      datasources: {\n        ...datasources,\n        [getDatasourceUid(initialDatasource)]: initialDatasource\n      },\n      saveModal: {\n        dashboards: [],\n        saveModalAlert: null,\n        isVisible: false\n      },\n      explore: exploreState\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}