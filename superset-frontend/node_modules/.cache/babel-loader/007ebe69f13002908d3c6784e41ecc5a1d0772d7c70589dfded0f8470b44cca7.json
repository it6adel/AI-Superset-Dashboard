{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with work for additional information\n * regarding copyright ownership.  The ASF licenses file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { ensureIsArray, GenericDataType, isAdhocMetricSimple, isSavedMetric, t, tn } from '@superset-ui/core';\nimport AdhocMetric from 'src/explore/components/controls/MetricControl/AdhocMetric';\nimport AdhocMetricPopoverTrigger from 'src/explore/components/controls/MetricControl/AdhocMetricPopoverTrigger';\nimport MetricDefinitionValue from 'src/explore/components/controls/MetricControl/MetricDefinitionValue';\nimport { isDatasourcePanelDndItem } from 'src/explore/components/DatasourcePanel/types';\nimport { DndItemType } from 'src/explore/components/DndItemType';\nimport DndSelectLabel from 'src/explore/components/controls/DndColumnSelectControl/DndSelectLabel';\nimport { AGGREGATES } from 'src/explore/constants';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst EMPTY_OBJECT = {};\nconst DND_ACCEPTED_TYPES = [DndItemType.Column, DndItemType.Metric];\nconst isDictionaryForAdhocMetric = (value) => value &&\n!(value instanceof AdhocMetric) &&\ntypeof value !== 'string' &&\nvalue.expressionType;\nconst coerceMetrics = (addedMetrics, savedMetrics, columns) => {\n  if (!addedMetrics) {\n    return [];\n  }\n  const metricsCompatibleWithDataset = ensureIsArray(addedMetrics).filter((metric) => {\n    if (isAdhocMetricSimple(metric)) {\n      return columns.some((column) => column.column_name === metric.column.column_name);\n    }\n    return true;\n  });\n  return metricsCompatibleWithDataset.map((metric) => {\n    if (isSavedMetric(metric) &&\n    !savedMetrics.some((savedMetric) => savedMetric.metric_name === metric)) {\n      return {\n        metric_name: metric,\n        error_text: t('This metric might be incompatible with current dataset')\n      };\n    }\n    if (!isDictionaryForAdhocMetric(metric)) {\n      return metric;\n    }\n    if (isAdhocMetricSimple(metric)) {\n      const column = columns.find((col) => col.column_name === metric.column.column_name);\n      if (column) {\n        return new AdhocMetric({ ...metric, column });\n      }\n    }\n    return new AdhocMetric(metric);\n  });\n};\nconst getOptionsForSavedMetrics = (savedMetrics, currentMetricValues, currentMetric) => {var _savedMetrics$filter;return (_savedMetrics$filter = savedMetrics == null ? void 0 : savedMetrics.filter((savedMetric) => {var _savedMetric$metric_n;return Array.isArray(currentMetricValues) ?\n    !currentMetricValues.includes((_savedMetric$metric_n = savedMetric.metric_name) != null ? _savedMetric$metric_n : '') ||\n    savedMetric.metric_name === currentMetric :\n    savedMetric;})) != null ? _savedMetrics$filter : [];};\nconst DndMetricSelect = (props) => {\n  const { onChange, multi, datasource, savedMetrics } = props;\n  const extra = useMemo(() => {\n    let extra = {};\n    if (datasource != null && datasource.extra) {\n      try {\n        extra = JSON.parse(datasource.extra);\n      }\n      catch {} // eslint-disable-line no-empty\n    }\n    return extra;\n  }, [datasource == null ? void 0 : datasource.extra]);\n  const savedMetricSet = useMemo(() => new Set(savedMetrics.map(({ metric_name }) => metric_name)), [savedMetrics]);\n  const handleChange = useCallback((opts) => {\n    // if clear out options\n    if (opts === null) {\n      onChange(null);\n      return;\n    }\n    const transformedOpts = ensureIsArray(opts);\n    const optionValues = transformedOpts.\n    map((option) => {\n      // pre-defined metric\n      if (option.metric_name) {\n        return option.metric_name;\n      }\n      return option;\n    }).\n    filter((option) => option);\n    onChange(multi ? optionValues : optionValues[0]);\n  }, [multi, onChange]);\n  const [value, setValue] = useState(coerceMetrics(props.value, props.savedMetrics, props.columns));\n  const [droppedItem, setDroppedItem] = useState({});\n  const [newMetricPopoverVisible, setNewMetricPopoverVisible] = useState(false);\n  useEffect(() => {\n    setValue(coerceMetrics(props.value, props.savedMetrics, props.columns));\n  }, [\n  JSON.stringify(props.value),\n  JSON.stringify(props.savedMetrics),\n  JSON.stringify(props.columns)]\n  );\n  const canDrop = useCallback((item) => {\n    if (extra.disallow_adhoc_metrics && (\n    item.type !== DndItemType.Metric ||\n    !savedMetricSet.has(item.value.metric_name))) {\n      return false;\n    }\n    const isMetricAlreadyInValues = item.type === 'metric' ? value.includes(item.value.metric_name) : false;\n    return !isMetricAlreadyInValues;\n  }, [value, extra, savedMetricSet]);\n  const onNewMetric = useCallback((newMetric) => {\n    const newValue = props.multi ? [...value, newMetric] : [newMetric];\n    setValue(newValue);\n    handleChange(newValue);\n  }, [handleChange, props.multi, value]);\n  const onMetricEdit = useCallback((changedMetric, oldMetric) => {\n    if (oldMetric instanceof AdhocMetric && oldMetric.equals(changedMetric)) {\n      return;\n    }\n    const newValue = value.map((value) => {\n      if (\n      // compare saved metrics\n      'metric_name' in oldMetric && value === oldMetric.metric_name ||\n      // compare adhoc metrics\n      typeof value.optionName !== 'undefined' ?\n      value.optionName ===\n      oldMetric.optionName :\n      false) {\n        return changedMetric;\n      }\n      return value;\n    });\n    setValue(newValue);\n    handleChange(newValue);\n  }, [handleChange, value]);\n  const onRemoveMetric = useCallback((index) => {\n    if (!Array.isArray(value)) {\n      return;\n    }\n    const valuesCopy = [...value];\n    valuesCopy.splice(index, 1);\n    setValue(valuesCopy);\n    handleChange(valuesCopy);\n  }, [handleChange, value]);\n  const moveLabel = useCallback((dragIndex, hoverIndex) => {\n    const newValues = [...value];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    setValue(newValues);\n  }, [value]);\n  const newSavedMetricOptions = useMemo(() => getOptionsForSavedMetrics(props.savedMetrics, props.value), [props.savedMetrics, props.value]);\n  const getSavedMetricOptionsForMetric = useCallback((index) => {var _props$value;return getOptionsForSavedMetrics(props.savedMetrics, props.value, (_props$value = props.value) == null ? void 0 : _props$value[index]);}, [props.savedMetrics, props.value]);\n  const handleDropLabel = useCallback(() => onChange(multi ? value : value[0]), [multi, onChange, value]);\n  const valueRenderer = useCallback((option, index) => _jsx(MetricDefinitionValue, { index: index, option: option, onMetricEdit: onMetricEdit, onRemoveMetric: onRemoveMetric, columns: props.columns, savedMetrics: props.savedMetrics, savedMetricsOptions: getSavedMetricOptionsForMetric(index), datasource: props.datasource, onMoveLabel: moveLabel, onDropLabel: handleDropLabel, type: `${DndItemType.AdhocMetricOption}_${props.name}_${props.label}`, multi: multi, datasourceWarningMessage: option instanceof AdhocMetric && option.datasourceWarning ?\n    t('This metric might be incompatible with current dataset') :\n    undefined }, index), [\n  getSavedMetricOptionsForMetric,\n  handleDropLabel,\n  moveLabel,\n  multi,\n  onMetricEdit,\n  onRemoveMetric,\n  props.columns,\n  props.datasource,\n  props.label,\n  props.name,\n  props.savedMetrics]\n  );\n  const valuesRenderer = useCallback(() => value.map((value, index) => valueRenderer(value, index)), [value, valueRenderer]);\n  const togglePopover = useCallback((visible) => {\n    setNewMetricPopoverVisible(visible);\n  }, []);\n  const closePopover = useCallback(() => {\n    togglePopover(false);\n  }, [togglePopover]);\n  const handleDrop = useCallback((item) => {\n    if (item.type === DndItemType.Metric) {\n      onNewMetric(item.value);\n    }\n    if (item.type === DndItemType.Column) {\n      setDroppedItem(item);\n      togglePopover(true);\n    }\n  }, [onNewMetric, togglePopover]);\n  const handleClickGhostButton = useCallback(() => {\n    setDroppedItem({});\n    togglePopover(true);\n  }, [togglePopover]);\n  const adhocMetric = useMemo(() => {\n    if (isDatasourcePanelDndItem(droppedItem) &&\n    droppedItem.type === DndItemType.Column) {\n      const itemValue = droppedItem.value;\n      const config = {\n        column: itemValue\n      };\n      if (itemValue.type_generic === GenericDataType.Numeric) {\n        config.aggregate = AGGREGATES.SUM;\n      } else\n      if (itemValue.type_generic === GenericDataType.String ||\n      itemValue.type_generic === GenericDataType.Boolean ||\n      itemValue.type_generic === GenericDataType.Temporal) {\n        config.aggregate = AGGREGATES.COUNT_DISTINCT;\n      }\n      return new AdhocMetric(config);\n    }\n    return new AdhocMetric({});\n  }, [droppedItem]);\n  const ghostButtonText = tn('Drop a column/metric here or click', 'Drop columns/metrics here or click', multi ? 2 : 1);\n  return _jsxs(\"div\", { className: \"metrics-select\", children: [\n    _jsx(DndSelectLabel, { onDrop: handleDrop, canDrop: canDrop, valuesRenderer: valuesRenderer, accept: DND_ACCEPTED_TYPES, ghostButtonText: ghostButtonText, displayGhostButton: multi || value.length === 0, onClickGhostButton: handleClickGhostButton, ...props }),\n    _jsx(AdhocMetricPopoverTrigger, { adhocMetric: adhocMetric, onMetricEdit: onNewMetric, columns: props.columns, savedMetricsOptions: newSavedMetricOptions, savedMetric: EMPTY_OBJECT, datasource: props.datasource, isControlledComponent: true, visible: newMetricPopoverVisible, togglePopover: togglePopover, closePopover: closePopover, isNew: true, children:\n      _jsx(\"div\", {}) }\n    )] }\n  );\n};\nexport { DndMetricSelect };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}