{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { Component } from 'react';\nimport { t, safeHtmlSpan } from '@superset-ui/core';\nimport PropTypes from 'prop-types';\nimport { PivotData, flatKey } from './utilities';\nimport { Styles } from './Styles';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nconst parseLabel = (value) => {\n  if (typeof value === 'string') {\n    if (value === 'metric') return t('metric');\n    return value;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return String(value);\n};\n\nfunction displayHeaderCell(\nneedToggle,\nArrowIcon,\nonArrowClick,\nvalue,\nnamesMapping,\nallowRenderHtml)\n{\n  const name = namesMapping[value] || value;\n  const parsedLabel = parseLabel(name);\n  const labelContent =\n  allowRenderHtml && typeof parsedLabel === 'string' ?\n  safeHtmlSpan(parsedLabel) :\n  parsedLabel;\n  return needToggle ?\n  _jsxs(\"span\", { className: \"toggle-wrapper\", children: [\n    _jsx(\"span\", {\n      role: \"button\",\n      tabIndex: \"0\",\n      className: \"toggle\",\n      onClick: onArrowClick, children:\n\n      ArrowIcon }\n    ),\n    _jsx(\"span\", { className: \"toggle-val\", children: labelContent })] }\n  ) :\n\n  labelContent;\n\n}\n\nexport class TableRenderer extends Component {\n  constructor(props) {\n    super(props);\n\n    // We need state to record which entries are collapsed and which aren't.\n    // This is an object with flat-keys indicating if the corresponding rows\n    // should be collapsed.\n    this.state = { collapsedRows: {}, collapsedCols: {} };\n\n    this.clickHeaderHandler = this.clickHeaderHandler.bind(this);\n    this.clickHandler = this.clickHandler.bind(this);\n  }\n\n  getBasePivotSettings() {\n    // One-time extraction of pivot settings that we'll use throughout the render.\n\n    const { props } = this;\n    const colAttrs = props.cols;\n    const rowAttrs = props.rows;\n\n    const tableOptions = {\n      rowTotals: true,\n      colTotals: true,\n      ...props.tableOptions\n    };\n    const rowTotals = tableOptions.rowTotals || colAttrs.length === 0;\n    const colTotals = tableOptions.colTotals || rowAttrs.length === 0;\n\n    const namesMapping = props.namesMapping || {};\n    const subtotalOptions = {\n      arrowCollapsed: '\\u25B2',\n      arrowExpanded: '\\u25BC',\n      ...props.subtotalOptions\n    };\n\n    const colSubtotalDisplay = {\n      displayOnTop: false,\n      enabled: tableOptions.colSubTotals,\n      hideOnExpand: false,\n      ...subtotalOptions.colSubtotalDisplay\n    };\n\n    const rowSubtotalDisplay = {\n      displayOnTop: false,\n      enabled: tableOptions.rowSubTotals,\n      hideOnExpand: false,\n      ...subtotalOptions.rowSubtotalDisplay\n    };\n\n    const pivotData = new PivotData(props, {\n      rowEnabled: rowSubtotalDisplay.enabled,\n      colEnabled: colSubtotalDisplay.enabled,\n      rowPartialOnTop: rowSubtotalDisplay.displayOnTop,\n      colPartialOnTop: colSubtotalDisplay.displayOnTop\n    });\n    const rowKeys = pivotData.getRowKeys();\n    const colKeys = pivotData.getColKeys();\n\n    // Also pre-calculate all the callbacks for cells, etc... This is nice to have to\n    // avoid re-calculations of the call-backs on cell expansions, etc...\n    const cellCallbacks = {};\n    const rowTotalCallbacks = {};\n    const colTotalCallbacks = {};\n    let grandTotalCallback = null;\n    if (tableOptions.clickCallback) {\n      rowKeys.forEach((rowKey) => {\n        const flatRowKey = flatKey(rowKey);\n        if (!(flatRowKey in cellCallbacks)) {\n          cellCallbacks[flatRowKey] = {};\n        }\n        colKeys.forEach((colKey) => {\n          cellCallbacks[flatRowKey][flatKey(colKey)] = this.clickHandler(\n            pivotData,\n            rowKey,\n            colKey\n          );\n        });\n      });\n\n      // Add in totals as well.\n      if (rowTotals) {\n        rowKeys.forEach((rowKey) => {\n          rowTotalCallbacks[flatKey(rowKey)] = this.clickHandler(\n            pivotData,\n            rowKey,\n            []\n          );\n        });\n      }\n      if (colTotals) {\n        colKeys.forEach((colKey) => {\n          colTotalCallbacks[flatKey(colKey)] = this.clickHandler(\n            pivotData,\n            [],\n            colKey\n          );\n        });\n      }\n      if (rowTotals && colTotals) {\n        grandTotalCallback = this.clickHandler(pivotData, [], []);\n      }\n    }\n\n    return {\n      pivotData,\n      colAttrs,\n      rowAttrs,\n      colKeys,\n      rowKeys,\n      rowTotals,\n      colTotals,\n      arrowCollapsed: subtotalOptions.arrowCollapsed,\n      arrowExpanded: subtotalOptions.arrowExpanded,\n      colSubtotalDisplay,\n      rowSubtotalDisplay,\n      cellCallbacks,\n      rowTotalCallbacks,\n      colTotalCallbacks,\n      grandTotalCallback,\n      namesMapping,\n      allowRenderHtml: props.allowRenderHtml\n    };\n  }\n\n  clickHandler(pivotData, rowValues, colValues) {\n    const colAttrs = this.props.cols;\n    const rowAttrs = this.props.rows;\n    const value = pivotData.getAggregator(rowValues, colValues).value();\n    const filters = {};\n    const colLimit = Math.min(colAttrs.length, colValues.length);\n    for (let i = 0; i < colLimit; i += 1) {\n      const attr = colAttrs[i];\n      if (colValues[i] !== null) {\n        filters[attr] = colValues[i];\n      }\n    }\n    const rowLimit = Math.min(rowAttrs.length, rowValues.length);\n    for (let i = 0; i < rowLimit; i += 1) {\n      const attr = rowAttrs[i];\n      if (rowValues[i] !== null) {\n        filters[attr] = rowValues[i];\n      }\n    }\n    return (e) =>\n    this.props.tableOptions.clickCallback(e, value, filters, pivotData);\n  }\n\n  clickHeaderHandler(\n  pivotData,\n  values,\n  attrs,\n  attrIdx,\n  callback,\n  isSubtotal = false,\n  isGrandTotal = false)\n  {\n    const filters = {};\n    for (let i = 0; i <= attrIdx; i += 1) {\n      const attr = attrs[i];\n      filters[attr] = values[i];\n    }\n    return (e) =>\n    callback(\n      e,\n      values[attrIdx],\n      filters,\n      pivotData,\n      isSubtotal,\n      isGrandTotal\n    );\n  }\n\n  collapseAttr(rowOrCol, attrIdx, allKeys) {\n    return (e) => {\n      // Collapse an entire attribute.\n      e.stopPropagation();\n      const keyLen = attrIdx + 1;\n      const collapsed = allKeys.filter((k) => k.length === keyLen).map(flatKey);\n\n      const updates = {};\n      collapsed.forEach((k) => {\n        updates[k] = true;\n      });\n\n      if (rowOrCol) {\n        this.setState((state) => ({\n          collapsedRows: { ...state.collapsedRows, ...updates }\n        }));\n      } else {\n        this.setState((state) => ({\n          collapsedCols: { ...state.collapsedCols, ...updates }\n        }));\n      }\n    };\n  }\n\n  expandAttr(rowOrCol, attrIdx, allKeys) {\n    return (e) => {\n      // Expand an entire attribute. This implicitly implies expanding all of the\n      // parents as well. It's a bit inefficient but ah well...\n      e.stopPropagation();\n      const updates = {};\n      allKeys.forEach((k) => {\n        for (let i = 0; i <= attrIdx; i += 1) {\n          updates[flatKey(k.slice(0, i + 1))] = false;\n        }\n      });\n\n      if (rowOrCol) {\n        this.setState((state) => ({\n          collapsedRows: { ...state.collapsedRows, ...updates }\n        }));\n      } else {\n        this.setState((state) => ({\n          collapsedCols: { ...state.collapsedCols, ...updates }\n        }));\n      }\n    };\n  }\n\n  toggleRowKey(flatRowKey) {\n    return (e) => {\n      e.stopPropagation();\n      this.setState((state) => ({\n        collapsedRows: {\n          ...state.collapsedRows,\n          [flatRowKey]: !state.collapsedRows[flatRowKey]\n        }\n      }));\n    };\n  }\n\n  toggleColKey(flatColKey) {\n    return (e) => {\n      e.stopPropagation();\n      this.setState((state) => ({\n        collapsedCols: {\n          ...state.collapsedCols,\n          [flatColKey]: !state.collapsedCols[flatColKey]\n        }\n      }));\n    };\n  }\n\n  calcAttrSpans(attrArr, numAttrs) {\n    // Given an array of attribute values (i.e. each element is another array with\n    // the value at every level), compute the spans for every attribute value at\n    // every level. The return value is a nested array of the same shape. It has\n    // -1's for repeated values and the span number otherwise.\n\n    const spans = [];\n    // Index of the last new value\n    const li = Array(numAttrs).map(() => 0);\n    let lv = Array(numAttrs).map(() => null);\n    for (let i = 0; i < attrArr.length; i += 1) {\n      // Keep increasing span values as long as the last keys are the same. For\n      // the rest, record spans of 1. Update the indices too.\n      const cv = attrArr[i];\n      const ent = [];\n      let depth = 0;\n      const limit = Math.min(lv.length, cv.length);\n      while (depth < limit && lv[depth] === cv[depth]) {\n        ent.push(-1);\n        spans[li[depth]][depth] += 1;\n        depth += 1;\n      }\n      while (depth < cv.length) {\n        li[depth] = i;\n        ent.push(1);\n        depth += 1;\n      }\n      spans.push(ent);\n      lv = cv;\n    }\n    return spans;\n  }\n\n  renderColHeaderRow(attrName, attrIdx, pivotSettings) {\n    // Render a single row in the column header at the top of the pivot table.\n\n    const {\n      rowAttrs,\n      colAttrs,\n      colKeys,\n      visibleColKeys,\n      colAttrSpans,\n      rowTotals,\n      arrowExpanded,\n      arrowCollapsed,\n      colSubtotalDisplay,\n      maxColVisible,\n      pivotData,\n      namesMapping,\n      allowRenderHtml\n    } = pivotSettings;\n    const {\n      highlightHeaderCellsOnHover,\n      omittedHighlightHeaderGroups = [],\n      highlightedHeaderCells,\n      dateFormatters\n    } = this.props.tableOptions;\n\n    const spaceCell =\n    attrIdx === 0 && rowAttrs.length !== 0 ?\n    _jsx(\"th\", {\n\n      colSpan: rowAttrs.length,\n      rowSpan: colAttrs.length,\n      \"aria-hidden\": \"true\" }, \"padding\"\n    ) :\n    null;\n\n    const needToggle =\n    colSubtotalDisplay.enabled && attrIdx !== colAttrs.length - 1;\n    let arrowClickHandle = null;\n    let subArrow = null;\n    if (needToggle) {\n      arrowClickHandle =\n      attrIdx + 1 < maxColVisible ?\n      this.collapseAttr(false, attrIdx, colKeys) :\n      this.expandAttr(false, attrIdx, colKeys);\n      subArrow = attrIdx + 1 < maxColVisible ? arrowExpanded : arrowCollapsed;\n    }\n    const attrNameCell =\n    _jsx(\"th\", { className: \"pvtAxisLabel\", children:\n      displayHeaderCell(\n        needToggle,\n        subArrow,\n        arrowClickHandle,\n        attrName,\n        namesMapping,\n        allowRenderHtml\n      ) }, \"label\"\n    );\n\n\n    const attrValueCells = [];\n    const rowIncrSpan = rowAttrs.length !== 0 ? 1 : 0;\n    // Iterate through columns. Jump over duplicate values.\n    let i = 0;\n    while (i < visibleColKeys.length) {\n      let handleContextMenu;\n      const colKey = visibleColKeys[i];\n      const colSpan = attrIdx < colKey.length ? colAttrSpans[i][attrIdx] : 1;\n      let colLabelClass = 'pvtColLabel';\n      if (attrIdx < colKey.length) {\n        if (!omittedHighlightHeaderGroups.includes(colAttrs[attrIdx])) {\n          if (highlightHeaderCellsOnHover) {\n            colLabelClass += ' hoverable';\n          }\n          handleContextMenu = (e) =>\n          this.props.onContextMenu(e, colKey, undefined, {\n            [attrName]: colKey[attrIdx]\n          });\n        }\n        if (\n        highlightedHeaderCells &&\n        Array.isArray(highlightedHeaderCells[colAttrs[attrIdx]]) &&\n        highlightedHeaderCells[colAttrs[attrIdx]].includes(colKey[attrIdx]))\n        {\n          colLabelClass += ' active';\n        }\n\n        const rowSpan = 1 + (attrIdx === colAttrs.length - 1 ? rowIncrSpan : 0);\n        const flatColKey = flatKey(colKey.slice(0, attrIdx + 1));\n        const onArrowClick = needToggle ? this.toggleColKey(flatColKey) : null;\n\n        const headerCellFormattedValue =\n        dateFormatters &&\n        dateFormatters[attrName] &&\n        typeof dateFormatters[attrName] === 'function' ?\n        dateFormatters[attrName](colKey[attrIdx]) :\n        colKey[attrIdx];\n        attrValueCells.push(\n          _jsx(\"th\", {\n            className: colLabelClass,\n\n            colSpan: colSpan,\n            rowSpan: rowSpan,\n            role: \"columnheader button\",\n            onClick: this.clickHeaderHandler(\n              pivotData,\n              colKey,\n              this.props.cols,\n              attrIdx,\n              this.props.tableOptions.clickColumnHeaderCallback\n            ),\n            onContextMenu: handleContextMenu, children:\n\n            displayHeaderCell(\n              needToggle,\n              this.state.collapsedCols[flatColKey] ?\n              arrowCollapsed :\n              arrowExpanded,\n              onArrowClick,\n              headerCellFormattedValue,\n              namesMapping,\n              allowRenderHtml\n            ) }, `colKey-${flatColKey}`\n          )\n        );\n      } else if (attrIdx === colKey.length) {\n        const rowSpan = colAttrs.length - colKey.length + rowIncrSpan;\n        attrValueCells.push(\n          _jsx(\"th\", {\n            className: `${colLabelClass} pvtSubtotalLabel`,\n\n            colSpan: colSpan,\n            rowSpan: rowSpan,\n            role: \"columnheader button\",\n            onClick: this.clickHeaderHandler(\n              pivotData,\n              colKey,\n              this.props.cols,\n              attrIdx,\n              this.props.tableOptions.clickColumnHeaderCallback,\n              true\n            ), children:\n\n            t('Subtotal') }, `colKeyBuffer-${flatKey(colKey)}`\n          )\n        );\n      }\n      // The next colSpan columns will have the same value anyway...\n      i += colSpan;\n    }\n\n    const totalCell =\n    attrIdx === 0 && rowTotals ?\n    _jsx(\"th\", {\n\n      className: \"pvtTotalLabel\",\n      rowSpan: colAttrs.length + Math.min(rowAttrs.length, 1),\n      role: \"columnheader button\",\n      onClick: this.clickHeaderHandler(\n        pivotData,\n        [],\n        this.props.cols,\n        attrIdx,\n        this.props.tableOptions.clickColumnHeaderCallback,\n        false,\n        true\n      ), children:\n\n      t('Total (%(aggregatorName)s)', {\n        aggregatorName: t(this.props.aggregatorName)\n      }) }, \"total\"\n    ) :\n    null;\n\n    const cells = [spaceCell, attrNameCell, ...attrValueCells, totalCell];\n    return _jsx(\"tr\", { children: cells }, `colAttr-${attrIdx}`);\n  }\n\n  renderRowHeaderRow(pivotSettings) {\n    // Render just the attribute names of the rows (the actual attribute values\n    // will show up in the individual rows).\n\n    const {\n      rowAttrs,\n      colAttrs,\n      rowKeys,\n      arrowCollapsed,\n      arrowExpanded,\n      rowSubtotalDisplay,\n      maxRowVisible,\n      pivotData,\n      namesMapping,\n      allowRenderHtml\n    } = pivotSettings;\n    return (\n      _jsxs(\"tr\", { children: [\n        rowAttrs.map((r, i) => {\n          const needLabelToggle =\n          rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;\n          let arrowClickHandle = null;\n          let subArrow = null;\n          if (needLabelToggle) {\n            arrowClickHandle =\n            i + 1 < maxRowVisible ?\n            this.collapseAttr(true, i, rowKeys) :\n            this.expandAttr(true, i, rowKeys);\n            subArrow = i + 1 < maxRowVisible ? arrowExpanded : arrowCollapsed;\n          }\n          return (\n            _jsx(\"th\", { className: \"pvtAxisLabel\", children:\n              displayHeaderCell(\n                needLabelToggle,\n                subArrow,\n                arrowClickHandle,\n                r,\n                namesMapping,\n                allowRenderHtml\n              ) }, `rowAttr-${i}`\n            ));\n\n        }),\n        _jsx(\"th\", {\n          className: \"pvtTotalLabel\",\n\n          role: \"columnheader button\",\n          onClick: this.clickHeaderHandler(\n            pivotData,\n            [],\n            this.props.rows,\n            0,\n            this.props.tableOptions.clickRowHeaderCallback,\n            false,\n            true\n          ), children:\n\n          colAttrs.length === 0 ?\n          t('Total (%(aggregatorName)s)', {\n            aggregatorName: t(this.props.aggregatorName)\n          }) :\n          null }, \"padding\"\n        )] }, \"rowHdr\"\n      ));\n\n  }\n\n  renderTableRow(rowKey, rowIdx, pivotSettings) {\n    // Render a single row in the pivot table.\n\n    const {\n      rowAttrs,\n      colAttrs,\n      rowAttrSpans,\n      visibleColKeys,\n      pivotData,\n      rowTotals,\n      rowSubtotalDisplay,\n      arrowExpanded,\n      arrowCollapsed,\n      cellCallbacks,\n      rowTotalCallbacks,\n      namesMapping,\n      allowRenderHtml\n    } = pivotSettings;\n\n    const {\n      highlightHeaderCellsOnHover,\n      omittedHighlightHeaderGroups = [],\n      highlightedHeaderCells,\n      cellColorFormatters,\n      dateFormatters\n    } = this.props.tableOptions;\n    const flatRowKey = flatKey(rowKey);\n\n    const colIncrSpan = colAttrs.length !== 0 ? 1 : 0;\n    const attrValueCells = rowKey.map((r, i) => {\n      let handleContextMenu;\n      let valueCellClassName = 'pvtRowLabel';\n      if (!omittedHighlightHeaderGroups.includes(rowAttrs[i])) {\n        if (highlightHeaderCellsOnHover) {\n          valueCellClassName += ' hoverable';\n        }\n        handleContextMenu = (e) =>\n        this.props.onContextMenu(e, undefined, rowKey, {\n          [rowAttrs[i]]: r\n        });\n      }\n      if (\n      highlightedHeaderCells &&\n      Array.isArray(highlightedHeaderCells[rowAttrs[i]]) &&\n      highlightedHeaderCells[rowAttrs[i]].includes(r))\n      {\n        valueCellClassName += ' active';\n      }\n      const rowSpan = rowAttrSpans[rowIdx][i];\n      if (rowSpan > 0) {\n        const flatRowKey = flatKey(rowKey.slice(0, i + 1));\n        const colSpan = 1 + (i === rowAttrs.length - 1 ? colIncrSpan : 0);\n        const needRowToggle =\n        rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;\n        const onArrowClick = needRowToggle ?\n        this.toggleRowKey(flatRowKey) :\n        null;\n\n        const headerCellFormattedValue =\n        dateFormatters && dateFormatters[rowAttrs[i]] ?\n        dateFormatters[rowAttrs[i]](r) :\n        r;\n        return (\n          _jsx(\"th\", {\n\n            className: valueCellClassName,\n            rowSpan: rowSpan,\n            colSpan: colSpan,\n            role: \"columnheader button\",\n            onClick: this.clickHeaderHandler(\n              pivotData,\n              rowKey,\n              this.props.rows,\n              i,\n              this.props.tableOptions.clickRowHeaderCallback\n            ),\n            onContextMenu: handleContextMenu, children:\n\n            displayHeaderCell(\n              needRowToggle,\n              this.state.collapsedRows[flatRowKey] ?\n              arrowCollapsed :\n              arrowExpanded,\n              onArrowClick,\n              headerCellFormattedValue,\n              namesMapping,\n              allowRenderHtml\n            ) }, `rowKeyLabel-${i}`\n          ));\n\n      }\n      return null;\n    });\n\n    const attrValuePaddingCell =\n    rowKey.length < rowAttrs.length ?\n    _jsx(\"th\", {\n      className: \"pvtRowLabel pvtSubtotalLabel\",\n\n      colSpan: rowAttrs.length - rowKey.length + colIncrSpan,\n      rowSpan: 1,\n      role: \"columnheader button\",\n      onClick: this.clickHeaderHandler(\n        pivotData,\n        rowKey,\n        this.props.rows,\n        rowKey.length,\n        this.props.tableOptions.clickRowHeaderCallback,\n        true\n      ), children:\n\n      t('Subtotal') }, \"rowKeyBuffer\"\n    ) :\n    null;\n\n    const rowClickHandlers = cellCallbacks[flatRowKey] || {};\n    const valueCells = visibleColKeys.map((colKey) => {\n      const flatColKey = flatKey(colKey);\n      const agg = pivotData.getAggregator(rowKey, colKey);\n      const aggValue = agg.value();\n\n      const keys = [...rowKey, ...colKey];\n      let backgroundColor;\n      if (cellColorFormatters) {\n        Object.values(cellColorFormatters).forEach((cellColorFormatter) => {\n          if (Array.isArray(cellColorFormatter)) {\n            keys.forEach((key) => {\n              if (backgroundColor) {\n                return;\n              }\n              cellColorFormatter.\n              filter((formatter) => formatter.column === key).\n              forEach((formatter) => {\n                const formatterResult = formatter.getColorFromValue(aggValue);\n                if (formatterResult) {\n                  backgroundColor = formatterResult;\n                }\n              });\n            });\n          }\n        });\n      }\n\n      const style = agg.isSubtotal ?\n      { fontWeight: 'bold' } :\n      { backgroundColor };\n\n      return (\n        _jsx(\"td\", {\n          role: \"gridcell\",\n          className: \"pvtVal\",\n\n          onClick: rowClickHandlers[flatColKey],\n          onContextMenu: (e) => this.props.onContextMenu(e, colKey, rowKey),\n          style: style, children:\n\n          agg.format(aggValue) }, `pvtVal-${flatColKey}`\n        ));\n\n    });\n\n    let totalCell = null;\n    if (rowTotals) {\n      const agg = pivotData.getAggregator(rowKey, []);\n      const aggValue = agg.value();\n      totalCell =\n      _jsx(\"td\", {\n        role: \"gridcell\",\n\n        className: \"pvtTotal\",\n        onClick: rowTotalCallbacks[flatRowKey],\n        onContextMenu: (e) => this.props.onContextMenu(e, undefined, rowKey), children:\n\n        agg.format(aggValue) }, \"total\"\n      );\n\n    }\n\n    const rowCells = [\n    ...attrValueCells,\n    attrValuePaddingCell,\n    ...valueCells,\n    totalCell];\n\n\n    return _jsx(\"tr\", { children: rowCells }, `keyRow-${flatRowKey}`);\n  }\n\n  renderTotalsRow(pivotSettings) {\n    // Render the final totals rows that has the totals for all the columns.\n\n    const {\n      rowAttrs,\n      colAttrs,\n      visibleColKeys,\n      rowTotals,\n      pivotData,\n      colTotalCallbacks,\n      grandTotalCallback\n    } = pivotSettings;\n\n    const totalLabelCell =\n    _jsx(\"th\", {\n\n      className: \"pvtTotalLabel pvtRowTotalLabel\",\n      colSpan: rowAttrs.length + Math.min(colAttrs.length, 1),\n      role: \"columnheader button\",\n      onClick: this.clickHeaderHandler(\n        pivotData,\n        [],\n        this.props.rows,\n        0,\n        this.props.tableOptions.clickRowHeaderCallback,\n        false,\n        true\n      ), children:\n\n      t('Total (%(aggregatorName)s)', {\n        aggregatorName: t(this.props.aggregatorName)\n      }) }, \"label\"\n    );\n\n\n    const totalValueCells = visibleColKeys.map((colKey) => {\n      const flatColKey = flatKey(colKey);\n      const agg = pivotData.getAggregator([], colKey);\n      const aggValue = agg.value();\n\n      return (\n        _jsx(\"td\", {\n          role: \"gridcell\",\n          className: \"pvtTotal pvtRowTotal\",\n\n          onClick: colTotalCallbacks[flatColKey],\n          onContextMenu: (e) => this.props.onContextMenu(e, colKey, undefined),\n          style: { padding: '5px' }, children:\n\n          agg.format(aggValue) }, `total-${flatColKey}`\n        ));\n\n    });\n\n    let grandTotalCell = null;\n    if (rowTotals) {\n      const agg = pivotData.getAggregator([], []);\n      const aggValue = agg.value();\n      grandTotalCell =\n      _jsx(\"td\", {\n        role: \"gridcell\",\n\n        className: \"pvtGrandTotal pvtRowTotal\",\n        onClick: grandTotalCallback,\n        onContextMenu: (e) => this.props.onContextMenu(e, undefined, undefined), children:\n\n        agg.format(aggValue) }, \"total\"\n      );\n\n    }\n\n    const totalCells = [totalLabelCell, ...totalValueCells, grandTotalCell];\n\n    return (\n      _jsx(\"tr\", { className: \"pvtRowTotals\", children:\n        totalCells }, \"total\"\n      ));\n\n  }\n\n  visibleKeys(keys, collapsed, numAttrs, subtotalDisplay) {\n    return keys.filter(\n      (key) =>\n      // Is the key hidden by one of its parents?\n      !key.some((k, j) => collapsed[flatKey(key.slice(0, j))]) && (\n      // Leaf key.\n      key.length === numAttrs ||\n      // Children hidden. Must show total.\n      flatKey(key) in collapsed ||\n      // Don't hide totals.\n      !subtotalDisplay.hideOnExpand)\n    );\n  }\n\n  isDashboardEditMode() {\n    return document.contains(document.querySelector('.dashboard--editing'));\n  }\n\n  render() {\n    if (this.cachedProps !== this.props) {\n      this.cachedProps = this.props;\n      this.cachedBasePivotSettings = this.getBasePivotSettings();\n    }\n    const {\n      colAttrs,\n      rowAttrs,\n      rowKeys,\n      colKeys,\n      colTotals,\n      rowSubtotalDisplay,\n      colSubtotalDisplay,\n      allowRenderHtml\n    } = this.cachedBasePivotSettings;\n\n    // Need to account for exclusions to compute the effective row\n    // and column keys.\n    const visibleRowKeys = this.visibleKeys(\n      rowKeys,\n      this.state.collapsedRows,\n      rowAttrs.length,\n      rowSubtotalDisplay\n    );\n    const visibleColKeys = this.visibleKeys(\n      colKeys,\n      this.state.collapsedCols,\n      colAttrs.length,\n      colSubtotalDisplay\n    );\n\n    const pivotSettings = {\n      visibleRowKeys,\n      maxRowVisible: Math.max(...visibleRowKeys.map((k) => k.length)),\n      visibleColKeys,\n      maxColVisible: Math.max(...visibleColKeys.map((k) => k.length)),\n      rowAttrSpans: this.calcAttrSpans(visibleRowKeys, rowAttrs.length),\n      colAttrSpans: this.calcAttrSpans(visibleColKeys, colAttrs.length),\n      allowRenderHtml,\n      ...this.cachedBasePivotSettings\n    };\n\n    return (\n      _jsx(Styles, { isDashboardEditMode: this.isDashboardEditMode(), children:\n        _jsxs(\"table\", { className: \"pvtTable\", role: \"grid\", children: [\n          _jsxs(\"thead\", { children: [\n            colAttrs.map((c, j) =>\n            this.renderColHeaderRow(c, j, pivotSettings)\n            ),\n            rowAttrs.length !== 0 && this.renderRowHeaderRow(pivotSettings)] }\n          ),\n          _jsxs(\"tbody\", { children: [\n            visibleRowKeys.map((r, i) =>\n            this.renderTableRow(r, i, pivotSettings)\n            ),\n            colTotals && this.renderTotalsRow(pivotSettings)] }\n          )] }\n        ) }\n      ));\n\n  }\n}\n\nTableRenderer.propTypes = {\n  ...PivotData.propTypes,\n  tableOptions: PropTypes.object,\n  onContextMenu: PropTypes.func\n};\nTableRenderer.defaultProps = { ...PivotData.defaultProps, tableOptions: {} };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}