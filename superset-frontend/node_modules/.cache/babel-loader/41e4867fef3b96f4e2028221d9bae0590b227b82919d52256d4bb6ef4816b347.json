{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isFeatureEnabled, FeatureFlag, styled, SupersetClient, t, css, useTheme } from '@superset-ui/core';\nimport { useSelector } from 'react-redux';\nimport { useState, useMemo, useCallback } from 'react';\nimport { Link } from 'react-router-dom';\nimport rison from 'rison';\nimport { createFetchRelated, createErrorHandler, handleDashboardDelete } from 'src/views/CRUD/utils';\nimport { useListViewResource, useFavoriteStatus } from 'src/views/CRUD/hooks';\nimport ConfirmStatusChange from 'src/components/ConfirmStatusChange';\nimport { PublishedLabel } from 'src/components/Label';\nimport { TagsList } from 'src/components/Tags';\nimport handleResourceExport from 'src/utils/export';\nimport Loading from 'src/components/Loading';\nimport SubMenu from 'src/features/home/SubMenu';\nimport ListView, { FilterOperator } from 'src/components/ListView';\nimport { dangerouslyGetItemDoNotUse } from 'src/utils/localStorageHelpers';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport FacePile from 'src/components/FacePile';\nimport Icons from 'src/components/Icons';\nimport DeleteModal from 'src/components/DeleteModal';\nimport FaveStar from 'src/components/FaveStar';\nimport PropertiesModal from 'src/dashboard/components/PropertiesModal';\nimport { Tooltip } from 'src/components/Tooltip';\nimport ImportModelsModal from 'src/components/ImportModal/index';\nimport { QueryObjectColumns } from 'src/views/CRUD/types';\nimport CertifiedBadge from 'src/components/CertifiedBadge';\nimport { loadTags } from 'src/components/Tags/utils';\nimport DashboardCard from 'src/features/dashboards/DashboardCard';\nimport { DashboardStatus } from 'src/features/dashboards/types';\nimport { findPermission } from 'src/utils/findPermission';\nimport { ModifiedInfo } from 'src/components/AuditInfo';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst PAGE_SIZE = 25;\nconst PASSWORDS_NEEDED_MESSAGE = t('The passwords for the databases below are needed in order to ' +\n'import them together with the dashboards. Please note that the ' +\n'\"Secure Extra\" and \"Certificate\" sections of ' +\n'the database configuration are not present in export files, and ' +\n'should be added manually after the import if they are needed.');\nconst CONFIRM_OVERWRITE_MESSAGE = t('You are importing one or more dashboards that already exist. ' +\n'Overwriting might cause you to lose some of your work. Are you ' +\n'sure you want to overwrite?');\nconst Actions = styled.div`\n  color: ${({ theme }) => theme.colors.grayscale.base};\n`;\nconst DASHBOARD_COLUMNS_TO_FETCH = [\n'id',\n'dashboard_title',\n'published',\n'url',\n'slug',\n'changed_by',\n'changed_by.id',\n'changed_by.first_name',\n'changed_by.last_name',\n'changed_on_delta_humanized',\n'owners',\n'owners.id',\n'owners.first_name',\n'owners.last_name',\n'tags.id',\n'tags.name',\n'tags.type',\n'status',\n'certified_by',\n'certification_details',\n'changed_on'];\n\nfunction DashboardList(props) {var _user$userId;\n  const { addDangerToast, addSuccessToast, user } = props;\n  const theme = useTheme();\n  const { roles } = useSelector((state) => state.user);\n  const canReadTag = findPermission('can_read', 'Tag', roles);\n  const { state: { loading, resourceCount: dashboardCount, resourceCollection: dashboards, bulkSelectEnabled }, setResourceCollection: setDashboards, hasPerm, fetchData, toggleBulkSelect, refreshData } = useListViewResource('dashboard', t('dashboard'), addDangerToast, undefined, undefined, undefined, undefined, DASHBOARD_COLUMNS_TO_FETCH);\n  const dashboardIds = useMemo(() => dashboards.map((d) => d.id), [dashboards]);\n  const [saveFavoriteStatus, favoriteStatus] = useFavoriteStatus('dashboard', dashboardIds, addDangerToast);\n  const [dashboardToEdit, setDashboardToEdit] = useState(null);\n  const [dashboardToDelete, setDashboardToDelete] = useState(null);\n  const [importingDashboard, showImportModal] = useState(false);\n  const [passwordFields, setPasswordFields] = useState([]);\n  const [preparingExport, setPreparingExport] = useState(false);\n  const [sshTunnelPasswordFields, setSSHTunnelPasswordFields] = useState([]);\n  const [sshTunnelPrivateKeyFields, setSSHTunnelPrivateKeyFields] = useState([]);\n  const [sshTunnelPrivateKeyPasswordFields, setSSHTunnelPrivateKeyPasswordFields] = useState([]);\n  const openDashboardImportModal = () => {\n    showImportModal(true);\n  };\n  const closeDashboardImportModal = () => {\n    showImportModal(false);\n  };\n  const handleDashboardImport = () => {\n    showImportModal(false);\n    refreshData();\n    addSuccessToast(t('Dashboard imported'));\n  };\n  // TODO: Fix usage of localStorage keying on the user id\n  const userKey = dangerouslyGetItemDoNotUse(user == null ? void 0 : (_user$userId = user.userId) == null ? void 0 : _user$userId.toString(), null);\n  const canCreate = hasPerm('can_write');\n  const canEdit = hasPerm('can_write');\n  const canDelete = hasPerm('can_write');\n  const canExport = hasPerm('can_export');\n  const initialSort = [{ id: 'changed_on_delta_humanized', desc: true }];\n  function openDashboardEditModal(dashboard) {\n    setDashboardToEdit(dashboard);\n  }\n  function handleDashboardEdit(edits) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/dashboard/${edits.id}`\n    }).then(({ json = {} }) => {\n      setDashboards(dashboards.map((dashboard) => {var _json$result;\n        if (dashboard.id === (json == null ? void 0 : (_json$result = json.result) == null ? void 0 : _json$result.id)) {\n          const { changed_by_name, changed_by, dashboard_title = '', slug = '', json_metadata = '', changed_on_delta_humanized, url = '', certified_by = '', certification_details = '', owners, tags } = json.result;\n          return {\n            ...dashboard,\n            changed_by_name,\n            changed_by,\n            dashboard_title,\n            slug,\n            json_metadata,\n            changed_on_delta_humanized,\n            url,\n            certified_by,\n            certification_details,\n            owners,\n            tags\n          };\n        }\n        return dashboard;\n      }));\n    }, createErrorHandler((errMsg) => addDangerToast(t('An error occurred while fetching dashboards: %s', errMsg))));\n  }\n  const handleBulkDashboardExport = (dashboardsToExport) => {\n    const ids = dashboardsToExport.map(({ id }) => id);\n    handleResourceExport('dashboard', ids, () => {\n      setPreparingExport(false);\n    });\n    setPreparingExport(true);\n  };\n  function handleBulkDashboardDelete(dashboardsToDelete) {\n    return SupersetClient.delete({\n      endpoint: `/api/v1/dashboard/?q=${rison.encode(dashboardsToDelete.map(({ id }) => id))}`\n    }).then(({ json = {} }) => {\n      refreshData();\n      addSuccessToast(json.message);\n    }, createErrorHandler((errMsg) => addDangerToast(t('There was an issue deleting the selected dashboards: ', errMsg))));\n  }\n  const columns = useMemo(() => [\n  {\n    Cell: ({ row: { original: { id } } }) => (user == null ? void 0 : user.userId) && _jsx(FaveStar, { itemId: id, saveFaveStar: saveFavoriteStatus, isStarred: favoriteStatus[id] }),\n    Header: '',\n    id: 'id',\n    disableSortBy: true,\n    size: 'xs',\n    hidden: !(user != null && user.userId)\n  },\n  {\n    Cell: ({ row: { original: { url, dashboard_title: dashboardTitle, certified_by: certifiedBy, certification_details: certificationDetails } } }) => _jsxs(Link, { to: url, children: [\n      certifiedBy && _jsxs(_Fragment, { children: [\n        _jsx(CertifiedBadge, { certifiedBy: certifiedBy, details: certificationDetails }), ' '] }\n      ),\n      dashboardTitle] }\n    ),\n    Header: t('Name'),\n    accessor: 'dashboard_title'\n  },\n  {\n    Cell: ({ row: { original: { status } } }) => _jsx(PublishedLabel, { isPublished: status === DashboardStatus.PUBLISHED }),\n    Header: t('Status'),\n    accessor: 'published',\n    size: 'xl'\n  },\n  {\n    Cell: ({ row: { original: { tags = [] } } }) =>\n    // Only show custom type tags\n    _jsx(TagsList, { tags: tags.filter((tag) => tag.type === 'TagTypes.custom' || tag.type === 1), maxTags: 3 }),\n    Header: t('Tags'),\n    accessor: 'tags',\n    disableSortBy: true,\n    hidden: !isFeatureEnabled(FeatureFlag.TaggingSystem)\n  },\n  {\n    Cell: ({ row: { original: { owners = [] } } }) => _jsx(FacePile, { users: owners }),\n    Header: t('Owners'),\n    accessor: 'owners',\n    disableSortBy: true,\n    size: 'xl'\n  },\n  {\n    Cell: ({ row: { original: { changed_on_delta_humanized: changedOn, changed_by: changedBy } } }) => _jsx(ModifiedInfo, { date: changedOn, user: changedBy }),\n    Header: t('Last modified'),\n    accessor: 'changed_on_delta_humanized',\n    size: 'xl'\n  },\n  {\n    Cell: ({ row: { original } }) => {\n      const handleDelete = () => handleDashboardDelete(original, refreshData, addSuccessToast, addDangerToast);\n      const handleEdit = () => openDashboardEditModal(original);\n      const handleExport = () => handleBulkDashboardExport([original]);\n      return _jsxs(Actions, { className: \"actions\", children: [\n        canDelete && _jsx(ConfirmStatusChange, { title: t('Please confirm'), description: _jsxs(_Fragment, { children: [\n            t('Are you sure you want to delete'), ' ',\n            _jsx(\"b\", { children: original.dashboard_title }), \"?\"] }\n          ), onConfirm: handleDelete, children:\n          (confirmDelete) => _jsx(Tooltip, { id: \"delete-action-tooltip\", title: t('Delete'), placement: \"bottom\", children:\n            _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", onClick: confirmDelete, children:\n              _jsx(Icons.DeleteOutlined, { iconSize: \"l\" }) }\n            ) }\n          ) }\n        ),\n        canExport && _jsx(Tooltip, { id: \"export-action-tooltip\", title: t('Export'), placement: \"bottom\", children:\n          _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", onClick: handleExport, children:\n            _jsx(Icons.UploadOutlined, { iconSize: \"l\" }) }\n          ) }\n        ),\n        canEdit && _jsx(Tooltip, { id: \"edit-action-tooltip\", title: t('Edit'), placement: \"bottom\", children:\n          _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", onClick: handleEdit, children:\n            _jsx(Icons.EditOutlined, { iconSize: \"l\" }) }\n          ) }\n        )] }\n      );\n    },\n    Header: t('Actions'),\n    id: 'actions',\n    hidden: !canEdit && !canDelete && !canExport,\n    disableSortBy: true\n  },\n  {\n    accessor: QueryObjectColumns.ChangedBy,\n    hidden: true\n  }],\n  [\n  user == null ? void 0 : user.userId,\n  canEdit,\n  canDelete,\n  canExport,\n  saveFavoriteStatus,\n  favoriteStatus,\n  refreshData,\n  addSuccessToast,\n  addDangerToast]\n  );\n  const favoritesFilter = useMemo(() => ({\n    Header: t('Favorite'),\n    key: 'favorite',\n    id: 'id',\n    urlDisplay: 'favorite',\n    input: 'select',\n    operator: FilterOperator.DashboardIsFav,\n    unfilteredLabel: t('Any'),\n    selects: [\n    { label: t('Yes'), value: true },\n    { label: t('No'), value: false }]\n\n  }), []);\n  const filters = useMemo(() => {\n    const filters_list = [\n    {\n      Header: t('Name'),\n      key: 'search',\n      id: 'dashboard_title',\n      input: 'search',\n      operator: FilterOperator.TitleOrSlug\n    },\n    {\n      Header: t('Status'),\n      key: 'published',\n      id: 'published',\n      input: 'select',\n      operator: FilterOperator.Equals,\n      unfilteredLabel: t('Any'),\n      selects: [\n      { label: t('Published'), value: true },\n      { label: t('Draft'), value: false }]\n\n    },\n    ...(isFeatureEnabled(FeatureFlag.TaggingSystem) && canReadTag ?\n    [\n    {\n      Header: t('Tag'),\n      key: 'tags',\n      id: 'tags',\n      input: 'select',\n      operator: FilterOperator.DashboardTagById,\n      unfilteredLabel: t('All'),\n      fetchSelects: loadTags\n    }] :\n\n    []),\n    {\n      Header: t('Owner'),\n      key: 'owner',\n      id: 'owners',\n      input: 'select',\n      operator: FilterOperator.RelationManyMany,\n      unfilteredLabel: t('All'),\n      fetchSelects: createFetchRelated('dashboard', 'owners', createErrorHandler((errMsg) => addDangerToast(t('An error occurred while fetching dashboard owner values: %s', errMsg))), props.user),\n      paginate: true\n    },\n    ...(user != null && user.userId ? [favoritesFilter] : []),\n    {\n      Header: t('Certified'),\n      key: 'certified',\n      id: 'id',\n      urlDisplay: 'certified',\n      input: 'select',\n      operator: FilterOperator.DashboardIsCertified,\n      unfilteredLabel: t('Any'),\n      selects: [\n      { label: t('Yes'), value: true },\n      { label: t('No'), value: false }]\n\n    },\n    {\n      Header: t('Modified by'),\n      key: 'changed_by',\n      id: 'changed_by',\n      input: 'select',\n      operator: FilterOperator.RelationOneMany,\n      unfilteredLabel: t('All'),\n      fetchSelects: createFetchRelated('dashboard', 'changed_by', createErrorHandler((errMsg) => t('An error occurred while fetching dataset datasource values: %s', errMsg)), user),\n      paginate: true\n    }];\n\n    return filters_list;\n  }, [addDangerToast, favoritesFilter, props.user]);\n  const sortTypes = [\n  {\n    desc: false,\n    id: 'dashboard_title',\n    label: t('Alphabetical'),\n    value: 'alphabetical'\n  },\n  {\n    desc: true,\n    id: 'changed_on_delta_humanized',\n    label: t('Recently modified'),\n    value: 'recently_modified'\n  },\n  {\n    desc: false,\n    id: 'changed_on_delta_humanized',\n    label: t('Least recently modified'),\n    value: 'least_recently_modified'\n  }];\n\n  const renderCard = useCallback((dashboard) => _jsx(DashboardCard, { dashboard: dashboard, hasPerm: hasPerm, bulkSelectEnabled: bulkSelectEnabled, showThumbnails: userKey ?\n    userKey.thumbnails :\n    isFeatureEnabled(FeatureFlag.Thumbnails), userId: user == null ? void 0 : user.userId, loading: loading, openDashboardEditModal: openDashboardEditModal, saveFavoriteStatus: saveFavoriteStatus, favoriteStatus: favoriteStatus[dashboard.id], handleBulkDashboardExport: handleBulkDashboardExport, onDelete: (dashboard) => setDashboardToDelete(dashboard) }), [\n  bulkSelectEnabled,\n  favoriteStatus,\n  hasPerm,\n  loading,\n  user == null ? void 0 : user.userId,\n  saveFavoriteStatus,\n  userKey]\n  );\n  const subMenuButtons = [];\n  if (canDelete || canExport) {\n    subMenuButtons.push({\n      name: t('Bulk select'),\n      buttonStyle: 'secondary',\n\n      onClick: toggleBulkSelect\n    });\n  }\n  if (canCreate) {\n    subMenuButtons.push({\n      name: _jsxs(_Fragment, { children: [\n        _jsx(Icons.PlusOutlined, { iconColor: theme.colors.primary.light5, iconSize: \"m\", css: css`\n              margin: auto ${theme.gridUnit * 2}px auto 0;\n              vertical-align: text-top;\n            ` }),\n        t('Dashboard')] }\n      ),\n      buttonStyle: 'primary',\n      onClick: () => {\n        window.location.assign('/dashboard/new');\n      }\n    });\n    subMenuButtons.push({\n      name: _jsx(Tooltip, { id: \"import-tooltip\", title: t('Import dashboards'), placement: \"bottomRight\", children:\n        _jsx(Icons.DownloadOutlined, {}) }\n      ),\n      buttonStyle: 'link',\n      onClick: openDashboardImportModal\n    });\n  }\n  return _jsxs(_Fragment, { children: [\n    _jsx(SubMenu, { name: t('Dashboards'), buttons: subMenuButtons }),\n    _jsx(ConfirmStatusChange, { title: t('Please confirm'), description: t('Are you sure you want to delete the selected dashboards?'), onConfirm: handleBulkDashboardDelete, children:\n      (confirmDelete) => {\n        const bulkActions = [];\n        if (canDelete) {\n          bulkActions.push({\n            key: 'delete',\n            name: t('Delete'),\n            type: 'danger',\n            onSelect: confirmDelete\n          });\n        }\n        if (canExport) {\n          bulkActions.push({\n            key: 'export',\n            name: t('Export'),\n            type: 'primary',\n            onSelect: handleBulkDashboardExport\n          });\n        }\n        return _jsxs(_Fragment, { children: [\n          dashboardToEdit && _jsx(PropertiesModal, { dashboardId: dashboardToEdit.id, show: true, onHide: () => setDashboardToEdit(null), onSubmit: handleDashboardEdit }),\n          dashboardToDelete && _jsx(DeleteModal, { description: _jsxs(_Fragment, { children: [\n              t('Are you sure you want to delete'), ' ',\n              _jsx(\"b\", { children: dashboardToDelete.dashboard_title }), \"?\"] }\n            ), onConfirm: () => {\n              handleDashboardDelete(dashboardToDelete, refreshData, addSuccessToast, addDangerToast, undefined, user == null ? void 0 : user.userId);\n              setDashboardToDelete(null);\n            }, onHide: () => setDashboardToDelete(null), open: !!dashboardToDelete, title: t('Please confirm') }),\n          _jsx(ListView, { bulkActions: bulkActions, bulkSelectEnabled: bulkSelectEnabled, cardSortSelectOptions: sortTypes, className: \"dashboard-list-view\", columns: columns, count: dashboardCount, data: dashboards, disableBulkSelect: toggleBulkSelect, fetchData: fetchData, refreshData: refreshData, filters: filters, initialSort: initialSort, loading: loading, pageSize: PAGE_SIZE, addSuccessToast: addSuccessToast, addDangerToast: addDangerToast, showThumbnails: userKey ?\n            userKey.thumbnails :\n            isFeatureEnabled(FeatureFlag.Thumbnails), renderCard: renderCard, defaultViewMode: isFeatureEnabled(FeatureFlag.ListviewsDefaultCardView) ?\n            'card' :\n            'table', enableBulkTag: true, bulkTagResourceName: \"dashboard\" })] }\n        );\n      } }\n    ),\n\n    _jsx(ImportModelsModal, { resourceName: \"dashboard\", resourceLabel: t('dashboard'), passwordsNeededMessage: PASSWORDS_NEEDED_MESSAGE, confirmOverwriteMessage: CONFIRM_OVERWRITE_MESSAGE, addDangerToast: addDangerToast, addSuccessToast: addSuccessToast, onModelImport: handleDashboardImport, show: importingDashboard, onHide: closeDashboardImportModal, passwordFields: passwordFields, setPasswordFields: setPasswordFields, sshTunnelPasswordFields: sshTunnelPasswordFields, setSSHTunnelPasswordFields: setSSHTunnelPasswordFields, sshTunnelPrivateKeyFields: sshTunnelPrivateKeyFields, setSSHTunnelPrivateKeyFields: setSSHTunnelPrivateKeyFields, sshTunnelPrivateKeyPasswordFields: sshTunnelPrivateKeyPasswordFields, setSSHTunnelPrivateKeyPasswordFields: setSSHTunnelPrivateKeyPasswordFields }),\n\n    preparingExport && _jsx(Loading, {})] }\n  );\n}\nexport default withToasts(DashboardList);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}