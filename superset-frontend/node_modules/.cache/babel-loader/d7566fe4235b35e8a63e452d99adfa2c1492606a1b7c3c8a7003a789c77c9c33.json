{"ast":null,"code":"import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\n\nimport { AxisType, buildCustomFormatters, CategoricalColorNamespace, CurrencyFormatter, ensureIsArray, GenericDataType, getCustomFormatter, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, tooltipHtml } from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { DEFAULT_FORM_DATA } from './types';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, extractTooltipKeys, getAxisType, getColtypesMapping, getLegendProps, getMinAndMaxFromBounds, getOverMaxHiddenFormatter } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum, reorderForecastSeries } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from '../Timeseries/transformers';\nimport { TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getTooltipTimeFormatter, getXAxisFormatter, getYAxisFormatter } from '../utils/formatters';\nconst getFormatter = (customFormatters, defaultFormatter, metrics, formatterKey, forcePercentFormat) => {var _getCustomFormatter;\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (_getCustomFormatter = getCustomFormatter(customFormatters, metrics, formatterKey)) != null ? _getCustomFormatter :\n  defaultFormatter;\n};\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, formData, queriesData, hooks, filterState, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { label_map: labelMap } = queriesData[0];\n  const { label_map: labelMapB } = queriesData[1];\n  const data1 = queriesData[0].data || [];\n  const data2 = queriesData[1].data || [];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1])\n  };\n  const { area, areaB, annotationLayers, colorScheme, timeShiftColor, contributionMode, legendOrientation, legendType, logAxis, logAxisSecondary, markerEnabled, markerEnabledB, markerSize, markerSizeB, opacity, opacityB, minorSplitLine, minorTicks, seriesType, seriesTypeB, showLegend, showValue, showValueB, stack, stackB, truncateXAxis, truncateYAxis, tooltipTimeFormat, yAxisFormat, currencyFormat, yAxisFormatSecondary, currencyFormatSecondary, xAxisTimeFormat, yAxisBounds, yAxisBoundsSecondary, yAxisIndex, yAxisIndexB, yAxisTitleSecondary, zoomable, richTooltip, tooltipSortByMetric, xAxisBounds, xAxisLabelRotation, groupby, groupbyB, xAxis: xAxisOrig, xAxisForceCategorical, xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId, timeGrainSqla, percentageThreshold, metrics = [], metricsB = [] } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel\n  });\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series = [];\n  const formatter = contributionMode ?\n  getNumberFormatter(',.0%') :\n  currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({\n    d3Format: yAxisFormat,\n    currency: currencyFormat\n  }) :\n  getNumberFormatter(yAxisFormat);\n  const formatterSecondary = contributionMode ?\n  getNumberFormatter(',.0%') :\n  currencyFormatSecondary != null && currencyFormatSecondary.symbol ?\n  new CurrencyFormatter({\n    d3Format: yAxisFormatSecondary,\n    currency: currencyFormatSecondary\n  }) :\n  getNumberFormatter(yAxisFormatSecondary);\n  const customFormatters = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const customFormattersSecondary = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormatSecondary, currencyFormatSecondary);\n  const primarySeries = new Set();\n  const secondarySeries = new Set();\n  const mapSeriesIdToAxis = (seriesOption, index) => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id);\n    } else\n    {\n      primarySeries.add(seriesOption.id);\n    }\n  };\n  rawSeriesA.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndex));\n  rawSeriesB.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndexB));\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedDataA, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel\n  });\n  const { totalStackedValues: totalStackedValuesB, thresholdValues: thresholdValuesB } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel\n  });\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data1, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data1, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(parseAxisBound);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeriesA.forEach((entry) => {var _labelMap$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const seriesFormatter = getFormatter(customFormatters, formatter, metrics, labelMap == null ? void 0 : (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      showValue,\n      stack: Boolean(stack),\n      stackIdSuffix: '\\na',\n      yAxisIndex,\n      filterState,\n      seriesKey: entry.name,\n      sliceId,\n      queryIndex: 0,\n      formatter: seriesType === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: yAxisMax,\n        formatter: seriesFormatter\n      }) :\n      seriesFormatter,\n      showValueIndexes: showValueIndexesA,\n      totalStackedValues,\n      thresholdValues,\n      timeShiftColor\n    });\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  rawSeriesB.forEach((entry) => {var _labelMapB$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesEntry = inverted[entryName] || entryName;\n    const seriesName = `${seriesEntry} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesEntry, array);\n    const seriesFormatter = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, labelMapB == null ? void 0 : (_labelMapB$seriesName = labelMapB[seriesName]) == null ? void 0 : _labelMapB$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area: areaB,\n      markerEnabled: markerEnabledB,\n      markerSize: markerSizeB,\n      areaOpacity: opacityB,\n      seriesType: seriesTypeB,\n      showValue: showValueB,\n      stack: Boolean(stackB),\n      stackIdSuffix: '\\nb',\n      yAxisIndex: yAxisIndexB,\n      filterState,\n      seriesKey: primarySeries.has(entry.name) ?\n      `${entry.name} (1)` :\n      entry.name,\n      sliceId,\n      queryIndex: 1,\n      formatter: seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: maxSecondary,\n        formatter: seriesFormatter\n      }) :\n      seriesFormatter,\n      showValueIndexes: showValueIndexesB,\n      totalStackedValues: totalStackedValuesB,\n      thresholdValues: thresholdValuesB,\n      timeShiftColor\n    });\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (yAxisMin === undefined)\n    yAxisMin = 0;\n    if (yAxisMax === undefined)\n    yAxisMax = 1;\n    if (minSecondary === undefined)\n    minSecondary = 0;\n    if (maxSecondary === undefined)\n    maxSecondary = 1;\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation\n      },\n      minorTick: { show: minorTicks },\n      minInterval: xAxisType === AxisType.Time && timeGrainSqla ?\n      TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n      0,\n      ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax, seriesType === EchartsTimeseriesSeriesType.Bar ||\n      seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      EchartsTimeseriesSeriesType.Bar :\n      undefined)\n    },\n    yAxis: [\n    {\n      ...defaultYAxis,\n      type: logAxis ? 'log' : 'value',\n      min: yAxisMin,\n      max: yAxisMax,\n      minorTick: { show: minorTicks },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metrics, !!contributionMode, customFormatters, formatter, yAxisFormat)\n      },\n      scale: truncateYAxis,\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n      alignTicks\n    },\n    {\n      ...defaultYAxis,\n      type: logAxisSecondary ? 'log' : 'value',\n      min: minSecondary,\n      max: maxSecondary,\n      minorTick: { show: minorTicks },\n      splitLine: { show: false },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metricsB, !!contributionMode, customFormattersSecondary, formatterSecondary, yAxisFormatSecondary)\n      },\n      scale: truncateYAxis,\n      name: yAxisTitleSecondary,\n      alignTicks\n    }],\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const xValue = richTooltip ?\n        params[0].value[0] :\n        params.value[0];\n        const forecastValue = richTooltip ? params : [params];\n        const sortedKeys = extractTooltipKeys(forecastValue,\n        // horizontal mode is not supported in mixed series chart\n        1, richTooltip, tooltipSortByMetric);\n        const rows = [];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue);\n        const keys = Object.keys(forecastValues);\n        let focusedRow;\n        sortedKeys.\n        filter((key) => keys.includes(key)).\n        forEach((key) => {\n          const value = forecastValues[key];\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          let formatterKey;\n          if (primarySeries.has(key)) {var _labelMap$key;\n            formatterKey =\n            groupby.length === 0 ? inverted[key] : (_labelMap$key = labelMap[key]) == null ? void 0 : _labelMap$key[0];\n          } else\n          {var _labelMapB$key;\n            formatterKey =\n            groupbyB.length === 0 ? inverted[key] : (_labelMapB$key = labelMapB[key]) == null ? void 0 : _labelMapB$key[0];\n          }\n          const tooltipFormatter = getFormatter(customFormatters, formatter, metrics, formatterKey, !!contributionMode);\n          const tooltipFormatterSecondary = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, formatterKey, !!contributionMode);\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key) ?\n            tooltipFormatter :\n            tooltipFormatterSecondary\n          });\n          rows.push(row);\n          if (key === focusedSeries) {\n            focusedRow = rows.length - 1;\n          }\n        });\n        return tooltipHtml(rows, tooltipFormatter(xValue), focusedRow);\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable),\n      // @ts-ignore\n      data: rawSeriesA.\n      concat(rawSeriesB).\n      filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n      ForecastSeriesEnum.Observation).\n      map((entry) => entry.name || '').\n      concat(extractAnnotationLabels(annotationLayers, annotationData))\n    },\n    series: dedupSeries(reorderForecastSeries(series)),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom'\n          }\n        }\n      }\n    },\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom\n    }] :\n\n    []\n  };\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType\n    },\n    refs,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}