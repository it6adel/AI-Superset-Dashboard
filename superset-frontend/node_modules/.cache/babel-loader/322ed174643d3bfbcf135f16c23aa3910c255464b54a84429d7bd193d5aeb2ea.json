{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { buildQueryContext, ensureIsArray, getMetricLabel, isPhysicalColumn, QueryMode, removeDuplicates } from '@superset-ui/core';\nimport { isTimeComparison, timeCompareOperator } from '@superset-ui/chart-controls';\n\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData == null ? void 0 : formData.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\nconst buildQuery = (formData, options) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false, extra_form_data } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla = (extra_form_data == null ? void 0 : extra_form_data.time_grain_sqla) || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false\n    };\n  }\n  const addComparisonPercentMetrics = (metrics, suffixes) => metrics.reduce((acc, metric) => {\n    const newMetrics = suffixes.map((suffix) => `${metric}__${suffix}`);\n    return acc.concat([metric, ...newMetrics]);\n  }, []);\n  return buildQueryContext(formDataCopy, (baseQueryObject) => {var _options$ownState, _options$extras, _options$extras$cache, _options$extras2, _options$extras2$cach, _options$hooks2, _metrics2, _formData$extra_form_;\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    const { extras = {} } = baseQueryObject;\n    let postProcessing = [];\n    const nonCustomNorInheritShifts = ensureIsArray(formData.time_compare).filter((shift) => shift !== 'custom' && shift !== 'inherit');\n    const customOrInheritShifts = ensureIsArray(formData.time_compare).filter((shift) => shift === 'custom' || shift === 'inherit');\n    let timeOffsets = [];\n    // Shifts for non-custom or non inherit time comparison\n    if (isTimeComparison(formData, baseQueryObject) &&\n    !_isEmpty(nonCustomNorInheritShifts)) {\n      timeOffsets = nonCustomNorInheritShifts;\n    }\n    // Shifts for custom or inherit time comparison\n    if (isTimeComparison(formData, baseQueryObject) &&\n    !_isEmpty(customOrInheritShifts)) {\n      if (customOrInheritShifts.includes('custom')) {\n        timeOffsets = timeOffsets.concat([formData.start_date_offset]);\n      }\n      if (customOrInheritShifts.includes('inherit')) {\n        timeOffsets = timeOffsets.concat(['inherit']);\n      }\n    }\n    let temporalColumnAdded = false;\n    let temporalColumn = null;\n    if (queryMode === QueryMode.Aggregate) {var _metrics;\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else\n      if (((_metrics = metrics) == null ? void 0 : _metrics.length) > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricsLabelsWithTimeComparison = isTimeComparison(formData, baseQueryObject) ?\n        addComparisonPercentMetrics(percentMetrics.map(getMetricLabel), timeOffsets) :\n        percentMetrics.map(getMetricLabel);\n        const percentMetricLabels = removeDuplicates(percentMetricsLabelsWithTimeComparison);\n        metrics = removeDuplicates(metrics.concat(percentMetrics), getMetricLabel);\n        postProcessing = [\n        {\n          operation: 'contribution',\n          options: {\n            columns: percentMetricLabels,\n            rename_columns: percentMetricLabels.map((x) => `%${x}`)\n          }\n        }];\n\n      }\n      // Add the operator for the time comparison if some is selected\n      if (!_isEmpty(timeOffsets)) {\n        postProcessing.push(timeCompareOperator(formData, baseQueryObject));\n      }\n      const temporalColumnsLookup = formData == null ? void 0 : formData.temporal_columns_lookup;\n      // Filter out the column if needed and prepare the temporal column object\n      columns = columns.filter((col) => {\n        const shouldBeAdded = isPhysicalColumn(col) &&\n        time_grain_sqla && (\n        temporalColumnsLookup == null ? void 0 : temporalColumnsLookup[col]);\n        if (shouldBeAdded && !temporalColumnAdded) {\n          temporalColumn = {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL'\n          };\n          temporalColumnAdded = true;\n          return false; // Do not include this in the output; it's added separately\n        }\n        return true;\n      });\n      // So we ensure the temporal column is added first\n      if (temporalColumn) {\n        columns = [temporalColumn, ...columns];\n      }\n    }\n    const moreProps = {};\n    const ownState = (_options$ownState = options == null ? void 0 : options.ownState) != null ? _options$ownState : {};\n    if (formDataCopy.server_pagination) {var _ownState$pageSize, _ownState$currentPage, _ownState$pageSize2;\n      moreProps.row_limit = (_ownState$pageSize =\n      ownState.pageSize) != null ? _ownState$pageSize : formDataCopy.server_page_length;\n      moreProps.row_offset =\n      ((_ownState$currentPage = ownState.currentPage) != null ? _ownState$currentPage : 0) * ((_ownState$pageSize2 = ownState.pageSize) != null ? _ownState$pageSize2 : 0);\n    }\n    if (!temporalColumn) {\n      // This query is not using temporal column, so it doesn't need time grain\n      extras.time_grain_sqla = undefined;\n    }\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      extras,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      time_offsets: timeOffsets,\n      ...moreProps\n    };\n    if (formData.server_pagination &&\n    options != null && (_options$extras = options.extras) != null && (_options$extras$cache = _options$extras.cachedChanges) != null && _options$extras$cache[formData.slice_id] &&\n    JSON.stringify(options == null ? void 0 : (_options$extras2 = options.extras) == null ? void 0 : (_options$extras2$cach = _options$extras2.cachedChanges) == null ? void 0 : _options$extras2$cach[formData.slice_id]) !==\n    JSON.stringify(queryObject.filters)) {var _options$hooks, _queryObject$row_limi;\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(options == null ? void 0 : (_options$hooks = options.hooks) == null ? void 0 : _options$hooks.setDataMask, 0, (_queryObject$row_limi = queryObject.row_limit) != null ? _queryObject$row_limi : 0);\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options == null ? void 0 : (_options$hooks2 = options.hooks) == null ? void 0 : _options$hooks2.setCachedChanges({\n      [formData.slice_id]: queryObject.filters\n    });\n    const extraQueries = [];\n    if ((_metrics2 = metrics) != null && _metrics2.length &&\n    formData.show_totals &&\n    queryMode === QueryMode.Aggregate) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined,\n        orderby: undefined // because this query will be used for get total aggregation.\n      });\n    }\n    const interactiveGroupBy = (_formData$extra_form_ = formData.extra_form_data) == null ? void 0 : _formData$extra_form_.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n      ...new Set([...queryObject.columns, ...interactiveGroupBy])];\n\n    }\n    if (formData.server_pagination) {\n      return [\n      { ...queryObject },\n      {\n        ...queryObject,\n        time_offsets: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        is_rowcount: true\n      },\n      ...extraQueries];\n\n    }\n    return [queryObject, ...extraQueries];\n  });\n};\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = () => {\n  let cachedChanges = {};\n  const setCachedChanges = (newChanges) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n  return (formData, options) => {var _options$ownState2;return buildQuery({ ...formData }, {\n      extras: { cachedChanges },\n      ownState: (_options$ownState2 = options == null ? void 0 : options.ownState) != null ? _options$ownState2 : {},\n      hooks: {\n        ...(options == null ? void 0 : options.hooks),\n        setDataMask: () => {},\n        setCachedChanges\n      }\n    });};\n};\nexport default cachedBuildQuery();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}