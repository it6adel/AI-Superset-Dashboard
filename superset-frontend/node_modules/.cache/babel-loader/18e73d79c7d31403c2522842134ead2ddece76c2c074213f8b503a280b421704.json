{"ast":null,"code":"import _debounce from \"lodash/debounce\";function _EMOTION_STRINGIFIED_CSS_ERROR__() {return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";} /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// TODO: Remove fa-icon\n/* eslint-disable icons/no-fa-icons-usage */\nimport { useState, useRef, useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\nimport Collapse from 'src/components/Collapse';\nimport Card from 'src/components/Card';\nimport ButtonGroup from 'src/components/ButtonGroup';\nimport { css, t, styled, useTheme } from '@superset-ui/core';\n\nimport { removeDataPreview, removeTables, addDangerToast, syncTable } from 'src/SqlLab/actions/sqlLab';\nimport { tableApiUtil, useTableExtendedMetadataQuery, useTableMetadataQuery } from 'src/hooks/apiResources';\nimport { Tooltip } from 'src/components/Tooltip';\nimport CopyToClipboard from 'src/components/CopyToClipboard';\nimport { IconTooltip } from 'src/components/IconTooltip';\nimport ModalTrigger from 'src/components/ModalTrigger';\nimport Loading from 'src/components/Loading';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport Icons from 'src/components/Icons';\nimport ColumnElement from '../ColumnElement';\nimport ShowSQL from '../ShowSQL';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";import { createElement as _createElement } from \"@emotion/react\";\nconst StyledSpan = styled.span`\n  color: ${({ theme }) => theme.colors.primary.dark1};\n  &:hover {\n    color: ${({ theme }) => theme.colors.primary.dark2};\n  }\n  cursor: pointer;\n`;\nconst Fade = styled.div`\n  transition: all ${({ theme }) => theme.transitionTiming}s;\n  opacity: ${(props) => props.hovered ? 1 : 0};\n`;\nconst StyledCollapsePanel = styled(Collapse.Panel)`\n  ${({ theme }) => css`\n    & {\n      .ws-el-controls {\n        margin-right: ${-theme.gridUnit}px;\n        display: flex;\n      }\n\n      .header-container {\n        display: flex;\n        flex: 1;\n        align-items: center;\n        width: 100%;\n\n        .table-name {\n          white-space: nowrap;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          font-size: ${theme.typography.sizes.l}px;\n          flex: 1;\n        }\n\n        .header-right-side {\n          margin-left: auto;\n          display: flex;\n          align-items: center;\n          margin-right: ${theme.gridUnit * 8}px;\n        }\n      }\n    }\n  `}\n`;var _ref = process.env.NODE_ENV === \"production\" ? { name: \"1hs1mx1\", styles: \"padding-top:6px\" } : { name: \"14hmmm7-metadata\", styles: \"padding-top:6px;label:metadata;/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL1NxbExhYi9jb21wb25lbnRzL1RhYmxlRWxlbWVudC9pbmRleC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa1BrSSIsImZpbGUiOiIvaG9tZS9hZGVsL3N1cGVyc2V0L3N1cGVyc2V0LWZyb250ZW5kL3NyYy9TcWxMYWIvY29tcG9uZW50cy9UYWJsZUVsZW1lbnQvaW5kZXgudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gVE9ETzogUmVtb3ZlIGZhLWljb25cbi8qIGVzbGludC1kaXNhYmxlIGljb25zL25vLWZhLWljb25zLXVzYWdlICovXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VEaXNwYXRjaCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBDb2xsYXBzZSBmcm9tICdzcmMvY29tcG9uZW50cy9Db2xsYXBzZSc7XG5pbXBvcnQgQ2FyZCBmcm9tICdzcmMvY29tcG9uZW50cy9DYXJkJztcbmltcG9ydCBCdXR0b25Hcm91cCBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cCc7XG5pbXBvcnQgeyBjc3MsIHQsIHN0eWxlZCwgdXNlVGhlbWUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyByZW1vdmVEYXRhUHJldmlldywgcmVtb3ZlVGFibGVzLCBhZGREYW5nZXJUb2FzdCwgc3luY1RhYmxlLCB9IGZyb20gJ3NyYy9TcWxMYWIvYWN0aW9ucy9zcWxMYWInO1xuaW1wb3J0IHsgdGFibGVBcGlVdGlsLCB1c2VUYWJsZUV4dGVuZGVkTWV0YWRhdGFRdWVyeSwgdXNlVGFibGVNZXRhZGF0YVF1ZXJ5LCB9IGZyb20gJ3NyYy9ob29rcy9hcGlSZXNvdXJjZXMnO1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJ3NyYy9jb21wb25lbnRzL1Rvb2x0aXAnO1xuaW1wb3J0IENvcHlUb0NsaXBib2FyZCBmcm9tICdzcmMvY29tcG9uZW50cy9Db3B5VG9DbGlwYm9hcmQnO1xuaW1wb3J0IHsgSWNvblRvb2x0aXAgfSBmcm9tICdzcmMvY29tcG9uZW50cy9JY29uVG9vbHRpcCc7XG5pbXBvcnQgTW9kYWxUcmlnZ2VyIGZyb20gJ3NyYy9jb21wb25lbnRzL01vZGFsVHJpZ2dlcic7XG5pbXBvcnQgTG9hZGluZyBmcm9tICdzcmMvY29tcG9uZW50cy9Mb2FkaW5nJztcbmltcG9ydCB1c2VFZmZlY3RFdmVudCBmcm9tICdzcmMvaG9va3MvdXNlRWZmZWN0RXZlbnQnO1xuaW1wb3J0IEljb25zIGZyb20gJ3NyYy9jb21wb25lbnRzL0ljb25zJztcbmltcG9ydCBDb2x1bW5FbGVtZW50IGZyb20gJy4uL0NvbHVtbkVsZW1lbnQnO1xuaW1wb3J0IFNob3dTUUwgZnJvbSAnLi4vU2hvd1NRTCc7XG5jb25zdCBTdHlsZWRTcGFuID0gc3R5bGVkLnNwYW4gYFxuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMucHJpbWFyeS5kYXJrMX07XG4gICY6aG92ZXIge1xuICAgIGNvbG9yOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy5wcmltYXJ5LmRhcmsyfTtcbiAgfVxuICBjdXJzb3I6IHBvaW50ZXI7XG5gO1xuY29uc3QgRmFkZSA9IHN0eWxlZC5kaXYgYFxuICB0cmFuc2l0aW9uOiBhbGwgJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50cmFuc2l0aW9uVGltaW5nfXM7XG4gIG9wYWNpdHk6ICR7KHByb3BzKSA9PiAocHJvcHMuaG92ZXJlZCA/IDEgOiAwKX07XG5gO1xuY29uc3QgU3R5bGVkQ29sbGFwc2VQYW5lbCA9IHN0eWxlZChDb2xsYXBzZS5QYW5lbCkgYFxuICAkeyh7IHRoZW1lIH0pID0+IGNzcyBgXG4gICAgJiB7XG4gICAgICAud3MtZWwtY29udHJvbHMge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6ICR7LXRoZW1lLmdyaWRVbml0fXB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgfVxuXG4gICAgICAuaGVhZGVyLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuXG4gICAgICAgIC50YWJsZS1uYW1lIHtcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMubH1weDtcbiAgICAgICAgICBmbGV4OiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLmhlYWRlci1yaWdodC1zaWRlIHtcbiAgICAgICAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLmdyaWRVbml0ICogOH1weDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgYH1cbmA7XG5jb25zdCBUYWJsZUVsZW1lbnQgPSAoeyB0YWJsZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgZGJJZCwgY2F0YWxvZywgc2NoZW1hLCBuYW1lLCBleHBhbmRlZCB9ID0gdGFibGU7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICBjb25zdCB7IGN1cnJlbnREYXRhOiB0YWJsZU1ldGFkYXRhLCBpc1N1Y2Nlc3M6IGlzTWV0YWRhdGFTdWNjZXNzLCBpc0ZldGNoaW5nOiBpc01ldGFkYXRhRmV0Y2hpbmcsIGlzRXJyb3I6IGhhc01ldGFkYXRhRXJyb3IsIH0gPSB1c2VUYWJsZU1ldGFkYXRhUXVlcnkoe1xuICAgICAgICBkYklkLFxuICAgICAgICBjYXRhbG9nLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHRhYmxlOiBuYW1lLFxuICAgIH0sIHsgc2tpcDogIWV4cGFuZGVkIH0pO1xuICAgIGNvbnN0IHsgY3VycmVudERhdGE6IHRhYmxlRXh0ZW5kZWRNZXRhZGF0YSwgaXNTdWNjZXNzOiBpc0V4dHJhTWV0YWRhdGFTdWNjZXNzLCBpc0xvYWRpbmc6IGlzRXh0cmFNZXRhZGF0YUxvYWRpbmcsIGlzRXJyb3I6IGhhc0V4dGVuZGVkTWV0YWRhdGFFcnJvciwgfSA9IHVzZVRhYmxlRXh0ZW5kZWRNZXRhZGF0YVF1ZXJ5KHtcbiAgICAgICAgZGJJZCxcbiAgICAgICAgY2F0YWxvZyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0YWJsZTogbmFtZSxcbiAgICB9LCB7IHNraXA6ICFleHBhbmRlZCB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaGFzTWV0YWRhdGFFcnJvciB8fCBoYXNFeHRlbmRlZE1ldGFkYXRhRXJyb3IpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGFkZERhbmdlclRvYXN0KHQoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRhYmxlIG1ldGFkYXRhJykpKTtcbiAgICAgICAgfVxuICAgIH0sIFtoYXNNZXRhZGF0YUVycm9yLCBoYXNFeHRlbmRlZE1ldGFkYXRhRXJyb3IsIGRpc3BhdGNoXSk7XG4gICAgY29uc3QgdGFibGVEYXRhID0ge1xuICAgICAgICAuLi50YWJsZU1ldGFkYXRhLFxuICAgICAgICAuLi50YWJsZUV4dGVuZGVkTWV0YWRhdGEsXG4gICAgfTtcbiAgICAvLyBUT0RPOiBtaWdyYXRlIHN5bmNUYWJsZSBsb2dpYyBieSBTSVAtOTNcbiAgICBjb25zdCBzeW5jVGFibGVNZXRhZGF0YSA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsaXplZCB9ID0gdGFibGU7XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN5bmNUYWJsZSh0YWJsZSwgdGFibGVEYXRhKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaXNNZXRhZGF0YVN1Y2Nlc3MgJiYgaXNFeHRyYU1ldGFkYXRhU3VjY2Vzcykge1xuICAgICAgICAgICAgc3luY1RhYmxlTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc01ldGFkYXRhU3VjY2VzcywgaXNFeHRyYU1ldGFkYXRhU3VjY2Vzcywgc3luY1RhYmxlTWV0YWRhdGFdKTtcbiAgICBjb25zdCBbc29ydENvbHVtbnMsIHNldFNvcnRDb2x1bW5zXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaG92ZXJlZCwgc2V0SG92ZXJlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgdGFibGVOYW1lUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNldEhvdmVyID0gKGhvdmVyZWQpID0+IHtcbiAgICAgICAgZGVib3VuY2UoKCkgPT4gc2V0SG92ZXJlZChob3ZlcmVkKSwgMTAwKSgpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlVGFibGUgPSAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHJlbW92ZURhdGFQcmV2aWV3KHRhYmxlKSk7XG4gICAgICAgIGRpc3BhdGNoKHJlbW92ZVRhYmxlcyhbdGFibGVdKSk7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVTb3J0Q29sdW1ucyA9ICgpID0+IHtcbiAgICAgICAgc2V0U29ydENvbHVtbnMocHJldlN0YXRlID0+ICFwcmV2U3RhdGUpO1xuICAgIH07XG4gICAgY29uc3QgcmVmcmVzaFRhYmxlTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHRhYmxlQXBpVXRpbC5pbnZhbGlkYXRlVGFncyhbeyB0eXBlOiAnVGFibGVNZXRhZGF0YXMnLCBpZDogbmFtZSB9XSkpO1xuICAgICAgICBkaXNwYXRjaChzeW5jVGFibGUodGFibGUsIHRhYmxlRGF0YSkpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyV2VsbCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHBhcnRpdGlvbnM7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgaWYgKHRhYmxlRGF0YS5wYXJ0aXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgcGFydGl0aW9uUXVlcnk7XG4gICAgICAgICAgICBsZXQgcGFydGl0aW9uQ2xpcEJvYXJkO1xuICAgICAgICAgICAgaWYgKHRhYmxlRGF0YS5wYXJ0aXRpb25zLnBhcnRpdGlvblF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgKHsgcGFydGl0aW9uUXVlcnkgfSA9IHRhYmxlRGF0YS5wYXJ0aXRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0dCA9IHQoJ0NvcHkgcGFydGl0aW9uIHF1ZXJ5IHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbkNsaXBCb2FyZCA9ICg8Q29weVRvQ2xpcGJvYXJkIHRleHQ9e3BhcnRpdGlvblF1ZXJ5fSBzaG91bGRTaG93VGV4dD17ZmFsc2V9IHRvb2x0aXBUZXh0PXt0dH0gY29weU5vZGU9ezxJY29ucy5Db3B5T3V0bGluZWQgaWNvblNpemU9XCJzXCIvPn0vPik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXRlc3QgPSBPYmplY3QuZW50cmllcyh0YWJsZURhdGEucGFydGl0aW9ucz8ubGF0ZXN0IHx8IFtdKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0ke3ZhbHVlfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIHBhcnRpdGlvbnMgPSAoPGRpdj5cbiAgICAgICAgICA8c21hbGw+XG4gICAgICAgICAgICB7dCgnbGF0ZXN0IHBhcnRpdGlvbjonKX0ge2xhdGVzdH1cbiAgICAgICAgICA8L3NtYWxsPnsnICd9XG4gICAgICAgICAge3BhcnRpdGlvbkNsaXBCb2FyZH1cbiAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFibGVEYXRhLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IE9iamVjdC5lbnRyaWVzKHRhYmxlRGF0YS5tZXRhZGF0YSkubWFwKChba2V5LCB2YWx1ZV0pID0+ICg8ZGl2PlxuICAgICAgICAgIDxzbWFsbD5cbiAgICAgICAgICAgIDxzdHJvbmc+e2tleX06PC9zdHJvbmc+IHt2YWx1ZX1cbiAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICA8L2Rpdj4pKTtcbiAgICAgICAgICAgIGlmICghbWV0YWRhdGE/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGhpZGUgbWV0YWRhdGEgY2FyZCB2aWV3XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJ0aXRpb25zKSB7XG4gICAgICAgICAgICAvLyBoaWRlIHBhcnRpdGlvbiBjYXJkIHZpZXdcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPENhcmQgc2l6ZT1cInNtYWxsXCI+XG4gICAgICAgIHtwYXJ0aXRpb25zfVxuICAgICAgICB7bWV0YWRhdGF9XG4gICAgICA8L0NhcmQ+KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckNvbnRyb2xzID0gKCkgPT4ge1xuICAgICAgICBsZXQga2V5TGluaztcbiAgICAgICAgY29uc3QgS0VZU19GT1JfVEFCTEVfVEVYVCA9IHQoJ0tleXMgZm9yIHRhYmxlJyk7XG4gICAgICAgIGlmICh0YWJsZURhdGE/LmluZGV4ZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAga2V5TGluayA9ICg8TW9kYWxUcmlnZ2VyIG1vZGFsVGl0bGU9e2Ake0tFWVNfRk9SX1RBQkxFX1RFWFR9ICR7bmFtZX1gfSBtb2RhbEJvZHk9e3RhYmxlRGF0YS5pbmRleGVzLm1hcCgoaXgsIGkpID0+ICg8cHJlIGtleT17aX0+e0pTT04uc3RyaW5naWZ5KGl4LCBudWxsLCAnICAnKX08L3ByZT4pKX0gdHJpZ2dlck5vZGU9ezxJY29uVG9vbHRpcCBjbGFzc05hbWU9XCJwdWxsLWxlZnQgbS1sLTJcIiB0b29sdGlwPXt0KCdWaWV3IGtleXMgJiBpbmRleGVzICglcyknLCB0YWJsZURhdGEuaW5kZXhlcy5sZW5ndGgpfT5cbiAgICAgICAgICAgICAgPEljb25zLktleU91dGxpbmVkIGljb25TaXplPVwic1wiLz5cbiAgICAgICAgICAgIDwvSWNvblRvb2x0aXA+fS8+KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxCdXR0b25Hcm91cCBjc3M9e2NzcyBgXG4gICAgICAgICAgY29sdW1uLWdhcDogJHt0aGVtZS5ncmlkVW5pdCAqIDEuNX1weDtcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuZ3JpZFVuaXR9cHg7XG4gICAgICAgICAgJiBzcGFuIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgIHdpZHRoOiAke3RoZW1lLmdyaWRVbml0ICogNH1weDtcbiAgICAgICAgICB9XG4gICAgICAgIGB9PlxuICAgICAgICA8SWNvblRvb2x0aXAgY2xhc3NOYW1lPVwicHVsbC1sZWZ0IG0tbC0yIHBvaW50ZXJcIiBvbkNsaWNrPXtyZWZyZXNoVGFibGVNZXRhZGF0YX0gdG9vbHRpcD17dCgnUmVmcmVzaCB0YWJsZSBzY2hlbWEnKX0+XG4gICAgICAgICAgPEljb25zLlN5bmNPdXRsaW5lZCBpY29uU2l6ZT1cIm1cIiBpY29uQ29sb3I9e3RoZW1lLmNvbG9ycy5wcmltYXJ5LmRhcmsyfS8+XG4gICAgICAgIDwvSWNvblRvb2x0aXA+XG4gICAgICAgIHtrZXlMaW5rfVxuICAgICAgICA8SWNvblRvb2x0aXAgY2xhc3NOYW1lPXtgZmEgZmEtc29ydC0ke3NvcnRDb2x1bW5zID8gJ251bWVyaWMnIDogJ2FscGhhJ30tYXNjIGAgK1xuICAgICAgICAgICAgICAgICdwdWxsLWxlZnQgc29ydC1jb2xzIG0tbC0yIHBvaW50ZXInfSBvbkNsaWNrPXt0b2dnbGVTb3J0Q29sdW1uc30gdG9vbHRpcD17c29ydENvbHVtbnNcbiAgICAgICAgICAgICAgICA/IHQoJ09yaWdpbmFsIHRhYmxlIGNvbHVtbiBvcmRlcicpXG4gICAgICAgICAgICAgICAgOiB0KCdTb3J0IGNvbHVtbnMgYWxwaGFiZXRpY2FsbHknKX0vPlxuICAgICAgICB7dGFibGVEYXRhLnNlbGVjdFN0YXIgJiYgKDxDb3B5VG9DbGlwYm9hcmQgY29weU5vZGU9ezxJY29uVG9vbHRpcCBhcmlhLWxhYmVsPVwiQ29weVwiIHRvb2x0aXA9e3QoJ0NvcHkgU0VMRUNUIHN0YXRlbWVudCB0byB0aGUgY2xpcGJvYXJkJyl9PlxuICAgICAgICAgICAgICAgIDxJY29ucy5Db3B5T3V0bGluZWQgaWNvblNpemU9XCJtXCIgaWNvbkNvbG9yPXt0aGVtZS5jb2xvcnMucHJpbWFyeS5kYXJrMn0gYXJpYS1oaWRkZW4vPlxuICAgICAgICAgICAgICA8L0ljb25Ub29sdGlwPn0gdGV4dD17dGFibGVEYXRhLnNlbGVjdFN0YXJ9IHNob3VsZFNob3dUZXh0PXtmYWxzZX0vPil9XG4gICAgICAgIHt0YWJsZURhdGEudmlldyAmJiAoPFNob3dTUUwgc3FsPXt0YWJsZURhdGEudmlld30gdG9vbHRpcFRleHQ9e3QoJ1Nob3cgQ1JFQVRFIFZJRVcgc3RhdGVtZW50Jyl9IHRpdGxlPXt0KCdDUkVBVEUgVklFVyBzdGF0ZW1lbnQnKX0vPil9XG4gICAgICAgIDxJY29uVG9vbHRpcCBjbGFzc05hbWU9XCIgdGFibGUtcmVtb3ZlIHB1bGwtbGVmdCBtLWwtMiBwb2ludGVyXCIgb25DbGljaz17cmVtb3ZlVGFibGV9IHRvb2x0aXA9e3QoJ1JlbW92ZSB0YWJsZSBwcmV2aWV3Jyl9PlxuICAgICAgICAgIDxJY29ucy5DbG9zZU91dGxpbmVkIGljb25TaXplPVwibVwiIGljb25Db2xvcj17dGhlbWUuY29sb3JzLnByaW1hcnkuZGFyazJ9IGFyaWEtaGlkZGVuLz5cbiAgICAgICAgPC9JY29uVG9vbHRpcD5cbiAgICAgIDwvQnV0dG9uR3JvdXA+KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckhlYWRlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRhYmxlTmFtZVJlZi5jdXJyZW50O1xuICAgICAgICBsZXQgdHJpZ2dlciA9IFtdO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm9mZnNldFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgdHJpZ2dlciA9IFsnaG92ZXInXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxkaXYgZGF0YS10ZXN0PVwidGFibGUtZWxlbWVudC1oZWFkZXItY29udGFpbmVyXCIgY2xhc3NOYW1lPVwiY2xlYXJmaXggaGVhZGVyLWNvbnRhaW5lclwiIG9uTW91c2VFbnRlcj17KCkgPT4gc2V0SG92ZXIodHJ1ZSl9IG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0SG92ZXIoZmFsc2UpfT5cbiAgICAgICAgPFRvb2x0aXAgaWQ9XCJjb3B5LXRvLWNsaXBib2FyZC10b29sdGlwXCIgc3R5bGU9e3sgY3Vyc29yOiAncG9pbnRlcicgfX0gdGl0bGU9e25hbWV9IHRyaWdnZXI9e3RyaWdnZXJ9PlxuICAgICAgICAgIDxTdHlsZWRTcGFuIGRhdGEtdGVzdD1cImNvbGxhcHNlXCIgcmVmPXt0YWJsZU5hbWVSZWZ9IGNsYXNzTmFtZT1cInRhYmxlLW5hbWVcIj5cbiAgICAgICAgICAgIDxzdHJvbmc+e25hbWV9PC9zdHJvbmc+XG4gICAgICAgICAgPC9TdHlsZWRTcGFuPlxuICAgICAgICA8L1Rvb2x0aXA+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0IGhlYWRlci1yaWdodC1zaWRlXCI+XG4gICAgICAgICAge2lzTWV0YWRhdGFGZXRjaGluZyB8fCBpc0V4dHJhTWV0YWRhdGFMb2FkaW5nID8gKDxMb2FkaW5nIHBvc2l0aW9uPVwiaW5saW5lXCIvPikgOiAoPEZhZGUgZGF0YS10ZXN0PVwiZmFkZVwiIGhvdmVyZWQ9e2hvdmVyZWR9IG9uQ2xpY2s9e2UgPT4gZS5zdG9wUHJvcGFnYXRpb24oKX0+XG4gICAgICAgICAgICAgIHtyZW5kZXJDb250cm9scygpfVxuICAgICAgICAgICAgPC9GYWRlPil9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlckJvZHkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBjb2xzO1xuICAgICAgICBpZiAodGFibGVEYXRhLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIGNvbHMgPSB0YWJsZURhdGEuY29sdW1ucy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHNvcnRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgY29scy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbEEgPSBhLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sQiA9IGIubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sQSA8IGNvbEIgPyAtMSA6IGNvbEEgPiBjb2xCID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSAoPGRpdiBkYXRhLXRlc3Q9XCJ0YWJsZS1lbGVtZW50XCIgb25Nb3VzZUVudGVyPXsoKSA9PiBzZXRIb3Zlcih0cnVlKX0gb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRIb3ZlcihmYWxzZSl9IGNzcz17eyBwYWRkaW5nVG9wOiA2IH19PlxuICAgICAgICB7cmVuZGVyV2VsbCgpfVxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIHtjb2xzPy5tYXAoY29sID0+IDxDb2x1bW5FbGVtZW50IGNvbHVtbj17Y29sfSBrZXk9e2NvbC5uYW1lfS8+KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj4pO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gKDxTdHlsZWRDb2xsYXBzZVBhbmVsIHsuLi5wcm9wc30ga2V5PXt0YWJsZS5pZH0gaGVhZGVyPXtyZW5kZXJIZWFkZXIoKX0gY2xhc3NOYW1lPVwiVGFibGVFbGVtZW50XCIgZm9yY2VSZW5kZXI+XG4gICAgICB7cmVuZGVyQm9keSgpfVxuICAgIDwvU3R5bGVkQ29sbGFwc2VQYW5lbD4pO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRhYmxlRWxlbWVudDtcbiJdfQ== */\", toString: _EMOTION_STRINGIFIED_CSS_ERROR__ };\nconst TableElement = ({ table, ...props }) => {\n  const { dbId, catalog, schema, name, expanded } = table;\n  const theme = useTheme();\n  const dispatch = useDispatch();\n  const { currentData: tableMetadata, isSuccess: isMetadataSuccess, isFetching: isMetadataFetching, isError: hasMetadataError } = useTableMetadataQuery({\n    dbId,\n    catalog,\n    schema,\n    table: name\n  }, { skip: !expanded });\n  const { currentData: tableExtendedMetadata, isSuccess: isExtraMetadataSuccess, isLoading: isExtraMetadataLoading, isError: hasExtendedMetadataError } = useTableExtendedMetadataQuery({\n    dbId,\n    catalog,\n    schema,\n    table: name\n  }, { skip: !expanded });\n  useEffect(() => {\n    if (hasMetadataError || hasExtendedMetadataError) {\n      dispatch(addDangerToast(t('An error occurred while fetching table metadata')));\n    }\n  }, [hasMetadataError, hasExtendedMetadataError, dispatch]);\n  const tableData = {\n    ...tableMetadata,\n    ...tableExtendedMetadata\n  };\n  // TODO: migrate syncTable logic by SIP-93\n  const syncTableMetadata = useEffectEvent(() => {\n    const { initialized } = table;\n    if (!initialized) {\n      dispatch(syncTable(table, tableData));\n    }\n  });\n  useEffect(() => {\n    if (isMetadataSuccess && isExtraMetadataSuccess) {\n      syncTableMetadata();\n    }\n  }, [isMetadataSuccess, isExtraMetadataSuccess, syncTableMetadata]);\n  const [sortColumns, setSortColumns] = useState(false);\n  const [hovered, setHovered] = useState(false);\n  const tableNameRef = useRef(null);\n  const setHover = (hovered) => {\n    _debounce(() => setHovered(hovered), 100)();\n  };\n  const removeTable = () => {\n    dispatch(removeDataPreview(table));\n    dispatch(removeTables([table]));\n  };\n  const toggleSortColumns = () => {\n    setSortColumns((prevState) => !prevState);\n  };\n  const refreshTableMetadata = () => {\n    dispatch(tableApiUtil.invalidateTags([{ type: 'TableMetadatas', id: name }]));\n    dispatch(syncTable(table, tableData));\n  };\n  const renderWell = () => {\n    let partitions;\n    let metadata;\n    if (tableData.partitions) {var _tableData$partitions;\n      let partitionQuery;\n      let partitionClipBoard;\n      if (tableData.partitions.partitionQuery) {\n        ({ partitionQuery } = tableData.partitions);\n        const tt = t('Copy partition query to clipboard');\n        partitionClipBoard = _jsx(CopyToClipboard, { text: partitionQuery, shouldShowText: false, tooltipText: tt, copyNode: _jsx(Icons.CopyOutlined, { iconSize: \"s\" }) });\n      }\n      const latest = Object.entries(((_tableData$partitions = tableData.partitions) == null ? void 0 : _tableData$partitions.latest) || []).\n      map(([key, value]) => `${key}=${value}`).\n      join('/');\n      partitions = _jsxs(\"div\", { children: [\n        _jsxs(\"small\", { children: [\n          t('latest partition:'), \" \", latest] }\n        ), ' ',\n        partitionClipBoard] }\n      );\n    }\n    if (tableData.metadata) {var _metadata;\n      metadata = Object.entries(tableData.metadata).map(([key, value]) => _jsx(\"div\", { children:\n        _jsxs(\"small\", { children: [\n          _jsxs(\"strong\", { children: [key, \":\"] }), \" \", value] }\n        ) }\n      ));\n      if (!((_metadata = metadata) != null && _metadata.length)) {\n        // hide metadata card view\n        return null;\n      }\n    }\n    if (!partitions) {\n      // hide partition card view\n      return null;\n    }\n    return _jsxs(Card, { size: \"small\", children: [\n      partitions,\n      metadata] }\n    );\n  };\n  const renderControls = () => {var _tableData$indexes;\n    let keyLink;\n    const KEYS_FOR_TABLE_TEXT = t('Keys for table');\n    if (tableData != null && (_tableData$indexes = tableData.indexes) != null && _tableData$indexes.length) {\n      keyLink = _jsx(ModalTrigger, { modalTitle: `${KEYS_FOR_TABLE_TEXT} ${name}`, modalBody: tableData.indexes.map((ix, i) => _jsx(\"pre\", { children: JSON.stringify(ix, null, '  ') }, i)), triggerNode: _jsx(IconTooltip, { className: \"pull-left m-l-2\", tooltip: t('View keys & indexes (%s)', tableData.indexes.length), children:\n          _jsx(Icons.KeyOutlined, { iconSize: \"s\" }) }\n        ) });\n    }\n    return _jsxs(ButtonGroup, { css: css`\n          column-gap: ${theme.gridUnit * 1.5}px;\n          margin-right: ${theme.gridUnit}px;\n          & span {\n            display: flex;\n            justify-content: center;\n            width: ${theme.gridUnit * 4}px;\n          }\n        `, children: [\n      _jsx(IconTooltip, { className: \"pull-left m-l-2 pointer\", onClick: refreshTableMetadata, tooltip: t('Refresh table schema'), children:\n        _jsx(Icons.SyncOutlined, { iconSize: \"m\", iconColor: theme.colors.primary.dark2 }) }\n      ),\n      keyLink,\n      _jsx(IconTooltip, { className: `fa fa-sort-${sortColumns ? 'numeric' : 'alpha'}-asc ` +\n        'pull-left sort-cols m-l-2 pointer', onClick: toggleSortColumns, tooltip: sortColumns ?\n        t('Original table column order') :\n        t('Sort columns alphabetically') }),\n      tableData.selectStar && _jsx(CopyToClipboard, { copyNode: _jsx(IconTooltip, { \"aria-label\": \"Copy\", tooltip: t('Copy SELECT statement to the clipboard'), children:\n          _jsx(Icons.CopyOutlined, { iconSize: \"m\", iconColor: theme.colors.primary.dark2, \"aria-hidden\": true }) }\n        ), text: tableData.selectStar, shouldShowText: false }),\n      tableData.view && _jsx(ShowSQL, { sql: tableData.view, tooltipText: t('Show CREATE VIEW statement'), title: t('CREATE VIEW statement') }),\n      _jsx(IconTooltip, { className: \" table-remove pull-left m-l-2 pointer\", onClick: removeTable, tooltip: t('Remove table preview'), children:\n        _jsx(Icons.CloseOutlined, { iconSize: \"m\", iconColor: theme.colors.primary.dark2, \"aria-hidden\": true }) }\n      )] }\n    );\n  };\n  const renderHeader = () => {\n    const element = tableNameRef.current;\n    let trigger = [];\n    if (element && element.offsetWidth < element.scrollWidth) {\n      trigger = ['hover'];\n    }\n    return _jsxs(\"div\", { className: \"clearfix header-container\", onMouseEnter: () => setHover(true), onMouseLeave: () => setHover(false), children: [\n      _jsx(Tooltip, { id: \"copy-to-clipboard-tooltip\", style: { cursor: 'pointer' }, title: name, trigger: trigger, children:\n        _jsx(StyledSpan, { ref: tableNameRef, className: \"table-name\", children:\n          _jsx(\"strong\", { children: name }) }\n        ) }\n      ),\n\n      _jsx(\"div\", { className: \"pull-right header-right-side\", children:\n        isMetadataFetching || isExtraMetadataLoading ? _jsx(Loading, { position: \"inline\" }) : _jsx(Fade, { hovered: hovered, onClick: (e) => e.stopPropagation(), children:\n          renderControls() }\n        ) }\n      )] }\n    );\n  };\n  const renderBody = () => {var _cols;\n    let cols;\n    if (tableData.columns) {\n      cols = tableData.columns.slice();\n      if (sortColumns) {\n        cols.sort((a, b) => {\n          const colA = a.name.toUpperCase();\n          const colB = b.name.toUpperCase();\n          return colA < colB ? -1 : colA > colB ? 1 : 0;\n        });\n      }\n    }\n    const metadata = _jsxs(\"div\", { onMouseEnter: () => setHover(true), onMouseLeave: () => setHover(false), css: _ref, children: [\n      renderWell(),\n      _jsx(\"div\", { children: (_cols =\n        cols) == null ? void 0 : _cols.map((col) => _jsx(ColumnElement, { column: col }, col.name)) }\n      )] }\n    );\n    return metadata;\n  };\n  return _createElement(StyledCollapsePanel, { ...props, key: table.id, header: renderHeader(), className: \"TableElement\", forceRender: true },\n  renderBody()\n  );\n};\nexport default TableElement;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}