{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useMemo, useState, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport { styled, t, usePrevious, css } from '@superset-ui/core';\nimport { useSelector } from 'react-redux';\nimport { LineEditableTabs } from 'src/components/Tabs';\nimport Icons from 'src/components/Icons';\nimport { LOG_ACTIONS_SELECT_DASHBOARD_TAB } from 'src/logger/LogUtils';\nimport Modal from 'src/components/Modal';\nimport { DROP_LEFT, DROP_RIGHT } from 'src/dashboard/util/getDropPosition';\nimport { Draggable } from '../dnd/DragDroppable';\nimport DragHandle from '../dnd/DragHandle';\nimport DashboardComponent from '../../containers/DashboardComponent';\nimport DeleteComponentButton from '../DeleteComponentButton';\nimport HoverMenu from '../menu/HoverMenu';\nimport findTabIndexByComponentId from '../../util/findTabIndexByComponentId';\nimport getDirectPathToTabIndex from '../../util/getDirectPathToTabIndex';\nimport getLeafComponentIdFromPath from '../../util/getLeafComponentIdFromPath';\nimport { componentShape } from '../../util/propShapes';\nimport { NEW_TAB_ID } from '../../util/constants';\nimport { RENDER_TAB, RENDER_TAB_CONTENT } from './Tab';\nimport { TABS_TYPE, TAB_TYPE } from '../../util/componentTypes';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nconst propTypes = {\n  id: PropTypes.string.isRequired,\n  parentId: PropTypes.string.isRequired,\n  component: componentShape.isRequired,\n  parentComponent: componentShape.isRequired,\n  index: PropTypes.number.isRequired,\n  depth: PropTypes.number.isRequired,\n  renderTabContent: PropTypes.bool, // whether to render tabs + content or just tabs\n  editMode: PropTypes.bool.isRequired,\n  renderHoverMenu: PropTypes.bool,\n  activeTabs: PropTypes.arrayOf(PropTypes.string),\n\n  // actions (from DashboardComponent.jsx)\n  logEvent: PropTypes.func.isRequired,\n  setActiveTab: PropTypes.func,\n\n  // grid related\n  availableColumnCount: PropTypes.number,\n  columnWidth: PropTypes.number,\n  onResizeStart: PropTypes.func,\n  onResize: PropTypes.func,\n  onResizeStop: PropTypes.func,\n\n  // dnd\n  createComponent: PropTypes.func.isRequired,\n  handleComponentDrop: PropTypes.func.isRequired,\n  onChangeTab: PropTypes.func.isRequired,\n  deleteComponent: PropTypes.func.isRequired,\n  updateComponents: PropTypes.func.isRequired\n};\n\nconst defaultProps = {\n  setActiveTab() {},\n  onResizeStart() {},\n  onResize() {},\n  onResizeStop() {}\n};\n\nconst StyledTabsContainer = styled.div`\n  ${({ theme }) => css`\n    width: 100%;\n    background-color: ${theme.colors.grayscale.light5};\n\n    .dashboard-component-tabs-content {\n      min-height: ${theme.gridUnit * 12}px;\n      margin-top: ${theme.gridUnit / 4}px;\n      position: relative;\n    }\n\n    .ant-tabs {\n      overflow: visible;\n\n      .ant-tabs-nav-wrap {\n        min-height: ${theme.gridUnit * 12.5}px;\n      }\n\n      .ant-tabs-content-holder {\n        overflow: visible;\n      }\n    }\n\n    div .ant-tabs-tab-btn {\n      text-transform: none;\n    }\n  `}\n`;\nconst DropIndicator = styled.div`\n  border: 2px solid ${({ theme }) => theme.colors.primary.base};\n  width: 5px;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  ${({ pos }) => pos === 'left' ? 'left: -4px' : 'right: -4px'};\n  border-radius: 2px;\n`;\n\nconst CloseIconWithDropIndicator = (props) =>\n_jsxs(_Fragment, { children: [\n  _jsx(Icons.CloseOutlined, { iconSize: \"s\" }),\n  props.showDropIndicators.right &&\n  _jsx(DropIndicator, { className: \"drop-indicator-right\", pos: \"right\" })] }\n\n);\n\n\nconst Tabs = (props) => {\n  const nativeFilters = useSelector((state) => state.nativeFilters);\n  const activeTabs = useSelector((state) => state.dashboardState.activeTabs);\n  const directPathToChild = useSelector(\n    (state) => state.dashboardState.directPathToChild\n  );\n\n  const { tabIndex: initTabIndex, activeKey: initActiveKey } = useMemo(() => {\n    let tabIndex = Math.max(\n      0,\n      findTabIndexByComponentId({\n        currentComponent: props.component,\n        directPathToChild\n      })\n    );\n    if (tabIndex === 0 && activeTabs != null && activeTabs.length) {\n      props.component.children.forEach((tabId, index) => {\n        if (tabIndex === 0 && activeTabs != null && activeTabs.includes(tabId)) {\n          tabIndex = index;\n        }\n      });\n    }\n    const { children: tabIds } = props.component;\n    const activeKey = tabIds[tabIndex];\n\n    return {\n      tabIndex,\n      activeKey\n    };\n  }, [activeTabs, props.component, directPathToChild]);\n\n  const [activeKey, setActiveKey] = useState(initActiveKey);\n  const [selectedTabIndex, setSelectedTabIndex] = useState(initTabIndex);\n  const [dropPosition, setDropPosition] = useState(null);\n  const [dragOverTabIndex, setDragOverTabIndex] = useState(null);\n  const [draggingTabId, setDraggingTabId] = useState(null);\n  const prevActiveKey = usePrevious(activeKey);\n  const prevDashboardId = usePrevious(props.dashboardId);\n  const prevDirectPathToChild = usePrevious(directPathToChild);\n  const prevTabIds = usePrevious(props.component.children);\n\n  useEffect(() => {\n    if (prevActiveKey) {\n      props.setActiveTab(activeKey, prevActiveKey);\n    } else {\n      props.setActiveTab(activeKey);\n    }\n  }, [props.setActiveTab, prevActiveKey, activeKey]);\n\n  useEffect(() => {\n    if (prevDashboardId && props.dashboardId !== prevDashboardId) {\n      setSelectedTabIndex(initTabIndex);\n      setActiveKey(initActiveKey);\n    }\n  }, [props.dashboardId, prevDashboardId, initTabIndex, initActiveKey]);\n\n  useEffect(() => {\n    const maxIndex = Math.max(0, props.component.children.length - 1);\n    if (selectedTabIndex > maxIndex) {\n      setSelectedTabIndex(maxIndex);\n    }\n  }, [selectedTabIndex, props.component.children.length, setSelectedTabIndex]);\n\n  useEffect(() => {\n    const currTabsIds = props.component.children;\n\n    if (props.isComponentVisible) {\n      const nextFocusComponent = getLeafComponentIdFromPath(directPathToChild);\n      const currentFocusComponent = getLeafComponentIdFromPath(\n        prevDirectPathToChild\n      );\n\n      // If the currently selected component is different than the new one,\n      // or the tab length/order changed, calculate the new tab index and\n      // replace it if it's different than the current one\n      if (\n      nextFocusComponent !== currentFocusComponent ||\n      nextFocusComponent === currentFocusComponent &&\n      currTabsIds !== prevTabIds)\n      {\n        const nextTabIndex = findTabIndexByComponentId({\n          currentComponent: props.component,\n          directPathToChild\n        });\n\n        // make sure nextFocusComponent is under this tabs component\n        if (nextTabIndex > -1 && nextTabIndex !== selectedTabIndex) {\n          setSelectedTabIndex(nextTabIndex);\n          setActiveKey(currTabsIds[nextTabIndex]);\n        }\n      }\n    }\n  }, [\n  props.component,\n  directPathToChild,\n  props.isComponentVisible,\n  selectedTabIndex,\n  prevDirectPathToChild,\n  prevTabIds]\n  );\n\n  const handleClickTab = useCallback(\n    (tabIndex) => {\n      const { component } = props;\n      const { children: tabIds } = component;\n\n      if (tabIndex !== selectedTabIndex) {\n        const pathToTabIndex = getDirectPathToTabIndex(component, tabIndex);\n        const targetTabId = pathToTabIndex[pathToTabIndex.length - 1];\n        props.logEvent(LOG_ACTIONS_SELECT_DASHBOARD_TAB, {\n          target_id: targetTabId,\n          index: tabIndex\n        });\n\n        props.onChangeTab({ pathToTabIndex });\n      }\n      setActiveKey(tabIds[tabIndex]);\n    },\n    [\n    props.component,\n    props.logEvent,\n    props.onChangeTab,\n    selectedTabIndex,\n    setActiveKey]\n\n  );\n\n  const handleDropOnTab = useCallback(\n    (dropResult) => {\n      const { component } = props;\n\n      // Ensure dropped tab is visible\n      const { destination } = dropResult;\n      if (destination) {\n        const dropTabIndex =\n        destination.id === component.id ?\n        destination.index // dropped ON tabs\n        : component.children.indexOf(destination.id); // dropped IN tab\n\n        if (dropTabIndex > -1) {\n          setTimeout(() => {\n            handleClickTab(dropTabIndex);\n          }, 30);\n        }\n      }\n    },\n    [props.component, handleClickTab]\n  );\n\n  const handleDrop = useCallback(\n    (dropResult) => {\n      if (dropResult.dragging.type !== TABS_TYPE) {\n        props.handleComponentDrop(dropResult);\n      }\n    },\n    [props.handleComponentDrop]\n  );\n\n  const handleDeleteTab = useCallback(\n    (tabIndex) => {\n      // If we're removing the currently selected tab,\n      // select the previous one (if any)\n      if (selectedTabIndex === tabIndex) {\n        handleClickTab(Math.max(0, tabIndex - 1));\n      }\n    },\n    [selectedTabIndex, handleClickTab]\n  );\n\n  const showDeleteConfirmModal = useCallback(\n    (key) => {\n      const { component, deleteComponent } = props;\n      Modal.confirm({\n        title: t('Delete dashboard tab?'),\n        content:\n        _jsxs(\"span\", { children: [\n          t(\n            'Deleting a tab will remove all content within it and will deactivate any related alerts or reports. You may still ' +\n            'reverse this action with the'\n          ), ' ',\n          _jsx(\"b\", { children: t('undo') }), ' ',\n          t('button (cmd + z) until you save your changes.')] }\n        ),\n\n        onOk: () => {\n          deleteComponent(key, component.id);\n          const tabIndex = component.children.indexOf(key);\n          handleDeleteTab(tabIndex);\n        },\n        okType: 'danger',\n        okText: t('DELETE'),\n        cancelText: t('CANCEL'),\n        icon: null\n      });\n    },\n    [props.component, props.deleteComponent, handleDeleteTab]\n  );\n\n  const handleEdit = useCallback(\n    (event, action) => {\n      const { component, createComponent } = props;\n      if (action === 'add') {\n        // Prevent the tab container to be selected\n        event == null ? void 0 : event.stopPropagation == null ? void 0 : event.stopPropagation();\n\n        createComponent({\n          destination: {\n            id: component.id,\n            type: component.type,\n            index: component.children.length\n          },\n          dragging: {\n            id: NEW_TAB_ID,\n            type: TAB_TYPE\n          }\n        });\n      } else if (action === 'remove') {\n        showDeleteConfirmModal(event);\n      }\n    },\n    [props.component, props.createComponent, showDeleteConfirmModal]\n  );\n\n  const handleDeleteComponent = useCallback(() => {\n    const { deleteComponent, id, parentId } = props;\n    deleteComponent(id, parentId);\n  }, [props.deleteComponent, props.id, props.parentId]);\n\n  const handleGetDropPosition = useCallback((dragObject) => {\n    const { dropIndicator, isDraggingOver, index } = dragObject;\n\n    if (isDraggingOver) {\n      setDropPosition(dropIndicator);\n      setDragOverTabIndex(index);\n    } else {\n      setDropPosition(null);\n    }\n  }, []);\n\n  const handleDragggingTab = useCallback((tabId) => {\n    if (tabId) {\n      setDraggingTabId(tabId);\n    } else {\n      setDraggingTabId(null);\n    }\n  }, []);\n\n  const {\n    depth,\n    component: tabsComponent,\n    parentComponent,\n    index,\n    availableColumnCount = 0,\n    columnWidth = 0,\n    onResizeStart,\n    onResize,\n    onResizeStop,\n    renderTabContent = true,\n    renderHoverMenu = true,\n    isComponentVisible: isCurrentTabVisible,\n    editMode\n  } = props;\n\n  const { children: tabIds } = tabsComponent;\n\n  const showDropIndicators = useCallback(\n    (currentDropTabIndex) =>\n    currentDropTabIndex === dragOverTabIndex && {\n      left: editMode && dropPosition === DROP_LEFT,\n      right: editMode && dropPosition === DROP_RIGHT\n    },\n    [dragOverTabIndex, dropPosition, editMode]\n  );\n\n  const removeDraggedTab = useCallback(\n    (tabID) => draggingTabId === tabID,\n    [draggingTabId]\n  );\n\n  let tabsToHighlight;\n  const highlightedFilterId =\n  (nativeFilters == null ? void 0 : nativeFilters.focusedFilterId) || (nativeFilters == null ? void 0 : nativeFilters.hoveredFilterId);\n  if (highlightedFilterId) {var _nativeFilters$filter;\n    tabsToHighlight = (_nativeFilters$filter = nativeFilters.filters[highlightedFilterId]) == null ? void 0 : _nativeFilters$filter.tabsInScope;\n  }\n\n  const renderChild = useCallback(\n    ({ dragSourceRef: tabsDragSourceRef }) =>\n    _jsxs(StyledTabsContainer, {\n      className: \"dashboard-component dashboard-component-tabs\", children: [\n\n\n      editMode && renderHoverMenu &&\n      _jsxs(HoverMenu, { innerRef: tabsDragSourceRef, position: \"left\", children: [\n        _jsx(DragHandle, { position: \"left\" }),\n        _jsx(DeleteComponentButton, { onDelete: handleDeleteComponent })] }\n      ),\n\n\n      _jsx(LineEditableTabs, {\n        id: tabsComponent.id,\n        activeKey: activeKey,\n        onChange: (key) => {\n          handleClickTab(tabIds.indexOf(key));\n        },\n        onEdit: handleEdit,\n\n        type: editMode ? 'editable-card' : 'card', children:\n\n        tabIds.map((tabId, tabIndex) => {var _tabsToHighlight;return (\n            _jsx(LineEditableTabs.TabPane, {\n\n              tab:\n              removeDraggedTab(tabId) ?\n              _jsx(_Fragment, {}) :\n\n              _jsxs(_Fragment, { children: [\n                showDropIndicators(tabIndex).left &&\n                _jsx(DropIndicator, {\n                  className: \"drop-indicator-left\",\n                  pos: \"left\" }\n                ),\n\n                _jsx(DashboardComponent, {\n                  id: tabId,\n                  parentId: tabsComponent.id,\n                  depth: depth,\n                  index: tabIndex,\n                  renderType: RENDER_TAB,\n                  availableColumnCount: availableColumnCount,\n                  columnWidth: columnWidth,\n                  onDropOnTab: handleDropOnTab,\n                  onDropPositionChange: handleGetDropPosition,\n                  onDragTab: handleDragggingTab,\n                  onHoverTab: () => handleClickTab(tabIndex),\n                  isFocused: activeKey === tabId,\n                  isHighlighted:\n                  activeKey !== tabId && ((_tabsToHighlight = tabsToHighlight) == null ? void 0 : _tabsToHighlight.includes(tabId)) }\n\n                )] }\n              ),\n\n\n              closeIcon:\n              removeDraggedTab(tabId) ?\n              _jsx(_Fragment, {}) :\n\n              _jsx(CloseIconWithDropIndicator, {\n                role: \"button\",\n                tabIndex: tabIndex,\n                showDropIndicators: showDropIndicators(tabIndex) }\n              ), children:\n\n\n\n              renderTabContent &&\n              _jsx(DashboardComponent, {\n                id: tabId,\n                parentId: tabsComponent.id,\n                depth: depth // see isValidChild.js for why tabs don't increment child depth\n                , index: tabIndex,\n                renderType: RENDER_TAB_CONTENT,\n                availableColumnCount: availableColumnCount,\n                columnWidth: columnWidth,\n                onResizeStart: onResizeStart,\n                onResize: onResize,\n                onResizeStop: onResizeStop,\n                onDropOnTab: handleDropOnTab,\n                isComponentVisible:\n                selectedTabIndex === tabIndex && isCurrentTabVisible }\n\n              ) }, tabId\n\n            ));}\n        ) }\n      )] }\n    ),\n\n    [\n    editMode,\n    renderHoverMenu,\n    handleDeleteComponent,\n    tabsComponent.id,\n    activeKey,\n    handleEdit,\n    tabIds,\n    handleClickTab,\n    removeDraggedTab,\n    showDropIndicators,\n    depth,\n    availableColumnCount,\n    columnWidth,\n    handleDropOnTab,\n    handleGetDropPosition,\n    handleDragggingTab,\n    tabsToHighlight,\n    renderTabContent,\n    onResizeStart,\n    onResize,\n    onResizeStop,\n    selectedTabIndex,\n    isCurrentTabVisible]\n\n  );\n\n  return (\n    _jsx(Draggable, {\n      component: tabsComponent,\n      parentComponent: parentComponent,\n      orientation: \"row\",\n      index: index,\n      depth: depth,\n      onDrop: handleDrop,\n      editMode: editMode, children:\n\n      renderChild }\n    ));\n\n};\n\nTabs.propTypes = propTypes;\nTabs.defaultProps = defaultProps;\n\nexport default /*#__PURE__*/memo(Tabs);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}