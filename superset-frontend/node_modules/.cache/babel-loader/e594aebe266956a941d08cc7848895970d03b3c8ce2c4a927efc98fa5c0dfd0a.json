{"ast":null,"code":"import { css as _css } from \"@emotion/react\";import _pick from \"lodash/pick\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useState, memo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { useHistory } from 'react-router-dom';\n\nimport ButtonGroup from 'src/components/ButtonGroup';\nimport Alert from 'src/components/Alert';\nimport Button from 'src/components/Button';\nimport { nanoid } from 'nanoid';\nimport { QueryState, styled, t, tn, useTheme, usePrevious, css, getNumberFormatter, getExtensionsRegistry, ErrorTypeEnum } from '@superset-ui/core';\nimport ErrorMessageWithStackTrace from 'src/components/ErrorMessage/ErrorMessageWithStackTrace';\nimport { SaveDatasetModal } from 'src/SqlLab/components/SaveDatasetModal';\nimport { EXPLORE_CHART_DEFAULT } from 'src/SqlLab/types';\nimport { mountExploreUrl } from 'src/explore/exploreUtils';\nimport { postFormData } from 'src/explore/exploreUtils/formData';\nimport ProgressBar from 'src/components/ProgressBar';\nimport Loading from 'src/components/Loading';\nimport Card from 'src/components/Card';\nimport Label from 'src/components/Label';\nimport { Tooltip } from 'src/components/Tooltip';\nimport FilterableTable from 'src/components/FilterableTable';\nimport CopyToClipboard from 'src/components/CopyToClipboard';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport { prepareCopyToClipboardTabularData } from 'src/utils/common';\nimport { getItem, LocalStorageKeys } from 'src/utils/localStorageHelpers';\nimport Modal from 'src/components/Modal';\nimport { addQueryEditor, clearQueryResults, CtasEnum, fetchQueryResults, reFetchQueryResults, reRunQuery } from 'src/SqlLab/actions/sqlLab';\nimport { URL_PARAMS } from 'src/constants';\nimport useLogAction from 'src/logger/useLogAction';\nimport { LOG_ACTIONS_SQLLAB_COPY_RESULT_TO_CLIPBOARD, LOG_ACTIONS_SQLLAB_CREATE_CHART, LOG_ACTIONS_SQLLAB_DOWNLOAD_CSV } from 'src/logger/LogUtils';\nimport Icons from 'src/components/Icons';\nimport { findPermission } from 'src/utils/findPermission';\nimport ExploreCtasResultsButton from '../ExploreCtasResultsButton';\nimport ExploreResultsButton from '../ExploreResultsButton';\nimport HighlightedSql from '../HighlightedSql';\nimport QueryStateLabel from '../QueryStateLabel';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nvar LimitingFactor;\n(function (LimitingFactor) {\n  LimitingFactor[\"Query\"] = \"QUERY\";\n  LimitingFactor[\"QueryAndDropdown\"] = \"QUERY_AND_DROPDOWN\";\n  LimitingFactor[\"Dropdown\"] = \"DROPDOWN\";\n  LimitingFactor[\"NotLimited\"] = \"NOT_LIMITED\";\n})(LimitingFactor || (LimitingFactor = {}));\nconst ResultContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  row-gap: ${({ theme }) => theme.gridUnit * 2}px;\n`;\nconst ResultlessStyles = styled.div`\n  position: relative;\n  min-height: ${({ theme }) => theme.gridUnit * 25}px;\n  [role='alert'] {\n    margin-top: ${({ theme }) => theme.gridUnit * 2}px;\n  }\n  .sql-result-track-job {\n    margin-top: ${({ theme }) => theme.gridUnit * 2}px;\n  }\n`;\n// Making text render line breaks/tabs as is as monospace,\n// but wrapping text too so text doesn't overflow\nconst MonospaceDiv = styled.div`\n  font-family: ${({ theme }) => theme.typography.families.monospace};\n  white-space: pre;\n  word-break: break-word;\n  overflow-x: auto;\n  white-space: pre-wrap;\n`;\nconst ReturnedRows = styled.div`\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  line-height: 1;\n`;\nconst ResultSetControls = styled.div`\n  display: flex;\n  justify-content: space-between;\n`;\nconst ResultSetButtons = styled.div`\n  display: grid;\n  grid-auto-flow: column;\n  padding-right: ${({ theme }) => 2 * theme.gridUnit}px;\n`;\nconst copyButtonStyles = css`\n  &:hover {\n    text-decoration: unset;\n  }\n  span > :first-of-type {\n    margin: 0px;\n  }\n`;\nconst ROWS_CHIP_WIDTH = 100;\nconst GAP = 8;\nconst extensionsRegistry = getExtensionsRegistry();\nconst ResultSet = ({ cache = false, csv = true, database = {}, displayLimit, height, queryId, search = true, showSql = false, showSqlInline = false, visualize = true, defaultQueryLimit }) => {var _extensionsRegistry$g, _query$results2, _query$extra$progress, _query$extra2;\n  const user = useSelector(({ user }) => user, shallowEqual);\n  const query = useSelector(({ sqlLab: { queries } }) => _pick(queries[queryId], [\n  'id',\n  'errorMessage',\n  'cached',\n  'results',\n  'resultsKey',\n  'dbId',\n  'tab',\n  'sql',\n  'sqlEditorId',\n  'templateParams',\n  'schema',\n  'rows',\n  'queryLimit',\n  'limitingFactor',\n  'trackingUrl',\n  'state',\n  'errors',\n  'link',\n  'ctas',\n  'ctas_method',\n  'tempSchema',\n  'tempTable',\n  'isDataPreview',\n  'progress',\n  'extra']\n  ), shallowEqual);\n  const ResultTable = (_extensionsRegistry$g = extensionsRegistry.get('sqleditor.extension.resultTable')) != null ? _extensionsRegistry$g :\n  FilterableTable;\n  const theme = useTheme();\n  const [searchText, setSearchText] = useState('');\n  const [cachedData, setCachedData] = useState([]);\n  const [showSaveDatasetModal, setShowSaveDatasetModal] = useState(false);\n  const [alertIsOpen, setAlertIsOpen] = useState(false);\n  const history = useHistory();\n  const dispatch = useDispatch();\n  const logAction = useLogAction({ queryId, sqlEditorId: query.sqlEditorId });\n  const reRunQueryIfSessionTimeoutErrorOnMount = useCallback(() => {\n    if (query.errorMessage &&\n    query.errorMessage.indexOf('session timed out') > 0) {\n      dispatch(reRunQuery(query));\n    }\n  }, []);\n  useEffect(() => {\n    // only do this the first time the component is rendered/mounted\n    reRunQueryIfSessionTimeoutErrorOnMount();\n  }, [reRunQueryIfSessionTimeoutErrorOnMount]);\n  const fetchResults = (q, timeout) => {\n    dispatch(fetchQueryResults(q, displayLimit, timeout));\n  };\n  const prevQuery = usePrevious(query);\n  useEffect(() => {var _query$results, _query$results$data;\n    if (cache && query.cached && (query == null ? void 0 : (_query$results = query.results) == null ? void 0 : (_query$results$data = _query$results.data) == null ? void 0 : _query$results$data.length) > 0) {\n      setCachedData(query.results.data);\n      dispatch(clearQueryResults(query));\n    }\n    if (query.resultsKey && query.resultsKey !== (prevQuery == null ? void 0 : prevQuery.resultsKey)) {\n      fetchResults(query);\n    }\n  }, [query, cache]);\n  const calculateAlertRefHeight = (alertElement) => {\n    if (alertElement) {\n      setAlertIsOpen(true);\n    } else\n    {\n      setAlertIsOpen(false);\n    }\n  };\n  const popSelectStar = (tempSchema, tempTable) => {\n    const qe = {\n      id: nanoid(11),\n      name: tempTable,\n      autorun: false,\n      dbId: query.dbId,\n      sql: `SELECT * FROM ${tempSchema ? `${tempSchema}.` : ''}${tempTable}`\n    };\n    dispatch(addQueryEditor(qe));\n  };\n  const changeSearch = (event) => {\n    setSearchText(event.target.value);\n  };\n  const createExploreResultsOnClick = async (clickEvent) => {\n    const { results } = query;\n    const openInNewWindow = clickEvent.metaKey;\n    logAction(LOG_ACTIONS_SQLLAB_CREATE_CHART, {});\n    if (results != null && results.query_id) {\n      const key = await postFormData(results.query_id, 'query', {\n        ...EXPLORE_CHART_DEFAULT,\n        datasource: `${results.query_id}__query`,\n        ...{\n          all_columns: results.columns.map((column) => column.column_name)\n        }\n      });\n      const url = mountExploreUrl(null, {\n        [URL_PARAMS.formDataKey.name]: key\n      });\n      if (openInNewWindow) {\n        window.open(url, '_blank', 'noreferrer');\n      } else\n      {\n        history.push(url);\n      }\n    } else\n    {\n      addDangerToast(t('Unable to create chart without a query id.'));\n    }\n  };\n  const getExportCsvUrl = (clientId) => `/api/v1/sqllab/export/${clientId}/`;\n  const renderControls = () => {\n    if (search || visualize || csv) {var _results$data;\n      const { results, queryLimit, limitingFactor, rows } = query;\n      const limit = queryLimit || results.query.limit;\n      const rowsCount = Math.min(rows || 0, (results == null ? void 0 : (_results$data = results.data) == null ? void 0 : _results$data.length) || 0);\n      let { data } = query.results;\n      if (cache && query.cached) {\n        data = cachedData;\n      }\n      const { columns } = query.results;\n      // Added compute logic to stop user from being able to Save & Explore\n      const datasource = {\n        columns: query.results.columns,\n        name: (query == null ? void 0 : query.tab) || 'Untitled',\n        dbId: query == null ? void 0 : query.dbId,\n        sql: query == null ? void 0 : query.sql,\n        templateParams: query == null ? void 0 : query.templateParams,\n        schema: query == null ? void 0 : query.schema\n      };\n      const canExportData = findPermission('can_export_csv', 'SQLLab', user == null ? void 0 : user.roles);\n      return _jsxs(ResultSetControls, { children: [\n        _jsx(SaveDatasetModal, { visible: showSaveDatasetModal, onHide: () => setShowSaveDatasetModal(false), buttonTextOnSave: t('Save & Explore'), buttonTextOnOverwrite: t('Overwrite & Explore'), modalDescription: t('Save this query as a virtual dataset to continue exploring'), datasource: datasource }),\n        _jsxs(ResultSetButtons, { children: [\n          visualize && (database == null ? void 0 : database.allows_virtual_table_explore) && _jsx(ExploreResultsButton, { database: database, onClick: createExploreResultsOnClick }),\n          csv && canExportData && _jsxs(Button, { css: copyButtonStyles, buttonSize: \"small\", href: getExportCsvUrl(query.id), onClick: () => {\n              logAction(LOG_ACTIONS_SQLLAB_DOWNLOAD_CSV, {});\n              if (limitingFactor === LimitingFactor.Dropdown &&\n              limit === rowsCount) {\n                Modal.warning({\n                  title: t('Download is on the way'),\n                  content: t('Downloading %(rows)s rows based on the LIMIT configuration. If you want the entire result set, you need to adjust the LIMIT.', { rows: rowsCount.toLocaleString() })\n                });\n              }\n            }, children: [\n            _jsx(Icons.DownloadOutlined, { iconSize: \"m\", iconColor: theme.colors.primary.dark2 }), ' ',\n            t('Download to CSV')] }\n          ),\n\n          canExportData && _jsx(CopyToClipboard, { text: prepareCopyToClipboardTabularData(data, columns), wrapped: false, copyNode: _jsxs(Button, { css: copyButtonStyles, buttonSize: \"small\", children: [\n              _jsx(Icons.CopyOutlined, { iconSize: \"s\", iconColor: theme.colors.primary.dark2 }), ' ',\n              t('Copy to Clipboard')] }\n            ), hideTooltip: true, onCopyEnd: () => logAction(LOG_ACTIONS_SQLLAB_COPY_RESULT_TO_CLIPBOARD, {}) })] }\n        ),\n        search && _jsx(\"input\", { type: \"text\", onChange: changeSearch, value: searchText, className: \"form-control input-sm\", placeholder: t('Filter results') })] }\n      );\n    }\n    return _jsx(\"div\", {});\n  };\n  const renderRowsReturned = (alertMessage) => {var _user$roles, _results$data2;\n    const { results, rows, queryLimit, limitingFactor } = query;\n    let limitMessage = '';\n    const limitReached = results == null ? void 0 : results.displayLimitReached;\n    const limit = queryLimit || results.query.limit;\n    const isAdmin = !!(user != null && (_user$roles = user.roles) != null && _user$roles.Admin);\n    const rowsCount = Math.min(rows || 0, (results == null ? void 0 : (_results$data2 = results.data) == null ? void 0 : _results$data2.length) || 0);\n    const displayMaxRowsReachedMessage = {\n      withAdmin: t('The number of results displayed is limited to %(rows)d by the configuration DISPLAY_MAX_ROW. ' +\n      'Please add additional limits/filters or download to csv to see more rows up to ' +\n      'the %(limit)d limit.', { rows: rowsCount, limit }),\n      withoutAdmin: t('The number of results displayed is limited to %(rows)d. ' +\n      'Please add additional limits/filters, download to csv, or contact an admin ' +\n      'to see more rows up to the %(limit)d limit.', { rows: rowsCount, limit })\n    };\n    const shouldUseDefaultDropdownAlert = limit === defaultQueryLimit && limitingFactor === LimitingFactor.Dropdown;\n    if (limitingFactor === LimitingFactor.Query && csv) {\n      limitMessage = t('The number of rows displayed is limited to %(rows)d by the query', { rows });\n    } else\n    if (limitingFactor === LimitingFactor.Dropdown &&\n    !shouldUseDefaultDropdownAlert) {\n      limitMessage = t('The number of rows displayed is limited to %(rows)d by the limit dropdown.', { rows });\n    } else\n    if (limitingFactor === LimitingFactor.QueryAndDropdown) {\n      limitMessage = t('The number of rows displayed is limited to %(rows)d by the query and limit dropdown.', { rows });\n    }\n    const formattedRowCount = getNumberFormatter()(rows);\n    const rowsReturnedMessage = t('%(rows)d rows returned', {\n      rows\n    });\n    const tooltipText = `${rowsReturnedMessage}. ${limitMessage}`;\n    if (alertMessage) {\n      return _jsxs(_Fragment, { children: [\n        !limitReached && shouldUseDefaultDropdownAlert && _jsx(\"div\", { ref: calculateAlertRefHeight, children:\n          _jsx(Alert, { type: \"warning\", message: t('%(rows)d rows returned', { rows }), onClose: () => setAlertIsOpen(false), description: t('The number of rows displayed is limited to %(rows)d by the dropdown.', { rows }) }) }\n        ),\n        limitReached && _jsx(\"div\", { ref: calculateAlertRefHeight, children:\n          _jsx(Alert, { type: \"warning\", onClose: () => setAlertIsOpen(false), message: t('%(rows)d rows returned', { rows: rowsCount }), description: isAdmin ?\n            displayMaxRowsReachedMessage.withAdmin :\n            displayMaxRowsReachedMessage.withoutAdmin }) }\n        )] }\n      );\n    }\n    const showRowsReturned = showSqlInline || !limitReached && !shouldUseDefaultDropdownAlert;\n    return _jsx(_Fragment, { children:\n      showRowsReturned && _jsx(ReturnedRows, { children:\n        _jsx(Tooltip, { id: \"sqllab-rowcount-tooltip\", title: tooltipText, placement: \"left\", children:\n          _jsxs(Label, { css: css`\n                  line-height: ${theme.typography.sizes.l}px;\n                `, children: [\n            limitMessage && _jsx(Icons.ExclamationCircleOutlined, { css: css`\n                      font-size: ${theme.typography.sizes.m}px;\n                      margin-right: ${theme.gridUnit}px;\n                    ` }),\n            tn('%s row', '%s rows', rows, formattedRowCount)] }\n          ) }\n        ) }\n      ) }\n    );\n  };\n  const limitReached = query == null ? void 0 : (_query$results2 = query.results) == null ? void 0 : _query$results2.displayLimitReached;\n  let sql;\n  let exploreDBId = query.dbId;\n  if (database != null && database.explore_database_id) {\n    exploreDBId = database.explore_database_id;\n  }\n  let trackingUrl;\n  if (query.trackingUrl &&\n  query.state !== QueryState.Success &&\n  query.state !== QueryState.Fetching) {\n    trackingUrl = _jsx(Button, { className: \"sql-result-track-job\", buttonSize: \"small\", href: query.trackingUrl, target: \"_blank\", children:\n      query.state === QueryState.Running ?\n      t('Track job') :\n      t('See query details') }\n    );\n  }\n  if (showSql) {\n    sql = _jsx(HighlightedSql, { sql: query.sql, ...(showSqlInline && { maxLines: 1, maxWidth: 60 }) });\n  }\n  if (query.state === QueryState.Stopped) {\n    return _jsx(Alert, { type: \"warning\", message: t('Query was stopped') });\n  }\n  if (query.state === QueryState.Failed) {var _query$extra;\n    const errors = [...(((_query$extra = query.extra) == null ? void 0 : _query$extra.errors) || []), ...(query.errors || [])];\n    return _jsxs(ResultlessStyles, { children: [\n      errors.map((error, index) => _jsx(ErrorMessageWithStackTrace, { title: t('Database error'), error: error, subtitle: _jsx(MonospaceDiv, { children: error.message }), copyText: error.message || undefined, link: query.link, source: \"sqllab\" }, index)),\n      errors.some((error) => (error == null ? void 0 : error.error_type) === ErrorTypeEnum.FRONTEND_TIMEOUT_ERROR) ? _jsx(Button, { className: \"sql-result-track-job\", buttonSize: \"small\", onClick: () => fetchResults(query, 0), children:\n        t('Retry fetching results') }\n      ) : trackingUrl] }\n    );\n  }\n  if (query.state === QueryState.Success && query.ctas) {\n    const { tempSchema, tempTable } = query;\n    let object = 'Table';\n    if (query.ctas_method === CtasEnum.View) {\n      object = 'View';\n    }\n    return _jsx(\"div\", { children:\n      _jsx(Alert, { type: \"info\", message: _jsxs(_Fragment, { children: [\n          t(object), \" [\",\n          _jsxs(\"strong\", { children: [\n            tempSchema ? `${tempSchema}.` : '',\n            tempTable] }\n          ), \"] \",\n          t('was created'), \" \\xA0\",\n          _jsxs(ButtonGroup, { children: [\n            _jsx(Button, { buttonSize: \"small\", css: /*#__PURE__*/_css({ marginRight: theme.gridUnit }, process.env.NODE_ENV === \"production\" ? \"\" : \";label:ResultSet;\", process.env.NODE_ENV === \"production\" ? \"\" : \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL1NxbExhYi9jb21wb25lbnRzL1Jlc3VsdFNldC9pbmRleC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb1gyQyIsImZpbGUiOiIvaG9tZS9hZGVsL3N1cGVyc2V0L3N1cGVyc2V0LWZyb250ZW5kL3NyYy9TcWxMYWIvY29tcG9uZW50cy9SZXN1bHRTZXQvaW5kZXgudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUsIG1lbW8sIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0VxdWFsLCB1c2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyB1c2VIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCdXR0b25Hcm91cCBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cCc7XG5pbXBvcnQgQWxlcnQgZnJvbSAnc3JjL2NvbXBvbmVudHMvQWxlcnQnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b24nO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnbmFub2lkJztcbmltcG9ydCB7IFF1ZXJ5U3RhdGUsIHN0eWxlZCwgdCwgdG4sIHVzZVRoZW1lLCB1c2VQcmV2aW91cywgY3NzLCBnZXROdW1iZXJGb3JtYXR0ZXIsIGdldEV4dGVuc2lvbnNSZWdpc3RyeSwgRXJyb3JUeXBlRW51bSwgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgRXJyb3JNZXNzYWdlV2l0aFN0YWNrVHJhY2UgZnJvbSAnc3JjL2NvbXBvbmVudHMvRXJyb3JNZXNzYWdlL0Vycm9yTWVzc2FnZVdpdGhTdGFja1RyYWNlJztcbmltcG9ydCB7IFNhdmVEYXRhc2V0TW9kYWwsIH0gZnJvbSAnc3JjL1NxbExhYi9jb21wb25lbnRzL1NhdmVEYXRhc2V0TW9kYWwnO1xuaW1wb3J0IHsgRVhQTE9SRV9DSEFSVF9ERUZBVUxUIH0gZnJvbSAnc3JjL1NxbExhYi90eXBlcyc7XG5pbXBvcnQgeyBtb3VudEV4cGxvcmVVcmwgfSBmcm9tICdzcmMvZXhwbG9yZS9leHBsb3JlVXRpbHMnO1xuaW1wb3J0IHsgcG9zdEZvcm1EYXRhIH0gZnJvbSAnc3JjL2V4cGxvcmUvZXhwbG9yZVV0aWxzL2Zvcm1EYXRhJztcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tICdzcmMvY29tcG9uZW50cy9Qcm9ncmVzc0Jhcic7XG5pbXBvcnQgTG9hZGluZyBmcm9tICdzcmMvY29tcG9uZW50cy9Mb2FkaW5nJztcbmltcG9ydCBDYXJkIGZyb20gJ3NyYy9jb21wb25lbnRzL0NhcmQnO1xuaW1wb3J0IExhYmVsIGZyb20gJ3NyYy9jb21wb25lbnRzL0xhYmVsJztcbmltcG9ydCB7IFRvb2x0aXAgfSBmcm9tICdzcmMvY29tcG9uZW50cy9Ub29sdGlwJztcbmltcG9ydCBGaWx0ZXJhYmxlVGFibGUgZnJvbSAnc3JjL2NvbXBvbmVudHMvRmlsdGVyYWJsZVRhYmxlJztcbmltcG9ydCBDb3B5VG9DbGlwYm9hcmQgZnJvbSAnc3JjL2NvbXBvbmVudHMvQ29weVRvQ2xpcGJvYXJkJztcbmltcG9ydCB7IGFkZERhbmdlclRvYXN0IH0gZnJvbSAnc3JjL2NvbXBvbmVudHMvTWVzc2FnZVRvYXN0cy9hY3Rpb25zJztcbmltcG9ydCB7IHByZXBhcmVDb3B5VG9DbGlwYm9hcmRUYWJ1bGFyRGF0YSB9IGZyb20gJ3NyYy91dGlscy9jb21tb24nO1xuaW1wb3J0IHsgZ2V0SXRlbSwgTG9jYWxTdG9yYWdlS2V5cyB9IGZyb20gJ3NyYy91dGlscy9sb2NhbFN0b3JhZ2VIZWxwZXJzJztcbmltcG9ydCBNb2RhbCBmcm9tICdzcmMvY29tcG9uZW50cy9Nb2RhbCc7XG5pbXBvcnQgeyBhZGRRdWVyeUVkaXRvciwgY2xlYXJRdWVyeVJlc3VsdHMsIEN0YXNFbnVtLCBmZXRjaFF1ZXJ5UmVzdWx0cywgcmVGZXRjaFF1ZXJ5UmVzdWx0cywgcmVSdW5RdWVyeSwgfSBmcm9tICdzcmMvU3FsTGFiL2FjdGlvbnMvc3FsTGFiJztcbmltcG9ydCB7IFVSTF9QQVJBTVMgfSBmcm9tICdzcmMvY29uc3RhbnRzJztcbmltcG9ydCB1c2VMb2dBY3Rpb24gZnJvbSAnc3JjL2xvZ2dlci91c2VMb2dBY3Rpb24nO1xuaW1wb3J0IHsgTE9HX0FDVElPTlNfU1FMTEFCX0NPUFlfUkVTVUxUX1RPX0NMSVBCT0FSRCwgTE9HX0FDVElPTlNfU1FMTEFCX0NSRUFURV9DSEFSVCwgTE9HX0FDVElPTlNfU1FMTEFCX0RPV05MT0FEX0NTViwgfSBmcm9tICdzcmMvbG9nZ2VyL0xvZ1V0aWxzJztcbmltcG9ydCBJY29ucyBmcm9tICdzcmMvY29tcG9uZW50cy9JY29ucyc7XG5pbXBvcnQgeyBmaW5kUGVybWlzc2lvbiB9IGZyb20gJ3NyYy91dGlscy9maW5kUGVybWlzc2lvbic7XG5pbXBvcnQgRXhwbG9yZUN0YXNSZXN1bHRzQnV0dG9uIGZyb20gJy4uL0V4cGxvcmVDdGFzUmVzdWx0c0J1dHRvbic7XG5pbXBvcnQgRXhwbG9yZVJlc3VsdHNCdXR0b24gZnJvbSAnLi4vRXhwbG9yZVJlc3VsdHNCdXR0b24nO1xuaW1wb3J0IEhpZ2hsaWdodGVkU3FsIGZyb20gJy4uL0hpZ2hsaWdodGVkU3FsJztcbmltcG9ydCBRdWVyeVN0YXRlTGFiZWwgZnJvbSAnLi4vUXVlcnlTdGF0ZUxhYmVsJztcbnZhciBMaW1pdGluZ0ZhY3RvcjtcbihmdW5jdGlvbiAoTGltaXRpbmdGYWN0b3IpIHtcbiAgICBMaW1pdGluZ0ZhY3RvcltcIlF1ZXJ5XCJdID0gXCJRVUVSWVwiO1xuICAgIExpbWl0aW5nRmFjdG9yW1wiUXVlcnlBbmREcm9wZG93blwiXSA9IFwiUVVFUllfQU5EX0RST1BET1dOXCI7XG4gICAgTGltaXRpbmdGYWN0b3JbXCJEcm9wZG93blwiXSA9IFwiRFJPUERPV05cIjtcbiAgICBMaW1pdGluZ0ZhY3RvcltcIk5vdExpbWl0ZWRcIl0gPSBcIk5PVF9MSU1JVEVEXCI7XG59KShMaW1pdGluZ0ZhY3RvciB8fCAoTGltaXRpbmdGYWN0b3IgPSB7fSkpO1xuY29uc3QgUmVzdWx0Q29udGFpbmVyID0gc3R5bGVkLmRpdiBgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIHJvdy1nYXA6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuYDtcbmNvbnN0IFJlc3VsdGxlc3NTdHlsZXMgPSBzdHlsZWQuZGl2IGBcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBtaW4taGVpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMjV9cHg7XG4gIFtyb2xlPSdhbGVydCddIHtcbiAgICBtYXJnaW4tdG9wOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMn1weDtcbiAgfVxuICAuc3FsLXJlc3VsdC10cmFjay1qb2Ige1xuICAgIG1hcmdpbi10b3A6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICB9XG5gO1xuLy8gTWFraW5nIHRleHQgcmVuZGVyIGxpbmUgYnJlYWtzL3RhYnMgYXMgaXMgYXMgbW9ub3NwYWNlLFxuLy8gYnV0IHdyYXBwaW5nIHRleHQgdG9vIHNvIHRleHQgZG9lc24ndCBvdmVyZmxvd1xuY29uc3QgTW9ub3NwYWNlRGl2ID0gc3R5bGVkLmRpdiBgXG4gIGZvbnQtZmFtaWx5OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLnR5cG9ncmFwaHkuZmFtaWxpZXMubW9ub3NwYWNlfTtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgb3ZlcmZsb3cteDogYXV0bztcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuYDtcbmNvbnN0IFJldHVybmVkUm93cyA9IHN0eWxlZC5kaXYgYFxuICBmb250LXNpemU6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xuICBsaW5lLWhlaWdodDogMTtcbmA7XG5jb25zdCBSZXN1bHRTZXRDb250cm9scyA9IHN0eWxlZC5kaXYgYFxuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5gO1xuY29uc3QgUmVzdWx0U2V0QnV0dG9ucyA9IHN0eWxlZC5kaXYgYFxuICBkaXNwbGF5OiBncmlkO1xuICBncmlkLWF1dG8tZmxvdzogY29sdW1uO1xuICBwYWRkaW5nLXJpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IDIgKiB0aGVtZS5ncmlkVW5pdH1weDtcbmA7XG5jb25zdCBjb3B5QnV0dG9uU3R5bGVzID0gY3NzIGBcbiAgJjpob3ZlciB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bnNldDtcbiAgfVxuICBzcGFuID4gOmZpcnN0LW9mLXR5cGUge1xuICAgIG1hcmdpbjogMHB4O1xuICB9XG5gO1xuY29uc3QgUk9XU19DSElQX1dJRFRIID0gMTAwO1xuY29uc3QgR0FQID0gODtcbmNvbnN0IGV4dGVuc2lvbnNSZWdpc3RyeSA9IGdldEV4dGVuc2lvbnNSZWdpc3RyeSgpO1xuY29uc3QgUmVzdWx0U2V0ID0gKHsgY2FjaGUgPSBmYWxzZSwgY3N2ID0gdHJ1ZSwgZGF0YWJhc2UgPSB7fSwgZGlzcGxheUxpbWl0LCBoZWlnaHQsIHF1ZXJ5SWQsIHNlYXJjaCA9IHRydWUsIHNob3dTcWwgPSBmYWxzZSwgc2hvd1NxbElubGluZSA9IGZhbHNlLCB2aXN1YWxpemUgPSB0cnVlLCBkZWZhdWx0UXVlcnlMaW1pdCwgfSkgPT4ge1xuICAgIGNvbnN0IHVzZXIgPSB1c2VTZWxlY3RvcigoeyB1c2VyIH0pID0+IHVzZXIsIHNoYWxsb3dFcXVhbCk7XG4gICAgY29uc3QgcXVlcnkgPSB1c2VTZWxlY3RvcigoeyBzcWxMYWI6IHsgcXVlcmllcyB9IH0pID0+IHBpY2socXVlcmllc1txdWVyeUlkXSwgW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJyxcbiAgICAgICAgJ2NhY2hlZCcsXG4gICAgICAgICdyZXN1bHRzJyxcbiAgICAgICAgJ3Jlc3VsdHNLZXknLFxuICAgICAgICAnZGJJZCcsXG4gICAgICAgICd0YWInLFxuICAgICAgICAnc3FsJyxcbiAgICAgICAgJ3NxbEVkaXRvcklkJyxcbiAgICAgICAgJ3RlbXBsYXRlUGFyYW1zJyxcbiAgICAgICAgJ3NjaGVtYScsXG4gICAgICAgICdyb3dzJyxcbiAgICAgICAgJ3F1ZXJ5TGltaXQnLFxuICAgICAgICAnbGltaXRpbmdGYWN0b3InLFxuICAgICAgICAndHJhY2tpbmdVcmwnLFxuICAgICAgICAnc3RhdGUnLFxuICAgICAgICAnZXJyb3JzJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnY3RhcycsXG4gICAgICAgICdjdGFzX21ldGhvZCcsXG4gICAgICAgICd0ZW1wU2NoZW1hJyxcbiAgICAgICAgJ3RlbXBUYWJsZScsXG4gICAgICAgICdpc0RhdGFQcmV2aWV3JyxcbiAgICAgICAgJ3Byb2dyZXNzJyxcbiAgICAgICAgJ2V4dHJhJyxcbiAgICBdKSwgc2hhbGxvd0VxdWFsKTtcbiAgICBjb25zdCBSZXN1bHRUYWJsZSA9IGV4dGVuc2lvbnNSZWdpc3RyeS5nZXQoJ3NxbGVkaXRvci5leHRlbnNpb24ucmVzdWx0VGFibGUnKSA/P1xuICAgICAgICBGaWx0ZXJhYmxlVGFibGU7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKCcnKTtcbiAgICBjb25zdCBbY2FjaGVkRGF0YSwgc2V0Q2FjaGVkRGF0YV0gPSB1c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgW3Nob3dTYXZlRGF0YXNldE1vZGFsLCBzZXRTaG93U2F2ZURhdGFzZXRNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2FsZXJ0SXNPcGVuLCBzZXRBbGVydElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGlzdG9yeSA9IHVzZUhpc3RvcnkoKTtcbiAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgY29uc3QgbG9nQWN0aW9uID0gdXNlTG9nQWN0aW9uKHsgcXVlcnlJZCwgc3FsRWRpdG9ySWQ6IHF1ZXJ5LnNxbEVkaXRvcklkIH0pO1xuICAgIGNvbnN0IHJlUnVuUXVlcnlJZlNlc3Npb25UaW1lb3V0RXJyb3JPbk1vdW50ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocXVlcnkuZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgICBxdWVyeS5lcnJvck1lc3NhZ2UuaW5kZXhPZignc2Vzc2lvbiB0aW1lZCBvdXQnKSA+IDApIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHJlUnVuUXVlcnkocXVlcnkpKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBvbmx5IGRvIHRoaXMgdGhlIGZpcnN0IHRpbWUgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZC9tb3VudGVkXG4gICAgICAgIHJlUnVuUXVlcnlJZlNlc3Npb25UaW1lb3V0RXJyb3JPbk1vdW50KCk7XG4gICAgfSwgW3JlUnVuUXVlcnlJZlNlc3Npb25UaW1lb3V0RXJyb3JPbk1vdW50XSk7XG4gICAgY29uc3QgZmV0Y2hSZXN1bHRzID0gKHEsIHRpbWVvdXQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goZmV0Y2hRdWVyeVJlc3VsdHMocSwgZGlzcGxheUxpbWl0LCB0aW1lb3V0KSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB1c2VQcmV2aW91cyhxdWVyeSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlICYmIHF1ZXJ5LmNhY2hlZCAmJiBxdWVyeT8ucmVzdWx0cz8uZGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2V0Q2FjaGVkRGF0YShxdWVyeS5yZXN1bHRzLmRhdGEpO1xuICAgICAgICAgICAgZGlzcGF0Y2goY2xlYXJRdWVyeVJlc3VsdHMocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkucmVzdWx0c0tleSAmJiBxdWVyeS5yZXN1bHRzS2V5ICE9PSBwcmV2UXVlcnk/LnJlc3VsdHNLZXkpIHtcbiAgICAgICAgICAgIGZldGNoUmVzdWx0cyhxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9LCBbcXVlcnksIGNhY2hlXSk7XG4gICAgY29uc3QgY2FsY3VsYXRlQWxlcnRSZWZIZWlnaHQgPSAoYWxlcnRFbGVtZW50KSA9PiB7XG4gICAgICAgIGlmIChhbGVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNldEFsZXJ0SXNPcGVuKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0QWxlcnRJc09wZW4oZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwb3BTZWxlY3RTdGFyID0gKHRlbXBTY2hlbWEsIHRlbXBUYWJsZSkgPT4ge1xuICAgICAgICBjb25zdCBxZSA9IHtcbiAgICAgICAgICAgIGlkOiBuYW5vaWQoMTEpLFxuICAgICAgICAgICAgbmFtZTogdGVtcFRhYmxlLFxuICAgICAgICAgICAgYXV0b3J1bjogZmFsc2UsXG4gICAgICAgICAgICBkYklkOiBxdWVyeS5kYklkLFxuICAgICAgICAgICAgc3FsOiBgU0VMRUNUICogRlJPTSAke3RlbXBTY2hlbWEgPyBgJHt0ZW1wU2NoZW1hfS5gIDogJyd9JHt0ZW1wVGFibGV9YCxcbiAgICAgICAgfTtcbiAgICAgICAgZGlzcGF0Y2goYWRkUXVlcnlFZGl0b3IocWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoYW5nZVNlYXJjaCA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXRTZWFyY2hUZXh0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVFeHBsb3JlUmVzdWx0c09uQ2xpY2sgPSBhc3luYyAoY2xpY2tFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlc3VsdHMgfSA9IHF1ZXJ5O1xuICAgICAgICBjb25zdCBvcGVuSW5OZXdXaW5kb3cgPSBjbGlja0V2ZW50Lm1ldGFLZXk7XG4gICAgICAgIGxvZ0FjdGlvbihMT0dfQUNUSU9OU19TUUxMQUJfQ1JFQVRFX0NIQVJULCB7fSk7XG4gICAgICAgIGlmIChyZXN1bHRzPy5xdWVyeV9pZCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcG9zdEZvcm1EYXRhKHJlc3VsdHMucXVlcnlfaWQsICdxdWVyeScsIHtcbiAgICAgICAgICAgICAgICAuLi5FWFBMT1JFX0NIQVJUX0RFRkFVTFQsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZTogYCR7cmVzdWx0cy5xdWVyeV9pZH1fX3F1ZXJ5YCxcbiAgICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgICAgIGFsbF9jb2x1bW5zOiByZXN1bHRzLmNvbHVtbnMubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX25hbWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG1vdW50RXhwbG9yZVVybChudWxsLCB7XG4gICAgICAgICAgICAgICAgW1VSTF9QQVJBTVMuZm9ybURhdGFLZXkubmFtZV06IGtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wZW5Jbk5ld1dpbmRvdykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycsICdub3JlZmVycmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2godXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZERhbmdlclRvYXN0KHQoJ1VuYWJsZSB0byBjcmVhdGUgY2hhcnQgd2l0aG91dCBhIHF1ZXJ5IGlkLicpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0RXhwb3J0Q3N2VXJsID0gKGNsaWVudElkKSA9PiBgL2FwaS92MS9zcWxsYWIvZXhwb3J0LyR7Y2xpZW50SWR9L2A7XG4gICAgY29uc3QgcmVuZGVyQ29udHJvbHMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzZWFyY2ggfHwgdmlzdWFsaXplIHx8IGNzdikge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHRzLCBxdWVyeUxpbWl0LCBsaW1pdGluZ0ZhY3Rvciwgcm93cyB9ID0gcXVlcnk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHF1ZXJ5TGltaXQgfHwgcmVzdWx0cy5xdWVyeS5saW1pdDtcbiAgICAgICAgICAgIGNvbnN0IHJvd3NDb3VudCA9IE1hdGgubWluKHJvd3MgfHwgMCwgcmVzdWx0cz8uZGF0YT8ubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgbGV0IHsgZGF0YSB9ID0gcXVlcnkucmVzdWx0cztcbiAgICAgICAgICAgIGlmIChjYWNoZSAmJiBxdWVyeS5jYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gY2FjaGVkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29sdW1ucyB9ID0gcXVlcnkucmVzdWx0cztcbiAgICAgICAgICAgIC8vIEFkZGVkIGNvbXB1dGUgbG9naWMgdG8gc3RvcCB1c2VyIGZyb20gYmVpbmcgYWJsZSB0byBTYXZlICYgRXhwbG9yZVxuICAgICAgICAgICAgY29uc3QgZGF0YXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBxdWVyeS5yZXN1bHRzLmNvbHVtbnMsXG4gICAgICAgICAgICAgICAgbmFtZTogcXVlcnk/LnRhYiB8fCAnVW50aXRsZWQnLFxuICAgICAgICAgICAgICAgIGRiSWQ6IHF1ZXJ5Py5kYklkLFxuICAgICAgICAgICAgICAgIHNxbDogcXVlcnk/LnNxbCxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVBhcmFtczogcXVlcnk/LnRlbXBsYXRlUGFyYW1zLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogcXVlcnk/LnNjaGVtYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYW5FeHBvcnREYXRhID0gZmluZFBlcm1pc3Npb24oJ2Nhbl9leHBvcnRfY3N2JywgJ1NRTExhYicsIHVzZXI/LnJvbGVzKTtcbiAgICAgICAgICAgIHJldHVybiAoPFJlc3VsdFNldENvbnRyb2xzPlxuICAgICAgICAgIDxTYXZlRGF0YXNldE1vZGFsIHZpc2libGU9e3Nob3dTYXZlRGF0YXNldE1vZGFsfSBvbkhpZGU9eygpID0+IHNldFNob3dTYXZlRGF0YXNldE1vZGFsKGZhbHNlKX0gYnV0dG9uVGV4dE9uU2F2ZT17dCgnU2F2ZSAmIEV4cGxvcmUnKX0gYnV0dG9uVGV4dE9uT3ZlcndyaXRlPXt0KCdPdmVyd3JpdGUgJiBFeHBsb3JlJyl9IG1vZGFsRGVzY3JpcHRpb249e3QoJ1NhdmUgdGhpcyBxdWVyeSBhcyBhIHZpcnR1YWwgZGF0YXNldCB0byBjb250aW51ZSBleHBsb3JpbmcnKX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0vPlxuICAgICAgICAgIDxSZXN1bHRTZXRCdXR0b25zPlxuICAgICAgICAgICAge3Zpc3VhbGl6ZSAmJiBkYXRhYmFzZT8uYWxsb3dzX3ZpcnR1YWxfdGFibGVfZXhwbG9yZSAmJiAoPEV4cGxvcmVSZXN1bHRzQnV0dG9uIGRhdGFiYXNlPXtkYXRhYmFzZX0gb25DbGljaz17Y3JlYXRlRXhwbG9yZVJlc3VsdHNPbkNsaWNrfS8+KX1cbiAgICAgICAgICAgIHtjc3YgJiYgY2FuRXhwb3J0RGF0YSAmJiAoPEJ1dHRvbiBjc3M9e2NvcHlCdXR0b25TdHlsZXN9IGJ1dHRvblNpemU9XCJzbWFsbFwiIGhyZWY9e2dldEV4cG9ydENzdlVybChxdWVyeS5pZCl9IGRhdGEtdGVzdD1cImV4cG9ydC1jc3YtYnV0dG9uXCIgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nQWN0aW9uKExPR19BQ1RJT05TX1NRTExBQl9ET1dOTE9BRF9DU1YsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdGluZ0ZhY3RvciA9PT0gTGltaXRpbmdGYWN0b3IuRHJvcGRvd24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9PT0gcm93c0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kYWwud2FybmluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0KCdEb3dubG9hZCBpcyBvbiB0aGUgd2F5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHQoJ0Rvd25sb2FkaW5nICUocm93cylzIHJvd3MgYmFzZWQgb24gdGhlIExJTUlUIGNvbmZpZ3VyYXRpb24uIElmIHlvdSB3YW50IHRoZSBlbnRpcmUgcmVzdWx0IHNldCwgeW91IG5lZWQgdG8gYWRqdXN0IHRoZSBMSU1JVC4nLCB7IHJvd3M6IHJvd3NDb3VudC50b0xvY2FsZVN0cmluZygpIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICA8SWNvbnMuRG93bmxvYWRPdXRsaW5lZCBpY29uU2l6ZT1cIm1cIiBpY29uQ29sb3I9e3RoZW1lLmNvbG9ycy5wcmltYXJ5LmRhcmsyfS8+eycgJ31cbiAgICAgICAgICAgICAgICB7dCgnRG93bmxvYWQgdG8gQ1NWJyl9XG4gICAgICAgICAgICAgIDwvQnV0dG9uPil9XG5cbiAgICAgICAgICAgIHtjYW5FeHBvcnREYXRhICYmICg8Q29weVRvQ2xpcGJvYXJkIHRleHQ9e3ByZXBhcmVDb3B5VG9DbGlwYm9hcmRUYWJ1bGFyRGF0YShkYXRhLCBjb2x1bW5zKX0gd3JhcHBlZD17ZmFsc2V9IGNvcHlOb2RlPXs8QnV0dG9uIGNzcz17Y29weUJ1dHRvblN0eWxlc30gYnV0dG9uU2l6ZT1cInNtYWxsXCIgZGF0YS10ZXN0PVwiY29weS10by1jbGlwYm9hcmQtYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxJY29ucy5Db3B5T3V0bGluZWQgaWNvblNpemU9XCJzXCIgaWNvbkNvbG9yPXt0aGVtZS5jb2xvcnMucHJpbWFyeS5kYXJrMn0vPnsnICd9XG4gICAgICAgICAgICAgICAgICAgIHt0KCdDb3B5IHRvIENsaXBib2FyZCcpfVxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+fSBoaWRlVG9vbHRpcCBvbkNvcHlFbmQ9eygpID0+IGxvZ0FjdGlvbihMT0dfQUNUSU9OU19TUUxMQUJfQ09QWV9SRVNVTFRfVE9fQ0xJUEJPQVJELCB7fSl9Lz4pfVxuICAgICAgICAgIDwvUmVzdWx0U2V0QnV0dG9ucz5cbiAgICAgICAgICB7c2VhcmNoICYmICg8aW5wdXQgdHlwZT1cInRleHRcIiBvbkNoYW5nZT17Y2hhbmdlU2VhcmNofSB2YWx1ZT17c2VhcmNoVGV4dH0gY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCIgcGxhY2Vob2xkZXI9e3QoJ0ZpbHRlciByZXN1bHRzJyl9Lz4pfVxuICAgICAgICA8L1Jlc3VsdFNldENvbnRyb2xzPik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDxkaXYgLz47XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJSb3dzUmV0dXJuZWQgPSAoYWxlcnRNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0cywgcm93cywgcXVlcnlMaW1pdCwgbGltaXRpbmdGYWN0b3IgfSA9IHF1ZXJ5O1xuICAgICAgICBsZXQgbGltaXRNZXNzYWdlID0gJyc7XG4gICAgICAgIGNvbnN0IGxpbWl0UmVhY2hlZCA9IHJlc3VsdHM/LmRpc3BsYXlMaW1pdFJlYWNoZWQ7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gcXVlcnlMaW1pdCB8fCByZXN1bHRzLnF1ZXJ5LmxpbWl0O1xuICAgICAgICBjb25zdCBpc0FkbWluID0gISF1c2VyPy5yb2xlcz8uQWRtaW47XG4gICAgICAgIGNvbnN0IHJvd3NDb3VudCA9IE1hdGgubWluKHJvd3MgfHwgMCwgcmVzdWx0cz8uZGF0YT8ubGVuZ3RoIHx8IDApO1xuICAgICAgICBjb25zdCBkaXNwbGF5TWF4Um93c1JlYWNoZWRNZXNzYWdlID0ge1xuICAgICAgICAgICAgd2l0aEFkbWluOiB0KCdUaGUgbnVtYmVyIG9mIHJlc3VsdHMgZGlzcGxheWVkIGlzIGxpbWl0ZWQgdG8gJShyb3dzKWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gRElTUExBWV9NQVhfUk9XLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGFkZCBhZGRpdGlvbmFsIGxpbWl0cy9maWx0ZXJzIG9yIGRvd25sb2FkIHRvIGNzdiB0byBzZWUgbW9yZSByb3dzIHVwIHRvICcgK1xuICAgICAgICAgICAgICAgICd0aGUgJShsaW1pdClkIGxpbWl0LicsIHsgcm93czogcm93c0NvdW50LCBsaW1pdCB9KSxcbiAgICAgICAgICAgIHdpdGhvdXRBZG1pbjogdCgnVGhlIG51bWJlciBvZiByZXN1bHRzIGRpc3BsYXllZCBpcyBsaW1pdGVkIHRvICUocm93cylkLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGFkZCBhZGRpdGlvbmFsIGxpbWl0cy9maWx0ZXJzLCBkb3dubG9hZCB0byBjc3YsIG9yIGNvbnRhY3QgYW4gYWRtaW4gJyArXG4gICAgICAgICAgICAgICAgJ3RvIHNlZSBtb3JlIHJvd3MgdXAgdG8gdGhlICUobGltaXQpZCBsaW1pdC4nLCB7IHJvd3M6IHJvd3NDb3VudCwgbGltaXQgfSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZFVzZURlZmF1bHREcm9wZG93bkFsZXJ0ID0gbGltaXQgPT09IGRlZmF1bHRRdWVyeUxpbWl0ICYmIGxpbWl0aW5nRmFjdG9yID09PSBMaW1pdGluZ0ZhY3Rvci5Ecm9wZG93bjtcbiAgICAgICAgaWYgKGxpbWl0aW5nRmFjdG9yID09PSBMaW1pdGluZ0ZhY3Rvci5RdWVyeSAmJiBjc3YpIHtcbiAgICAgICAgICAgIGxpbWl0TWVzc2FnZSA9IHQoJ1RoZSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgaXMgbGltaXRlZCB0byAlKHJvd3MpZCBieSB0aGUgcXVlcnknLCB7IHJvd3MgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGltaXRpbmdGYWN0b3IgPT09IExpbWl0aW5nRmFjdG9yLkRyb3Bkb3duICYmXG4gICAgICAgICAgICAhc2hvdWxkVXNlRGVmYXVsdERyb3Bkb3duQWxlcnQpIHtcbiAgICAgICAgICAgIGxpbWl0TWVzc2FnZSA9IHQoJ1RoZSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgaXMgbGltaXRlZCB0byAlKHJvd3MpZCBieSB0aGUgbGltaXQgZHJvcGRvd24uJywgeyByb3dzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbWl0aW5nRmFjdG9yID09PSBMaW1pdGluZ0ZhY3Rvci5RdWVyeUFuZERyb3Bkb3duKSB7XG4gICAgICAgICAgICBsaW1pdE1lc3NhZ2UgPSB0KCdUaGUgbnVtYmVyIG9mIHJvd3MgZGlzcGxheWVkIGlzIGxpbWl0ZWQgdG8gJShyb3dzKWQgYnkgdGhlIHF1ZXJ5IGFuZCBsaW1pdCBkcm9wZG93bi4nLCB7IHJvd3MgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkUm93Q291bnQgPSBnZXROdW1iZXJGb3JtYXR0ZXIoKShyb3dzKTtcbiAgICAgICAgY29uc3Qgcm93c1JldHVybmVkTWVzc2FnZSA9IHQoJyUocm93cylkIHJvd3MgcmV0dXJuZWQnLCB7XG4gICAgICAgICAgICByb3dzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9vbHRpcFRleHQgPSBgJHtyb3dzUmV0dXJuZWRNZXNzYWdlfS4gJHtsaW1pdE1lc3NhZ2V9YDtcbiAgICAgICAgaWYgKGFsZXJ0TWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuICg8PlxuICAgICAgICAgIHshbGltaXRSZWFjaGVkICYmIHNob3VsZFVzZURlZmF1bHREcm9wZG93bkFsZXJ0ICYmICg8ZGl2IHJlZj17Y2FsY3VsYXRlQWxlcnRSZWZIZWlnaHR9PlxuICAgICAgICAgICAgICA8QWxlcnQgdHlwZT1cIndhcm5pbmdcIiBtZXNzYWdlPXt0KCclKHJvd3MpZCByb3dzIHJldHVybmVkJywgeyByb3dzIH0pfSBvbkNsb3NlPXsoKSA9PiBzZXRBbGVydElzT3BlbihmYWxzZSl9IGRlc2NyaXB0aW9uPXt0KCdUaGUgbnVtYmVyIG9mIHJvd3MgZGlzcGxheWVkIGlzIGxpbWl0ZWQgdG8gJShyb3dzKWQgYnkgdGhlIGRyb3Bkb3duLicsIHsgcm93cyB9KX0vPlxuICAgICAgICAgICAgPC9kaXY+KX1cbiAgICAgICAgICB7bGltaXRSZWFjaGVkICYmICg8ZGl2IHJlZj17Y2FsY3VsYXRlQWxlcnRSZWZIZWlnaHR9PlxuICAgICAgICAgICAgICA8QWxlcnQgdHlwZT1cIndhcm5pbmdcIiBvbkNsb3NlPXsoKSA9PiBzZXRBbGVydElzT3BlbihmYWxzZSl9IG1lc3NhZ2U9e3QoJyUocm93cylkIHJvd3MgcmV0dXJuZWQnLCB7IHJvd3M6IHJvd3NDb3VudCB9KX0gZGVzY3JpcHRpb249e2lzQWRtaW5cbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGlzcGxheU1heFJvd3NSZWFjaGVkTWVzc2FnZS53aXRoQWRtaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGlzcGxheU1heFJvd3NSZWFjaGVkTWVzc2FnZS53aXRob3V0QWRtaW59Lz5cbiAgICAgICAgICAgIDwvZGl2Pil9XG4gICAgICAgIDwvPik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvd1Jvd3NSZXR1cm5lZCA9IHNob3dTcWxJbmxpbmUgfHwgKCFsaW1pdFJlYWNoZWQgJiYgIXNob3VsZFVzZURlZmF1bHREcm9wZG93bkFsZXJ0KTtcbiAgICAgICAgcmV0dXJuICg8PlxuICAgICAgICB7c2hvd1Jvd3NSZXR1cm5lZCAmJiAoPFJldHVybmVkUm93cz5cbiAgICAgICAgICAgIDxUb29sdGlwIGlkPVwic3FsbGFiLXJvd2NvdW50LXRvb2x0aXBcIiB0aXRsZT17dG9vbHRpcFRleHR9IHBsYWNlbWVudD1cImxlZnRcIj5cbiAgICAgICAgICAgICAgPExhYmVsIGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMubH1weDtcbiAgICAgICAgICAgICAgICBgfT5cbiAgICAgICAgICAgICAgICB7bGltaXRNZXNzYWdlICYmICg8SWNvbnMuRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZCBjc3M9e2NzcyBgXG4gICAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMubX1weDtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuZ3JpZFVuaXR9cHg7XG4gICAgICAgICAgICAgICAgICAgIGB9Lz4pfVxuICAgICAgICAgICAgICAgIHt0bignJXMgcm93JywgJyVzIHJvd3MnLCByb3dzLCBmb3JtYXR0ZWRSb3dDb3VudCl9XG4gICAgICAgICAgICAgIDwvTGFiZWw+XG4gICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgPC9SZXR1cm5lZFJvd3M+KX1cbiAgICAgIDwvPik7XG4gICAgfTtcbiAgICBjb25zdCBsaW1pdFJlYWNoZWQgPSBxdWVyeT8ucmVzdWx0cz8uZGlzcGxheUxpbWl0UmVhY2hlZDtcbiAgICBsZXQgc3FsO1xuICAgIGxldCBleHBsb3JlREJJZCA9IHF1ZXJ5LmRiSWQ7XG4gICAgaWYgKGRhdGFiYXNlPy5leHBsb3JlX2RhdGFiYXNlX2lkKSB7XG4gICAgICAgIGV4cGxvcmVEQklkID0gZGF0YWJhc2UuZXhwbG9yZV9kYXRhYmFzZV9pZDtcbiAgICB9XG4gICAgbGV0IHRyYWNraW5nVXJsO1xuICAgIGlmIChxdWVyeS50cmFja2luZ1VybCAmJlxuICAgICAgICBxdWVyeS5zdGF0ZSAhPT0gUXVlcnlTdGF0ZS5TdWNjZXNzICYmXG4gICAgICAgIHF1ZXJ5LnN0YXRlICE9PSBRdWVyeVN0YXRlLkZldGNoaW5nKSB7XG4gICAgICAgIHRyYWNraW5nVXJsID0gKDxCdXR0b24gY2xhc3NOYW1lPVwic3FsLXJlc3VsdC10cmFjay1qb2JcIiBidXR0b25TaXplPVwic21hbGxcIiBocmVmPXtxdWVyeS50cmFja2luZ1VybH0gdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgIHtxdWVyeS5zdGF0ZSA9PT0gUXVlcnlTdGF0ZS5SdW5uaW5nXG4gICAgICAgICAgICAgICAgPyB0KCdUcmFjayBqb2InKVxuICAgICAgICAgICAgICAgIDogdCgnU2VlIHF1ZXJ5IGRldGFpbHMnKX1cbiAgICAgIDwvQnV0dG9uPik7XG4gICAgfVxuICAgIGlmIChzaG93U3FsKSB7XG4gICAgICAgIHNxbCA9ICg8SGlnaGxpZ2h0ZWRTcWwgc3FsPXtxdWVyeS5zcWx9IHsuLi4oc2hvd1NxbElubGluZSAmJiB7IG1heExpbmVzOiAxLCBtYXhXaWR0aDogNjAgfSl9Lz4pO1xuICAgIH1cbiAgICBpZiAocXVlcnkuc3RhdGUgPT09IFF1ZXJ5U3RhdGUuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm4gPEFsZXJ0IHR5cGU9XCJ3YXJuaW5nXCIgbWVzc2FnZT17dCgnUXVlcnkgd2FzIHN0b3BwZWQnKX0vPjtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnN0YXRlID09PSBRdWVyeVN0YXRlLkZhaWxlZCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbLi4uKHF1ZXJ5LmV4dHJhPy5lcnJvcnMgfHwgW10pLCAuLi4ocXVlcnkuZXJyb3JzIHx8IFtdKV07XG4gICAgICAgIHJldHVybiAoPFJlc3VsdGxlc3NTdHlsZXM+XG4gICAgICAgIHtlcnJvcnMubWFwKChlcnJvciwgaW5kZXgpID0+ICg8RXJyb3JNZXNzYWdlV2l0aFN0YWNrVHJhY2Uga2V5PXtpbmRleH0gdGl0bGU9e3QoJ0RhdGFiYXNlIGVycm9yJyl9IGVycm9yPXtlcnJvcn0gc3VidGl0bGU9ezxNb25vc3BhY2VEaXY+e2Vycm9yLm1lc3NhZ2V9PC9Nb25vc3BhY2VEaXY+fSBjb3B5VGV4dD17ZXJyb3IubWVzc2FnZSB8fCB1bmRlZmluZWR9IGxpbms9e3F1ZXJ5Lmxpbmt9IHNvdXJjZT1cInNxbGxhYlwiLz4pKX1cbiAgICAgICAge2Vycm9ycy5zb21lKGVycm9yID0+IGVycm9yPy5lcnJvcl90eXBlID09PSBFcnJvclR5cGVFbnVtLkZST05URU5EX1RJTUVPVVRfRVJST1IpID8gKDxCdXR0b24gY2xhc3NOYW1lPVwic3FsLXJlc3VsdC10cmFjay1qb2JcIiBidXR0b25TaXplPVwic21hbGxcIiBvbkNsaWNrPXsoKSA9PiBmZXRjaFJlc3VsdHMocXVlcnksIDApfT5cbiAgICAgICAgICAgIHt0KCdSZXRyeSBmZXRjaGluZyByZXN1bHRzJyl9XG4gICAgICAgICAgPC9CdXR0b24+KSA6ICh0cmFja2luZ1VybCl9XG4gICAgICA8L1Jlc3VsdGxlc3NTdHlsZXM+KTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnN0YXRlID09PSBRdWVyeVN0YXRlLlN1Y2Nlc3MgJiYgcXVlcnkuY3Rhcykge1xuICAgICAgICBjb25zdCB7IHRlbXBTY2hlbWEsIHRlbXBUYWJsZSB9ID0gcXVlcnk7XG4gICAgICAgIGxldCBvYmplY3QgPSAnVGFibGUnO1xuICAgICAgICBpZiAocXVlcnkuY3Rhc19tZXRob2QgPT09IEN0YXNFbnVtLlZpZXcpIHtcbiAgICAgICAgICAgIG9iamVjdCA9ICdWaWV3JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxkaXY+XG4gICAgICAgIDxBbGVydCB0eXBlPVwiaW5mb1wiIG1lc3NhZ2U9ezw+XG4gICAgICAgICAgICAgIHt0KG9iamVjdCl9IFtcbiAgICAgICAgICAgICAgPHN0cm9uZz5cbiAgICAgICAgICAgICAgICB7dGVtcFNjaGVtYSA/IGAke3RlbXBTY2hlbWF9LmAgOiAnJ31cbiAgICAgICAgICAgICAgICB7dGVtcFRhYmxlfVxuICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgXSB7dCgnd2FzIGNyZWF0ZWQnKX0gJm5ic3A7XG4gICAgICAgICAgICAgIDxCdXR0b25Hcm91cD5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIGJ1dHRvblNpemU9XCJzbWFsbFwiIGNzcz17eyBtYXJnaW5SaWdodDogdGhlbWUuZ3JpZFVuaXQgfX0gb25DbGljaz17KCkgPT4gcG9wU2VsZWN0U3Rhcih0ZW1wU2NoZW1hLCB0ZW1wVGFibGUpfT5cbiAgICAgICAgICAgICAgICAgIHt0KCdRdWVyeSBpbiBhIG5ldyB0YWInKX1cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8RXhwbG9yZUN0YXNSZXN1bHRzQnV0dG9uIHRhYmxlPXt0ZW1wVGFibGV9IHNjaGVtYT17dGVtcFNjaGVtYX0gZGJJZD17ZXhwbG9yZURCSWR9Lz5cbiAgICAgICAgICAgICAgPC9CdXR0b25Hcm91cD5cbiAgICAgICAgICAgIDwvPn0vPlxuICAgICAgPC9kaXY+KTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnN0YXRlID09PSBRdWVyeVN0YXRlLlN1Y2Nlc3MgJiYgcXVlcnkucmVzdWx0cykge1xuICAgICAgICBjb25zdCB7IHJlc3VsdHMgfSA9IHF1ZXJ5O1xuICAgICAgICAvLyBBY2NvdW50cyBmb3Igb2Zmc2V0IG5lZWRlZCBmb3IgaGVpZ2h0IG9mIFJlc3VsdFNldFJvd3NSZXR1cm5lZCBjb21wb25lbnQgaWYgIWxpbWl0UmVhY2hlZFxuICAgICAgICBjb25zdCByb3dNZXNzYWdlSGVpZ2h0ID0gIWxpbWl0UmVhY2hlZCA/IDMyIDogMDtcbiAgICAgICAgLy8gQWNjb3VudHMgZm9yIG9mZnNldCBuZWVkZWQgZm9yIGhlaWdodCBvZiBBbGVydCBpZiB0aGlzLnN0YXRlLmFsZXJ0SXNPcGVuXG4gICAgICAgIGNvbnN0IGFsZXJ0Q29udGFpbmVySGVpZ2h0ID0gNzA7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhpcy5yZW5kZXJSb3dzUmV0dXJuZWQoKVxuICAgICAgICAvLyBpZiB3ZSB3YW50IHJlc3VsdHMgcGFuZWwgdG8gYmUgcHJvcGVyIGhlaWdodCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBGaWx0ZXJUYWJsZSBjb21wb25lbnQgbmVlZHMgYW4gZXhwbGljaXQgaGVpZ2h0IHRvIHJlbmRlclxuICAgICAgICAvLyB0aGUgVGFibGUgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IHJvd3NIZWlnaHQgPSBhbGVydElzT3BlblxuICAgICAgICAgICAgPyBoZWlnaHQgLSBhbGVydENvbnRhaW5lckhlaWdodFxuICAgICAgICAgICAgOiBoZWlnaHQgLSByb3dNZXNzYWdlSGVpZ2h0O1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHF1ZXJ5LmNhY2hlZCkge1xuICAgICAgICAgICAgZGF0YSA9IGNhY2hlZERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0cz8uZGF0YSkge1xuICAgICAgICAgICAgKHsgZGF0YSB9ID0gcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZENvbHVtbnMgPSByZXN1bHRzLmV4cGFuZGVkX2NvbHVtbnNcbiAgICAgICAgICAgICAgICA/IHJlc3VsdHMuZXhwYW5kZWRfY29sdW1ucy5tYXAoY29sID0+IGNvbC5jb2x1bW5fbmFtZSlcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dIVE1MID0gZ2V0SXRlbShMb2NhbFN0b3JhZ2VLZXlzLlNxbGxhYklzUmVuZGVySHRtbEVuYWJsZWQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICg8UmVzdWx0Q29udGFpbmVyPlxuICAgICAgICAgIHtyZW5kZXJDb250cm9scygpfVxuICAgICAgICAgIHtzaG93U3FsICYmIHNob3dTcWxJbmxpbmUgPyAoPD5cbiAgICAgICAgICAgICAgPGRpdiBjc3M9e2NzcyBgXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgICAgZ2FwOiAke0dBUH1weDtcbiAgICAgICAgICAgICAgICBgfT5cbiAgICAgICAgICAgICAgICA8Q2FyZCBjc3M9e1tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcyBgXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyOHB4O1xuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSAke1JPV1NfQ0hJUF9XSURUSCArIEdBUH1weCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29kZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICAgICAgXX0+XG4gICAgICAgICAgICAgICAgICB7c3FsfVxuICAgICAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgICAgICB7cmVuZGVyUm93c1JldHVybmVkKGZhbHNlKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHtyZW5kZXJSb3dzUmV0dXJuZWQodHJ1ZSl9XG4gICAgICAgICAgICA8Lz4pIDogKDw+XG4gICAgICAgICAgICAgIHtyZW5kZXJSb3dzUmV0dXJuZWQoZmFsc2UpfVxuICAgICAgICAgICAgICB7cmVuZGVyUm93c1JldHVybmVkKHRydWUpfVxuICAgICAgICAgICAgICB7c3FsfVxuICAgICAgICAgICAgPC8+KX1cbiAgICAgICAgICA8UmVzdWx0VGFibGUgZGF0YT17ZGF0YX0gcXVlcnlJZD17cXVlcnkuaWR9IG9yZGVyZWRDb2x1bW5LZXlzPXtyZXN1bHRzLmNvbHVtbnMubWFwKGNvbCA9PiBjb2wuY29sdW1uX25hbWUpfSBoZWlnaHQ9e3Jvd3NIZWlnaHR9IGZpbHRlclRleHQ9e3NlYXJjaFRleHR9IGV4cGFuZGVkQ29sdW1ucz17ZXhwYW5kZWRDb2x1bW5zfSBhbGxvd0hUTUw9e2FsbG93SFRNTH0vPlxuICAgICAgICA8L1Jlc3VsdENvbnRhaW5lcj4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gPEFsZXJ0IHR5cGU9XCJ3YXJuaW5nXCIgbWVzc2FnZT17dCgnVGhlIHF1ZXJ5IHJldHVybmVkIG5vIGRhdGEnKX0vPjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkuY2FjaGVkIHx8IChxdWVyeS5zdGF0ZSA9PT0gUXVlcnlTdGF0ZS5TdWNjZXNzICYmICFxdWVyeS5yZXN1bHRzKSkge1xuICAgICAgICBpZiAocXVlcnkuaXNEYXRhUHJldmlldykge1xuICAgICAgICAgICAgcmV0dXJuICg8QnV0dG9uIGJ1dHRvblNpemU9XCJzbWFsbFwiIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiIG9uQ2xpY2s9eygpID0+IGRpc3BhdGNoKHJlRmV0Y2hRdWVyeVJlc3VsdHMoe1xuICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgaXNEYXRhUHJldmlldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSl9PlxuICAgICAgICAgIHt0KCdGZXRjaCBkYXRhIHByZXZpZXcnKX1cbiAgICAgICAgPC9CdXR0b24+KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkucmVzdWx0c0tleSkge1xuICAgICAgICAgICAgcmV0dXJuICg8QnV0dG9uIGJ1dHRvblNpemU9XCJzbWFsbFwiIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiIG9uQ2xpY2s9eygpID0+IGZldGNoUmVzdWx0cyhxdWVyeSl9PlxuICAgICAgICAgIHt0KCdSZWZldGNoIHJlc3VsdHMnKX1cbiAgICAgICAgPC9CdXR0b24+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvZ3Jlc3NCYXI7XG4gICAgaWYgKHF1ZXJ5LnByb2dyZXNzID4gMCkge1xuICAgICAgICBwcm9ncmVzc0JhciA9ICg8UHJvZ3Jlc3NCYXIgcGVyY2VudD17cGFyc2VJbnQocXVlcnkucHJvZ3Jlc3MudG9GaXhlZCgwKSwgMTApfSBzdHJpcGVkLz4pO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmVzc01zZyA9IHF1ZXJ5Py5leHRyYT8ucHJvZ3Jlc3MgPz8gbnVsbDtcbiAgICByZXR1cm4gKDxSZXN1bHRsZXNzU3R5bGVzPlxuICAgICAgPGRpdj57IXByb2dyZXNzQmFyICYmIDxMb2FkaW5nIHBvc2l0aW9uPVwibm9ybWFsXCIvPn08L2Rpdj5cbiAgICAgIHsvKiBzaG93IGxvYWRpbmcgYmFyIHdoZW5ldmVyIHByb2dyZXNzIGJhciBpcyBjb21wbGV0ZWQgYnV0IG5lZWRzIHRpbWUgdG8gcmVuZGVyICovfVxuICAgICAgPGRpdj57cXVlcnkucHJvZ3Jlc3MgPT09IDEwMCAmJiA8TG9hZGluZyBwb3NpdGlvbj1cIm5vcm1hbFwiLz59PC9kaXY+XG4gICAgICA8UXVlcnlTdGF0ZUxhYmVsIHF1ZXJ5PXtxdWVyeX0vPlxuICAgICAgPGRpdj57cHJvZ3Jlc3NNc2cgJiYgPEFsZXJ0IHR5cGU9XCJzdWNjZXNzXCIgbWVzc2FnZT17cHJvZ3Jlc3NNc2d9Lz59PC9kaXY+XG4gICAgICA8ZGl2PntxdWVyeS5wcm9ncmVzcyAhPT0gMTAwICYmIHByb2dyZXNzQmFyfTwvZGl2PlxuICAgICAge3RyYWNraW5nVXJsICYmIDxkaXY+e3RyYWNraW5nVXJsfTwvZGl2Pn1cbiAgICA8L1Jlc3VsdGxlc3NTdHlsZXM+KTtcbn07XG5leHBvcnQgZGVmYXVsdCBtZW1vKFJlc3VsdFNldCk7XG4iXX0= */\"), onClick: () => popSelectStar(tempSchema, tempTable), children:\n              t('Query in a new tab') }\n            ),\n            _jsx(ExploreCtasResultsButton, { table: tempTable, schema: tempSchema, dbId: exploreDBId })] }\n          )] }\n        ) }) }\n    );\n  }\n  if (query.state === QueryState.Success && query.results) {\n    const { results } = query;\n    // Accounts for offset needed for height of ResultSetRowsReturned component if !limitReached\n    const rowMessageHeight = !limitReached ? 32 : 0;\n    // Accounts for offset needed for height of Alert if this.state.alertIsOpen\n    const alertContainerHeight = 70;\n    // We need to calculate the height of this.renderRowsReturned()\n    // if we want results panel to be proper height because the\n    // FilterTable component needs an explicit height to render\n    // the Table component\n    const rowsHeight = alertIsOpen ?\n    height - alertContainerHeight :\n    height - rowMessageHeight;\n    let data;\n    if (cache && query.cached) {\n      data = cachedData;\n    } else\n    if (results != null && results.data) {\n      ({ data } = results);\n    }\n    if (data && data.length > 0) {\n      const expandedColumns = results.expanded_columns ?\n      results.expanded_columns.map((col) => col.column_name) :\n      [];\n      const allowHTML = getItem(LocalStorageKeys.SqllabIsRenderHtmlEnabled, true);\n      return _jsxs(ResultContainer, { children: [\n        renderControls(),\n        showSql && showSqlInline ? _jsxs(_Fragment, { children: [\n          _jsxs(\"div\", { css: css`\n                  display: flex;\n                  justify-content: space-between;\n                  gap: ${GAP}px;\n                `, children: [\n            _jsx(Card, { css: [\n              css`\n                      height: 28px;\n                      width: calc(100% - ${ROWS_CHIP_WIDTH + GAP}px);\n                      code {\n                        width: 100%;\n                        overflow: hidden;\n                        white-space: nowrap !important;\n                        text-overflow: ellipsis;\n                        display: block;\n                      }\n                    `, process.env.NODE_ENV === \"production\" ? \"\" : \";label:ResultSet;\", process.env.NODE_ENV === \"production\" ? \"\" : \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvc3JjL1NxbExhYi9jb21wb25lbnRzL1Jlc3VsdFNldC9pbmRleC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNlpzQiIsImZpbGUiOiIvaG9tZS9hZGVsL3N1cGVyc2V0L3N1cGVyc2V0LWZyb250ZW5kL3NyYy9TcWxMYWIvY29tcG9uZW50cy9SZXN1bHRTZXQvaW5kZXgudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUsIG1lbW8sIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0VxdWFsLCB1c2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyB1c2VIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyBwaWNrIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCdXR0b25Hcm91cCBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b25Hcm91cCc7XG5pbXBvcnQgQWxlcnQgZnJvbSAnc3JjL2NvbXBvbmVudHMvQWxlcnQnO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b24nO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnbmFub2lkJztcbmltcG9ydCB7IFF1ZXJ5U3RhdGUsIHN0eWxlZCwgdCwgdG4sIHVzZVRoZW1lLCB1c2VQcmV2aW91cywgY3NzLCBnZXROdW1iZXJGb3JtYXR0ZXIsIGdldEV4dGVuc2lvbnNSZWdpc3RyeSwgRXJyb3JUeXBlRW51bSwgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgRXJyb3JNZXNzYWdlV2l0aFN0YWNrVHJhY2UgZnJvbSAnc3JjL2NvbXBvbmVudHMvRXJyb3JNZXNzYWdlL0Vycm9yTWVzc2FnZVdpdGhTdGFja1RyYWNlJztcbmltcG9ydCB7IFNhdmVEYXRhc2V0TW9kYWwsIH0gZnJvbSAnc3JjL1NxbExhYi9jb21wb25lbnRzL1NhdmVEYXRhc2V0TW9kYWwnO1xuaW1wb3J0IHsgRVhQTE9SRV9DSEFSVF9ERUZBVUxUIH0gZnJvbSAnc3JjL1NxbExhYi90eXBlcyc7XG5pbXBvcnQgeyBtb3VudEV4cGxvcmVVcmwgfSBmcm9tICdzcmMvZXhwbG9yZS9leHBsb3JlVXRpbHMnO1xuaW1wb3J0IHsgcG9zdEZvcm1EYXRhIH0gZnJvbSAnc3JjL2V4cGxvcmUvZXhwbG9yZVV0aWxzL2Zvcm1EYXRhJztcbmltcG9ydCBQcm9ncmVzc0JhciBmcm9tICdzcmMvY29tcG9uZW50cy9Qcm9ncmVzc0Jhcic7XG5pbXBvcnQgTG9hZGluZyBmcm9tICdzcmMvY29tcG9uZW50cy9Mb2FkaW5nJztcbmltcG9ydCBDYXJkIGZyb20gJ3NyYy9jb21wb25lbnRzL0NhcmQnO1xuaW1wb3J0IExhYmVsIGZyb20gJ3NyYy9jb21wb25lbnRzL0xhYmVsJztcbmltcG9ydCB7IFRvb2x0aXAgfSBmcm9tICdzcmMvY29tcG9uZW50cy9Ub29sdGlwJztcbmltcG9ydCBGaWx0ZXJhYmxlVGFibGUgZnJvbSAnc3JjL2NvbXBvbmVudHMvRmlsdGVyYWJsZVRhYmxlJztcbmltcG9ydCBDb3B5VG9DbGlwYm9hcmQgZnJvbSAnc3JjL2NvbXBvbmVudHMvQ29weVRvQ2xpcGJvYXJkJztcbmltcG9ydCB7IGFkZERhbmdlclRvYXN0IH0gZnJvbSAnc3JjL2NvbXBvbmVudHMvTWVzc2FnZVRvYXN0cy9hY3Rpb25zJztcbmltcG9ydCB7IHByZXBhcmVDb3B5VG9DbGlwYm9hcmRUYWJ1bGFyRGF0YSB9IGZyb20gJ3NyYy91dGlscy9jb21tb24nO1xuaW1wb3J0IHsgZ2V0SXRlbSwgTG9jYWxTdG9yYWdlS2V5cyB9IGZyb20gJ3NyYy91dGlscy9sb2NhbFN0b3JhZ2VIZWxwZXJzJztcbmltcG9ydCBNb2RhbCBmcm9tICdzcmMvY29tcG9uZW50cy9Nb2RhbCc7XG5pbXBvcnQgeyBhZGRRdWVyeUVkaXRvciwgY2xlYXJRdWVyeVJlc3VsdHMsIEN0YXNFbnVtLCBmZXRjaFF1ZXJ5UmVzdWx0cywgcmVGZXRjaFF1ZXJ5UmVzdWx0cywgcmVSdW5RdWVyeSwgfSBmcm9tICdzcmMvU3FsTGFiL2FjdGlvbnMvc3FsTGFiJztcbmltcG9ydCB7IFVSTF9QQVJBTVMgfSBmcm9tICdzcmMvY29uc3RhbnRzJztcbmltcG9ydCB1c2VMb2dBY3Rpb24gZnJvbSAnc3JjL2xvZ2dlci91c2VMb2dBY3Rpb24nO1xuaW1wb3J0IHsgTE9HX0FDVElPTlNfU1FMTEFCX0NPUFlfUkVTVUxUX1RPX0NMSVBCT0FSRCwgTE9HX0FDVElPTlNfU1FMTEFCX0NSRUFURV9DSEFSVCwgTE9HX0FDVElPTlNfU1FMTEFCX0RPV05MT0FEX0NTViwgfSBmcm9tICdzcmMvbG9nZ2VyL0xvZ1V0aWxzJztcbmltcG9ydCBJY29ucyBmcm9tICdzcmMvY29tcG9uZW50cy9JY29ucyc7XG5pbXBvcnQgeyBmaW5kUGVybWlzc2lvbiB9IGZyb20gJ3NyYy91dGlscy9maW5kUGVybWlzc2lvbic7XG5pbXBvcnQgRXhwbG9yZUN0YXNSZXN1bHRzQnV0dG9uIGZyb20gJy4uL0V4cGxvcmVDdGFzUmVzdWx0c0J1dHRvbic7XG5pbXBvcnQgRXhwbG9yZVJlc3VsdHNCdXR0b24gZnJvbSAnLi4vRXhwbG9yZVJlc3VsdHNCdXR0b24nO1xuaW1wb3J0IEhpZ2hsaWdodGVkU3FsIGZyb20gJy4uL0hpZ2hsaWdodGVkU3FsJztcbmltcG9ydCBRdWVyeVN0YXRlTGFiZWwgZnJvbSAnLi4vUXVlcnlTdGF0ZUxhYmVsJztcbnZhciBMaW1pdGluZ0ZhY3RvcjtcbihmdW5jdGlvbiAoTGltaXRpbmdGYWN0b3IpIHtcbiAgICBMaW1pdGluZ0ZhY3RvcltcIlF1ZXJ5XCJdID0gXCJRVUVSWVwiO1xuICAgIExpbWl0aW5nRmFjdG9yW1wiUXVlcnlBbmREcm9wZG93blwiXSA9IFwiUVVFUllfQU5EX0RST1BET1dOXCI7XG4gICAgTGltaXRpbmdGYWN0b3JbXCJEcm9wZG93blwiXSA9IFwiRFJPUERPV05cIjtcbiAgICBMaW1pdGluZ0ZhY3RvcltcIk5vdExpbWl0ZWRcIl0gPSBcIk5PVF9MSU1JVEVEXCI7XG59KShMaW1pdGluZ0ZhY3RvciB8fCAoTGltaXRpbmdGYWN0b3IgPSB7fSkpO1xuY29uc3QgUmVzdWx0Q29udGFpbmVyID0gc3R5bGVkLmRpdiBgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIHJvdy1nYXA6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuYDtcbmNvbnN0IFJlc3VsdGxlc3NTdHlsZXMgPSBzdHlsZWQuZGl2IGBcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBtaW4taGVpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMjV9cHg7XG4gIFtyb2xlPSdhbGVydCddIHtcbiAgICBtYXJnaW4tdG9wOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMn1weDtcbiAgfVxuICAuc3FsLXJlc3VsdC10cmFjay1qb2Ige1xuICAgIG1hcmdpbi10b3A6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICB9XG5gO1xuLy8gTWFraW5nIHRleHQgcmVuZGVyIGxpbmUgYnJlYWtzL3RhYnMgYXMgaXMgYXMgbW9ub3NwYWNlLFxuLy8gYnV0IHdyYXBwaW5nIHRleHQgdG9vIHNvIHRleHQgZG9lc24ndCBvdmVyZmxvd1xuY29uc3QgTW9ub3NwYWNlRGl2ID0gc3R5bGVkLmRpdiBgXG4gIGZvbnQtZmFtaWx5OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLnR5cG9ncmFwaHkuZmFtaWxpZXMubW9ub3NwYWNlfTtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgb3ZlcmZsb3cteDogYXV0bztcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuYDtcbmNvbnN0IFJldHVybmVkUm93cyA9IHN0eWxlZC5kaXYgYFxuICBmb250LXNpemU6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xuICBsaW5lLWhlaWdodDogMTtcbmA7XG5jb25zdCBSZXN1bHRTZXRDb250cm9scyA9IHN0eWxlZC5kaXYgYFxuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5gO1xuY29uc3QgUmVzdWx0U2V0QnV0dG9ucyA9IHN0eWxlZC5kaXYgYFxuICBkaXNwbGF5OiBncmlkO1xuICBncmlkLWF1dG8tZmxvdzogY29sdW1uO1xuICBwYWRkaW5nLXJpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IDIgKiB0aGVtZS5ncmlkVW5pdH1weDtcbmA7XG5jb25zdCBjb3B5QnV0dG9uU3R5bGVzID0gY3NzIGBcbiAgJjpob3ZlciB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bnNldDtcbiAgfVxuICBzcGFuID4gOmZpcnN0LW9mLXR5cGUge1xuICAgIG1hcmdpbjogMHB4O1xuICB9XG5gO1xuY29uc3QgUk9XU19DSElQX1dJRFRIID0gMTAwO1xuY29uc3QgR0FQID0gODtcbmNvbnN0IGV4dGVuc2lvbnNSZWdpc3RyeSA9IGdldEV4dGVuc2lvbnNSZWdpc3RyeSgpO1xuY29uc3QgUmVzdWx0U2V0ID0gKHsgY2FjaGUgPSBmYWxzZSwgY3N2ID0gdHJ1ZSwgZGF0YWJhc2UgPSB7fSwgZGlzcGxheUxpbWl0LCBoZWlnaHQsIHF1ZXJ5SWQsIHNlYXJjaCA9IHRydWUsIHNob3dTcWwgPSBmYWxzZSwgc2hvd1NxbElubGluZSA9IGZhbHNlLCB2aXN1YWxpemUgPSB0cnVlLCBkZWZhdWx0UXVlcnlMaW1pdCwgfSkgPT4ge1xuICAgIGNvbnN0IHVzZXIgPSB1c2VTZWxlY3RvcigoeyB1c2VyIH0pID0+IHVzZXIsIHNoYWxsb3dFcXVhbCk7XG4gICAgY29uc3QgcXVlcnkgPSB1c2VTZWxlY3RvcigoeyBzcWxMYWI6IHsgcXVlcmllcyB9IH0pID0+IHBpY2socXVlcmllc1txdWVyeUlkXSwgW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnZXJyb3JNZXNzYWdlJyxcbiAgICAgICAgJ2NhY2hlZCcsXG4gICAgICAgICdyZXN1bHRzJyxcbiAgICAgICAgJ3Jlc3VsdHNLZXknLFxuICAgICAgICAnZGJJZCcsXG4gICAgICAgICd0YWInLFxuICAgICAgICAnc3FsJyxcbiAgICAgICAgJ3NxbEVkaXRvcklkJyxcbiAgICAgICAgJ3RlbXBsYXRlUGFyYW1zJyxcbiAgICAgICAgJ3NjaGVtYScsXG4gICAgICAgICdyb3dzJyxcbiAgICAgICAgJ3F1ZXJ5TGltaXQnLFxuICAgICAgICAnbGltaXRpbmdGYWN0b3InLFxuICAgICAgICAndHJhY2tpbmdVcmwnLFxuICAgICAgICAnc3RhdGUnLFxuICAgICAgICAnZXJyb3JzJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnY3RhcycsXG4gICAgICAgICdjdGFzX21ldGhvZCcsXG4gICAgICAgICd0ZW1wU2NoZW1hJyxcbiAgICAgICAgJ3RlbXBUYWJsZScsXG4gICAgICAgICdpc0RhdGFQcmV2aWV3JyxcbiAgICAgICAgJ3Byb2dyZXNzJyxcbiAgICAgICAgJ2V4dHJhJyxcbiAgICBdKSwgc2hhbGxvd0VxdWFsKTtcbiAgICBjb25zdCBSZXN1bHRUYWJsZSA9IGV4dGVuc2lvbnNSZWdpc3RyeS5nZXQoJ3NxbGVkaXRvci5leHRlbnNpb24ucmVzdWx0VGFibGUnKSA/P1xuICAgICAgICBGaWx0ZXJhYmxlVGFibGU7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIGNvbnN0IFtzZWFyY2hUZXh0LCBzZXRTZWFyY2hUZXh0XSA9IHVzZVN0YXRlKCcnKTtcbiAgICBjb25zdCBbY2FjaGVkRGF0YSwgc2V0Q2FjaGVkRGF0YV0gPSB1c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgW3Nob3dTYXZlRGF0YXNldE1vZGFsLCBzZXRTaG93U2F2ZURhdGFzZXRNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2FsZXJ0SXNPcGVuLCBzZXRBbGVydElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGlzdG9yeSA9IHVzZUhpc3RvcnkoKTtcbiAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgY29uc3QgbG9nQWN0aW9uID0gdXNlTG9nQWN0aW9uKHsgcXVlcnlJZCwgc3FsRWRpdG9ySWQ6IHF1ZXJ5LnNxbEVkaXRvcklkIH0pO1xuICAgIGNvbnN0IHJlUnVuUXVlcnlJZlNlc3Npb25UaW1lb3V0RXJyb3JPbk1vdW50ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocXVlcnkuZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgICBxdWVyeS5lcnJvck1lc3NhZ2UuaW5kZXhPZignc2Vzc2lvbiB0aW1lZCBvdXQnKSA+IDApIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHJlUnVuUXVlcnkocXVlcnkpKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBvbmx5IGRvIHRoaXMgdGhlIGZpcnN0IHRpbWUgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZC9tb3VudGVkXG4gICAgICAgIHJlUnVuUXVlcnlJZlNlc3Npb25UaW1lb3V0RXJyb3JPbk1vdW50KCk7XG4gICAgfSwgW3JlUnVuUXVlcnlJZlNlc3Npb25UaW1lb3V0RXJyb3JPbk1vdW50XSk7XG4gICAgY29uc3QgZmV0Y2hSZXN1bHRzID0gKHEsIHRpbWVvdXQpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goZmV0Y2hRdWVyeVJlc3VsdHMocSwgZGlzcGxheUxpbWl0LCB0aW1lb3V0KSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB1c2VQcmV2aW91cyhxdWVyeSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlICYmIHF1ZXJ5LmNhY2hlZCAmJiBxdWVyeT8ucmVzdWx0cz8uZGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2V0Q2FjaGVkRGF0YShxdWVyeS5yZXN1bHRzLmRhdGEpO1xuICAgICAgICAgICAgZGlzcGF0Y2goY2xlYXJRdWVyeVJlc3VsdHMocXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkucmVzdWx0c0tleSAmJiBxdWVyeS5yZXN1bHRzS2V5ICE9PSBwcmV2UXVlcnk/LnJlc3VsdHNLZXkpIHtcbiAgICAgICAgICAgIGZldGNoUmVzdWx0cyhxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9LCBbcXVlcnksIGNhY2hlXSk7XG4gICAgY29uc3QgY2FsY3VsYXRlQWxlcnRSZWZIZWlnaHQgPSAoYWxlcnRFbGVtZW50KSA9PiB7XG4gICAgICAgIGlmIChhbGVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNldEFsZXJ0SXNPcGVuKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0QWxlcnRJc09wZW4oZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwb3BTZWxlY3RTdGFyID0gKHRlbXBTY2hlbWEsIHRlbXBUYWJsZSkgPT4ge1xuICAgICAgICBjb25zdCBxZSA9IHtcbiAgICAgICAgICAgIGlkOiBuYW5vaWQoMTEpLFxuICAgICAgICAgICAgbmFtZTogdGVtcFRhYmxlLFxuICAgICAgICAgICAgYXV0b3J1bjogZmFsc2UsXG4gICAgICAgICAgICBkYklkOiBxdWVyeS5kYklkLFxuICAgICAgICAgICAgc3FsOiBgU0VMRUNUICogRlJPTSAke3RlbXBTY2hlbWEgPyBgJHt0ZW1wU2NoZW1hfS5gIDogJyd9JHt0ZW1wVGFibGV9YCxcbiAgICAgICAgfTtcbiAgICAgICAgZGlzcGF0Y2goYWRkUXVlcnlFZGl0b3IocWUpKTtcbiAgICB9O1xuICAgIGNvbnN0IGNoYW5nZVNlYXJjaCA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXRTZWFyY2hUZXh0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVFeHBsb3JlUmVzdWx0c09uQ2xpY2sgPSBhc3luYyAoY2xpY2tFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlc3VsdHMgfSA9IHF1ZXJ5O1xuICAgICAgICBjb25zdCBvcGVuSW5OZXdXaW5kb3cgPSBjbGlja0V2ZW50Lm1ldGFLZXk7XG4gICAgICAgIGxvZ0FjdGlvbihMT0dfQUNUSU9OU19TUUxMQUJfQ1JFQVRFX0NIQVJULCB7fSk7XG4gICAgICAgIGlmIChyZXN1bHRzPy5xdWVyeV9pZCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcG9zdEZvcm1EYXRhKHJlc3VsdHMucXVlcnlfaWQsICdxdWVyeScsIHtcbiAgICAgICAgICAgICAgICAuLi5FWFBMT1JFX0NIQVJUX0RFRkFVTFQsXG4gICAgICAgICAgICAgICAgZGF0YXNvdXJjZTogYCR7cmVzdWx0cy5xdWVyeV9pZH1fX3F1ZXJ5YCxcbiAgICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgICAgIGFsbF9jb2x1bW5zOiByZXN1bHRzLmNvbHVtbnMubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX25hbWUpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG1vdW50RXhwbG9yZVVybChudWxsLCB7XG4gICAgICAgICAgICAgICAgW1VSTF9QQVJBTVMuZm9ybURhdGFLZXkubmFtZV06IGtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wZW5Jbk5ld1dpbmRvdykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycsICdub3JlZmVycmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2godXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZERhbmdlclRvYXN0KHQoJ1VuYWJsZSB0byBjcmVhdGUgY2hhcnQgd2l0aG91dCBhIHF1ZXJ5IGlkLicpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0RXhwb3J0Q3N2VXJsID0gKGNsaWVudElkKSA9PiBgL2FwaS92MS9zcWxsYWIvZXhwb3J0LyR7Y2xpZW50SWR9L2A7XG4gICAgY29uc3QgcmVuZGVyQ29udHJvbHMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzZWFyY2ggfHwgdmlzdWFsaXplIHx8IGNzdikge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHRzLCBxdWVyeUxpbWl0LCBsaW1pdGluZ0ZhY3Rvciwgcm93cyB9ID0gcXVlcnk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHF1ZXJ5TGltaXQgfHwgcmVzdWx0cy5xdWVyeS5saW1pdDtcbiAgICAgICAgICAgIGNvbnN0IHJvd3NDb3VudCA9IE1hdGgubWluKHJvd3MgfHwgMCwgcmVzdWx0cz8uZGF0YT8ubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgbGV0IHsgZGF0YSB9ID0gcXVlcnkucmVzdWx0cztcbiAgICAgICAgICAgIGlmIChjYWNoZSAmJiBxdWVyeS5jYWNoZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gY2FjaGVkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29sdW1ucyB9ID0gcXVlcnkucmVzdWx0cztcbiAgICAgICAgICAgIC8vIEFkZGVkIGNvbXB1dGUgbG9naWMgdG8gc3RvcCB1c2VyIGZyb20gYmVpbmcgYWJsZSB0byBTYXZlICYgRXhwbG9yZVxuICAgICAgICAgICAgY29uc3QgZGF0YXNvdXJjZSA9IHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBxdWVyeS5yZXN1bHRzLmNvbHVtbnMsXG4gICAgICAgICAgICAgICAgbmFtZTogcXVlcnk/LnRhYiB8fCAnVW50aXRsZWQnLFxuICAgICAgICAgICAgICAgIGRiSWQ6IHF1ZXJ5Py5kYklkLFxuICAgICAgICAgICAgICAgIHNxbDogcXVlcnk/LnNxbCxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVBhcmFtczogcXVlcnk/LnRlbXBsYXRlUGFyYW1zLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogcXVlcnk/LnNjaGVtYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYW5FeHBvcnREYXRhID0gZmluZFBlcm1pc3Npb24oJ2Nhbl9leHBvcnRfY3N2JywgJ1NRTExhYicsIHVzZXI/LnJvbGVzKTtcbiAgICAgICAgICAgIHJldHVybiAoPFJlc3VsdFNldENvbnRyb2xzPlxuICAgICAgICAgIDxTYXZlRGF0YXNldE1vZGFsIHZpc2libGU9e3Nob3dTYXZlRGF0YXNldE1vZGFsfSBvbkhpZGU9eygpID0+IHNldFNob3dTYXZlRGF0YXNldE1vZGFsKGZhbHNlKX0gYnV0dG9uVGV4dE9uU2F2ZT17dCgnU2F2ZSAmIEV4cGxvcmUnKX0gYnV0dG9uVGV4dE9uT3ZlcndyaXRlPXt0KCdPdmVyd3JpdGUgJiBFeHBsb3JlJyl9IG1vZGFsRGVzY3JpcHRpb249e3QoJ1NhdmUgdGhpcyBxdWVyeSBhcyBhIHZpcnR1YWwgZGF0YXNldCB0byBjb250aW51ZSBleHBsb3JpbmcnKX0gZGF0YXNvdXJjZT17ZGF0YXNvdXJjZX0vPlxuICAgICAgICAgIDxSZXN1bHRTZXRCdXR0b25zPlxuICAgICAgICAgICAge3Zpc3VhbGl6ZSAmJiBkYXRhYmFzZT8uYWxsb3dzX3ZpcnR1YWxfdGFibGVfZXhwbG9yZSAmJiAoPEV4cGxvcmVSZXN1bHRzQnV0dG9uIGRhdGFiYXNlPXtkYXRhYmFzZX0gb25DbGljaz17Y3JlYXRlRXhwbG9yZVJlc3VsdHNPbkNsaWNrfS8+KX1cbiAgICAgICAgICAgIHtjc3YgJiYgY2FuRXhwb3J0RGF0YSAmJiAoPEJ1dHRvbiBjc3M9e2NvcHlCdXR0b25TdHlsZXN9IGJ1dHRvblNpemU9XCJzbWFsbFwiIGhyZWY9e2dldEV4cG9ydENzdlVybChxdWVyeS5pZCl9IGRhdGEtdGVzdD1cImV4cG9ydC1jc3YtYnV0dG9uXCIgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nQWN0aW9uKExPR19BQ1RJT05TX1NRTExBQl9ET1dOTE9BRF9DU1YsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdGluZ0ZhY3RvciA9PT0gTGltaXRpbmdGYWN0b3IuRHJvcGRvd24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9PT0gcm93c0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kYWwud2FybmluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0KCdEb3dubG9hZCBpcyBvbiB0aGUgd2F5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHQoJ0Rvd25sb2FkaW5nICUocm93cylzIHJvd3MgYmFzZWQgb24gdGhlIExJTUlUIGNvbmZpZ3VyYXRpb24uIElmIHlvdSB3YW50IHRoZSBlbnRpcmUgcmVzdWx0IHNldCwgeW91IG5lZWQgdG8gYWRqdXN0IHRoZSBMSU1JVC4nLCB7IHJvd3M6IHJvd3NDb3VudC50b0xvY2FsZVN0cmluZygpIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICA8SWNvbnMuRG93bmxvYWRPdXRsaW5lZCBpY29uU2l6ZT1cIm1cIiBpY29uQ29sb3I9e3RoZW1lLmNvbG9ycy5wcmltYXJ5LmRhcmsyfS8+eycgJ31cbiAgICAgICAgICAgICAgICB7dCgnRG93bmxvYWQgdG8gQ1NWJyl9XG4gICAgICAgICAgICAgIDwvQnV0dG9uPil9XG5cbiAgICAgICAgICAgIHtjYW5FeHBvcnREYXRhICYmICg8Q29weVRvQ2xpcGJvYXJkIHRleHQ9e3ByZXBhcmVDb3B5VG9DbGlwYm9hcmRUYWJ1bGFyRGF0YShkYXRhLCBjb2x1bW5zKX0gd3JhcHBlZD17ZmFsc2V9IGNvcHlOb2RlPXs8QnV0dG9uIGNzcz17Y29weUJ1dHRvblN0eWxlc30gYnV0dG9uU2l6ZT1cInNtYWxsXCIgZGF0YS10ZXN0PVwiY29weS10by1jbGlwYm9hcmQtYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxJY29ucy5Db3B5T3V0bGluZWQgaWNvblNpemU9XCJzXCIgaWNvbkNvbG9yPXt0aGVtZS5jb2xvcnMucHJpbWFyeS5kYXJrMn0vPnsnICd9XG4gICAgICAgICAgICAgICAgICAgIHt0KCdDb3B5IHRvIENsaXBib2FyZCcpfVxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+fSBoaWRlVG9vbHRpcCBvbkNvcHlFbmQ9eygpID0+IGxvZ0FjdGlvbihMT0dfQUNUSU9OU19TUUxMQUJfQ09QWV9SRVNVTFRfVE9fQ0xJUEJPQVJELCB7fSl9Lz4pfVxuICAgICAgICAgIDwvUmVzdWx0U2V0QnV0dG9ucz5cbiAgICAgICAgICB7c2VhcmNoICYmICg8aW5wdXQgdHlwZT1cInRleHRcIiBvbkNoYW5nZT17Y2hhbmdlU2VhcmNofSB2YWx1ZT17c2VhcmNoVGV4dH0gY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCIgcGxhY2Vob2xkZXI9e3QoJ0ZpbHRlciByZXN1bHRzJyl9Lz4pfVxuICAgICAgICA8L1Jlc3VsdFNldENvbnRyb2xzPik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDxkaXYgLz47XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJSb3dzUmV0dXJuZWQgPSAoYWxlcnRNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0cywgcm93cywgcXVlcnlMaW1pdCwgbGltaXRpbmdGYWN0b3IgfSA9IHF1ZXJ5O1xuICAgICAgICBsZXQgbGltaXRNZXNzYWdlID0gJyc7XG4gICAgICAgIGNvbnN0IGxpbWl0UmVhY2hlZCA9IHJlc3VsdHM/LmRpc3BsYXlMaW1pdFJlYWNoZWQ7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gcXVlcnlMaW1pdCB8fCByZXN1bHRzLnF1ZXJ5LmxpbWl0O1xuICAgICAgICBjb25zdCBpc0FkbWluID0gISF1c2VyPy5yb2xlcz8uQWRtaW47XG4gICAgICAgIGNvbnN0IHJvd3NDb3VudCA9IE1hdGgubWluKHJvd3MgfHwgMCwgcmVzdWx0cz8uZGF0YT8ubGVuZ3RoIHx8IDApO1xuICAgICAgICBjb25zdCBkaXNwbGF5TWF4Um93c1JlYWNoZWRNZXNzYWdlID0ge1xuICAgICAgICAgICAgd2l0aEFkbWluOiB0KCdUaGUgbnVtYmVyIG9mIHJlc3VsdHMgZGlzcGxheWVkIGlzIGxpbWl0ZWQgdG8gJShyb3dzKWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gRElTUExBWV9NQVhfUk9XLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGFkZCBhZGRpdGlvbmFsIGxpbWl0cy9maWx0ZXJzIG9yIGRvd25sb2FkIHRvIGNzdiB0byBzZWUgbW9yZSByb3dzIHVwIHRvICcgK1xuICAgICAgICAgICAgICAgICd0aGUgJShsaW1pdClkIGxpbWl0LicsIHsgcm93czogcm93c0NvdW50LCBsaW1pdCB9KSxcbiAgICAgICAgICAgIHdpdGhvdXRBZG1pbjogdCgnVGhlIG51bWJlciBvZiByZXN1bHRzIGRpc3BsYXllZCBpcyBsaW1pdGVkIHRvICUocm93cylkLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIGFkZCBhZGRpdGlvbmFsIGxpbWl0cy9maWx0ZXJzLCBkb3dubG9hZCB0byBjc3YsIG9yIGNvbnRhY3QgYW4gYWRtaW4gJyArXG4gICAgICAgICAgICAgICAgJ3RvIHNlZSBtb3JlIHJvd3MgdXAgdG8gdGhlICUobGltaXQpZCBsaW1pdC4nLCB7IHJvd3M6IHJvd3NDb3VudCwgbGltaXQgfSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3VsZFVzZURlZmF1bHREcm9wZG93bkFsZXJ0ID0gbGltaXQgPT09IGRlZmF1bHRRdWVyeUxpbWl0ICYmIGxpbWl0aW5nRmFjdG9yID09PSBMaW1pdGluZ0ZhY3Rvci5Ecm9wZG93bjtcbiAgICAgICAgaWYgKGxpbWl0aW5nRmFjdG9yID09PSBMaW1pdGluZ0ZhY3Rvci5RdWVyeSAmJiBjc3YpIHtcbiAgICAgICAgICAgIGxpbWl0TWVzc2FnZSA9IHQoJ1RoZSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgaXMgbGltaXRlZCB0byAlKHJvd3MpZCBieSB0aGUgcXVlcnknLCB7IHJvd3MgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGltaXRpbmdGYWN0b3IgPT09IExpbWl0aW5nRmFjdG9yLkRyb3Bkb3duICYmXG4gICAgICAgICAgICAhc2hvdWxkVXNlRGVmYXVsdERyb3Bkb3duQWxlcnQpIHtcbiAgICAgICAgICAgIGxpbWl0TWVzc2FnZSA9IHQoJ1RoZSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgaXMgbGltaXRlZCB0byAlKHJvd3MpZCBieSB0aGUgbGltaXQgZHJvcGRvd24uJywgeyByb3dzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbWl0aW5nRmFjdG9yID09PSBMaW1pdGluZ0ZhY3Rvci5RdWVyeUFuZERyb3Bkb3duKSB7XG4gICAgICAgICAgICBsaW1pdE1lc3NhZ2UgPSB0KCdUaGUgbnVtYmVyIG9mIHJvd3MgZGlzcGxheWVkIGlzIGxpbWl0ZWQgdG8gJShyb3dzKWQgYnkgdGhlIHF1ZXJ5IGFuZCBsaW1pdCBkcm9wZG93bi4nLCB7IHJvd3MgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkUm93Q291bnQgPSBnZXROdW1iZXJGb3JtYXR0ZXIoKShyb3dzKTtcbiAgICAgICAgY29uc3Qgcm93c1JldHVybmVkTWVzc2FnZSA9IHQoJyUocm93cylkIHJvd3MgcmV0dXJuZWQnLCB7XG4gICAgICAgICAgICByb3dzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9vbHRpcFRleHQgPSBgJHtyb3dzUmV0dXJuZWRNZXNzYWdlfS4gJHtsaW1pdE1lc3NhZ2V9YDtcbiAgICAgICAgaWYgKGFsZXJ0TWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuICg8PlxuICAgICAgICAgIHshbGltaXRSZWFjaGVkICYmIHNob3VsZFVzZURlZmF1bHREcm9wZG93bkFsZXJ0ICYmICg8ZGl2IHJlZj17Y2FsY3VsYXRlQWxlcnRSZWZIZWlnaHR9PlxuICAgICAgICAgICAgICA8QWxlcnQgdHlwZT1cIndhcm5pbmdcIiBtZXNzYWdlPXt0KCclKHJvd3MpZCByb3dzIHJldHVybmVkJywgeyByb3dzIH0pfSBvbkNsb3NlPXsoKSA9PiBzZXRBbGVydElzT3BlbihmYWxzZSl9IGRlc2NyaXB0aW9uPXt0KCdUaGUgbnVtYmVyIG9mIHJvd3MgZGlzcGxheWVkIGlzIGxpbWl0ZWQgdG8gJShyb3dzKWQgYnkgdGhlIGRyb3Bkb3duLicsIHsgcm93cyB9KX0vPlxuICAgICAgICAgICAgPC9kaXY+KX1cbiAgICAgICAgICB7bGltaXRSZWFjaGVkICYmICg8ZGl2IHJlZj17Y2FsY3VsYXRlQWxlcnRSZWZIZWlnaHR9PlxuICAgICAgICAgICAgICA8QWxlcnQgdHlwZT1cIndhcm5pbmdcIiBvbkNsb3NlPXsoKSA9PiBzZXRBbGVydElzT3BlbihmYWxzZSl9IG1lc3NhZ2U9e3QoJyUocm93cylkIHJvd3MgcmV0dXJuZWQnLCB7IHJvd3M6IHJvd3NDb3VudCB9KX0gZGVzY3JpcHRpb249e2lzQWRtaW5cbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGlzcGxheU1heFJvd3NSZWFjaGVkTWVzc2FnZS53aXRoQWRtaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGlzcGxheU1heFJvd3NSZWFjaGVkTWVzc2FnZS53aXRob3V0QWRtaW59Lz5cbiAgICAgICAgICAgIDwvZGl2Pil9XG4gICAgICAgIDwvPik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvd1Jvd3NSZXR1cm5lZCA9IHNob3dTcWxJbmxpbmUgfHwgKCFsaW1pdFJlYWNoZWQgJiYgIXNob3VsZFVzZURlZmF1bHREcm9wZG93bkFsZXJ0KTtcbiAgICAgICAgcmV0dXJuICg8PlxuICAgICAgICB7c2hvd1Jvd3NSZXR1cm5lZCAmJiAoPFJldHVybmVkUm93cz5cbiAgICAgICAgICAgIDxUb29sdGlwIGlkPVwic3FsbGFiLXJvd2NvdW50LXRvb2x0aXBcIiB0aXRsZT17dG9vbHRpcFRleHR9IHBsYWNlbWVudD1cImxlZnRcIj5cbiAgICAgICAgICAgICAgPExhYmVsIGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMubH1weDtcbiAgICAgICAgICAgICAgICBgfT5cbiAgICAgICAgICAgICAgICB7bGltaXRNZXNzYWdlICYmICg8SWNvbnMuRXhjbGFtYXRpb25DaXJjbGVPdXRsaW5lZCBjc3M9e2NzcyBgXG4gICAgICAgICAgICAgICAgICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMubX1weDtcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuZ3JpZFVuaXR9cHg7XG4gICAgICAgICAgICAgICAgICAgIGB9Lz4pfVxuICAgICAgICAgICAgICAgIHt0bignJXMgcm93JywgJyVzIHJvd3MnLCByb3dzLCBmb3JtYXR0ZWRSb3dDb3VudCl9XG4gICAgICAgICAgICAgIDwvTGFiZWw+XG4gICAgICAgICAgICA8L1Rvb2x0aXA+XG4gICAgICAgICAgPC9SZXR1cm5lZFJvd3M+KX1cbiAgICAgIDwvPik7XG4gICAgfTtcbiAgICBjb25zdCBsaW1pdFJlYWNoZWQgPSBxdWVyeT8ucmVzdWx0cz8uZGlzcGxheUxpbWl0UmVhY2hlZDtcbiAgICBsZXQgc3FsO1xuICAgIGxldCBleHBsb3JlREJJZCA9IHF1ZXJ5LmRiSWQ7XG4gICAgaWYgKGRhdGFiYXNlPy5leHBsb3JlX2RhdGFiYXNlX2lkKSB7XG4gICAgICAgIGV4cGxvcmVEQklkID0gZGF0YWJhc2UuZXhwbG9yZV9kYXRhYmFzZV9pZDtcbiAgICB9XG4gICAgbGV0IHRyYWNraW5nVXJsO1xuICAgIGlmIChxdWVyeS50cmFja2luZ1VybCAmJlxuICAgICAgICBxdWVyeS5zdGF0ZSAhPT0gUXVlcnlTdGF0ZS5TdWNjZXNzICYmXG4gICAgICAgIHF1ZXJ5LnN0YXRlICE9PSBRdWVyeVN0YXRlLkZldGNoaW5nKSB7XG4gICAgICAgIHRyYWNraW5nVXJsID0gKDxCdXR0b24gY2xhc3NOYW1lPVwic3FsLXJlc3VsdC10cmFjay1qb2JcIiBidXR0b25TaXplPVwic21hbGxcIiBocmVmPXtxdWVyeS50cmFja2luZ1VybH0gdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgIHtxdWVyeS5zdGF0ZSA9PT0gUXVlcnlTdGF0ZS5SdW5uaW5nXG4gICAgICAgICAgICAgICAgPyB0KCdUcmFjayBqb2InKVxuICAgICAgICAgICAgICAgIDogdCgnU2VlIHF1ZXJ5IGRldGFpbHMnKX1cbiAgICAgIDwvQnV0dG9uPik7XG4gICAgfVxuICAgIGlmIChzaG93U3FsKSB7XG4gICAgICAgIHNxbCA9ICg8SGlnaGxpZ2h0ZWRTcWwgc3FsPXtxdWVyeS5zcWx9IHsuLi4oc2hvd1NxbElubGluZSAmJiB7IG1heExpbmVzOiAxLCBtYXhXaWR0aDogNjAgfSl9Lz4pO1xuICAgIH1cbiAgICBpZiAocXVlcnkuc3RhdGUgPT09IFF1ZXJ5U3RhdGUuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm4gPEFsZXJ0IHR5cGU9XCJ3YXJuaW5nXCIgbWVzc2FnZT17dCgnUXVlcnkgd2FzIHN0b3BwZWQnKX0vPjtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnN0YXRlID09PSBRdWVyeVN0YXRlLkZhaWxlZCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbLi4uKHF1ZXJ5LmV4dHJhPy5lcnJvcnMgfHwgW10pLCAuLi4ocXVlcnkuZXJyb3JzIHx8IFtdKV07XG4gICAgICAgIHJldHVybiAoPFJlc3VsdGxlc3NTdHlsZXM+XG4gICAgICAgIHtlcnJvcnMubWFwKChlcnJvciwgaW5kZXgpID0+ICg8RXJyb3JNZXNzYWdlV2l0aFN0YWNrVHJhY2Uga2V5PXtpbmRleH0gdGl0bGU9e3QoJ0RhdGFiYXNlIGVycm9yJyl9IGVycm9yPXtlcnJvcn0gc3VidGl0bGU9ezxNb25vc3BhY2VEaXY+e2Vycm9yLm1lc3NhZ2V9PC9Nb25vc3BhY2VEaXY+fSBjb3B5VGV4dD17ZXJyb3IubWVzc2FnZSB8fCB1bmRlZmluZWR9IGxpbms9e3F1ZXJ5Lmxpbmt9IHNvdXJjZT1cInNxbGxhYlwiLz4pKX1cbiAgICAgICAge2Vycm9ycy5zb21lKGVycm9yID0+IGVycm9yPy5lcnJvcl90eXBlID09PSBFcnJvclR5cGVFbnVtLkZST05URU5EX1RJTUVPVVRfRVJST1IpID8gKDxCdXR0b24gY2xhc3NOYW1lPVwic3FsLXJlc3VsdC10cmFjay1qb2JcIiBidXR0b25TaXplPVwic21hbGxcIiBvbkNsaWNrPXsoKSA9PiBmZXRjaFJlc3VsdHMocXVlcnksIDApfT5cbiAgICAgICAgICAgIHt0KCdSZXRyeSBmZXRjaGluZyByZXN1bHRzJyl9XG4gICAgICAgICAgPC9CdXR0b24+KSA6ICh0cmFja2luZ1VybCl9XG4gICAgICA8L1Jlc3VsdGxlc3NTdHlsZXM+KTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnN0YXRlID09PSBRdWVyeVN0YXRlLlN1Y2Nlc3MgJiYgcXVlcnkuY3Rhcykge1xuICAgICAgICBjb25zdCB7IHRlbXBTY2hlbWEsIHRlbXBUYWJsZSB9ID0gcXVlcnk7XG4gICAgICAgIGxldCBvYmplY3QgPSAnVGFibGUnO1xuICAgICAgICBpZiAocXVlcnkuY3Rhc19tZXRob2QgPT09IEN0YXNFbnVtLlZpZXcpIHtcbiAgICAgICAgICAgIG9iamVjdCA9ICdWaWV3JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDxkaXY+XG4gICAgICAgIDxBbGVydCB0eXBlPVwiaW5mb1wiIG1lc3NhZ2U9ezw+XG4gICAgICAgICAgICAgIHt0KG9iamVjdCl9IFtcbiAgICAgICAgICAgICAgPHN0cm9uZz5cbiAgICAgICAgICAgICAgICB7dGVtcFNjaGVtYSA/IGAke3RlbXBTY2hlbWF9LmAgOiAnJ31cbiAgICAgICAgICAgICAgICB7dGVtcFRhYmxlfVxuICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgXSB7dCgnd2FzIGNyZWF0ZWQnKX0gJm5ic3A7XG4gICAgICAgICAgICAgIDxCdXR0b25Hcm91cD5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIGJ1dHRvblNpemU9XCJzbWFsbFwiIGNzcz17eyBtYXJnaW5SaWdodDogdGhlbWUuZ3JpZFVuaXQgfX0gb25DbGljaz17KCkgPT4gcG9wU2VsZWN0U3Rhcih0ZW1wU2NoZW1hLCB0ZW1wVGFibGUpfT5cbiAgICAgICAgICAgICAgICAgIHt0KCdRdWVyeSBpbiBhIG5ldyB0YWInKX1cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8RXhwbG9yZUN0YXNSZXN1bHRzQnV0dG9uIHRhYmxlPXt0ZW1wVGFibGV9IHNjaGVtYT17dGVtcFNjaGVtYX0gZGJJZD17ZXhwbG9yZURCSWR9Lz5cbiAgICAgICAgICAgICAgPC9CdXR0b25Hcm91cD5cbiAgICAgICAgICAgIDwvPn0vPlxuICAgICAgPC9kaXY+KTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LnN0YXRlID09PSBRdWVyeVN0YXRlLlN1Y2Nlc3MgJiYgcXVlcnkucmVzdWx0cykge1xuICAgICAgICBjb25zdCB7IHJlc3VsdHMgfSA9IHF1ZXJ5O1xuICAgICAgICAvLyBBY2NvdW50cyBmb3Igb2Zmc2V0IG5lZWRlZCBmb3IgaGVpZ2h0IG9mIFJlc3VsdFNldFJvd3NSZXR1cm5lZCBjb21wb25lbnQgaWYgIWxpbWl0UmVhY2hlZFxuICAgICAgICBjb25zdCByb3dNZXNzYWdlSGVpZ2h0ID0gIWxpbWl0UmVhY2hlZCA/IDMyIDogMDtcbiAgICAgICAgLy8gQWNjb3VudHMgZm9yIG9mZnNldCBuZWVkZWQgZm9yIGhlaWdodCBvZiBBbGVydCBpZiB0aGlzLnN0YXRlLmFsZXJ0SXNPcGVuXG4gICAgICAgIGNvbnN0IGFsZXJ0Q29udGFpbmVySGVpZ2h0ID0gNzA7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhpcy5yZW5kZXJSb3dzUmV0dXJuZWQoKVxuICAgICAgICAvLyBpZiB3ZSB3YW50IHJlc3VsdHMgcGFuZWwgdG8gYmUgcHJvcGVyIGhlaWdodCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBGaWx0ZXJUYWJsZSBjb21wb25lbnQgbmVlZHMgYW4gZXhwbGljaXQgaGVpZ2h0IHRvIHJlbmRlclxuICAgICAgICAvLyB0aGUgVGFibGUgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IHJvd3NIZWlnaHQgPSBhbGVydElzT3BlblxuICAgICAgICAgICAgPyBoZWlnaHQgLSBhbGVydENvbnRhaW5lckhlaWdodFxuICAgICAgICAgICAgOiBoZWlnaHQgLSByb3dNZXNzYWdlSGVpZ2h0O1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHF1ZXJ5LmNhY2hlZCkge1xuICAgICAgICAgICAgZGF0YSA9IGNhY2hlZERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0cz8uZGF0YSkge1xuICAgICAgICAgICAgKHsgZGF0YSB9ID0gcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZENvbHVtbnMgPSByZXN1bHRzLmV4cGFuZGVkX2NvbHVtbnNcbiAgICAgICAgICAgICAgICA/IHJlc3VsdHMuZXhwYW5kZWRfY29sdW1ucy5tYXAoY29sID0+IGNvbC5jb2x1bW5fbmFtZSlcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dIVE1MID0gZ2V0SXRlbShMb2NhbFN0b3JhZ2VLZXlzLlNxbGxhYklzUmVuZGVySHRtbEVuYWJsZWQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICg8UmVzdWx0Q29udGFpbmVyPlxuICAgICAgICAgIHtyZW5kZXJDb250cm9scygpfVxuICAgICAgICAgIHtzaG93U3FsICYmIHNob3dTcWxJbmxpbmUgPyAoPD5cbiAgICAgICAgICAgICAgPGRpdiBjc3M9e2NzcyBgXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAgICAgICAgICAgZ2FwOiAke0dBUH1weDtcbiAgICAgICAgICAgICAgICBgfT5cbiAgICAgICAgICAgICAgICA8Q2FyZCBjc3M9e1tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzcyBgXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyOHB4O1xuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSAke1JPV1NfQ0hJUF9XSURUSCArIEdBUH1weCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29kZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICAgICAgXX0+XG4gICAgICAgICAgICAgICAgICB7c3FsfVxuICAgICAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgICAgICB7cmVuZGVyUm93c1JldHVybmVkKGZhbHNlKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHtyZW5kZXJSb3dzUmV0dXJuZWQodHJ1ZSl9XG4gICAgICAgICAgICA8Lz4pIDogKDw+XG4gICAgICAgICAgICAgIHtyZW5kZXJSb3dzUmV0dXJuZWQoZmFsc2UpfVxuICAgICAgICAgICAgICB7cmVuZGVyUm93c1JldHVybmVkKHRydWUpfVxuICAgICAgICAgICAgICB7c3FsfVxuICAgICAgICAgICAgPC8+KX1cbiAgICAgICAgICA8UmVzdWx0VGFibGUgZGF0YT17ZGF0YX0gcXVlcnlJZD17cXVlcnkuaWR9IG9yZGVyZWRDb2x1bW5LZXlzPXtyZXN1bHRzLmNvbHVtbnMubWFwKGNvbCA9PiBjb2wuY29sdW1uX25hbWUpfSBoZWlnaHQ9e3Jvd3NIZWlnaHR9IGZpbHRlclRleHQ9e3NlYXJjaFRleHR9IGV4cGFuZGVkQ29sdW1ucz17ZXhwYW5kZWRDb2x1bW5zfSBhbGxvd0hUTUw9e2FsbG93SFRNTH0vPlxuICAgICAgICA8L1Jlc3VsdENvbnRhaW5lcj4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gPEFsZXJ0IHR5cGU9XCJ3YXJuaW5nXCIgbWVzc2FnZT17dCgnVGhlIHF1ZXJ5IHJldHVybmVkIG5vIGRhdGEnKX0vPjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkuY2FjaGVkIHx8IChxdWVyeS5zdGF0ZSA9PT0gUXVlcnlTdGF0ZS5TdWNjZXNzICYmICFxdWVyeS5yZXN1bHRzKSkge1xuICAgICAgICBpZiAocXVlcnkuaXNEYXRhUHJldmlldykge1xuICAgICAgICAgICAgcmV0dXJuICg8QnV0dG9uIGJ1dHRvblNpemU9XCJzbWFsbFwiIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiIG9uQ2xpY2s9eygpID0+IGRpc3BhdGNoKHJlRmV0Y2hRdWVyeVJlc3VsdHMoe1xuICAgICAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgaXNEYXRhUHJldmlldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSl9PlxuICAgICAgICAgIHt0KCdGZXRjaCBkYXRhIHByZXZpZXcnKX1cbiAgICAgICAgPC9CdXR0b24+KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkucmVzdWx0c0tleSkge1xuICAgICAgICAgICAgcmV0dXJuICg8QnV0dG9uIGJ1dHRvblNpemU9XCJzbWFsbFwiIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiIG9uQ2xpY2s9eygpID0+IGZldGNoUmVzdWx0cyhxdWVyeSl9PlxuICAgICAgICAgIHt0KCdSZWZldGNoIHJlc3VsdHMnKX1cbiAgICAgICAgPC9CdXR0b24+KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvZ3Jlc3NCYXI7XG4gICAgaWYgKHF1ZXJ5LnByb2dyZXNzID4gMCkge1xuICAgICAgICBwcm9ncmVzc0JhciA9ICg8UHJvZ3Jlc3NCYXIgcGVyY2VudD17cGFyc2VJbnQocXVlcnkucHJvZ3Jlc3MudG9GaXhlZCgwKSwgMTApfSBzdHJpcGVkLz4pO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmVzc01zZyA9IHF1ZXJ5Py5leHRyYT8ucHJvZ3Jlc3MgPz8gbnVsbDtcbiAgICByZXR1cm4gKDxSZXN1bHRsZXNzU3R5bGVzPlxuICAgICAgPGRpdj57IXByb2dyZXNzQmFyICYmIDxMb2FkaW5nIHBvc2l0aW9uPVwibm9ybWFsXCIvPn08L2Rpdj5cbiAgICAgIHsvKiBzaG93IGxvYWRpbmcgYmFyIHdoZW5ldmVyIHByb2dyZXNzIGJhciBpcyBjb21wbGV0ZWQgYnV0IG5lZWRzIHRpbWUgdG8gcmVuZGVyICovfVxuICAgICAgPGRpdj57cXVlcnkucHJvZ3Jlc3MgPT09IDEwMCAmJiA8TG9hZGluZyBwb3NpdGlvbj1cIm5vcm1hbFwiLz59PC9kaXY+XG4gICAgICA8UXVlcnlTdGF0ZUxhYmVsIHF1ZXJ5PXtxdWVyeX0vPlxuICAgICAgPGRpdj57cHJvZ3Jlc3NNc2cgJiYgPEFsZXJ0IHR5cGU9XCJzdWNjZXNzXCIgbWVzc2FnZT17cHJvZ3Jlc3NNc2d9Lz59PC9kaXY+XG4gICAgICA8ZGl2PntxdWVyeS5wcm9ncmVzcyAhPT0gMTAwICYmIHByb2dyZXNzQmFyfTwvZGl2PlxuICAgICAge3RyYWNraW5nVXJsICYmIDxkaXY+e3RyYWNraW5nVXJsfTwvZGl2Pn1cbiAgICA8L1Jlc3VsdGxlc3NTdHlsZXM+KTtcbn07XG5leHBvcnQgZGVmYXVsdCBtZW1vKFJlc3VsdFNldCk7XG4iXX0= */\"], children:\n\n              sql }\n            ),\n            renderRowsReturned(false)] }\n          ),\n          renderRowsReturned(true)] }\n        ) : _jsxs(_Fragment, { children: [\n          renderRowsReturned(false),\n          renderRowsReturned(true),\n          sql] }\n        ),\n        _jsx(ResultTable, { data: data, queryId: query.id, orderedColumnKeys: results.columns.map((col) => col.column_name), height: rowsHeight, filterText: searchText, expandedColumns: expandedColumns, allowHTML: allowHTML })] }\n      );\n    }\n    if (data && data.length === 0) {\n      return _jsx(Alert, { type: \"warning\", message: t('The query returned no data') });\n    }\n  }\n  if (query.cached || query.state === QueryState.Success && !query.results) {\n    if (query.isDataPreview) {\n      return _jsx(Button, { buttonSize: \"small\", buttonStyle: \"primary\", onClick: () => dispatch(reFetchQueryResults({\n          ...query,\n          isDataPreview: true\n        })), children:\n        t('Fetch data preview') }\n      );\n    }\n    if (query.resultsKey) {\n      return _jsx(Button, { buttonSize: \"small\", buttonStyle: \"primary\", onClick: () => fetchResults(query), children:\n        t('Refetch results') }\n      );\n    }\n  }\n  let progressBar;\n  if (query.progress > 0) {\n    progressBar = _jsx(ProgressBar, { percent: parseInt(query.progress.toFixed(0), 10), striped: true });\n  }\n  const progressMsg = (_query$extra$progress = query == null ? void 0 : (_query$extra2 = query.extra) == null ? void 0 : _query$extra2.progress) != null ? _query$extra$progress : null;\n  return _jsxs(ResultlessStyles, { children: [\n    _jsx(\"div\", { children: !progressBar && _jsx(Loading, { position: \"normal\" }) }),\n\n    _jsx(\"div\", { children: query.progress === 100 && _jsx(Loading, { position: \"normal\" }) }),\n    _jsx(QueryStateLabel, { query: query }),\n    _jsx(\"div\", { children: progressMsg && _jsx(Alert, { type: \"success\", message: progressMsg }) }),\n    _jsx(\"div\", { children: query.progress !== 100 && progressBar }),\n    trackingUrl && _jsx(\"div\", { children: trackingUrl })] }\n  );\n};\nexport default /*#__PURE__*/memo(ResultSet);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}