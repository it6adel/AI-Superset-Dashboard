{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback } from 'react';\nimport { getColumnLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport Echart from '../components/Echart';\nimport { formatSeriesName } from '../utils/series';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport const extractTreePathInfo = (treePathInfo) => (treePathInfo != null ? treePathInfo : []).\nmap((pathInfo) => (pathInfo == null ? void 0 : pathInfo.name) || '').\nfilter((path) => path !== '');\nexport default function EchartsSunburst(props) {\n  const { height, width, echartOptions, setDataMask, labelMap, selectedValues, formData, onContextMenu, refs, emitCrossFilters, coltypeMapping } = props;\n  const { columns } = formData;\n  const getCrossFilterDataMask = useCallback((treePathInfo) => {\n    const treePath = extractTreePathInfo(treePathInfo);\n    const name = treePath.join(',');\n    const selected = Object.values(selectedValues);\n    let values;\n    if (selected.includes(name)) {\n      values = selected.filter((v) => v !== name);\n    } else\n    {\n      values = [name];\n    }\n    const labels = values.map((value) => labelMap[value]);\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: values.length === 0 || !columns ?\n          [] :\n          columns.slice(0, treePath.length).map((col, idx) => {\n            const val = labels.map((v) => v[idx]);\n            if (val === null || val === undefined)\n            return {\n              col,\n              op: 'IS NULL'\n            };\n            return {\n              col,\n              op: 'IN',\n              val: val\n            };\n          })\n        },\n        filterState: {\n          value: labels.length ? labels : null,\n          selectedValues: values.length ? values : null\n        }\n      },\n      isCurrentValueSelected: selected.includes(name)\n    };\n  }, [columns, labelMap, selectedValues]);\n  const handleChange = useCallback((treePathInfo) => {\n    if (!emitCrossFilters || !(columns != null && columns.length)) {\n      return;\n    }\n    setDataMask(getCrossFilterDataMask(treePathInfo).dataMask);\n  }, [emitCrossFilters, setDataMask, getCrossFilterDataMask]);\n  const eventHandlers = {\n    click: (props) => {\n      const { treePathInfo } = props;\n      handleChange(treePathInfo);\n    },\n    contextmenu: async (eventParams) => {\n      if (onContextMenu) {\n        eventParams.event.stop();\n        const { data, treePathInfo } = eventParams;\n        const { records } = data;\n        const treePath = extractTreePathInfo(eventParams.treePathInfo);\n        const pointerEvent = eventParams.event.event;\n        const drillToDetailFilters = [];\n        const drillByFilters = [];\n        if (columns != null && columns.length) {\n          treePath.forEach((path, i) => drillToDetailFilters.push({\n            col: columns[i],\n            op: '==',\n            val: records[i],\n            formattedVal: path\n          }));\n          const val = treePath[treePath.length - 1];\n          drillByFilters.push({\n            col: columns[treePath.length - 1],\n            op: '==',\n            val,\n            formattedVal: formatSeriesName(val, {\n              timeFormatter: getTimeFormatter(formData.dateFormat),\n              numberFormatter: getNumberFormatter(formData.numberFormat),\n              coltype: coltypeMapping == null ? void 0 : coltypeMapping[getColumnLabel(columns[treePath.length - 1])]\n            })\n          });\n        }\n        onContextMenu(pointerEvent.clientX, pointerEvent.clientY, {\n          drillToDetail: drillToDetailFilters,\n          crossFilter: columns != null && columns.length ?\n          getCrossFilterDataMask(treePathInfo) :\n          undefined,\n          drillBy: { filters: drillByFilters, groupbyFieldName: 'columns' }\n        });\n      }\n    }\n  };\n  return _jsx(Echart, { refs: refs, height: height, width: width, echartOptions: echartOptions, eventHandlers: eventHandlers, selectedValues: selectedValues });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}