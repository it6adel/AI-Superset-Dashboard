{"ast":null,"code":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n(function (Actions) {\n  Actions[\"GET\"] = \"get\";\n  Actions[\"REPLY\"] = \"reply\";\n  Actions[\"EMIT\"] = \"emit\";\n  Actions[\"ERROR\"] = \"error\";\n})(Actions || (Actions = {}));\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n}\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n\n\n\n\n\n\n\n  constructor(params) {this.port = void 0;this.name = '';this.methods = {}; // used to make unique ids\n    this.incrementor = 1;this.debugMode = void 0;this.isInitialised = void 0;if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n  init(params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n    const { port, name = 'switchboard', debug = false } = params;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n    port.addEventListener('message', async (event) => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else\n      if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n    this.isInitialised = true;\n  }\n  async getMethodResult({ messageId, method, args }) {\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined`\n      };\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result\n      };\n    }\n    catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error`\n      };\n    }\n  }\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonsense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args = undefined) {\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event) => {\n        const message = event.data;\n        if (message.messageId !== messageId)\n        return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else\n        {\n          const errStr = isError(message) ?\n          message.error :\n          'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args\n      };\n      this.port.postMessage(message);\n    });\n  }\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args = undefined) {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args\n    };\n    this.port.postMessage(message);\n  }\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n  log(...args) {\n    if (this.debugMode) {\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n  logError(...args) {\n    console.error(`[${this.name}]`, ...args);\n  }\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  }\n}\nexport default new Switchboard();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}