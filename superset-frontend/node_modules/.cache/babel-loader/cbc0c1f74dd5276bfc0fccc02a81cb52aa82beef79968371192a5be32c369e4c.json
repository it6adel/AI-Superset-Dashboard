{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef, useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { logging } from '@superset-ui/core';\nimport { useUpdateCurrentSqlEditorTabMutation, useUpdateSqlEditorTabMutation, useDeleteSqlEditorTabMutation } from 'src/hooks/apiResources/sqlEditorTabs';\nimport { useDebounceValue } from 'src/hooks/useDebounceValue';\nimport { syncQueryEditor, setEditorTabLastUpdate, setLastUpdatedActiveTab, clearDestoryedQueryEditor } from 'src/SqlLab/actions/sqlLab';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nexport const INTERVAL = 5000;\nfunction hasUnsavedChanges(queryEditor, lastSavedTimestamp) {\n  return queryEditor.inLocalStorage ||\n  queryEditor.updatedAt && queryEditor.updatedAt > lastSavedTimestamp;\n}\nexport function filterUnsavedQueryEditorList(queryEditors, unsavedQueryEditor, lastSavedTimestamp) {\n  return queryEditors.\n  map((queryEditor) => ({\n    ...queryEditor,\n    ...(unsavedQueryEditor.id === queryEditor.id && unsavedQueryEditor)\n  })).\n  filter((queryEditor) => hasUnsavedChanges(queryEditor, lastSavedTimestamp));\n}\nconst EditorAutoSync = () => {\n  const queryEditors = useSelector((state) => state.sqlLab.queryEditors);\n  const unsavedQueryEditor = useSelector((state) => state.sqlLab.unsavedQueryEditor);\n  const editorTabLastUpdatedAt = useSelector((state) => state.sqlLab.editorTabLastUpdatedAt);\n  const dispatch = useDispatch();\n  const lastSavedTimestampRef = useRef(editorTabLastUpdatedAt);\n  const currentQueryEditorId = useSelector(({ sqlLab }) => sqlLab.tabHistory.slice(-1)[0] || '');\n  const lastUpdatedActiveTab = useSelector(({ sqlLab }) => sqlLab.lastUpdatedActiveTab);\n  const destroyedQueryEditors = useSelector(({ sqlLab }) => sqlLab.destroyedQueryEditors);\n  const [updateSqlEditor, { error }] = useUpdateSqlEditorTabMutation();\n  const [updateCurrentSqlEditor] = useUpdateCurrentSqlEditorTabMutation();\n  const [deleteSqlEditor] = useDeleteSqlEditorTabMutation();\n  const debouncedUnsavedQueryEditor = useDebounceValue(unsavedQueryEditor, INTERVAL);\n  const getUnsavedItems = useEffectEvent((unsavedQE) => filterUnsavedQueryEditorList(queryEditors, unsavedQE, lastSavedTimestampRef.current));\n  const getUnsavedNewQueryEditor = useEffectEvent(() => filterUnsavedQueryEditorList(queryEditors, unsavedQueryEditor, lastSavedTimestampRef.current).find(({ inLocalStorage }) => Boolean(inLocalStorage)));\n  const syncCurrentQueryEditor = useEffectEvent(() => {var _queryEditors$find;\n    if (currentQueryEditorId &&\n    currentQueryEditorId !== lastUpdatedActiveTab &&\n    !((_queryEditors$find = queryEditors.find(({ id }) => id === currentQueryEditorId)) != null && _queryEditors$find.\n    inLocalStorage)) {\n      updateCurrentSqlEditor(currentQueryEditorId).then(() => {\n        dispatch(setLastUpdatedActiveTab(currentQueryEditorId));\n      });\n    }\n  });\n  const syncDeletedQueryEditor = useEffectEvent(() => {\n    if (Object.keys(destroyedQueryEditors).length > 0) {\n      Object.keys(destroyedQueryEditors).forEach((id) => {\n        deleteSqlEditor(id).\n        then(() => {\n          dispatch(clearDestoryedQueryEditor(id));\n        }).\n        catch(({ status }) => {\n          if (status === 404) {\n            dispatch(clearDestoryedQueryEditor(id));\n          }\n        });\n      });\n    }\n  });\n  useEffect(() => {\n    let saveTimer;\n    function saveUnsavedQueryEditor() {\n      const firstUnsavedQueryEditor = getUnsavedNewQueryEditor();\n      if (firstUnsavedQueryEditor) {\n        dispatch(syncQueryEditor(firstUnsavedQueryEditor));\n      }\n      saveTimer = setTimeout(saveUnsavedQueryEditor, INTERVAL);\n    }\n    const syncTimer = setInterval(syncCurrentQueryEditor, INTERVAL);\n    saveTimer = setTimeout(saveUnsavedQueryEditor, INTERVAL);\n    const clearQueryEditorTimer = setInterval(syncDeletedQueryEditor, INTERVAL);\n    return () => {\n      clearTimeout(saveTimer);\n      clearInterval(syncTimer);\n      clearInterval(clearQueryEditorTimer);\n    };\n  }, [\n  getUnsavedNewQueryEditor,\n  syncCurrentQueryEditor,\n  syncDeletedQueryEditor,\n  dispatch]\n  );\n  useEffect(() => {\n    const unsaved = getUnsavedItems(debouncedUnsavedQueryEditor);\n    Promise.all(unsaved.\n    filter(({ inLocalStorage }) => !inLocalStorage).\n    map((queryEditor) => updateSqlEditor({ queryEditor }))).then((resolvers) => {\n      if (!resolvers.some((result) => 'error' in result)) {\n        lastSavedTimestampRef.current = Date.now();\n        dispatch(setEditorTabLastUpdate(lastSavedTimestampRef.current));\n      }\n    });\n  }, [debouncedUnsavedQueryEditor, getUnsavedItems, dispatch, updateSqlEditor]);\n  useEffect(() => {\n    if (error) {\n      logging.warn('An error occurred while saving your editor state.', error);\n    }\n  }, [dispatch, error]);\n  return null;\n};\nexport default EditorAutoSync;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}