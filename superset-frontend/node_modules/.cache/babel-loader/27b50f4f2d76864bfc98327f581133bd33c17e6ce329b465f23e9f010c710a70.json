{"ast":null,"code":"import _uniqBy from \"lodash/uniqBy\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { isFeatureEnabled, FeatureFlag, getChartMetadataRegistry, styled, SupersetClient, t, useTheme, css } from '@superset-ui/core';\nimport { useState, useMemo, useCallback } from 'react';\nimport rison from 'rison';\n\nimport { useSelector } from 'react-redux';\nimport { createErrorHandler, createFetchRelated, handleChartDelete } from 'src/views/CRUD/utils';\nimport { useChartEditModal, useFavoriteStatus, useListViewResource } from 'src/views/CRUD/hooks';\nimport handleResourceExport from 'src/utils/export';\nimport ConfirmStatusChange from 'src/components/ConfirmStatusChange';\nimport { TagsList } from 'src/components/Tags';\nimport SubMenu from 'src/features/home/SubMenu';\nimport FaveStar from 'src/components/FaveStar';\nimport { Link, useHistory } from 'react-router-dom';\nimport ListView, { FilterOperator } from 'src/components/ListView';\nimport Loading from 'src/components/Loading';\nimport { dangerouslyGetItemDoNotUse } from 'src/utils/localStorageHelpers';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport PropertiesModal from 'src/explore/components/PropertiesModal';\nimport ImportModelsModal from 'src/components/ImportModal/index';\nimport { Tooltip } from 'src/components/Tooltip';\nimport Icons from 'src/components/Icons';\nimport { nativeFilterGate } from 'src/dashboard/components/nativeFilters/utils';\nimport InfoTooltip from 'src/components/InfoTooltip';\nimport CertifiedBadge from 'src/components/CertifiedBadge';\nimport { GenericLink } from 'src/components/GenericLink/GenericLink';\nimport { loadTags } from 'src/components/Tags/utils';\nimport FacePile from 'src/components/FacePile';\nimport ChartCard from 'src/features/charts/ChartCard';\nimport { findPermission } from 'src/utils/findPermission';\nimport { DashboardCrossLinks } from 'src/components/ListView/DashboardCrossLinks';\nimport { ModifiedInfo } from 'src/components/AuditInfo';\nimport { QueryObjectColumns } from 'src/views/CRUD/types';import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst FlexRowContainer = styled.div`\n  align-items: center;\n  display: flex;\n\n  a {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    line-height: 1.2;\n  }\n\n  svg {\n    margin-right: ${({ theme }) => theme.gridUnit}px;\n  }\n`;\nconst PAGE_SIZE = 25;\nconst PASSWORDS_NEEDED_MESSAGE = t('The passwords for the databases below are needed in order to ' +\n'import them together with the charts. Please note that the ' +\n'\"Secure Extra\" and \"Certificate\" sections of ' +\n'the database configuration are not present in export files, and ' +\n'should be added manually after the import if they are needed.');\nconst CONFIRM_OVERWRITE_MESSAGE = t('You are importing one or more charts that already exist. ' +\n'Overwriting might cause you to lose some of your work. Are you ' +\n'sure you want to overwrite?');\nconst registry = getChartMetadataRegistry();\nconst createFetchDatasets = async (filterValue = '', page, pageSize) => {var _json$result;\n  // add filters if filterValue\n  const filters = filterValue ?\n  { filters: [{ col: 'table_name', opr: 'sw', value: filterValue }] } :\n  {};\n  const queryParams = rison.encode({\n    columns: ['datasource_name', 'datasource_id'],\n    keys: ['none'],\n    order_column: 'table_name',\n    order_direction: 'asc',\n    page,\n    page_size: pageSize,\n    ...filters\n  });\n  const { json = {} } = await SupersetClient.get({\n    endpoint: `/api/v1/dataset/?q=${queryParams}`\n  });\n  const datasets = json == null ? void 0 : (_json$result = json.result) == null ? void 0 : _json$result.map(({ table_name: tableName, id }) => ({\n    label: tableName,\n    value: id\n  }));\n  return {\n    data: _uniqBy(datasets, 'value'),\n    totalCount: json == null ? void 0 : json.count\n  };\n};\nconst StyledActions = styled.div`\n  color: ${({ theme }) => theme.colors.grayscale.base};\n`;\nfunction ChartList(props) {\n  const theme = useTheme();\n  const { addDangerToast, addSuccessToast, user: { userId } } = props;\n  const history = useHistory();\n  const { state: { loading, resourceCount: chartCount, resourceCollection: charts, bulkSelectEnabled }, setResourceCollection: setCharts, hasPerm, fetchData, toggleBulkSelect, refreshData } = useListViewResource('chart', t('chart'), addDangerToast);\n  const chartIds = useMemo(() => charts.map((c) => c.id), [charts]);\n  const { roles } = useSelector((state) => state.user);\n  const canReadTag = findPermission('can_read', 'Tag', roles);\n  const [saveFavoriteStatus, favoriteStatus] = useFavoriteStatus('chart', chartIds, addDangerToast);\n  const { sliceCurrentlyEditing, handleChartUpdated, openChartEditModal, closeChartEditModal } = useChartEditModal(setCharts, charts);\n  const [importingChart, showImportModal] = useState(false);\n  const [passwordFields, setPasswordFields] = useState([]);\n  const [preparingExport, setPreparingExport] = useState(false);\n  const [sshTunnelPasswordFields, setSSHTunnelPasswordFields] = useState([]);\n  const [sshTunnelPrivateKeyFields, setSSHTunnelPrivateKeyFields] = useState([]);\n  const [sshTunnelPrivateKeyPasswordFields, setSSHTunnelPrivateKeyPasswordFields] = useState([]);\n  // TODO: Fix usage of localStorage keying on the user id\n  const userSettings = dangerouslyGetItemDoNotUse(userId == null ? void 0 : userId.toString(), null);\n  const openChartImportModal = () => {\n    showImportModal(true);\n  };\n  const closeChartImportModal = () => {\n    showImportModal(false);\n  };\n  const handleChartImport = () => {\n    showImportModal(false);\n    refreshData();\n    addSuccessToast(t('Chart imported'));\n  };\n  const canCreate = hasPerm('can_write');\n  const canEdit = hasPerm('can_write');\n  const canDelete = hasPerm('can_write');\n  const canExport = hasPerm('can_export');\n  const initialSort = [{ id: 'changed_on_delta_humanized', desc: true }];\n  const handleBulkChartExport = (chartsToExport) => {\n    const ids = chartsToExport.map(({ id }) => id);\n    handleResourceExport('chart', ids, () => {\n      setPreparingExport(false);\n    });\n    setPreparingExport(true);\n  };\n  function handleBulkChartDelete(chartsToDelete) {\n    SupersetClient.delete({\n      endpoint: `/api/v1/chart/?q=${rison.encode(chartsToDelete.map(({ id }) => id))}`\n    }).then(({ json = {} }) => {\n      refreshData();\n      addSuccessToast(json.message);\n    }, createErrorHandler((errMsg) => addDangerToast(t('There was an issue deleting the selected charts: %s', errMsg))));\n  }\n  const fetchDashboards = async (filterValue = '', page, pageSize) => {var _response$json, _response$json$result, _response$json2;\n    // add filters if filterValue\n    const filters = filterValue ?\n    {\n      filters: [\n      {\n        col: 'dashboard_title',\n        opr: FilterOperator.StartsWith,\n        value: filterValue\n      }]\n\n    } :\n    {};\n    const queryParams = rison.encode({\n      columns: ['dashboard_title', 'id'],\n      keys: ['none'],\n      order_column: 'dashboard_title',\n      order_direction: 'asc',\n      page,\n      page_size: pageSize,\n      ...filters\n    });\n    const response = await SupersetClient.get({\n      endpoint: `/api/v1/dashboard/?q=${queryParams}`\n    }).catch(() => addDangerToast(t('An error occurred while fetching dashboards')));\n    const dashboards = response == null ? void 0 : (_response$json = response.json) == null ? void 0 : (_response$json$result = _response$json.result) == null ? void 0 : _response$json$result.map(({ dashboard_title: dashboardTitle, id }) => ({\n      label: dashboardTitle,\n      value: id\n    }));\n    return {\n      data: _uniqBy(dashboards, 'value'),\n      totalCount: response == null ? void 0 : (_response$json2 = response.json) == null ? void 0 : _response$json2.count\n    };\n  };\n  const columns = useMemo(() => [\n  {\n    Cell: ({ row: { original: { id } } }) => userId && _jsx(FaveStar, { itemId: id, saveFaveStar: saveFavoriteStatus, isStarred: favoriteStatus[id] }),\n    Header: '',\n    id: 'id',\n    disableSortBy: true,\n    size: 'xs',\n    hidden: !userId\n  },\n  {\n    Cell: ({ row: { original: { url, slice_name: sliceName, certified_by: certifiedBy, certification_details: certificationDetails, description } } }) => _jsxs(FlexRowContainer, { children: [\n      _jsxs(Link, { to: url, children: [\n        certifiedBy && _jsxs(_Fragment, { children: [\n          _jsx(CertifiedBadge, { certifiedBy: certifiedBy, details: certificationDetails }), ' '] }\n        ),\n        sliceName] }\n      ),\n      description && _jsx(InfoTooltip, { tooltip: description })] }\n    ),\n    Header: t('Name'),\n    accessor: 'slice_name'\n  },\n  {\n    Cell: ({ row: { original: { viz_type: vizType } } }) => {var _registry$get;return ((_registry$get = registry.get(vizType)) == null ? void 0 : _registry$get.name) || vizType;},\n    Header: t('Type'),\n    accessor: 'viz_type',\n    size: 'xxl'\n  },\n  {\n    Cell: ({ row: { original: { datasource_name_text: dsNameTxt, datasource_url: dsUrl } } }) => _jsx(Tooltip, { title: dsNameTxt, placement: \"top\", children:\n      _jsx(GenericLink, { to: dsUrl, children: dsNameTxt == null ? void 0 : dsNameTxt.split('.')[1] }) }\n    ),\n    Header: t('Dataset'),\n    accessor: 'datasource_id',\n    disableSortBy: true,\n    size: 'xl'\n  },\n  {\n    Cell: ({ row: { original: { dashboards } } }) => _jsx(DashboardCrossLinks, { dashboards: dashboards }),\n    Header: t('On dashboards'),\n    accessor: 'dashboards',\n    disableSortBy: true,\n    size: 'xxl'\n  },\n  {\n    Cell: ({ row: { original: { tags = [] } } }) =>\n    // Only show custom type tags\n    _jsx(TagsList, { tags: tags.filter((tag) => tag.type ?\n      tag.type === 1 || tag.type === 'TagTypes.custom' :\n      true), maxTags: 3 }),\n    Header: t('Tags'),\n    accessor: 'tags',\n    disableSortBy: true,\n    hidden: !isFeatureEnabled(FeatureFlag.TaggingSystem)\n  },\n  {\n    Cell: ({ row: { original: { owners = [] } } }) => _jsx(FacePile, { users: owners }),\n    Header: t('Owners'),\n    accessor: 'owners',\n    disableSortBy: true,\n    size: 'xl'\n  },\n  {\n    Cell: ({ row: { original: { changed_on_delta_humanized: changedOn, changed_by: changedBy } } }) => _jsx(ModifiedInfo, { date: changedOn, user: changedBy }),\n    Header: t('Last modified'),\n    accessor: 'last_saved_at',\n    size: 'xl'\n  },\n  {\n    Cell: ({ row: { original } }) => {\n      const handleDelete = () => handleChartDelete(original, addSuccessToast, addDangerToast, refreshData);\n      const openEditModal = () => openChartEditModal(original);\n      const handleExport = () => handleBulkChartExport([original]);\n      if (!canEdit && !canDelete && !canExport) {\n        return null;\n      }\n      return _jsxs(StyledActions, { className: \"actions\", children: [\n        canDelete && _jsx(ConfirmStatusChange, { title: t('Please confirm'), description: _jsxs(_Fragment, { children: [\n            t('Are you sure you want to delete'), ' ',\n            _jsx(\"b\", { children: original.slice_name }), \"?\"] }\n          ), onConfirm: handleDelete, children:\n          (confirmDelete) => _jsx(Tooltip, { id: \"delete-action-tooltip\", title: t('Delete'), placement: \"bottom\", children:\n            _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", onClick: confirmDelete, children:\n              _jsx(Icons.DeleteOutlined, { iconSize: \"l\" }) }\n            ) }\n          ) }\n        ),\n        canExport && _jsx(Tooltip, { id: \"export-action-tooltip\", title: t('Export'), placement: \"bottom\", children:\n          _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", onClick: handleExport, children:\n            _jsx(Icons.UploadOutlined, { iconSize: \"l\" }) }\n          ) }\n        ),\n        canEdit && _jsx(Tooltip, { id: \"edit-action-tooltip\", title: t('Edit'), placement: \"bottom\", children:\n          _jsx(\"span\", { role: \"button\", tabIndex: 0, className: \"action-button\", onClick: openEditModal, children:\n            _jsx(Icons.EditOutlined, { iconSize: \"l\" }) }\n          ) }\n        )] }\n      );\n    },\n    Header: t('Actions'),\n    id: 'actions',\n    disableSortBy: true,\n    hidden: !canEdit && !canDelete\n  },\n  {\n    accessor: QueryObjectColumns.ChangedBy,\n    hidden: true\n  }],\n  [\n  userId,\n  canEdit,\n  canDelete,\n  canExport,\n  saveFavoriteStatus,\n  favoriteStatus,\n  refreshData,\n  addSuccessToast,\n  addDangerToast]\n  );\n  const favoritesFilter = useMemo(() => ({\n    Header: t('Favorite'),\n    key: 'favorite',\n    id: 'id',\n    urlDisplay: 'favorite',\n    input: 'select',\n    operator: FilterOperator.ChartIsFav,\n    unfilteredLabel: t('Any'),\n    selects: [\n    { label: t('Yes'), value: true },\n    { label: t('No'), value: false }]\n\n  }), []);\n  const filters = useMemo(() => {\n    const filters_list = [\n    {\n      Header: t('Name'),\n      key: 'search',\n      id: 'slice_name',\n      input: 'search',\n      operator: FilterOperator.ChartAllText\n    },\n    {\n      Header: t('Type'),\n      key: 'viz_type',\n      id: 'viz_type',\n      input: 'select',\n      operator: FilterOperator.Equals,\n      unfilteredLabel: t('All'),\n      selects: registry.\n      keys().\n      filter((k) => {var _registry$get2;return nativeFilterGate(((_registry$get2 = registry.get(k)) == null ? void 0 : _registry$get2.behaviors) || []);}).\n      map((k) => {var _registry$get3;return { label: ((_registry$get3 = registry.get(k)) == null ? void 0 : _registry$get3.name) || k, value: k };}).\n      sort((a, b) => {\n        if (!a.label || !b.label) {\n          return 0;\n        }\n        if (a.label > b.label) {\n          return 1;\n        }\n        if (a.label < b.label) {\n          return -1;\n        }\n        return 0;\n      })\n    },\n    {\n      Header: t('Dataset'),\n      key: 'dataset',\n      id: 'datasource_id',\n      input: 'select',\n      operator: FilterOperator.Equals,\n      unfilteredLabel: t('All'),\n      fetchSelects: createFetchDatasets,\n      paginate: true\n    },\n    ...(isFeatureEnabled(FeatureFlag.TaggingSystem) && canReadTag ?\n    [\n    {\n      Header: t('Tag'),\n      key: 'tags',\n      id: 'tags',\n      input: 'select',\n      operator: FilterOperator.ChartTagById,\n      unfilteredLabel: t('All'),\n      fetchSelects: loadTags\n    }] :\n\n    []),\n    {\n      Header: t('Owner'),\n      key: 'owner',\n      id: 'owners',\n      input: 'select',\n      operator: FilterOperator.RelationManyMany,\n      unfilteredLabel: t('All'),\n      fetchSelects: createFetchRelated('chart', 'owners', createErrorHandler((errMsg) => addDangerToast(t('An error occurred while fetching chart owners values: %s', errMsg))), props.user),\n      paginate: true\n    },\n    {\n      Header: t('Dashboard'),\n      key: 'dashboards',\n      id: 'dashboards',\n      input: 'select',\n      operator: FilterOperator.RelationManyMany,\n      unfilteredLabel: t('All'),\n      fetchSelects: fetchDashboards,\n      paginate: true\n    },\n    ...(userId ? [favoritesFilter] : []),\n    {\n      Header: t('Certified'),\n      key: 'certified',\n      id: 'id',\n      urlDisplay: 'certified',\n      input: 'select',\n      operator: FilterOperator.ChartIsCertified,\n      unfilteredLabel: t('Any'),\n      selects: [\n      { label: t('Yes'), value: true },\n      { label: t('No'), value: false }]\n\n    },\n    {\n      Header: t('Modified by'),\n      key: 'changed_by',\n      id: 'changed_by',\n      input: 'select',\n      operator: FilterOperator.RelationOneMany,\n      unfilteredLabel: t('All'),\n      fetchSelects: createFetchRelated('chart', 'changed_by', createErrorHandler((errMsg) => t('An error occurred while fetching dataset datasource values: %s', errMsg)), props.user),\n      paginate: true\n    }];\n\n    return filters_list;\n  }, [addDangerToast, favoritesFilter, props.user]);\n  const sortTypes = [\n  {\n    desc: false,\n    id: 'slice_name',\n    label: t('Alphabetical'),\n    value: 'alphabetical'\n  },\n  {\n    desc: true,\n    id: 'changed_on_delta_humanized',\n    label: t('Recently modified'),\n    value: 'recently_modified'\n  },\n  {\n    desc: false,\n    id: 'changed_on_delta_humanized',\n    label: t('Least recently modified'),\n    value: 'least_recently_modified'\n  }];\n\n  const renderCard = useCallback((chart) => _jsx(ChartCard, { chart: chart, showThumbnails: userSettings ?\n    userSettings.thumbnails :\n    isFeatureEnabled(FeatureFlag.Thumbnails), hasPerm: hasPerm, openChartEditModal: openChartEditModal, bulkSelectEnabled: bulkSelectEnabled, addDangerToast: addDangerToast, addSuccessToast: addSuccessToast, refreshData: refreshData, userId: userId, loading: loading, favoriteStatus: favoriteStatus[chart.id], saveFavoriteStatus: saveFavoriteStatus, handleBulkChartExport: handleBulkChartExport }), [\n  addDangerToast,\n  addSuccessToast,\n  bulkSelectEnabled,\n  favoriteStatus,\n  hasPerm,\n  loading]\n  );\n  const subMenuButtons = [];\n  if (canDelete || canExport) {\n    subMenuButtons.push({\n      name: t('Bulk select'),\n      buttonStyle: 'secondary',\n\n      onClick: toggleBulkSelect\n    });\n  }\n  if (canCreate) {\n    subMenuButtons.push({\n      name: _jsxs(_Fragment, { children: [\n        _jsx(Icons.PlusOutlined, { iconColor: theme.colors.primary.light5, iconSize: \"m\", css: css`\n              vertical-align: text-top;\n            ` }),\n        _jsx(\"span\", { children: t('Chart') })] }\n      ),\n      buttonStyle: 'primary',\n      onClick: () => {\n        history.push('/chart/add');\n      }\n    });\n    subMenuButtons.push({\n      name: _jsx(Tooltip, { id: \"import-tooltip\", title: t('Import charts'), placement: \"bottomRight\", children:\n        _jsx(Icons.DownloadOutlined, { iconColor: theme.colors.primary.dark1 }) }\n      ),\n      buttonStyle: 'link',\n      onClick: openChartImportModal\n    });\n  }\n  return _jsxs(_Fragment, { children: [\n    _jsx(SubMenu, { name: t('Charts'), buttons: subMenuButtons }),\n    sliceCurrentlyEditing && _jsx(PropertiesModal, { onHide: closeChartEditModal, onSave: handleChartUpdated, show: true, slice: sliceCurrentlyEditing }),\n    _jsx(ConfirmStatusChange, { title: t('Please confirm'), description: t('Are you sure you want to delete the selected charts?'), onConfirm: handleBulkChartDelete, children:\n      (confirmDelete) => {\n        const bulkActions = [];\n        if (canDelete) {\n          bulkActions.push({\n            key: 'delete',\n            name: t('Delete'),\n            type: 'danger',\n            onSelect: confirmDelete\n          });\n        }\n        if (canExport) {\n          bulkActions.push({\n            key: 'export',\n            name: t('Export'),\n            type: 'primary',\n            onSelect: handleBulkChartExport\n          });\n        }\n        return _jsx(ListView, { bulkActions: bulkActions, bulkSelectEnabled: bulkSelectEnabled, cardSortSelectOptions: sortTypes, className: \"chart-list-view\", columns: columns, count: chartCount, data: charts, disableBulkSelect: toggleBulkSelect, refreshData: refreshData, fetchData: fetchData, filters: filters, initialSort: initialSort, loading: loading, pageSize: PAGE_SIZE, renderCard: renderCard, enableBulkTag: true, bulkTagResourceName: \"chart\", addSuccessToast: addSuccessToast, addDangerToast: addDangerToast, showThumbnails: userSettings ?\n          userSettings.thumbnails :\n          isFeatureEnabled(FeatureFlag.Thumbnails), defaultViewMode: isFeatureEnabled(FeatureFlag.ListviewsDefaultCardView) ?\n          'card' :\n          'table' });\n      } }\n    ),\n\n    _jsx(ImportModelsModal, { resourceName: \"chart\", resourceLabel: t('chart'), passwordsNeededMessage: PASSWORDS_NEEDED_MESSAGE, confirmOverwriteMessage: CONFIRM_OVERWRITE_MESSAGE, addDangerToast: addDangerToast, addSuccessToast: addSuccessToast, onModelImport: handleChartImport, show: importingChart, onHide: closeChartImportModal, passwordFields: passwordFields, setPasswordFields: setPasswordFields, sshTunnelPasswordFields: sshTunnelPasswordFields, setSSHTunnelPasswordFields: setSSHTunnelPasswordFields, sshTunnelPrivateKeyFields: sshTunnelPrivateKeyFields, setSSHTunnelPrivateKeyFields: setSSHTunnelPrivateKeyFields, sshTunnelPrivateKeyPasswordFields: sshTunnelPrivateKeyPasswordFields, setSSHTunnelPrivateKeyPasswordFields: setSSHTunnelPrivateKeyPasswordFields }),\n    preparingExport && _jsx(Loading, {})] }\n  );\n}\nexport default withToasts(ChartList);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}