{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";function _EMOTION_STRINGIFIED_CSS_ERROR__() {return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";} /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useLayoutEffect, useMemo, useState } from 'react';\nimport { extent as d3Extent, max as d3Max } from 'd3-array';\nimport { FaSort } from '@react-icons/all-files/fa/FaSort';\nimport { FaSortDown as FaSortDesc } from '@react-icons/all-files/fa/FaSortDown';\nimport { FaSortUp as FaSortAsc } from '@react-icons/all-files/fa/FaSortUp';\nimport cx from 'classnames';\nimport { DTTM_ALIAS, ensureIsArray, GenericDataType, getSelectedText, getTimeFormatterForGranularity, styled, css, t, tn, useTheme } from '@superset-ui/core';\nimport { Dropdown, Menu, Tooltip } from '@superset-ui/chart-controls';\nimport { CheckOutlined, InfoCircleOutlined, DownOutlined, MinusCircleOutlined, PlusCircleOutlined, TableOutlined } from '@ant-design/icons';\n\nimport { ColorSchemeEnum } from './types';\nimport DataTable from './DataTable';\nimport Styles from './Styles';\nimport { formatColumnValue } from './utils/formatValue';\nimport { PAGE_SIZE_OPTIONS } from './consts';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\nimport getScrollBarSize from './DataTable/utils/getScrollBarSize';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\nconst ACTION_KEYS = {\n  enter: 'Enter',\n  spacebar: 'Spacebar',\n  space: ' '\n};\n/**\n * Return sortType based on data type\n */\nfunction getSortTypeByDataType(dataType) {\n  if (dataType === GenericDataType.Temporal) {\n    return 'datetime';\n  }\n  if (dataType === GenericDataType.String) {\n    return 'alphanumeric';\n  }\n  return 'basic';\n}\n/**\n * Cell background width calculation for horizontal bar chart\n */\nfunction cellWidth({ value, valueRange, alignPositiveNegative }) {\n  const [minValue, maxValue] = valueRange;\n  if (alignPositiveNegative) {\n    const perc = Math.abs(Math.round(value / maxValue * 100));\n    return perc;\n  }\n  const posExtent = Math.abs(Math.max(maxValue, 0));\n  const negExtent = Math.abs(Math.min(minValue, 0));\n  const tot = posExtent + negExtent;\n  const perc2 = Math.round(Math.abs(value) / tot * 100);\n  return perc2;\n}\n/**\n * Cell left margin (offset) calculation for horizontal bar chart elements\n * when alignPositiveNegative is not set\n */\nfunction cellOffset({ value, valueRange, alignPositiveNegative }) {\n  if (alignPositiveNegative) {\n    return 0;\n  }\n  const [minValue, maxValue] = valueRange;\n  const posExtent = Math.abs(Math.max(maxValue, 0));\n  const negExtent = Math.abs(Math.min(minValue, 0));\n  const tot = posExtent + negExtent;\n  return Math.round(Math.min(negExtent + value, negExtent) / tot * 100);\n}\n/**\n * Cell background color calculation for horizontal bar chart\n */\nfunction cellBackground({ value, colorPositiveNegative = false }) {\n  const r = colorPositiveNegative && value < 0 ? 150 : 0;\n  return `rgba(${r},0,0,0.2)`;\n}\nfunction SortIcon({ column }) {\n  const { isSorted, isSortedDesc } = column;\n  let sortIcon = _jsx(FaSort, {});\n  if (isSorted) {\n    sortIcon = isSortedDesc ? _jsx(FaSortDesc, {}) : _jsx(FaSortAsc, {});\n  }\n  return sortIcon;\n}\nfunction SearchInput({ count, value, onChange }) {\n  return _jsxs(\"span\", { className: \"dt-global-filter\", children: [\n    t('Search'), ' ',\n    _jsx(\"input\", { \"aria-label\": t('Search %s records', count), className: \"form-control input-sm\", placeholder: tn('search.num_records', count), value: value, onChange: onChange })] }\n  );\n}\nfunction SelectPageSize({ options, current, onChange }) {\n  return _jsxs(\"span\", { className: \"dt-select-page-size form-inline\", role: \"group\", \"aria-label\": t('Select page size'), children: [\n    _jsx(\"label\", { htmlFor: \"pageSizeSelect\", className: \"sr-only\", children:\n      t('Select page size') }\n    ),\n    t('Show'), ' ',\n    _jsx(\"select\", { id: \"pageSizeSelect\", className: \"form-control input-sm\", value: current, onChange: (e) => {\n        onChange(Number(e.target.value));\n      }, \"aria-label\": t('Show entries per page'), children:\n      options.map((option) => {\n        const [size, text] = Array.isArray(option) ?\n        option :\n        [option, option];\n        return _jsx(\"option\", { value: size, children:\n          text }, size\n        );\n      }) }\n    ), ' ',\n    t('entries per page')] }\n  );\n}\nconst getNoResultsMessage = (filter) => filter ? t('No matching records found') : t('No records found');var _ref = process.env.NODE_ENV === \"production\" ? { name: \"tvoj80\", styles: \"display:inline-flex;align-items:flex-end\" } : { name: \"1f5n49p-Header\", styles: \"display:inline-flex;align-items:flex-end;label:Header;/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL1RhYmxlQ2hhcnQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXltQjJDIiwiZmlsZSI6Ii9ob21lL2FkZWwvc3VwZXJzZXQvc3VwZXJzZXQtZnJvbnRlbmQvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL1RhYmxlQ2hhcnQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUsIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZXh0ZW50IGFzIGQzRXh0ZW50LCBtYXggYXMgZDNNYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBGYVNvcnQgfSBmcm9tICdAcmVhY3QtaWNvbnMvYWxsLWZpbGVzL2ZhL0ZhU29ydCc7XG5pbXBvcnQgeyBGYVNvcnREb3duIGFzIEZhU29ydERlc2MgfSBmcm9tICdAcmVhY3QtaWNvbnMvYWxsLWZpbGVzL2ZhL0ZhU29ydERvd24nO1xuaW1wb3J0IHsgRmFTb3J0VXAgYXMgRmFTb3J0QXNjIH0gZnJvbSAnQHJlYWN0LWljb25zL2FsbC1maWxlcy9mYS9GYVNvcnRVcCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBEVFRNX0FMSUFTLCBlbnN1cmVJc0FycmF5LCBHZW5lcmljRGF0YVR5cGUsIGdldFNlbGVjdGVkVGV4dCwgZ2V0VGltZUZvcm1hdHRlckZvckdyYW51bGFyaXR5LCBzdHlsZWQsIGNzcywgdCwgdG4sIHVzZVRoZW1lLCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IERyb3Bkb3duLCBNZW51LCBUb29sdGlwIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NoYXJ0LWNvbnRyb2xzJztcbmltcG9ydCB7IENoZWNrT3V0bGluZWQsIEluZm9DaXJjbGVPdXRsaW5lZCwgRG93bk91dGxpbmVkLCBNaW51c0NpcmNsZU91dGxpbmVkLCBQbHVzQ2lyY2xlT3V0bGluZWQsIFRhYmxlT3V0bGluZWQsIH0gZnJvbSAnQGFudC1kZXNpZ24vaWNvbnMnO1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBDb2xvclNjaGVtZUVudW0sIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGF0YVRhYmxlIGZyb20gJy4vRGF0YVRhYmxlJztcbmltcG9ydCBTdHlsZXMgZnJvbSAnLi9TdHlsZXMnO1xuaW1wb3J0IHsgZm9ybWF0Q29sdW1uVmFsdWUgfSBmcm9tICcuL3V0aWxzL2Zvcm1hdFZhbHVlJztcbmltcG9ydCB7IFBBR0VfU0laRV9PUFRJT05TIH0gZnJvbSAnLi9jb25zdHMnO1xuaW1wb3J0IHsgdXBkYXRlRXh0ZXJuYWxGb3JtRGF0YSB9IGZyb20gJy4vRGF0YVRhYmxlL3V0aWxzL2V4dGVybmFsQVBJcyc7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuL0RhdGFUYWJsZS91dGlscy9nZXRTY3JvbGxCYXJTaXplJztcbmNvbnN0IEFDVElPTl9LRVlTID0ge1xuICAgIGVudGVyOiAnRW50ZXInLFxuICAgIHNwYWNlYmFyOiAnU3BhY2ViYXInLFxuICAgIHNwYWNlOiAnICcsXG59O1xuLyoqXG4gKiBSZXR1cm4gc29ydFR5cGUgYmFzZWQgb24gZGF0YSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNvcnRUeXBlQnlEYXRhVHlwZShkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLlRlbXBvcmFsKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZXRpbWUnO1xuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUgPT09IEdlbmVyaWNEYXRhVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdhbHBoYW51bWVyaWMnO1xuICAgIH1cbiAgICByZXR1cm4gJ2Jhc2ljJztcbn1cbi8qKlxuICogQ2VsbCBiYWNrZ3JvdW5kIHdpZHRoIGNhbGN1bGF0aW9uIGZvciBob3Jpem9udGFsIGJhciBjaGFydFxuICovXG5mdW5jdGlvbiBjZWxsV2lkdGgoeyB2YWx1ZSwgdmFsdWVSYW5nZSwgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlLCB9KSB7XG4gICAgY29uc3QgW21pblZhbHVlLCBtYXhWYWx1ZV0gPSB2YWx1ZVJhbmdlO1xuICAgIGlmIChhbGlnblBvc2l0aXZlTmVnYXRpdmUpIHtcbiAgICAgICAgY29uc3QgcGVyYyA9IE1hdGguYWJzKE1hdGgucm91bmQoKHZhbHVlIC8gbWF4VmFsdWUpICogMTAwKSk7XG4gICAgICAgIHJldHVybiBwZXJjO1xuICAgIH1cbiAgICBjb25zdCBwb3NFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1heChtYXhWYWx1ZSwgMCkpO1xuICAgIGNvbnN0IG5lZ0V4dGVudCA9IE1hdGguYWJzKE1hdGgubWluKG1pblZhbHVlLCAwKSk7XG4gICAgY29uc3QgdG90ID0gcG9zRXh0ZW50ICsgbmVnRXh0ZW50O1xuICAgIGNvbnN0IHBlcmMyID0gTWF0aC5yb3VuZCgoTWF0aC5hYnModmFsdWUpIC8gdG90KSAqIDEwMCk7XG4gICAgcmV0dXJuIHBlcmMyO1xufVxuLyoqXG4gKiBDZWxsIGxlZnQgbWFyZ2luIChvZmZzZXQpIGNhbGN1bGF0aW9uIGZvciBob3Jpem9udGFsIGJhciBjaGFydCBlbGVtZW50c1xuICogd2hlbiBhbGlnblBvc2l0aXZlTmVnYXRpdmUgaXMgbm90IHNldFxuICovXG5mdW5jdGlvbiBjZWxsT2Zmc2V0KHsgdmFsdWUsIHZhbHVlUmFuZ2UsIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSwgfSkge1xuICAgIGlmIChhbGlnblBvc2l0aXZlTmVnYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IFttaW5WYWx1ZSwgbWF4VmFsdWVdID0gdmFsdWVSYW5nZTtcbiAgICBjb25zdCBwb3NFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1heChtYXhWYWx1ZSwgMCkpO1xuICAgIGNvbnN0IG5lZ0V4dGVudCA9IE1hdGguYWJzKE1hdGgubWluKG1pblZhbHVlLCAwKSk7XG4gICAgY29uc3QgdG90ID0gcG9zRXh0ZW50ICsgbmVnRXh0ZW50O1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChNYXRoLm1pbihuZWdFeHRlbnQgKyB2YWx1ZSwgbmVnRXh0ZW50KSAvIHRvdCkgKiAxMDApO1xufVxuLyoqXG4gKiBDZWxsIGJhY2tncm91bmQgY29sb3IgY2FsY3VsYXRpb24gZm9yIGhvcml6b250YWwgYmFyIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNlbGxCYWNrZ3JvdW5kKHsgdmFsdWUsIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLCB9KSB7XG4gICAgY29uc3QgciA9IGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSAmJiB2YWx1ZSA8IDAgPyAxNTAgOiAwO1xuICAgIHJldHVybiBgcmdiYSgke3J9LDAsMCwwLjIpYDtcbn1cbmZ1bmN0aW9uIFNvcnRJY29uKHsgY29sdW1uIH0pIHtcbiAgICBjb25zdCB7IGlzU29ydGVkLCBpc1NvcnRlZERlc2MgfSA9IGNvbHVtbjtcbiAgICBsZXQgc29ydEljb24gPSA8RmFTb3J0IC8+O1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBzb3J0SWNvbiA9IGlzU29ydGVkRGVzYyA/IDxGYVNvcnREZXNjIC8+IDogPEZhU29ydEFzYyAvPjtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRJY29uO1xufVxuZnVuY3Rpb24gU2VhcmNoSW5wdXQoeyBjb3VudCwgdmFsdWUsIG9uQ2hhbmdlIH0pIHtcbiAgICByZXR1cm4gKDxzcGFuIGNsYXNzTmFtZT1cImR0LWdsb2JhbC1maWx0ZXJcIj5cbiAgICAgIHt0KCdTZWFyY2gnKX17JyAnfVxuICAgICAgPGlucHV0IGFyaWEtbGFiZWw9e3QoJ1NlYXJjaCAlcyByZWNvcmRzJywgY291bnQpfSBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIiBwbGFjZWhvbGRlcj17dG4oJ3NlYXJjaC5udW1fcmVjb3JkcycsIGNvdW50KX0gdmFsdWU9e3ZhbHVlfSBvbkNoYW5nZT17b25DaGFuZ2V9Lz5cbiAgICA8L3NwYW4+KTtcbn1cbmZ1bmN0aW9uIFNlbGVjdFBhZ2VTaXplKHsgb3B0aW9ucywgY3VycmVudCwgb25DaGFuZ2UsIH0pIHtcbiAgICByZXR1cm4gKDxzcGFuIGNsYXNzTmFtZT1cImR0LXNlbGVjdC1wYWdlLXNpemUgZm9ybS1pbmxpbmVcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPXt0KCdTZWxlY3QgcGFnZSBzaXplJyl9PlxuICAgICAgPGxhYmVsIGh0bWxGb3I9XCJwYWdlU2l6ZVNlbGVjdFwiIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5cbiAgICAgICAge3QoJ1NlbGVjdCBwYWdlIHNpemUnKX1cbiAgICAgIDwvbGFiZWw+XG4gICAgICB7dCgnU2hvdycpfXsnICd9XG4gICAgICA8c2VsZWN0IGlkPVwicGFnZVNpemVTZWxlY3RcIiBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIiB2YWx1ZT17Y3VycmVudH0gb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2UoTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgIH19IGFyaWEtbGFiZWw9e3QoJ1Nob3cgZW50cmllcyBwZXIgcGFnZScpfT5cbiAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc2l6ZSwgdGV4dF0gPSBBcnJheS5pc0FycmF5KG9wdGlvbilcbiAgICAgICAgICAgICAgICA/IG9wdGlvblxuICAgICAgICAgICAgICAgIDogW29wdGlvbiwgb3B0aW9uXTtcbiAgICAgICAgICAgIHJldHVybiAoPG9wdGlvbiBrZXk9e3NpemV9IHZhbHVlPXtzaXplfT5cbiAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICA8L29wdGlvbj4pO1xuICAgICAgICB9KX1cbiAgICAgIDwvc2VsZWN0PnsnICd9XG4gICAgICB7dCgnZW50cmllcyBwZXIgcGFnZScpfVxuICAgIDwvc3Bhbj4pO1xufVxuY29uc3QgZ2V0Tm9SZXN1bHRzTWVzc2FnZSA9IChmaWx0ZXIpID0+IGZpbHRlciA/IHQoJ05vIG1hdGNoaW5nIHJlY29yZHMgZm91bmQnKSA6IHQoJ05vIHJlY29yZHMgZm91bmQnKTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRhYmxlQ2hhcnQocHJvcHMpIHtcbiAgICBjb25zdCB7IHRpbWVHcmFpbiwgaGVpZ2h0LCB3aWR0aCwgZGF0YSwgdG90YWxzLCBpc1Jhd1JlY29yZHMsIHJvd0NvdW50ID0gMCwgY29sdW1uczogY29sdW1uc01ldGEsIGFsaWduUG9zaXRpdmVOZWdhdGl2ZTogZGVmYXVsdEFsaWduUE4gPSBmYWxzZSwgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlOiBkZWZhdWx0Q29sb3JQTiA9IGZhbHNlLCBpbmNsdWRlU2VhcmNoID0gZmFsc2UsIHBhZ2VTaXplID0gMCwgc2VydmVyUGFnaW5hdGlvbiA9IGZhbHNlLCBzZXJ2ZXJQYWdpbmF0aW9uRGF0YSwgc2V0RGF0YU1hc2ssIHNob3dDZWxsQmFycyA9IHRydWUsIHNvcnREZXNjID0gZmFsc2UsIGZpbHRlcnMsIHN0aWNreSA9IHRydWUsIC8vIHdoZXRoZXIgdG8gdXNlIHN0aWNreSBoZWFkZXJcbiAgICBjb2x1bW5Db2xvckZvcm1hdHRlcnMsIGFsbG93UmVhcnJhbmdlQ29sdW1ucyA9IGZhbHNlLCBhbGxvd1JlbmRlckh0bWwgPSB0cnVlLCBvbkNvbnRleHRNZW51LCBlbWl0Q3Jvc3NGaWx0ZXJzLCBpc1VzaW5nVGltZUNvbXBhcmlzb24sIGJhc2ljQ29sb3JGb3JtYXR0ZXJzLCBiYXNpY0NvbG9yQ29sdW1uRm9ybWF0dGVycywgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbXBhcmlzb25Db2x1bW5zID0gW1xuICAgICAgICB7IGtleTogJ2FsbCcsIGxhYmVsOiB0KCdEaXNwbGF5IGFsbCcpIH0sXG4gICAgICAgIHsga2V5OiAnIycsIGxhYmVsOiAnIycgfSxcbiAgICAgICAgeyBrZXk6ICfilrMnLCBsYWJlbDogJ+KWsycgfSxcbiAgICAgICAgeyBrZXk6ICclJywgbGFiZWw6ICclJyB9LFxuICAgIF07XG4gICAgY29uc3QgdGltZXN0YW1wRm9ybWF0dGVyID0gdXNlQ2FsbGJhY2sodmFsdWUgPT4gZ2V0VGltZUZvcm1hdHRlckZvckdyYW51bGFyaXR5KHRpbWVHcmFpbikodmFsdWUpLCBbdGltZUdyYWluXSk7XG4gICAgY29uc3QgW3RhYmxlU2l6ZSwgc2V0VGFibGVTaXplXSA9IHVzZVN0YXRlKHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICB9KTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgY29sdW1uIG9yZGVyIGNoYW5nZWQsIHNvIHRoYXQgY29sdW1uIHdpZHRocyBjYW4gdG9vXG4gICAgY29uc3QgW2NvbHVtbk9yZGVyVG9nZ2xlLCBzZXRDb2x1bW5PcmRlclRvZ2dsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dDb21wYXJpc29uRHJvcGRvd24sIHNldFNob3dDb21wYXJpc29uRHJvcGRvd25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWxlY3RlZENvbXBhcmlzb25Db2x1bW5zLCBzZXRTZWxlY3RlZENvbXBhcmlzb25Db2x1bW5zXSA9IHVzZVN0YXRlKFtcbiAgICAgICAgY29tcGFyaXNvbkNvbHVtbnNbMF0ua2V5LFxuICAgIF0pO1xuICAgIGNvbnN0IFtoaWRlQ29tcGFyaXNvbktleXMsIHNldEhpZGVDb21wYXJpc29uS2V5c10gPSB1c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICAgIC8vIG9ubHkgdGFrZSByZWxldmFudCBwYWdlIHNpemUgb3B0aW9uc1xuICAgIGNvbnN0IHBhZ2VTaXplT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRTZXJ2ZXJQYWdpbmF0aW9uID0gKG4pID0+IG4gPD0gcm93Q291bnQ7XG4gICAgICAgIHJldHVybiBQQUdFX1NJWkVfT1BUSU9OUy5maWx0ZXIoKFtuXSkgPT4gc2VydmVyUGFnaW5hdGlvbiA/IGdldFNlcnZlclBhZ2luYXRpb24obikgOiBuIDw9IDIgKiBkYXRhLmxlbmd0aCk7XG4gICAgfSwgW2RhdGEubGVuZ3RoLCByb3dDb3VudCwgc2VydmVyUGFnaW5hdGlvbl0pO1xuICAgIGNvbnN0IGdldFZhbHVlUmFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBnZXRWYWx1ZVJhbmdlKGtleSwgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YT8uWzBdPy5ba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bXMgPSBkYXRhLm1hcChyb3cgPT4gcm93W2tleV0pO1xuICAgICAgICAgICAgcmV0dXJuIChhbGlnblBvc2l0aXZlTmVnYXRpdmVcbiAgICAgICAgICAgICAgICA/IFswLCBkM01heChudW1zLm1hcChNYXRoLmFicykpXVxuICAgICAgICAgICAgICAgIDogZDNFeHRlbnQobnVtcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIFtkYXRhXSk7XG4gICAgY29uc3QgaXNBY3RpdmVGaWx0ZXJWYWx1ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGlzQWN0aXZlRmlsdGVyVmFsdWUoa2V5LCB2YWwpIHtcbiAgICAgICAgcmV0dXJuICEhZmlsdGVycyAmJiBmaWx0ZXJzW2tleV0/LmluY2x1ZGVzKHZhbCk7XG4gICAgfSwgW2ZpbHRlcnNdKTtcbiAgICBjb25zdCBnZXRDcm9zc0ZpbHRlckRhdGFNYXNrID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgbGV0IHVwZGF0ZWRGaWx0ZXJzID0geyAuLi4oZmlsdGVycyB8fCB7fSkgfTtcbiAgICAgICAgaWYgKGZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgdXBkYXRlZEZpbHRlcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWRGaWx0ZXJzID0ge1xuICAgICAgICAgICAgICAgIFtrZXldOiBbdmFsdWVdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVkRmlsdGVyc1trZXldKSAmJlxuICAgICAgICAgICAgdXBkYXRlZEZpbHRlcnNba2V5XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB1cGRhdGVkRmlsdGVyc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwQnkgPSBPYmplY3Qua2V5cyh1cGRhdGVkRmlsdGVycyk7XG4gICAgICAgIGNvbnN0IGdyb3VwQnlWYWx1ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50cyA9IFtdO1xuICAgICAgICBncm91cEJ5LmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVGltZXN0YW1wID0gY29sID09PSBEVFRNX0FMSUFTO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyVmFsdWVzID0gZW5zdXJlSXNBcnJheSh1cGRhdGVkRmlsdGVycz8uW2NvbF0pO1xuICAgICAgICAgICAgaWYgKGZpbHRlclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxhYmVscyA9IGZpbHRlclZhbHVlcy5tYXAodmFsdWUgPT4gaXNUaW1lc3RhbXAgPyB0aW1lc3RhbXBGb3JtYXR0ZXIodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxhYmVsRWxlbWVudHMucHVzaChgJHt2YWx1ZUxhYmVscy5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFNYXNrOiB7XG4gICAgICAgICAgICAgICAgZXh0cmFGb3JtRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzOiBncm91cEJ5Lmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBncm91cEJ5Lm1hcChjb2wgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGVuc3VyZUlzQXJyYXkodXBkYXRlZEZpbHRlcnM/Lltjb2xdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogJ0lTIE5VTEwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6ICdJTicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogdmFsLm1hcChlbCA9PiBlbCBpbnN0YW5jZW9mIERhdGUgPyBlbC5nZXRUaW1lKCkgOiBlbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYWluOiBjb2wgPT09IERUVE1fQUxJQVMgPyB0aW1lR3JhaW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsdGVyU3RhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsRWxlbWVudHMuam9pbignLCAnKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwQnlWYWx1ZXMubGVuZ3RoID8gZ3JvdXBCeVZhbHVlcyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnM6IHVwZGF0ZWRGaWx0ZXJzICYmIE9iamVjdC5rZXlzKHVwZGF0ZWRGaWx0ZXJzKS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlZEZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQ3VycmVudFZhbHVlU2VsZWN0ZWQ6IGlzQWN0aXZlRmlsdGVyVmFsdWUoa2V5LCB2YWx1ZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVGaWx0ZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0b2dnbGVGaWx0ZXIoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFlbWl0Q3Jvc3NGaWx0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGF0YU1hc2soZ2V0Q3Jvc3NGaWx0ZXJEYXRhTWFzayhrZXksIHZhbCkuZGF0YU1hc2spO1xuICAgIH0sIFtlbWl0Q3Jvc3NGaWx0ZXJzLCBnZXRDcm9zc0ZpbHRlckRhdGFNYXNrLCBzZXREYXRhTWFza10pO1xuICAgIGNvbnN0IGdldFNoYXJlZFN0eWxlID0gKGNvbHVtbikgPT4ge1xuICAgICAgICBjb25zdCB7IGlzTnVtZXJpYywgY29uZmlnID0ge30gfSA9IGNvbHVtbjtcbiAgICAgICAgY29uc3QgdGV4dEFsaWduID0gY29uZmlnLmhvcml6b250YWxBbGlnbiB8fFxuICAgICAgICAgICAgKGlzTnVtZXJpYyAmJiAhaXNVc2luZ1RpbWVDb21wYXJpc29uID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBjb21wYXJpc29uTGFiZWxzID0gW3QoJ01haW4nKSwgJyMnLCAn4pazJywgJyUnXTtcbiAgICBjb25zdCBmaWx0ZXJlZENvbHVtbnNNZXRhID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghaXNVc2luZ1RpbWVDb21wYXJpc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uc01ldGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsQ29sdW1ucyA9IGNvbXBhcmlzb25Db2x1bW5zWzBdLmtleTtcbiAgICAgICAgY29uc3QgbWFpbiA9IGNvbXBhcmlzb25MYWJlbHNbMF07XG4gICAgICAgIGNvbnN0IHNob3dBbGxDb2x1bW5zID0gc2VsZWN0ZWRDb21wYXJpc29uQ29sdW1ucy5pbmNsdWRlcyhhbGxDb2x1bW5zKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnNNZXRhLmZpbHRlcigoeyBsYWJlbCwga2V5IH0pID0+IHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGtleSBwb3J0aW9uIGFmdGVyIHRoZSBzcGFjZSwgYXNzdW1pbmcgdGhlIGZvcm1hdCBpcyBhbHdheXMgXCJsYWJlbCBrZXlcIlxuICAgICAgICAgICAgY29uc3Qga2V5UG9ydGlvbiA9IGtleS5zdWJzdHJpbmcobGFiZWwubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzS2V5SGlkZGVkID0gaGlkZUNvbXBhcmlzb25LZXlzLmluY2x1ZGVzKGtleVBvcnRpb24pO1xuICAgICAgICAgICAgY29uc3QgaXNMYWJsZU1haW4gPSBsYWJlbCA9PT0gbWFpbjtcbiAgICAgICAgICAgIHJldHVybiAoaXNMYWJsZU1haW4gfHxcbiAgICAgICAgICAgICAgICAoIWlzS2V5SGlkZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICghY29tcGFyaXNvbkxhYmVscy5pbmNsdWRlcyhsYWJlbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dBbGxDb2x1bW5zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENvbXBhcmlzb25Db2x1bW5zLmluY2x1ZGVzKGxhYmVsKSkpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBjb2x1bW5zTWV0YSxcbiAgICAgICAgY29tcGFyaXNvbkNvbHVtbnMsXG4gICAgICAgIGNvbXBhcmlzb25MYWJlbHMsXG4gICAgICAgIGlzVXNpbmdUaW1lQ29tcGFyaXNvbixcbiAgICAgICAgaGlkZUNvbXBhcmlzb25LZXlzLFxuICAgICAgICBzZWxlY3RlZENvbXBhcmlzb25Db2x1bW5zLFxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZUNvbnRleHRNZW51ID0gb25Db250ZXh0TWVudSAmJiAhaXNSYXdSZWNvcmRzXG4gICAgICAgID8gKHZhbHVlLCBjZWxsUG9pbnQsIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRyaWxsVG9EZXRhaWxGaWx0ZXJzID0gW107XG4gICAgICAgICAgICBmaWx0ZXJlZENvbHVtbnNNZXRhLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbC5pc01ldHJpYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhUmVjb3JkVmFsdWUgPSB2YWx1ZVtjb2wua2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZHJpbGxUb0RldGFpbEZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogJz09JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogZGF0YVJlY29yZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsOiBmb3JtYXRDb2x1bW5WYWx1ZShjb2wsIGRhdGFSZWNvcmRWYWx1ZSlbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25Db250ZXh0TWVudShjbGllbnRYLCBjbGllbnRZLCB7XG4gICAgICAgICAgICAgICAgZHJpbGxUb0RldGFpbDogZHJpbGxUb0RldGFpbEZpbHRlcnMsXG4gICAgICAgICAgICAgICAgY3Jvc3NGaWx0ZXI6IGNlbGxQb2ludC5pc01ldHJpY1xuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IGdldENyb3NzRmlsdGVyRGF0YU1hc2soY2VsbFBvaW50LmtleSwgY2VsbFBvaW50LnZhbHVlKSxcbiAgICAgICAgICAgICAgICBkcmlsbEJ5OiBjZWxsUG9pbnQuaXNNZXRyaWNcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNlbGxQb2ludC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiAnPT0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IGNlbGxQb2ludC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwYnlGaWVsZE5hbWU6ICdncm91cGJ5JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGdldEhlYWRlckNvbHVtbnMgPSAoY29sdW1uc01ldGEsIGVuYWJsZVRpbWVDb21wYXJpc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdE1hcCA9IHt9O1xuICAgICAgICBpZiAoIWVuYWJsZVRpbWVDb21wYXJpc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbnNNZXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50J3MgbGFiZWwgaXMgb25lIG9mIHRoZSBjb21wYXJpc29uIGxhYmVsc1xuICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25MYWJlbHMuaW5jbHVkZXMoZWxlbWVudC5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBrZXkgcG9ydGlvbiBhZnRlciB0aGUgc3BhY2UsIGFzc3VtaW5nIHRoZSBmb3JtYXQgaXMgYWx3YXlzIFwibGFiZWwga2V5XCJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQb3J0aW9uID0gZWxlbWVudC5rZXkuc3Vic3RyaW5nKGVsZW1lbnQubGFiZWwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUga2V5IHBvcnRpb24gaXMgbm90IGluIHRoZSBtYXAsIGluaXRpYWxpemUgaXQgd2l0aCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0TWFwW2tleVBvcnRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hcFtrZXlQb3J0aW9uXSA9IFtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGluZGV4IHRvIHRoZSBleGlzdGluZyBhcnJheVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRNYXBba2V5UG9ydGlvbl0ucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE1hcDtcbiAgICB9O1xuICAgIGNvbnN0IHJlbmRlclRpbWVDb21wYXJpc29uRHJvcGRvd24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFsbEtleSA9IGNvbXBhcmlzb25Db2x1bW5zWzBdLmtleTtcbiAgICAgICAgY29uc3QgaGFuZGxlT25DbGljayA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSB9ID0gZGF0YTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSAnQWxsJyBrZXkgc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBhbGxLZXkpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbXBhcmlzb25Db2x1bW5zKFthbGxLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkQ29tcGFyaXNvbkNvbHVtbnMuaW5jbHVkZXMoYWxsS2V5KSkge1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQ29tcGFyaXNvbkNvbHVtbnMoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVG9nZ2xlIHNlbGVjdGlvbiBmb3Igb3RoZXIga2V5c1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQ29tcGFyaXNvbkNvbHVtbnMoc2VsZWN0ZWRDb21wYXJpc29uQ29sdW1ucy5pbmNsdWRlcyhrZXkpXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZWN0ZWRDb21wYXJpc29uQ29sdW1ucy5maWx0ZXIoayA9PiBrICE9PSBrZXkpIC8vIERlc2VsZWN0IGlmIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgOiBbLi4uc2VsZWN0ZWRDb21wYXJpc29uQ29sdW1ucywga2V5XSk7IC8vIFNlbGVjdCBpZiBub3QgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVPbkJsdXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDb21wYXJpc29uQ29sdW1ucy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbXBhcmlzb25Db2x1bW5zKFtjb21wYXJpc29uQ29sdW1uc1swXS5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICg8RHJvcGRvd24gcGxhY2VtZW50PVwiYm90dG9tUmlnaHRcIiB2aXNpYmxlPXtzaG93Q29tcGFyaXNvbkRyb3Bkb3dufSBvblZpc2libGVDaGFuZ2U9eyhmbGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0U2hvd0NvbXBhcmlzb25Ecm9wZG93bihmbGFnKTtcbiAgICAgICAgICAgIH19IG92ZXJsYXk9ezxNZW51IG11bHRpcGxlIG9uQ2xpY2s9e2hhbmRsZU9uQ2xpY2t9IG9uQmx1cj17aGFuZGxlT25CbHVyfSBzZWxlY3RlZEtleXM9e3NlbGVjdGVkQ29tcGFyaXNvbkNvbHVtbnN9PlxuICAgICAgICAgICAgPGRpdiBjc3M9e2NzcyBgXG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiAyNDJweDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwICR7dGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICAgICAgICAgICAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuYmFzZX07XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgICAgICAgICAgICAgYH0+XG4gICAgICAgICAgICAgIHt0KCdTZWxlY3QgY29sdW1ucyB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSB0YWJsZS4gWW91IGNhbiBtdWx0aXNlbGVjdCBjb2x1bW5zLicpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7Y29tcGFyaXNvbkNvbHVtbnMubWFwKGNvbHVtbiA9PiAoPE1lbnUuSXRlbSBrZXk9e2NvbHVtbi5rZXl9PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMn07XG4gICAgICAgICAgICAgICAgICBgfT5cbiAgICAgICAgICAgICAgICAgIHtjb2x1bW4ubGFiZWx9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xuICAgICAgICAgICAgICAgICAgYH0+XG4gICAgICAgICAgICAgICAgICB7c2VsZWN0ZWRDb21wYXJpc29uQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW4ua2V5KSAmJiAoPENoZWNrT3V0bGluZWQgLz4pfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9NZW51Lkl0ZW0+KSl9XG4gICAgICAgICAgPC9NZW51Pn0gdHJpZ2dlcj17WydjbGljayddfT5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAgPFRhYmxlT3V0bGluZWQgLz4gPERvd25PdXRsaW5lZCAvPlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L0Ryb3Bkb3duPik7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXJHcm91cGluZ0hlYWRlcnMgPSAoKSA9PiB7XG4gICAgICAgIC8vIFRPRE86IE1ha2UgdXNlIG9mIENvbHVtbkdyb3VwIHRvIHJlbmRlciB0aGUgYWRpdGlvbmFsIGhlYWRlcnNcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudENvbHVtbkluZGV4ID0gMDtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ3JvdXBIZWFkZXJDb2x1bW5zIHx8IHt9KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBsYWNlaG9sZGVyIGNvbHVtbnMgbmVlZGVkIGJlZm9yZSB0aGUgY3VycmVudCBoZWFkZXJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB2YWx1ZVswXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbFNwYW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAvLyBBZGQgcGxhY2Vob2xkZXIgPHRoPiBmb3IgY29sdW1ucyBiZWZvcmUgdGhpcyBoZWFkZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50Q29sdW1uSW5kZXg7IGkgPCBzdGFydFBvc2l0aW9uOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goPHRoIGtleT17YHBsYWNlaG9sZGVyLSR7aX1gfSBzdHlsZT17eyBib3JkZXJCb3R0b206IDAgfX0gYXJpYS1sYWJlbD17YEhlYWRlci0ke2l9YH0vPik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGN1cnJlbnQgaGVhZGVyIDx0aD5cbiAgICAgICAgICAgIGhlYWRlcnMucHVzaCg8dGgga2V5PXtgaGVhZGVyLSR7a2V5fWB9IGNvbFNwYW49e2NvbFNwYW59IHN0eWxlPXt7IGJvcmRlckJvdHRvbTogMCB9fT5cbiAgICAgICAgICB7a2V5fVxuICAgICAgICAgIDxzcGFuIGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuICAgICAgICAgICAgICAmIHN2ZyB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlfSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfT5cbiAgICAgICAgICAgIHtoaWRlQ29tcGFyaXNvbktleXMuaW5jbHVkZXMoa2V5KSA/ICg8UGx1c0NpcmNsZU91dGxpbmVkIG9uQ2xpY2s9eygpID0+IHNldEhpZGVDb21wYXJpc29uS2V5cyhoaWRlQ29tcGFyaXNvbktleXMuZmlsdGVyKGsgPT4gayAhPT0ga2V5KSl9Lz4pIDogKDxNaW51c0NpcmNsZU91dGxpbmVkIG9uQ2xpY2s9eygpID0+IHNldEhpZGVDb21wYXJpc29uS2V5cyhbLi4uaGlkZUNvbXBhcmlzb25LZXlzLCBrZXldKX0vPil9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L3RoPik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY29sdW1uIGluZGV4XG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uSW5kZXggPSBzdGFydFBvc2l0aW9uICsgY29sU3BhbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoPHRyIGNzcz17Y3NzIGBcbiAgICAgICAgICB0aCB7XG4gICAgICAgICAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQyfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGg6Zmlyc3QtY2hpbGQge1xuICAgICAgICAgICAgYm9yZGVyLWxlZnQ6IG5vbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoOmxhc3QtY2hpbGQge1xuICAgICAgICAgICAgYm9yZGVyLXJpZ2h0OiBub25lO1xuICAgICAgICAgIH1cbiAgICAgICAgYH0+XG4gICAgICAgIHtoZWFkZXJzfVxuICAgICAgPC90cj4pO1xuICAgIH07XG4gICAgY29uc3QgZ3JvdXBIZWFkZXJDb2x1bW5zID0gdXNlTWVtbygoKSA9PiBnZXRIZWFkZXJDb2x1bW5zKGZpbHRlcmVkQ29sdW1uc01ldGEsIGlzVXNpbmdUaW1lQ29tcGFyaXNvbiksIFtmaWx0ZXJlZENvbHVtbnNNZXRhLCBpc1VzaW5nVGltZUNvbXBhcmlzb25dKTtcbiAgICBjb25zdCBnZXRDb2x1bW5Db25maWdzID0gdXNlQ2FsbGJhY2soKGNvbHVtbiwgaSkgPT4ge1xuICAgICAgICBjb25zdCB7IGtleSwgbGFiZWwsIGlzTnVtZXJpYywgZGF0YVR5cGUsIGlzTWV0cmljLCBpc1BlcmNlbnRNZXRyaWMsIGNvbmZpZyA9IHt9LCB9ID0gY29sdW1uO1xuICAgICAgICBjb25zdCBjb2x1bW5XaWR0aCA9IE51bWJlci5pc05hTihOdW1iZXIoY29uZmlnLmNvbHVtbldpZHRoKSlcbiAgICAgICAgICAgID8gY29uZmlnLmNvbHVtbldpZHRoXG4gICAgICAgICAgICA6IE51bWJlcihjb25maWcuY29sdW1uV2lkdGgpO1xuICAgICAgICAvLyBpbmxpbmUgc3R5bGUgZm9yIGJvdGggdGggYW5kIHRkIGNlbGxcbiAgICAgICAgY29uc3Qgc2hhcmVkU3R5bGUgPSBnZXRTaGFyZWRTdHlsZShjb2x1bW4pO1xuICAgICAgICBjb25zdCBhbGlnblBvc2l0aXZlTmVnYXRpdmUgPSBjb25maWcuYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZGVmYXVsdEFsaWduUE5cbiAgICAgICAgICAgIDogY29uZmlnLmFsaWduUG9zaXRpdmVOZWdhdGl2ZTtcbiAgICAgICAgY29uc3QgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlID0gY29uZmlnLmNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGRlZmF1bHRDb2xvclBOXG4gICAgICAgICAgICA6IGNvbmZpZy5jb2xvclBvc2l0aXZlTmVnYXRpdmU7XG4gICAgICAgIGNvbnN0IHsgdHJ1bmNhdGVMb25nQ2VsbHMgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgaGFzQ29sdW1uQ29sb3JGb3JtYXR0ZXJzID0gaXNOdW1lcmljICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNvbHVtbkNvbG9yRm9ybWF0dGVycykgJiZcbiAgICAgICAgICAgIGNvbHVtbkNvbG9yRm9ybWF0dGVycy5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBoYXNCYXNpY0NvbG9yRm9ybWF0dGVycyA9IGlzVXNpbmdUaW1lQ29tcGFyaXNvbiAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShiYXNpY0NvbG9yRm9ybWF0dGVycykgJiZcbiAgICAgICAgICAgIGJhc2ljQ29sb3JGb3JtYXR0ZXJzLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlUmFuZ2UgPSAhaGFzQmFzaWNDb2xvckZvcm1hdHRlcnMgJiZcbiAgICAgICAgICAgICFoYXNDb2x1bW5Db2xvckZvcm1hdHRlcnMgJiZcbiAgICAgICAgICAgIChjb25maWcuc2hvd0NlbGxCYXJzID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHNob3dDZWxsQmFyc1xuICAgICAgICAgICAgICAgIDogY29uZmlnLnNob3dDZWxsQmFycykgJiZcbiAgICAgICAgICAgIChpc01ldHJpYyB8fCBpc1Jhd1JlY29yZHMgfHwgaXNQZXJjZW50TWV0cmljKSAmJlxuICAgICAgICAgICAgZ2V0VmFsdWVSYW5nZShrZXksIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSk7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSAnJztcbiAgICAgICAgaWYgKGVtaXRDcm9zc0ZpbHRlcnMgJiYgIWlzTWV0cmljKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gJyBkdC1pcy1maWx0ZXInO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNZXRyaWMgJiYgIWlzUGVyY2VudE1ldHJpYykge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgcmlnaHQtYm9yZGVyLW9ubHknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25MYWJlbHMuaW5jbHVkZXMobGFiZWwpKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cGluSGVhZGVyID0ga2V5LnN1YnN0cmluZyhsYWJlbC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uc1VuZGVySGVhZGVyID0gZ3JvdXBIZWFkZXJDb2x1bW5zW2dyb3VwaW5IZWFkZXJdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKGkgPT09IGNvbHVtbnNVbmRlckhlYWRlcltjb2x1bW5zVW5kZXJIZWFkZXIubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gJyByaWdodC1ib3JkZXItb25seSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBTdHJpbmcoaSksXG4gICAgICAgICAgICAvLyBtdXN0IHVzZSBjdXN0b20gYWNjZXNzb3IgdG8gYWxsb3cgYC5gIGluIGNvbHVtbiBuYW1lc1xuICAgICAgICAgICAgLy8gdHlwaW5nIGlzIGluY29ycmVjdCBpbiBjdXJyZW50IHZlcnNpb24gb2YgYEB0eXBlcy9yZWFjdC10YWJsZWBcbiAgICAgICAgICAgIC8vIHNvIHdlIGFzayBUUyBub3QgdG8gY2hlY2suXG4gICAgICAgICAgICBhY2Nlc3NvcjogKChkYXR1bSkgPT4gZGF0dW1ba2V5XSksXG4gICAgICAgICAgICBDZWxsOiAoeyB2YWx1ZSwgcm93IH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaXNIdG1sLCB0ZXh0XSA9IGZvcm1hdENvbHVtblZhbHVlKGNvbHVtbiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSBpc0h0bWwgJiYgYWxsb3dSZW5kZXJIdG1sID8geyBfX2h0bWw6IHRleHQgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBhcnJvdyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbktleSA9IGNvbHVtbi5rZXkuc3Vic3RyaW5nKGNvbHVtbi5sYWJlbC5sZW5ndGgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0NvbHVtbkNvbG9yRm9ybWF0dGVycyAmJiBoYXNCYXNpY0NvbG9yRm9ybWF0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzaWNDb2xvckZvcm1hdHRlcnNbcm93LmluZGV4XVtvcmlnaW5LZXldPy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGFycm93ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5sYWJlbCA9PT0gY29tcGFyaXNvbkxhYmVsc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYmFzaWNDb2xvckZvcm1hdHRlcnNbcm93LmluZGV4XVtvcmlnaW5LZXldPy5tYWluQXJyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ29sdW1uQ29sb3JGb3JtYXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkNvbG9yRm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmb3JtYXR0ZXIgPT4gZm9ybWF0dGVyLmNvbHVtbiA9PT0gY29sdW1uLmtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZvcm1hdHRlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXJSZXN1bHQgPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZm9ybWF0dGVyLmdldENvbG9yRnJvbVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVyUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gZm9ybWF0dGVyUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhc2ljQ29sb3JDb2x1bW5Gb3JtYXR0ZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGJhc2ljQ29sb3JDb2x1bW5Gb3JtYXR0ZXJzPy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNpY0NvbG9yQ29sdW1uRm9ybWF0dGVyc1tyb3cuaW5kZXhdW2NvbHVtbi5rZXldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPy5iYWNrZ3JvdW5kQ29sb3IgfHwgYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICBhcnJvdyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubGFiZWwgPT09IGNvbXBhcmlzb25MYWJlbHNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJhc2ljQ29sb3JDb2x1bW5Gb3JtYXR0ZXJzW3Jvdy5pbmRleF1bY29sdW1uLmtleV0/Lm1haW5BcnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFN0eWxlZENlbGwgPSBzdHlsZWQudGQgYFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogJHtzaGFyZWRTdHlsZS50ZXh0QWxpZ259O1xuICAgICAgICAgICAgd2hpdGUtc3BhY2U6ICR7dmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gJ25vd3JhcCcgOiB1bmRlZmluZWR9O1xuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgYmFja2dyb3VuZDogJHtiYWNrZ3JvdW5kQ29sb3IgfHwgdW5kZWZpbmVkfTtcbiAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxCYXJTdHlsZXMgPSBjc3MgYFxuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICAke3ZhbHVlUmFuZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIHdpZHRoOiAke2Ake2NlbGxXaWR0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlLFxuICAgICAgICAgICAgICAgICAgICB9KX0lYH07XG4gICAgICAgICAgICAgICAgbGVmdDogJHtgJHtjZWxsT2Zmc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnblBvc2l0aXZlTmVnYXRpdmUsXG4gICAgICAgICAgICAgICAgICAgIH0pfSVgfTtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2NlbGxCYWNrZ3JvdW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgfSl9O1xuICAgICAgICAgICAgICBgfVxuICAgICAgICAgIGA7XG4gICAgICAgICAgICAgICAgbGV0IGFycm93U3R5bGVzID0gY3NzIGBcbiAgICAgICAgICAgIGNvbG9yOiAke2Jhc2ljQ29sb3JGb3JtYXR0ZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGJhc2ljQ29sb3JGb3JtYXR0ZXJzW3Jvdy5pbmRleF1bb3JpZ2luS2V5XT8uYXJyb3dDb2xvciA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIENvbG9yU2NoZW1lRW51bS5HcmVlblxuICAgICAgICAgICAgICAgICAgICA/IHRoZW1lLmNvbG9ycy5zdWNjZXNzLmJhc2VcbiAgICAgICAgICAgICAgICAgICAgOiB0aGVtZS5jb2xvcnMuZXJyb3IuYmFzZX07XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6ICR7dGhlbWUuZ3JpZFVuaXR9cHg7XG4gICAgICAgICAgYDtcbiAgICAgICAgICAgICAgICBpZiAoYmFzaWNDb2xvckNvbHVtbkZvcm1hdHRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgYmFzaWNDb2xvckNvbHVtbkZvcm1hdHRlcnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyb3dTdHlsZXMgPSBjc3MgYFxuICAgICAgICAgICAgICBjb2xvcjogJHtiYXNpY0NvbG9yQ29sdW1uRm9ybWF0dGVyc1tyb3cuaW5kZXhdW2NvbHVtbi5rZXldXG4gICAgICAgICAgICAgICAgICAgICAgICA/LmFycm93Q29sb3IgPT09IENvbG9yU2NoZW1lRW51bS5HcmVlblxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGVtZS5jb2xvcnMuc3VjY2Vzcy5iYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoZW1lLmNvbG9ycy5lcnJvci5iYXNlfTtcbiAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAke3RoZW1lLmdyaWRVbml0fXB4O1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbFByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogYGhlYWRlci0ke2NvbHVtbi5rZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG93IHJhdyBudW1iZXIgaW4gdGl0bGUgaW4gY2FzZSBvZiBudW1lcmljIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IFN0cmluZyh2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGVtaXRDcm9zc0ZpbHRlcnMgJiYgIXZhbHVlUmFuZ2UgJiYgIWlzTWV0cmljXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBzZWxlY3RpbmcgdGV4dCBpbiBhIGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFNlbGVjdGVkVGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUZpbHRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgb25Db250ZXh0TWVudTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVDb250ZXh0TWVudSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUNvbnRleHRNZW51KHJvdy5vcmlnaW5hbCwgeyBrZXksIHZhbHVlLCBpc01ldHJpYyB9LCBlLm5hdGl2ZUV2ZW50LmNsaWVudFgsIGUubmF0aXZlRXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT0gbnVsbCA/ICdkdC1pcy1udWxsJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbHVlKSA/ICcgZHQtaXMtYWN0aXZlLWZpbHRlcicgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydW5jYXRlTG9uZ0NlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDxTdHlsZWRDZWxsIHsuLi5jZWxsUHJvcHN9PlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkdC10cnVuY2F0ZS1jZWxsXCIgc3R5bGU9e2NvbHVtbldpZHRoID8geyB3aWR0aDogY29sdW1uV2lkdGggfSA6IHVuZGVmaW5lZH0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e2h0bWx9Lz5cbiAgICAgICAgICAgICAgICA8L1N0eWxlZENlbGw+KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8U3R5bGVkQ2VsbCB7Li4uY2VsbFByb3BzfSBkYW5nZXJvdXNseVNldElubmVySFRNTD17aHRtbH0vPjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgY2VsbFByb3BzIHJlbmRlcnMgdGV4dENvbnRlbnQgYWxyZWFkeSwgdGhlbiB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGBDZWxsYC4gVGhpcyBzYXZlcyBzb21lIHRpbWUgZm9yIGxhcmdlIHRhYmxlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gKDxTdHlsZWRDZWxsIHsuLi5jZWxsUHJvcHN9PlxuICAgICAgICAgICAgICB7dmFsdWVSYW5nZSAmJiAoPGRpdiBcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlIGZvbGxvd2luZyBjbGFzc2VzIGFyZSBhZGRlZCB0byBzdXBwb3J0IGN1c3RvbSBDU1Mgc3R5bGluZyAqL1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2N4KCdjZWxsLWJhcicsIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPCAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnbmVnYXRpdmUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAncG9zaXRpdmUnKX0gY3NzPXtjZWxsQmFyU3R5bGVzfSByb2xlPVwicHJlc2VudGF0aW9uXCIvPil9XG4gICAgICAgICAgICAgIHt0cnVuY2F0ZUxvbmdDZWxscyA/ICg8ZGl2IGNsYXNzTmFtZT1cImR0LXRydW5jYXRlLWNlbGxcIiBzdHlsZT17Y29sdW1uV2lkdGggPyB7IHdpZHRoOiBjb2x1bW5XaWR0aCB9IDogdW5kZWZpbmVkfT5cbiAgICAgICAgICAgICAgICAgIHthcnJvdyAmJiA8c3BhbiBjc3M9e2Fycm93U3R5bGVzfT57YXJyb3d9PC9zcGFuPn1cbiAgICAgICAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAgICAgIDwvZGl2PikgOiAoPD5cbiAgICAgICAgICAgICAgICAgIHthcnJvdyAmJiA8c3BhbiBjc3M9e2Fycm93U3R5bGVzfT57YXJyb3d9PC9zcGFuPn1cbiAgICAgICAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAgICAgIDwvPil9XG4gICAgICAgICAgICA8L1N0eWxlZENlbGw+KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBIZWFkZXI6ICh7IGNvbHVtbjogY29sLCBvbkNsaWNrLCBzdHlsZSwgb25EcmFnU3RhcnQsIG9uRHJvcCB9KSA9PiAoPHRoIGlkPXtgaGVhZGVyLSR7Y29sdW1uLmtleX1gfSB0aXRsZT17dCgnU2hpZnQgKyBDbGljayB0byBzb3J0IGJ5IG11bHRpcGxlIGNvbHVtbnMnKX0gY2xhc3NOYW1lPXtbY2xhc3NOYW1lLCBjb2wuaXNTb3J0ZWQgPyAnaXMtc29ydGVkJyA6ICcnXS5qb2luKCcgJyl9IHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNoYXJlZFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICAgICB9fSBvbktleURvd249eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW1hdGljYWxseSBzb3J0IGNvbHVtbiBvbiBrZXlwcmVzc1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhBQ1RJT05fS0VZUykuaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wudG9nZ2xlU29ydEJ5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fSByb2xlPVwiY29sdW1uaGVhZGVyIGJ1dHRvblwiIG9uQ2xpY2s9e29uQ2xpY2t9IGRhdGEtY29sdW1uLW5hbWU9e2NvbC5pZH0gey4uLihhbGxvd1JlYXJyYW5nZUNvbHVtbnMgJiYge1xuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogJ3RydWUnLFxuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgICAgIG9uRHJhZ092ZXI6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgIG9uRHJhZ0VudGVyOiBlID0+IGUucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICAgICAgICBvbkRyb3AsXG4gICAgICAgICAgICB9KX0gdGFiSW5kZXg9ezB9PlxuICAgICAgICAgICAgey8qIGNhbid0IHVzZSBgY29sdW1uV2lkdGggJiZgIGJlY2F1c2UgaXQgbWF5IGFsc28gYmUgemVybyAqL31cbiAgICAgICAgICAgIHtjb25maWcuY29sdW1uV2lkdGggPyAoXG4gICAgICAgICAgICAgICAgLy8gY29sdW1uIHdpZHRoIGhpbnRcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgIH19Lz4pIDogbnVsbH1cbiAgICAgICAgICAgIDxkaXYgZGF0YS1jb2x1bW4tbmFtZT17Y29sLmlkfSBjc3M9e3tcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgPHNwYW4gZGF0YS1jb2x1bW4tbmFtZT17Y29sLmlkfT57bGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICA8U29ydEljb24gY29sdW1uPXtjb2x9Lz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvdGg+KSxcbiAgICAgICAgICAgIEZvb3RlcjogdG90YWxzID8gKGkgPT09IDAgPyAoPHRoPlxuICAgICAgICAgICAgICA8ZGl2IGNzcz17Y3NzIGBcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICAgICAgJiBzdmcge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5ncmlkVW5pdH1weDtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMX0gIWltcG9ydGFudDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBgfT5cbiAgICAgICAgICAgICAgICB7dCgnU3VtbWFyeScpfVxuICAgICAgICAgICAgICAgIDxUb29sdGlwIG92ZXJsYXk9e3QoJ1Nob3cgdG90YWwgYWdncmVnYXRpb25zIG9mIHNlbGVjdGVkIG1ldHJpY3MuIE5vdGUgdGhhdCByb3cgbGltaXQgZG9lcyBub3QgYXBwbHkgdG8gdGhlIHJlc3VsdC4nKX0+XG4gICAgICAgICAgICAgICAgICA8SW5mb0NpcmNsZU91dGxpbmVkIC8+XG4gICAgICAgICAgICAgICAgPC9Ub29sdGlwPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvdGg+KSA6ICg8dGQgc3R5bGU9e3NoYXJlZFN0eWxlfT5cbiAgICAgICAgICAgICAgPHN0cm9uZz57Zm9ybWF0Q29sdW1uVmFsdWUoY29sdW1uLCB0b3RhbHNba2V5XSlbMV19PC9zdHJvbmc+XG4gICAgICAgICAgICA8L3RkPikpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc29ydERlc2NGaXJzdDogc29ydERlc2MsXG4gICAgICAgICAgICBzb3J0VHlwZTogZ2V0U29ydFR5cGVCeURhdGFUeXBlKGRhdGFUeXBlKSxcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGRlZmF1bHRBbGlnblBOLFxuICAgICAgICBkZWZhdWx0Q29sb3JQTixcbiAgICAgICAgZW1pdENyb3NzRmlsdGVycyxcbiAgICAgICAgZ2V0VmFsdWVSYW5nZSxcbiAgICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZSxcbiAgICAgICAgaXNSYXdSZWNvcmRzLFxuICAgICAgICBzaG93Q2VsbEJhcnMsXG4gICAgICAgIHNvcnREZXNjLFxuICAgICAgICB0b2dnbGVGaWx0ZXIsXG4gICAgICAgIHRvdGFscyxcbiAgICAgICAgY29sdW1uQ29sb3JGb3JtYXR0ZXJzLFxuICAgICAgICBjb2x1bW5PcmRlclRvZ2dsZSxcbiAgICBdKTtcbiAgICBjb25zdCBjb2x1bW5zID0gdXNlTWVtbygoKSA9PiBmaWx0ZXJlZENvbHVtbnNNZXRhLm1hcChnZXRDb2x1bW5Db25maWdzKSwgW2ZpbHRlcmVkQ29sdW1uc01ldGEsIGdldENvbHVtbkNvbmZpZ3NdKTtcbiAgICBjb25zdCBoYW5kbGVTZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHBhZ2VOdW1iZXIsIHBhZ2VTaXplKSA9PiB7XG4gICAgICAgIHVwZGF0ZUV4dGVybmFsRm9ybURhdGEoc2V0RGF0YU1hc2ssIHBhZ2VOdW1iZXIsIHBhZ2VTaXplKTtcbiAgICB9LCBbc2V0RGF0YU1hc2tdKTtcbiAgICBjb25zdCBoYW5kbGVTaXplQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgIHNldFRhYmxlU2l6ZSh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEFmdGVyIGluaXRpYWwgbG9hZCB0aGUgdGFibGUgc2hvdWxkIHJlc2l6ZSBvbmx5IHdoZW4gdGhlIG5ldyBzaXplc1xuICAgICAgICAvLyBBcmUgbm90IG9ubHkgc2Nyb2xsYmFyIHVwZGF0ZXMsIG90aGVyd2lzZSwgdGhlIHRhYmxlIHdvdWxkIHR3aXRjaFxuICAgICAgICBjb25zdCBzY3JvbGxCYXJTaXplID0gZ2V0U2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiB0YWJsZVdpZHRoLCBoZWlnaHQ6IHRhYmxlSGVpZ2h0IH0gPSB0YWJsZVNpemU7XG4gICAgICAgIC8vIFRhYmxlIGlzIGluY3JlYXNpbmcgaXRzIG9yaWdpbmFsIHNpemVcbiAgICAgICAgaWYgKHdpZHRoIC0gdGFibGVXaWR0aCA+IHNjcm9sbEJhclNpemUgfHxcbiAgICAgICAgICAgIGhlaWdodCAtIHRhYmxlSGVpZ2h0ID4gc2Nyb2xsQmFyU2l6ZSkge1xuICAgICAgICAgICAgaGFuZGxlU2l6ZUNoYW5nZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0gc2Nyb2xsQmFyU2l6ZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAtIHNjcm9sbEJhclNpemUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YWJsZVdpZHRoIC0gd2lkdGggPiBzY3JvbGxCYXJTaXplIHx8XG4gICAgICAgICAgICB0YWJsZUhlaWdodCAtIGhlaWdodCA+IHNjcm9sbEJhclNpemUpIHtcbiAgICAgICAgICAgIC8vIFRhYmxlIGlzIGRlY3JlYXNpbmcgaXRzIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgIGhhbmRsZVNpemVDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW3dpZHRoLCBoZWlnaHQsIGhhbmRsZVNpemVDaGFuZ2UsIHRhYmxlU2l6ZV0pO1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoRnJvbVN0YXRlLCBoZWlnaHQ6IGhlaWdodEZyb21TdGF0ZSB9ID0gdGFibGVTaXplO1xuICAgIHJldHVybiAoPFN0eWxlcz5cbiAgICAgIDxEYXRhVGFibGUgY29sdW1ucz17Y29sdW1uc30gZGF0YT17ZGF0YX0gcm93Q291bnQ9e3Jvd0NvdW50fSB0YWJsZUNsYXNzTmFtZT1cInRhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtY29uZGVuc2VkXCIgcGFnZVNpemU9e3BhZ2VTaXplfSBzZXJ2ZXJQYWdpbmF0aW9uRGF0YT17c2VydmVyUGFnaW5hdGlvbkRhdGF9IHBhZ2VTaXplT3B0aW9ucz17cGFnZVNpemVPcHRpb25zfSB3aWR0aD17d2lkdGhGcm9tU3RhdGV9IGhlaWdodD17aGVpZ2h0RnJvbVN0YXRlfSBzZXJ2ZXJQYWdpbmF0aW9uPXtzZXJ2ZXJQYWdpbmF0aW9ufSBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2U9e2hhbmRsZVNlcnZlclBhZ2luYXRpb25DaGFuZ2V9IG9uQ29sdW1uT3JkZXJDaGFuZ2U9eygpID0+IHNldENvbHVtbk9yZGVyVG9nZ2xlKCFjb2x1bW5PcmRlclRvZ2dsZSl9IFxuICAgIC8vIDkgcGFnZSBpdGVtcyBpbiA+IDM0MHB4IHdvcmtzIHdlbGwgZXZlbiBmb3IgMTAwKyBwYWdlc1xuICAgIG1heFBhZ2VJdGVtQ291bnQ9e3dpZHRoID4gMzQwID8gOSA6IDd9IG5vUmVzdWx0cz17Z2V0Tm9SZXN1bHRzTWVzc2FnZX0gc2VhcmNoSW5wdXQ9e2luY2x1ZGVTZWFyY2ggJiYgU2VhcmNoSW5wdXR9IHNlbGVjdFBhZ2VTaXplPXtwYWdlU2l6ZSAhPT0gbnVsbCAmJiBTZWxlY3RQYWdlU2l6ZX0gXG4gICAgLy8gbm90IGluIHVzZSBpbiBTdXBlcnNldCwgYnV0IG5lZWRlZCBmb3IgdW5pdCB0ZXN0c1xuICAgIHN0aWNreT17c3RpY2t5fSByZW5kZXJHcm91cGluZ0hlYWRlcnM9eyFpc0VtcHR5KGdyb3VwSGVhZGVyQ29sdW1ucykgPyByZW5kZXJHcm91cGluZ0hlYWRlcnMgOiB1bmRlZmluZWR9IHJlbmRlclRpbWVDb21wYXJpc29uRHJvcGRvd249e2lzVXNpbmdUaW1lQ29tcGFyaXNvbiA/IHJlbmRlclRpbWVDb21wYXJpc29uRHJvcGRvd24gOiB1bmRlZmluZWR9Lz5cbiAgICA8L1N0eWxlcz4pO1xufVxuIl19 */\", toString: _EMOTION_STRINGIFIED_CSS_ERROR__ };\nexport default function TableChart(props) {\n  const { timeGrain, height, width, data, totals, isRawRecords, rowCount = 0, columns: columnsMeta, alignPositiveNegative: defaultAlignPN = false, colorPositiveNegative: defaultColorPN = false, includeSearch = false, pageSize = 0, serverPagination = false, serverPaginationData, setDataMask, showCellBars = true, sortDesc = false, filters, sticky = true, // whether to use sticky header\n    columnColorFormatters, allowRearrangeColumns = false, allowRenderHtml = true, onContextMenu, emitCrossFilters, isUsingTimeComparison, basicColorFormatters, basicColorColumnFormatters } = props;\n  const comparisonColumns = [\n  { key: 'all', label: t('Display all') },\n  { key: '#', label: '#' },\n  { key: '△', label: '△' },\n  { key: '%', label: '%' }];\n\n  const timestampFormatter = useCallback((value) => getTimeFormatterForGranularity(timeGrain)(value), [timeGrain]);\n  const [tableSize, setTableSize] = useState({\n    width: 0,\n    height: 0\n  });\n  // keep track of whether column order changed, so that column widths can too\n  const [columnOrderToggle, setColumnOrderToggle] = useState(false);\n  const [showComparisonDropdown, setShowComparisonDropdown] = useState(false);\n  const [selectedComparisonColumns, setSelectedComparisonColumns] = useState([\n  comparisonColumns[0].key]\n  );\n  const [hideComparisonKeys, setHideComparisonKeys] = useState([]);\n  const theme = useTheme();\n  // only take relevant page size options\n  const pageSizeOptions = useMemo(() => {\n    const getServerPagination = (n) => n <= rowCount;\n    return PAGE_SIZE_OPTIONS.filter(([n]) => serverPagination ? getServerPagination(n) : n <= 2 * data.length);\n  }, [data.length, rowCount, serverPagination]);\n  const getValueRange = useCallback(function getValueRange(key, alignPositiveNegative) {var _data$;\n    if (typeof (data == null ? void 0 : (_data$ = data[0]) == null ? void 0 : _data$[key]) === 'number') {\n      const nums = data.map((row) => row[key]);\n      return alignPositiveNegative ?\n      [0, d3Max(nums.map(Math.abs))] :\n      d3Extent(nums);\n    }\n    return null;\n  }, [data]);\n  const isActiveFilterValue = useCallback(function isActiveFilterValue(key, val) {var _filters$key;\n    return !!filters && ((_filters$key = filters[key]) == null ? void 0 : _filters$key.includes(val));\n  }, [filters]);\n  const getCrossFilterDataMask = (key, value) => {\n    let updatedFilters = { ...(filters || {}) };\n    if (filters && isActiveFilterValue(key, value)) {\n      updatedFilters = {};\n    } else\n    {\n      updatedFilters = {\n        [key]: [value]\n      };\n    }\n    if (Array.isArray(updatedFilters[key]) &&\n    updatedFilters[key].length === 0) {\n      delete updatedFilters[key];\n    }\n    const groupBy = Object.keys(updatedFilters);\n    const groupByValues = Object.values(updatedFilters);\n    const labelElements = [];\n    groupBy.forEach((col) => {var _updatedFilters;\n      const isTimestamp = col === DTTM_ALIAS;\n      const filterValues = ensureIsArray((_updatedFilters = updatedFilters) == null ? void 0 : _updatedFilters[col]);\n      if (filterValues.length) {\n        const valueLabels = filterValues.map((value) => isTimestamp ? timestampFormatter(value) : value);\n        labelElements.push(`${valueLabels.join(', ')}`);\n      }\n    });\n    return {\n      dataMask: {\n        extraFormData: {\n          filters: groupBy.length === 0 ?\n          [] :\n          groupBy.map((col) => {var _updatedFilters2;\n            const val = ensureIsArray((_updatedFilters2 = updatedFilters) == null ? void 0 : _updatedFilters2[col]);\n            if (!val.length)\n            return {\n              col,\n              op: 'IS NULL'\n            };\n            return {\n              col,\n              op: 'IN',\n              val: val.map((el) => el instanceof Date ? el.getTime() : el),\n              grain: col === DTTM_ALIAS ? timeGrain : undefined\n            };\n          })\n        },\n        filterState: {\n          label: labelElements.join(', '),\n          value: groupByValues.length ? groupByValues : null,\n          filters: updatedFilters && Object.keys(updatedFilters).length ?\n          updatedFilters :\n          null\n        }\n      },\n      isCurrentValueSelected: isActiveFilterValue(key, value)\n    };\n  };\n  const toggleFilter = useCallback(function toggleFilter(key, val) {\n    if (!emitCrossFilters) {\n      return;\n    }\n    setDataMask(getCrossFilterDataMask(key, val).dataMask);\n  }, [emitCrossFilters, getCrossFilterDataMask, setDataMask]);\n  const getSharedStyle = (column) => {\n    const { isNumeric, config = {} } = column;\n    const textAlign = config.horizontalAlign || (\n    isNumeric && !isUsingTimeComparison ? 'right' : 'left');\n    return {\n      textAlign\n    };\n  };\n  const comparisonLabels = [t('Main'), '#', '△', '%'];\n  const filteredColumnsMeta = useMemo(() => {\n    if (!isUsingTimeComparison) {\n      return columnsMeta;\n    }\n    const allColumns = comparisonColumns[0].key;\n    const main = comparisonLabels[0];\n    const showAllColumns = selectedComparisonColumns.includes(allColumns);\n    return columnsMeta.filter(({ label, key }) => {\n      // Extract the key portion after the space, assuming the format is always \"label key\"\n      const keyPortion = key.substring(label.length);\n      const isKeyHidded = hideComparisonKeys.includes(keyPortion);\n      const isLableMain = label === main;\n      return isLableMain ||\n      !isKeyHidded && (\n      !comparisonLabels.includes(label) ||\n      showAllColumns ||\n      selectedComparisonColumns.includes(label));\n    });\n  }, [\n  columnsMeta,\n  comparisonColumns,\n  comparisonLabels,\n  isUsingTimeComparison,\n  hideComparisonKeys,\n  selectedComparisonColumns]\n  );\n  const handleContextMenu = onContextMenu && !isRawRecords ?\n  (value, cellPoint, clientX, clientY) => {\n    const drillToDetailFilters = [];\n    filteredColumnsMeta.forEach((col) => {\n      if (!col.isMetric) {\n        const dataRecordValue = value[col.key];\n        drillToDetailFilters.push({\n          col: col.key,\n          op: '==',\n          val: dataRecordValue,\n          formattedVal: formatColumnValue(col, dataRecordValue)[1]\n        });\n      }\n    });\n    onContextMenu(clientX, clientY, {\n      drillToDetail: drillToDetailFilters,\n      crossFilter: cellPoint.isMetric ?\n      undefined :\n      getCrossFilterDataMask(cellPoint.key, cellPoint.value),\n      drillBy: cellPoint.isMetric ?\n      undefined :\n      {\n        filters: [\n        {\n          col: cellPoint.key,\n          op: '==',\n          val: cellPoint.value\n        }],\n\n        groupbyFieldName: 'groupby'\n      }\n    });\n  } :\n  undefined;\n  const getHeaderColumns = (columnsMeta, enableTimeComparison) => {\n    const resultMap = {};\n    if (!enableTimeComparison) {\n      return resultMap;\n    }\n    columnsMeta.forEach((element, index) => {\n      // Check if element's label is one of the comparison labels\n      if (comparisonLabels.includes(element.label)) {\n        // Extract the key portion after the space, assuming the format is always \"label key\"\n        const keyPortion = element.key.substring(element.label.length);\n        // If the key portion is not in the map, initialize it with the current index\n        if (!resultMap[keyPortion]) {\n          resultMap[keyPortion] = [index];\n        } else\n        {\n          // Add the index to the existing array\n          resultMap[keyPortion].push(index);\n        }\n      }\n    });\n    return resultMap;\n  };\n  const renderTimeComparisonDropdown = () => {\n    const allKey = comparisonColumns[0].key;\n    const handleOnClick = (data) => {\n      const { key } = data;\n      // Toggle 'All' key selection\n      if (key === allKey) {\n        setSelectedComparisonColumns([allKey]);\n      } else\n      if (selectedComparisonColumns.includes(allKey)) {\n        setSelectedComparisonColumns([key]);\n      } else\n      {\n        // Toggle selection for other keys\n        setSelectedComparisonColumns(selectedComparisonColumns.includes(key) ?\n        selectedComparisonColumns.filter((k) => k !== key) // Deselect if already selected\n        : [...selectedComparisonColumns, key]); // Select if not already selected\n      }\n    };\n    const handleOnBlur = () => {\n      if (selectedComparisonColumns.length === 3) {\n        setSelectedComparisonColumns([comparisonColumns[0].key]);\n      }\n    };\n    return _jsx(Dropdown, { placement: \"bottomRight\", visible: showComparisonDropdown, onVisibleChange: (flag) => {\n        setShowComparisonDropdown(flag);\n      }, overlay: _jsxs(Menu, { multiple: true, onClick: handleOnClick, onBlur: handleOnBlur, selectedKeys: selectedComparisonColumns, children: [\n        _jsx(\"div\", { css: css`\n                max-width: 242px;\n                padding: 0 ${theme.gridUnit * 2}px;\n                color: ${theme.colors.grayscale.base};\n                font-size: ${theme.typography.sizes.s}px;\n              `, children:\n          t('Select columns that will be displayed in the table. You can multiselect columns.') }\n        ),\n        comparisonColumns.map((column) => _jsxs(Menu.Item, { children: [\n          _jsx(\"span\", { css: css`\n                    color: ${theme.colors.grayscale.dark2};\n                  `, children:\n            column.label }\n          ),\n          _jsx(\"span\", { css: css`\n                    float: right;\n                    font-size: ${theme.typography.sizes.s}px;\n                  `, children:\n            selectedComparisonColumns.includes(column.key) && _jsx(CheckOutlined, {}) }\n          )] }, column.key\n        ))] }\n      ), trigger: ['click'], children:\n      _jsxs(\"span\", { children: [\n        _jsx(TableOutlined, {}), \" \", _jsx(DownOutlined, {})] }\n      ) }\n    );\n  };\n  const renderGroupingHeaders = () => {\n    // TODO: Make use of ColumnGroup to render the aditional headers\n    const headers = [];\n    let currentColumnIndex = 0;\n    Object.entries(groupHeaderColumns || {}).forEach(([key, value]) => {\n      // Calculate the number of placeholder columns needed before the current header\n      const startPosition = value[0];\n      const colSpan = value.length;\n      // Add placeholder <th> for columns before this header\n      for (let i = currentColumnIndex; i < startPosition; i += 1) {\n        headers.push(_jsx(\"th\", { style: { borderBottom: 0 }, \"aria-label\": `Header-${i}` }, `placeholder-${i}`));\n      }\n      // Add the current header <th>\n      headers.push(_jsxs(\"th\", { colSpan: colSpan, style: { borderBottom: 0 }, children: [\n        key,\n        _jsx(\"span\", { css: css`\n              float: right;\n              & svg {\n                color: ${theme.colors.grayscale.base} !important;\n              }\n            `, children:\n          hideComparisonKeys.includes(key) ? _jsx(PlusCircleOutlined, { onClick: () => setHideComparisonKeys(hideComparisonKeys.filter((k) => k !== key)) }) : _jsx(MinusCircleOutlined, { onClick: () => setHideComparisonKeys([...hideComparisonKeys, key]) }) }\n        )] }, `header-${key}`\n      ));\n      // Update the current column index\n      currentColumnIndex = startPosition + colSpan;\n    });\n    return _jsx(\"tr\", { css: css`\n          th {\n            border-right: 2px solid ${theme.colors.grayscale.light2};\n          }\n          th:first-child {\n            border-left: none;\n          }\n          th:last-child {\n            border-right: none;\n          }\n        `, children:\n      headers }\n    );\n  };\n  const groupHeaderColumns = useMemo(() => getHeaderColumns(filteredColumnsMeta, isUsingTimeComparison), [filteredColumnsMeta, isUsingTimeComparison]);\n  const getColumnConfigs = useCallback((column, i) => {\n    const { key, label, isNumeric, dataType, isMetric, isPercentMetric, config = {} } = column;\n    const columnWidth = Number.isNaN(Number(config.columnWidth)) ?\n    config.columnWidth :\n    Number(config.columnWidth);\n    // inline style for both th and td cell\n    const sharedStyle = getSharedStyle(column);\n    const alignPositiveNegative = config.alignPositiveNegative === undefined ?\n    defaultAlignPN :\n    config.alignPositiveNegative;\n    const colorPositiveNegative = config.colorPositiveNegative === undefined ?\n    defaultColorPN :\n    config.colorPositiveNegative;\n    const { truncateLongCells } = config;\n    const hasColumnColorFormatters = isNumeric &&\n    Array.isArray(columnColorFormatters) &&\n    columnColorFormatters.length > 0;\n    const hasBasicColorFormatters = isUsingTimeComparison &&\n    Array.isArray(basicColorFormatters) &&\n    basicColorFormatters.length > 0;\n    const valueRange = !hasBasicColorFormatters &&\n    !hasColumnColorFormatters && (\n    config.showCellBars === undefined ?\n    showCellBars :\n    config.showCellBars) && (\n    isMetric || isRawRecords || isPercentMetric) &&\n    getValueRange(key, alignPositiveNegative);\n    let className = '';\n    if (emitCrossFilters && !isMetric) {\n      className += ' dt-is-filter';\n    }\n    if (!isMetric && !isPercentMetric) {\n      className += ' right-border-only';\n    } else\n    if (comparisonLabels.includes(label)) {\n      const groupinHeader = key.substring(label.length);\n      const columnsUnderHeader = groupHeaderColumns[groupinHeader] || [];\n      if (i === columnsUnderHeader[columnsUnderHeader.length - 1]) {\n        className += ' right-border-only';\n      }\n    }\n    return {\n      id: String(i),\n      // must use custom accessor to allow `.` in column names\n      // typing is incorrect in current version of `@types/react-table`\n      // so we ask TS not to check.\n      accessor: (datum) => datum[key],\n      Cell: ({ value, row }) => {var _basicColorFormatters3;\n        const [isHtml, text] = formatColumnValue(column, value);\n        const html = isHtml && allowRenderHtml ? { __html: text } : undefined;\n        let backgroundColor;\n        let arrow = '';\n        const originKey = column.key.substring(column.label.length).trim();\n        if (!hasColumnColorFormatters && hasBasicColorFormatters) {var _basicColorFormatters, _basicColorFormatters2;\n          backgroundColor = (_basicColorFormatters =\n          basicColorFormatters[row.index][originKey]) == null ? void 0 : _basicColorFormatters.backgroundColor;\n          arrow =\n          column.label === comparisonLabels[0] ? (_basicColorFormatters2 =\n          basicColorFormatters[row.index][originKey]) == null ? void 0 : _basicColorFormatters2.mainArrow :\n          '';\n        }\n        if (hasColumnColorFormatters) {\n          columnColorFormatters.\n          filter((formatter) => formatter.column === column.key).\n          forEach((formatter) => {\n            const formatterResult = value || value === 0 ?\n            formatter.getColorFromValue(value) :\n            false;\n            if (formatterResult) {\n              backgroundColor = formatterResult;\n            }\n          });\n        }\n        if (basicColorColumnFormatters &&\n        (basicColorColumnFormatters == null ? void 0 : basicColorColumnFormatters.length) > 0) {var _basicColorColumnForm, _basicColorColumnForm2;\n          backgroundColor =\n          ((_basicColorColumnForm = basicColorColumnFormatters[row.index][column.key]) == null ? void 0 : _basicColorColumnForm.\n          backgroundColor) || backgroundColor;\n          arrow =\n          column.label === comparisonLabels[0] ? (_basicColorColumnForm2 =\n          basicColorColumnFormatters[row.index][column.key]) == null ? void 0 : _basicColorColumnForm2.mainArrow :\n          '';\n        }\n        const StyledCell = styled.td`\n            text-align: ${sharedStyle.textAlign};\n            white-space: ${value instanceof Date ? 'nowrap' : undefined};\n            position: relative;\n            background: ${backgroundColor || undefined};\n          `;\n        const cellBarStyles = css`\n            position: absolute;\n            height: 100%;\n            display: block;\n            top: 0;\n            ${valueRange &&\n        `\n                width: ${`${cellWidth({\n          value: value,\n          valueRange,\n          alignPositiveNegative\n        })}%`};\n                left: ${`${cellOffset({\n          value: value,\n          valueRange,\n          alignPositiveNegative\n        })}%`};\n                background-color: ${cellBackground({\n          value: value,\n          colorPositiveNegative\n        })};\n              `}\n          `;\n        let arrowStyles = css`\n            color: ${basicColorFormatters &&\n        ((_basicColorFormatters3 = basicColorFormatters[row.index][originKey]) == null ? void 0 : _basicColorFormatters3.arrowColor) ===\n        ColorSchemeEnum.Green ?\n        theme.colors.success.base :\n        theme.colors.error.base};\n            margin-right: ${theme.gridUnit}px;\n          `;\n        if (basicColorColumnFormatters &&\n        (basicColorColumnFormatters == null ? void 0 : basicColorColumnFormatters.length) > 0) {var _basicColorColumnForm3;\n          arrowStyles = css`\n              color: ${((_basicColorColumnForm3 = basicColorColumnFormatters[row.index][column.key]) == null ? void 0 : _basicColorColumnForm3.\n          arrowColor) === ColorSchemeEnum.Green ?\n          theme.colors.success.base :\n          theme.colors.error.base};\n              margin-right: ${theme.gridUnit}px;\n            `;\n        }\n        const cellProps = {\n          'aria-labelledby': `header-${column.key}`,\n          role: 'cell',\n          // show raw number in title in case of numeric values\n          title: typeof value === 'number' ? String(value) : undefined,\n          onClick: emitCrossFilters && !valueRange && !isMetric ?\n          () => {\n            // allow selecting text in a cell\n            if (!getSelectedText()) {\n              toggleFilter(key, value);\n            }\n          } :\n          undefined,\n          onContextMenu: (e) => {\n            if (handleContextMenu) {\n              e.preventDefault();\n              e.stopPropagation();\n              handleContextMenu(row.original, { key, value, isMetric }, e.nativeEvent.clientX, e.nativeEvent.clientY);\n            }\n          },\n          className: [\n          className,\n          value == null ? 'dt-is-null' : '',\n          isActiveFilterValue(key, value) ? ' dt-is-active-filter' : ''].\n          join(' '),\n          tabIndex: 0\n        };\n        if (html) {\n          if (truncateLongCells) {\n            // eslint-disable-next-line react/no-danger\n            return _jsx(StyledCell, { ...cellProps, children:\n              _jsx(\"div\", { className: \"dt-truncate-cell\", style: columnWidth ? { width: columnWidth } : undefined, dangerouslySetInnerHTML: html }) }\n            );\n          }\n          // eslint-disable-next-line react/no-danger\n          return _jsx(StyledCell, { ...cellProps, dangerouslySetInnerHTML: html });\n        }\n        // If cellProps renders textContent already, then we don't have to\n        // render `Cell`. This saves some time for large tables.\n        return _jsxs(StyledCell, { ...cellProps, children: [\n          valueRange && _jsx(\"div\", {\n            /* The following classes are added to support custom CSS styling */\n            className: cx('cell-bar', typeof value === 'number' && value < 0 ?\n            'negative' :\n            'positive'), css: cellBarStyles, role: \"presentation\" }),\n          truncateLongCells ? _jsxs(\"div\", { className: \"dt-truncate-cell\", style: columnWidth ? { width: columnWidth } : undefined, children: [\n            arrow && _jsx(\"span\", { css: arrowStyles, children: arrow }),\n            text] }\n          ) : _jsxs(_Fragment, { children: [\n            arrow && _jsx(\"span\", { css: arrowStyles, children: arrow }),\n            text] }\n          )] }\n        );\n      },\n      Header: ({ column: col, onClick, style, onDragStart, onDrop }) => _jsxs(\"th\", { id: `header-${column.key}`, title: t('Shift + Click to sort by multiple columns'), className: [className, col.isSorted ? 'is-sorted' : ''].join(' '), style: {\n          ...sharedStyle,\n          ...style\n        }, onKeyDown: (e) => {\n          // programatically sort column on keypress\n          if (Object.values(ACTION_KEYS).includes(e.key)) {\n            col.toggleSortBy();\n          }\n        }, role: \"columnheader button\", onClick: onClick, \"data-column-name\": col.id, ...(allowRearrangeColumns && {\n          draggable: 'true',\n          onDragStart,\n          onDragOver: (e) => e.preventDefault(),\n          onDragEnter: (e) => e.preventDefault(),\n          onDrop\n        }), tabIndex: 0, children: [\n\n        config.columnWidth ?\n        // column width hint\n        _jsx(\"div\", { style: {\n            width: columnWidth,\n            height: 0.01\n          } }) : null,\n        _jsxs(\"div\", { \"data-column-name\": col.id, css: _ref, children: [\n\n\n\n          _jsx(\"span\", { \"data-column-name\": col.id, children: label }),\n          _jsx(SortIcon, { column: col })] }\n        )] }\n      ),\n      Footer: totals ? i === 0 ? _jsx(\"th\", { children:\n        _jsxs(\"div\", { css: css`\n                  display: flex;\n                  align-items: center;\n                  & svg {\n                    margin-left: ${theme.gridUnit}px;\n                    color: ${theme.colors.grayscale.dark1} !important;\n                  }\n                `, children: [\n          t('Summary'),\n          _jsx(Tooltip, { overlay: t('Show total aggregations of selected metrics. Note that row limit does not apply to the result.'), children:\n            _jsx(InfoCircleOutlined, {}) }\n          )] }\n        ) }\n      ) : _jsx(\"td\", { style: sharedStyle, children:\n        _jsx(\"strong\", { children: formatColumnValue(column, totals[key])[1] }) }\n      ) : undefined,\n      sortDescFirst: sortDesc,\n      sortType: getSortTypeByDataType(dataType)\n    };\n  }, [\n  defaultAlignPN,\n  defaultColorPN,\n  emitCrossFilters,\n  getValueRange,\n  isActiveFilterValue,\n  isRawRecords,\n  showCellBars,\n  sortDesc,\n  toggleFilter,\n  totals,\n  columnColorFormatters,\n  columnOrderToggle]\n  );\n  const columns = useMemo(() => filteredColumnsMeta.map(getColumnConfigs), [filteredColumnsMeta, getColumnConfigs]);\n  const handleServerPaginationChange = useCallback((pageNumber, pageSize) => {\n    updateExternalFormData(setDataMask, pageNumber, pageSize);\n  }, [setDataMask]);\n  const handleSizeChange = useCallback(({ width, height }) => {\n    setTableSize({ width, height });\n  }, []);\n  useLayoutEffect(() => {\n    // After initial load the table should resize only when the new sizes\n    // Are not only scrollbar updates, otherwise, the table would twitch\n    const scrollBarSize = getScrollBarSize();\n    const { width: tableWidth, height: tableHeight } = tableSize;\n    // Table is increasing its original size\n    if (width - tableWidth > scrollBarSize ||\n    height - tableHeight > scrollBarSize) {\n      handleSizeChange({\n        width: width - scrollBarSize,\n        height: height - scrollBarSize\n      });\n    } else\n    if (tableWidth - width > scrollBarSize ||\n    tableHeight - height > scrollBarSize) {\n      // Table is decreasing its original size\n      handleSizeChange({\n        width,\n        height\n      });\n    }\n  }, [width, height, handleSizeChange, tableSize]);\n  const { width: widthFromState, height: heightFromState } = tableSize;\n  return _jsx(Styles, { children:\n    _jsx(DataTable, { columns: columns, data: data, rowCount: rowCount, tableClassName: \"table table-striped table-condensed\", pageSize: pageSize, serverPaginationData: serverPaginationData, pageSizeOptions: pageSizeOptions, width: widthFromState, height: heightFromState, serverPagination: serverPagination, onServerPaginationChange: handleServerPaginationChange, onColumnOrderChange: () => setColumnOrderToggle(!columnOrderToggle)\n      // 9 page items in > 340px works well even for 100+ pages\n      , maxPageItemCount: width > 340 ? 9 : 7, noResults: getNoResultsMessage, searchInput: includeSearch && SearchInput, selectPageSize: pageSize !== null && SelectPageSize\n      // not in use in Superset, but needed for unit tests\n      , sticky: sticky, renderGroupingHeaders: !_isEmpty(groupHeaderColumns) ? renderGroupingHeaders : undefined, renderTimeComparisonDropdown: isUsingTimeComparison ? renderTimeComparisonDropdown : undefined }) }\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}