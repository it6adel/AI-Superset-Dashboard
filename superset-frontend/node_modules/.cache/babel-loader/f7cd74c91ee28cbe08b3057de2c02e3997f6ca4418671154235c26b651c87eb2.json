{"ast":null,"code":"import _omit from \"lodash/omit\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { normalizeTimestamp, QueryState, t } from '@superset-ui/core';\n\nimport { shallowEqual } from 'react-redux';\nimport * as actions from '../actions/sqlLab';\nimport { now } from '../../utils/dates';\nimport {\n  addToObject,\n  alterInObject,\n  alterInArr,\n  removeFromArr,\n  getFromArr,\n  addToArr,\n  extendArr } from\n'../../reduxUtils';\n\nfunction alterUnsavedQueryEditorState(state, updatedState, id, silent = false) {\n  if (state.tabHistory[state.tabHistory.length - 1] !== id) {\n    const { queryEditors } = alterInArr(\n      state,\n      'queryEditors',\n      { id },\n      updatedState\n    );\n    return {\n      queryEditors\n    };\n  }\n  return {\n    unsavedQueryEditor: {\n      ...(state.unsavedQueryEditor.id === id && state.unsavedQueryEditor),\n      ...(id ? { id, ...updatedState } : state.unsavedQueryEditor),\n      ...(!silent && { updatedAt: new Date().getTime() })\n    }\n  };\n}\n\nexport default function sqlLabReducer(state = {}, action) {\n  const actionHandlers = {\n    [actions.ADD_QUERY_EDITOR]() {\n      const mergeUnsavedState = alterInArr(\n        state,\n        'queryEditors',\n        state.unsavedQueryEditor,\n        {\n          ...state.unsavedQueryEditor\n        }\n      );\n      const newState = {\n        ...mergeUnsavedState,\n        tabHistory: [...state.tabHistory, action.queryEditor.id]\n      };\n      return addToArr(newState, 'queryEditors', {\n        ...action.queryEditor,\n        updatedAt: new Date().getTime()\n      });\n    },\n    [actions.QUERY_EDITOR_SAVED]() {\n      const { query, result, clientId } = action;\n      const existing = state.queryEditors.find((qe) => qe.id === clientId);\n      return alterInArr(\n        state,\n        'queryEditors',\n        existing,\n        {\n          remoteId: result.remoteId,\n          name: query.name\n        },\n        'id'\n      );\n    },\n    [actions.UPDATE_QUERY_EDITOR]() {\n      const id = action.alterations.remoteId;\n      const existing = state.queryEditors.find((qe) => qe.remoteId === id);\n      if (existing == null) return state;\n      return alterInArr(\n        state,\n        'queryEditors',\n        existing,\n        action.alterations,\n        'remoteId'\n      );\n    },\n    [actions.CLONE_QUERY_TO_NEW_TAB]() {\n      const queryEditor = state.queryEditors.find(\n        (qe) => qe.id === state.tabHistory[state.tabHistory.length - 1]\n      );\n      const progenitor = {\n        ...queryEditor,\n        ...(state.unsavedQueryEditor.id === queryEditor.id &&\n        state.unsavedQueryEditor)\n      };\n      const qe = {\n        remoteId: progenitor.remoteId,\n        name: t('Copy of %s', progenitor.name),\n        dbId: action.query.dbId ? action.query.dbId : null,\n        catalog: action.query.catalog ? action.query.catalog : null,\n        schema: action.query.schema ? action.query.schema : null,\n        autorun: true,\n        sql: action.query.sql,\n        queryLimit: action.query.queryLimit,\n        maxRow: action.query.maxRow\n      };\n      const stateWithoutUnsavedState = {\n        ...state,\n        unsavedQueryEditor: {}\n      };\n      return sqlLabReducer(\n        stateWithoutUnsavedState,\n        actions.addQueryEditor(qe)\n      );\n    },\n    [actions.REMOVE_QUERY_EDITOR]() {\n      const queryEditor = {\n        ...action.queryEditor,\n        ...(action.queryEditor.id === state.unsavedQueryEditor.id &&\n        state.unsavedQueryEditor)\n      };\n      let newState = removeFromArr(state, 'queryEditors', queryEditor);\n      // List of remaining queryEditor ids\n      const qeIds = newState.queryEditors.map((qe) => qe.id);\n\n      const queries = {};\n      Object.keys(state.queries).forEach((k) => {\n        const query = state.queries[k];\n        if (qeIds.indexOf(query.sqlEditorId) > -1) {\n          queries[k] = query;\n        }\n      });\n\n      let tabHistory = state.tabHistory.slice();\n      tabHistory = tabHistory.filter((id) => qeIds.indexOf(id) > -1);\n\n      // Remove associated table schemas\n      const tables = state.tables.filter(\n        (table) => table.queryEditorId !== queryEditor.id\n      );\n\n      newState = {\n        ...newState,\n        tabHistory:\n        tabHistory.length === 0 && newState.queryEditors.length > 0 ?\n        newState.queryEditors.slice(-1).map((qe) => qe.id) :\n        tabHistory,\n        tables,\n        queries,\n        unsavedQueryEditor: {\n          ...(action.queryEditor.id !== state.unsavedQueryEditor.id &&\n          state.unsavedQueryEditor)\n        },\n        destroyedQueryEditors: {\n          ...newState.destroyedQueryEditors,\n          [queryEditor.id]: Date.now()\n        }\n      };\n      return newState;\n    },\n    [actions.CLEAR_DESTROYED_QUERY_EDITOR]() {\n      const destroyedQueryEditors = { ...state.destroyedQueryEditors };\n      delete destroyedQueryEditors[action.queryEditorId];\n      return { ...state, destroyedQueryEditors };\n    },\n    [actions.REMOVE_QUERY]() {\n      const newQueries = { ...state.queries };\n      delete newQueries[action.query.id];\n      return { ...state, queries: newQueries };\n    },\n    [actions.RESET_STATE]() {\n      return { ...action.sqlLabInitialState };\n    },\n    [actions.MERGE_TABLE]() {\n      const at = { ...action.table };\n      const existingTableIndex = state.tables.findIndex(\n        (xt) =>\n        xt.dbId === at.dbId &&\n        xt.queryEditorId === at.queryEditorId &&\n        xt.catalog === at.catalog &&\n        xt.schema === at.schema &&\n        xt.name === at.name\n      );\n      if (existingTableIndex >= 0) {\n        if (action.query) {\n          at.dataPreviewQueryId = action.query.id;\n        }\n        return {\n          ...state,\n          tables: [\n          ...state.tables.slice(0, existingTableIndex),\n          {\n            ...state.tables[existingTableIndex],\n            ...at,\n            ...(state.tables[existingTableIndex].initialized && {\n              id: state.tables[existingTableIndex].id\n            })\n          },\n          ...state.tables.slice(existingTableIndex + 1)],\n\n          ...(at.expanded && {\n            activeSouthPaneTab: at.id\n          })\n        };\n      }\n      // for new table, associate Id of query for data preview\n      at.dataPreviewQueryId = null;\n      let newState = addToArr(state, 'tables', at, Boolean(action.prepend));\n      newState.activeSouthPaneTab = at.id;\n      if (action.query) {\n        newState = alterInArr(newState, 'tables', at, {\n          dataPreviewQueryId: action.query.id\n        });\n      }\n      return newState;\n    },\n    [actions.EXPAND_TABLE]() {\n      return alterInArr(state, 'tables', action.table, { expanded: true });\n    },\n    [actions.REMOVE_DATA_PREVIEW]() {\n      const queries = { ...state.queries };\n      delete queries[action.table.dataPreviewQueryId];\n      const newState = alterInArr(state, 'tables', action.table, {\n        dataPreviewQueryId: null\n      });\n      return { ...newState, queries };\n    },\n    [actions.CHANGE_DATA_PREVIEW_ID]() {\n      const queries = { ...state.queries };\n      delete queries[action.oldQueryId];\n\n      const newTables = [];\n      state.tables.forEach((xt) => {\n        if (xt.dataPreviewQueryId === action.oldQueryId) {\n          newTables.push({ ...xt, dataPreviewQueryId: action.newQuery.id });\n        } else {\n          newTables.push(xt);\n        }\n      });\n      return {\n        ...state,\n        queries,\n        tables: newTables\n      };\n    },\n    [actions.COLLAPSE_TABLE]() {\n      return alterInArr(state, 'tables', action.table, { expanded: false });\n    },\n    [actions.REMOVE_TABLES]() {var _tables$find$id, _tables$find;\n      const tableIds = action.tables.map((table) => table.id);\n      const tables = state.tables.filter((table) => !tableIds.includes(table.id));\n\n      return {\n        ...state,\n        tables,\n        ...(tableIds.includes(state.activeSouthPaneTab) && {\n          activeSouthPaneTab: (_tables$find$id = (_tables$find =\n          tables.find(\n            ({ queryEditorId }) =>\n            queryEditorId === action.tables[0].queryEditorId\n          )) == null ? void 0 : _tables$find.id) != null ? _tables$find$id : 'Results'\n        })\n      };\n    },\n    [actions.COST_ESTIMATE_STARTED]() {\n      return {\n        ...state,\n        queryCostEstimates: {\n          ...state.queryCostEstimates,\n          [action.query.id]: {\n            completed: false,\n            cost: null,\n            error: null\n          }\n        }\n      };\n    },\n    [actions.COST_ESTIMATE_RETURNED]() {\n      return {\n        ...state,\n        queryCostEstimates: {\n          ...state.queryCostEstimates,\n          [action.query.id]: {\n            completed: true,\n            cost: action.json.result,\n            error: null\n          }\n        }\n      };\n    },\n    [actions.COST_ESTIMATE_FAILED]() {\n      return {\n        ...state,\n        queryCostEstimates: {\n          ...state.queryCostEstimates,\n          [action.query.id]: {\n            completed: false,\n            cost: null,\n            error: action.error\n          }\n        }\n      };\n    },\n    [actions.START_QUERY]() {\n      let newState = { ...state };\n      if (action.query.sqlEditorId) {\n        const qe = {\n          ...getFromArr(state.queryEditors, action.query.sqlEditorId),\n          ...(action.query.sqlEditorId === state.unsavedQueryEditor.id &&\n          state.unsavedQueryEditor)\n        };\n        if (qe.latestQueryId && state.queries[qe.latestQueryId]) {\n          const newResults = {\n            ...state.queries[qe.latestQueryId].results,\n            data: [],\n            query: null\n          };\n          const q = { ...state.queries[qe.latestQueryId], results: newResults };\n          const queries = { ...state.queries, [q.id]: q };\n          newState = { ...state, queries };\n        }\n      }\n      newState = addToObject(newState, 'queries', action.query);\n\n      return {\n        ...newState,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            latestQueryId: action.query.id\n          },\n          action.query.sqlEditorId,\n          action.query.isDataPreview\n        )\n      };\n    },\n    [actions.STOP_QUERY]() {\n      return alterInObject(state, 'queries', action.query, {\n        state: QueryState.Stopped,\n        results: []\n      });\n    },\n    [actions.CLEAR_QUERY_RESULTS]() {\n      const newResults = { ...action.query.results };\n      newResults.data = [];\n      return alterInObject(state, 'queries', action.query, {\n        results: newResults,\n        cached: true\n      });\n    },\n    [actions.REQUEST_QUERY_RESULTS]() {\n      return alterInObject(state, 'queries', action.query, {\n        state: QueryState.Fetching\n      });\n    },\n    [actions.QUERY_SUCCESS]() {var _action$results, _action$results$query, _action$results2, _action$results2$quer, _action$results3, _action$results3$quer, _action$results4, _action$results4$quer, _action$results5, _action$results5$quer;\n      // prevent race condition where query succeeds shortly after being canceled\n      // or the final result was unsuccessful\n      if (\n      action.query.state === QueryState.STOPPED ||\n      action.results.status !== QueryState.Success)\n      {\n        return state;\n      }\n      const alts = {\n        endDttm: now(),\n        progress: 100,\n        results: action.results,\n        rows: (action == null ? void 0 : (_action$results = action.results) == null ? void 0 : (_action$results$query = _action$results.query) == null ? void 0 : _action$results$query.rows) || 0,\n        state: QueryState.Success,\n        limitingFactor: action == null ? void 0 : (_action$results2 = action.results) == null ? void 0 : (_action$results2$quer = _action$results2.query) == null ? void 0 : _action$results2$quer.limitingFactor,\n        tempSchema: action == null ? void 0 : (_action$results3 = action.results) == null ? void 0 : (_action$results3$quer = _action$results3.query) == null ? void 0 : _action$results3$quer.tempSchema,\n        tempTable: action == null ? void 0 : (_action$results4 = action.results) == null ? void 0 : (_action$results4$quer = _action$results4.query) == null ? void 0 : _action$results4$quer.tempTable,\n        errorMessage: null,\n        cached: false\n      };\n\n      const resultsKey = action == null ? void 0 : (_action$results5 = action.results) == null ? void 0 : (_action$results5$quer = _action$results5.query) == null ? void 0 : _action$results5$quer.resultsKey;\n      if (resultsKey) {\n        alts.resultsKey = resultsKey;\n      }\n\n      return alterInObject(state, 'queries', action.query, alts);\n    },\n    [actions.QUERY_FAILED]() {\n      if (action.query.state === QueryState.Stopped) {\n        return state;\n      }\n      const alts = {\n        state: QueryState.Failed,\n        errors: action.errors,\n        errorMessage: action.msg,\n        endDttm: now(),\n        link: action.link\n      };\n      return alterInObject(state, 'queries', action.query, alts);\n    },\n    [actions.SET_ACTIVE_QUERY_EDITOR]() {var _action$queryEditor;\n      const qeIds = state.queryEditors.map((qe) => qe.id);\n      if (\n      qeIds.indexOf((_action$queryEditor = action.queryEditor) == null ? void 0 : _action$queryEditor.id) > -1 &&\n      state.tabHistory[state.tabHistory.length - 1] !== action.queryEditor.id)\n      {\n        const mergeUnsavedState = {\n          ...alterInArr(state, 'queryEditors', state.unsavedQueryEditor, {\n            ...state.unsavedQueryEditor\n          }),\n          unsavedQueryEditor: {}\n        };\n        return {\n          ...(action.queryEditor.id === state.unsavedQueryEditor.id ?\n          alterInArr(\n            mergeUnsavedState,\n            'queryEditors',\n            action.queryEditor,\n            {\n              ...action.queryEditor,\n              ...state.unsavedQueryEditor\n            }\n          ) :\n          mergeUnsavedState),\n          tabHistory: [...state.tabHistory, action.queryEditor.id]\n        };\n      }\n      return state;\n    },\n    [actions.LOAD_QUERY_EDITOR]() {\n      const mergeUnsavedState = alterInArr(\n        state,\n        'queryEditors',\n        state.unsavedQueryEditor,\n        {\n          ...state.unsavedQueryEditor\n        }\n      );\n      return alterInArr(mergeUnsavedState, 'queryEditors', action.queryEditor, {\n        ...action.queryEditor\n      });\n    },\n    [actions.SET_TABLES]() {\n      return extendArr(state, 'tables', action.tables);\n    },\n    [actions.SET_ACTIVE_SOUTHPANE_TAB]() {\n      return { ...state, activeSouthPaneTab: action.tabId };\n    },\n    [actions.MIGRATE_QUERY_EDITOR]() {\n      try {\n        // remove migrated query editor from localStorage\n        const { sqlLab } = JSON.parse(localStorage.getItem('redux'));\n        sqlLab.queryEditors = sqlLab.queryEditors.filter(\n          (qe) => qe.id !== action.oldQueryEditor.id\n        );\n        localStorage.setItem('redux', JSON.stringify({ sqlLab }));\n      } catch (error) {\n\n        // continue regardless of error\n      } // replace localStorage query editor with the server backed one\n      return alterInArr(\n        state,\n        'queryEditors',\n        action.oldQueryEditor,\n        action.newQueryEditor\n      );\n    },\n    [actions.MIGRATE_TABLE]() {\n      try {\n        // remove migrated table from localStorage\n        const { sqlLab } = JSON.parse(localStorage.getItem('redux'));\n        sqlLab.tables = sqlLab.tables.filter(\n          (table) => table.id !== action.oldTable.id\n        );\n        localStorage.setItem('redux', JSON.stringify({ sqlLab }));\n      } catch (error) {\n\n        // continue regardless of error\n      }\n      // replace localStorage table with the server backed one\n      return addToArr(\n        removeFromArr(state, 'tables', action.oldTable),\n        'tables',\n        action.newTable\n      );\n    },\n    [actions.MIGRATE_TAB_HISTORY]() {\n      const tabHistory = state.tabHistory.map((tabId) =>\n      tabId === action.oldId ? action.newId : tabId\n      );\n      return { ...state, tabHistory };\n    },\n    [actions.MIGRATE_QUERY]() {\n      const query = {\n        ...state.queries[action.queryId],\n        // point query to migrated query editor\n        sqlEditorId: action.queryEditorId\n      };\n      const queries = { ...state.queries, [query.id]: query };\n      return { ...state, queries };\n    },\n    [actions.QUERY_EDITOR_SETDB]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            dbId: action.dbId\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_CATALOG]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            catalog: action.catalog\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_SCHEMA]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            schema: action.schema\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_TITLE]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            name: action.name\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_SQL]() {\n      const { unsavedQueryEditor } = state;\n      if (\n      (unsavedQueryEditor == null ? void 0 : unsavedQueryEditor.id) === action.queryEditor.id &&\n      unsavedQueryEditor.sql === action.sql)\n      {\n        return state;\n      }\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            sql: action.sql,\n            ...(action.queryId && { latestQueryId: action.queryId })\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_CURSOR_POSITION]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            cursorPosition: action.position\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_QUERY_LIMIT]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            queryLimit: action.queryLimit\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_TEMPLATE_PARAMS]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            templateParams: action.templateParams\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_SELECTED_TEXT]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            selectedText: action.sql\n          },\n          action.queryEditor.id,\n          true\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_SET_AUTORUN]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            autorun: action.autorun\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_PERSIST_HEIGHT]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            northPercent: action.northPercent,\n            southPercent: action.southPercent\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.QUERY_EDITOR_TOGGLE_LEFT_BAR]() {\n      return {\n        ...state,\n        ...alterUnsavedQueryEditorState(\n          state,\n          {\n            hideLeftBar: action.hideLeftBar\n          },\n          action.queryEditor.id\n        )\n      };\n    },\n    [actions.SET_DATABASES]() {\n      const databases = {};\n      action.databases.forEach((db) => {\n        databases[db.id] = {\n          ...db,\n          extra_json: JSON.parse(db.extra || '')\n        };\n      });\n      return { ...state, databases };\n    },\n    [actions.REFRESH_QUERIES]() {\n      let newQueries = { ...state.queries };\n      // Fetch the updates to the queries present in the store.\n      let change = false;\n      let { queriesLastUpdate } = state;\n      Object.entries(action.alteredQueries).forEach(([id, changedQuery]) => {\n        if (\n        !state.queries.hasOwnProperty(id) ||\n        state.queries[id].state !== QueryState.Stopped &&\n        state.queries[id].state !== QueryState.Failed)\n        {var _state$queries$id;\n          const changedOn = normalizeTimestamp(changedQuery.changed_on);\n          const timestamp = Date.parse(changedOn);\n          if (timestamp > queriesLastUpdate) {\n            queriesLastUpdate = timestamp;\n          }\n          const prevState = (_state$queries$id = state.queries[id]) == null ? void 0 : _state$queries$id.state;\n          const currentState = changedQuery.state;\n          newQueries[id] = {\n            ...state.queries[id],\n            ...changedQuery,\n            ...(changedQuery.startDttm && {\n              startDttm: Number(changedQuery.startDttm)\n            }),\n            ...(changedQuery.endDttm && {\n              endDttm: Number(changedQuery.endDttm)\n            }),\n            // race condition:\n            // because of async behavior, sql lab may still poll a couple of seconds\n            // when it started fetching or finished rendering results\n            state:\n            currentState === QueryState.Success &&\n            [\n            QueryState.Fetching,\n            QueryState.Success,\n            QueryState.Running].\n            includes(prevState) ?\n            prevState :\n            currentState\n          };\n          if (\n          shallowEqual(\n            _omit(newQueries[id], ['extra']),\n            _omit(state.queries[id], ['extra'])\n          ) &&\n          _isEqual(newQueries[id].extra, state.queries[id].extra))\n          {\n            newQueries[id] = state.queries[id];\n          } else {\n            change = true;\n          }\n        }\n      });\n      if (!change) {\n        newQueries = state.queries;\n      }\n      return { ...state, queries: newQueries, queriesLastUpdate };\n    },\n    [actions.CLEAR_INACTIVE_QUERIES]() {\n      const { queries } = state;\n      const cleanedQueries = Object.fromEntries(\n        Object.entries(queries).\n        filter(([, query]) => {\n          if (\n          ['running', 'pending'].includes(query.state) &&\n          Date.now() - query.startDttm > action.interval &&\n          query.progress === 0)\n          {\n            return false;\n          }\n          return true;\n        }).\n        map(([id, query]) => {var _query$results;return [\n          id,\n          {\n            ...query,\n            state:\n            query.resultsKey && (_query$results = query.results) != null && _query$results.status ?\n            query.results.status :\n            query.state\n          }];}\n        )\n      );\n      return { ...state, queries: cleanedQueries };\n    },\n    [actions.SET_USER_OFFLINE]() {\n      return { ...state, offline: action.offline };\n    },\n    [actions.CREATE_DATASOURCE_STARTED]() {\n      return { ...state, isDatasourceLoading: true, errorMessage: null };\n    },\n    [actions.CREATE_DATASOURCE_SUCCESS]() {\n      return {\n        ...state,\n        isDatasourceLoading: false,\n        errorMessage: null,\n        datasource: action.datasource\n      };\n    },\n    [actions.CREATE_DATASOURCE_FAILED]() {\n      return { ...state, isDatasourceLoading: false, errorMessage: action.err };\n    },\n    [actions.SET_EDITOR_TAB_LAST_UPDATE]() {\n      return { ...state, editorTabLastUpdatedAt: action.timestamp };\n    },\n    [actions.SET_LAST_UPDATED_ACTIVE_TAB]() {\n      return { ...state, lastUpdatedActiveTab: action.queryEditorId };\n    }\n  };\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}