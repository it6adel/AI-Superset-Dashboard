{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { SupersetClient } from '@superset-ui/core';\nimport rison from 'rison';\nexport const OBJECT_TYPES_VALUES = Object.freeze([\n'dashboard',\n'chart',\n'saved_query']\n);\nexport const OBJECT_TYPES = Object.freeze({\n  DASHBOARD: 'dashboard',\n  CHART: 'chart',\n  QUERY: 'saved_query'\n});\nconst OBJECT_TYPE_ID_MAP = {\n  saved_query: 1,\n  chart: 2,\n  dashboard: 3\n};\nconst map_object_type_to_id = (objectType) => {\n  if (!OBJECT_TYPES_VALUES.includes(objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  return OBJECT_TYPE_ID_MAP[objectType];\n};\nexport function fetchAllTags(\n// fetch all tags (excluding system tags)\ncallback, error) {\n  SupersetClient.get({\n    endpoint: `/api/v1/tag/?q=${rison.encode({\n      filters: [{ col: 'type', opr: 'custom_tag', value: true }]\n    })}`\n  }).\n  then(({ json }) => callback(json)).\n  catch((response) => error(response));\n}\nexport function fetchSingleTag(id, callback, error) {\n  SupersetClient.get({ endpoint: `/api/v1/tag/${id}` }).\n  then(({ json }) => callback(json.result)).\n  catch((response) => error(response));\n}\nexport function fetchTags({ objectType, objectId, includeTypes = false }, callback, error) {\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (!OBJECT_TYPES_VALUES.includes(objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  SupersetClient.get({\n    endpoint: `/api/v1/${objectType}/${objectId}`\n  }).\n  then(({ json }) => callback(json.result.tags.filter((tag) => tag.type === 1))).\n  catch((response) => error(response));\n}\nexport function deleteTaggedObjects({ objectType, objectId }, tag, callback, error) {\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  if (!OBJECT_TYPES_VALUES.includes(objectType)) {\n    const msg = `objectType ${objectType} is invalid`;\n    throw new Error(msg);\n  }\n  SupersetClient.delete({\n    endpoint: `/api/v1/tag/${map_object_type_to_id(objectType)}/${objectId}/${tag.name}`\n  }).\n  then(({ json }) => json ?\n  callback(JSON.stringify(json)) :\n  callback('Successfully Deleted Tagged Objects')).\n  catch((response) => {\n    const err_str = response.message;\n    return err_str ? error(err_str) : error('Error Deleting Tagged Objects');\n  });\n}\nexport function deleteTags(tags, callback, error) {\n  const tag_names = tags.map((tag) => tag.name);\n  SupersetClient.delete({\n    endpoint: `/api/v1/tag/?q=${rison.encode(tag_names)}`\n  }).\n  then(({ json }) => json.message ?\n  callback(json.message) :\n  callback('Successfully Deleted Tag')).\n  catch((response) => {\n    const err_str = response.message;\n    return err_str ? error(err_str) : error('Error Deleting Tag');\n  });\n}\nexport function addTag({ objectType, objectId, includeTypes = false }, tag, callback, error) {\n  if (objectType === undefined || objectId === undefined) {\n    throw new Error('Need to specify objectType and objectId');\n  }\n  const objectTypeId = map_object_type_to_id(objectType);\n  SupersetClient.post({\n    endpoint: `/api/v1/tag/${objectTypeId}/${objectId}/`,\n    body: JSON.stringify({\n      properties: {\n        tags: [tag]\n      }\n    }),\n    parseMethod: 'json',\n    headers: { 'Content-Type': 'application/json' }\n  }).\n  then(({ json }) => callback(JSON.stringify(json))).\n  catch((response) => error(response));\n}\nexport function fetchObjects({ tags = '', types }, callback, error) {\n  let url = `/api/v1/tag/get_objects/?tags=${tags}`;\n  if (types) {\n    url += `&types=${types}`;\n  }\n  SupersetClient.get({ endpoint: url }).\n  then(({ json }) => callback(json.result)).\n  catch((response) => error(response));\n}\nexport function fetchObjectsByTagIds({ tagIds = [], types }, callback, error) {\n  let url = `/api/v1/tag/get_objects/?tagIds=${tagIds}`;\n  if (types) {\n    url += `&types=${types}`;\n  }\n  SupersetClient.get({ endpoint: url }).\n  then(({ json }) => callback(json.result)).\n  catch((response) => error(response));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}