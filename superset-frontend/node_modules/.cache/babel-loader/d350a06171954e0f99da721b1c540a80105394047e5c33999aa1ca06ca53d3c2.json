{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// eslint-disable-next-line no-restricted-imports\nimport AntTable from 'antd/lib/table'; // TODO: Remove antd\nimport classNames from 'classnames';\nimport { useResizeDetector } from 'react-resize-detector';\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { VariableSizeGrid as Grid } from 'react-window';\nimport { useTheme, styled, safeHtmlSpan } from '@superset-ui/core';\nimport { TableSize, ETableAction } from './index';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst StyledCell = styled('div')(({ theme, height }) => `\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding-left: ${theme.gridUnit * 2}px;\n  padding-right: ${theme.gridUnit}px;\n  border-bottom: 1px solid ${theme.colors.grayscale.light3};\n  transition: background 0.3s;\n  line-height: ${height}px;\n  box-sizing: border-box;\n`);\nconst StyledTable = styled(AntTable)(({ theme }) => `\n    th.ant-table-cell {\n      font-weight: ${theme.typography.weights.bold};\n      color: ${theme.colors.grayscale.dark1};\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n\n    .ant-pagination-item-active {\n      border-color: ${theme.colors.primary.base};\n      }\n    }\n    .ant-table.ant-table-small {\n      font-size: ${theme.typography.sizes.s}px;\n    }\n`);\nconst SMALL = 39;\nconst MIDDLE = 47;\nconst VirtualTable = (props) => {var _columns$map;\n  const { columns, pagination, onChange, height, scroll, size, allowHTML = false } = props;\n  const [tableWidth, setTableWidth] = useState(0);\n  const onResize = useCallback((width) => {\n    setTableWidth(width);\n  }, []);\n  const { ref } = useResizeDetector({ onResize });\n  const theme = useTheme();\n  // If a column definition has no width, react-window will use this as the default column width\n  const DEFAULT_COL_WIDTH = (theme == null ? void 0 : theme.gridUnit) * 37 || 150;\n  const widthColumnCount = columns.filter(({ width }) => !width).length;\n  let staticColWidthTotal = 0;\n  columns == null ? void 0 : columns.forEach((column) => {\n    if (column.width) {\n      staticColWidthTotal += column.width;\n    }\n  });\n  let totalWidth = 0;\n  const defaultWidth = Math.max(Math.floor((tableWidth - staticColWidthTotal) / widthColumnCount), 50);\n  const mergedColumns = (_columns$map = columns == null ? void 0 : columns.map == null ? void 0 : columns.map((column) => {\n    const modifiedColumn = { ...column };\n    if (!column.width) {\n      modifiedColumn.width = defaultWidth;\n    }\n    totalWidth += modifiedColumn.width;\n    return modifiedColumn;\n  })) != null ? _columns$map : [];\n  /*\n   * There are cases where a user could set the width of each column and the total width is less than width of\n   * the table.  In this case we will stretch the last column to use the extra space\n   */\n  if (totalWidth < tableWidth) {\n    const lastColumn = mergedColumns[mergedColumns.length - 1];\n    lastColumn.width =\n    lastColumn.width + Math.floor(tableWidth - totalWidth);\n  }\n  const gridRef = useRef();\n  const [connectObject] = useState(() => {\n    const obj = {};\n    Object.defineProperty(obj, 'scrollLeft', {\n      get: () => {\n        if (gridRef.current) {var _gridRef$current, _gridRef$current$stat;\n          return (_gridRef$current = gridRef.current) == null ? void 0 : (_gridRef$current$stat = _gridRef$current.state) == null ? void 0 : _gridRef$current$stat.scrollLeft;\n        }\n        return null;\n      },\n      set: (scrollLeft) => {\n        if (gridRef.current) {\n          gridRef.current.scrollTo({ scrollLeft });\n        }\n      }\n    });\n    return obj;\n  });\n  const resetVirtualGrid = () => {var _gridRef$current2;\n    (_gridRef$current2 = gridRef.current) == null ? void 0 : _gridRef$current2.resetAfterIndices({\n      columnIndex: 0,\n      shouldForceUpdate: true\n    });\n  };\n  useEffect(() => resetVirtualGrid, [tableWidth, columns, size]);\n  /*\n   * antd Table has a runtime error when it tries to fire the onChange event triggered from a pageChange\n   * when the table body is overridden with the virtualized table.  This function capture the page change event\n   * from within the pagination controls and proxies the onChange event payload\n   */\n  const onPageChange = (page, size) => {var _gridRef$current3;\n    /**\n     * This resets vertical scroll position to 0 (top) when page changes\n     * We intentionally leave horizontal scroll where it was so user can focus on\n     * specific range of columns as they page through data\n     */\n    (_gridRef$current3 = gridRef.current) == null ? void 0 : _gridRef$current3.scrollTo == null ? void 0 : _gridRef$current3.scrollTo({ scrollTop: 0 });\n    onChange == null ? void 0 : onChange({\n      ...pagination,\n      current: page,\n      pageSize: size\n    }, {}, {}, {\n      action: ETableAction.Paginate,\n      currentDataSource: []\n    });\n  };\n  const renderVirtualList = (rawData, { ref, onScroll }) => {\n    // eslint-disable-next-line no-param-reassign\n    ref.current = connectObject;\n    const cellSize = size === TableSize.Middle ? MIDDLE : SMALL;\n    return _jsx(Grid, { ref: gridRef, className: \"virtual-grid\", columnCount: mergedColumns.length, columnWidth: (index) => {\n        const { width = DEFAULT_COL_WIDTH } = mergedColumns[index];\n        return width;\n      }, height: height || scroll.y, rowCount: rawData.length, rowHeight: () => cellSize, width: tableWidth, onScroll: ({ scrollLeft }) => {\n        onScroll({ scrollLeft });\n      }, children:\n      ({ columnIndex, rowIndex, style }) => {var _mergedColumns$column, _mergedColumns$column2;\n        const data = rawData == null ? void 0 : rawData[rowIndex];\n        // Set default content\n        let content = data == null ? void 0 : data[mergedColumns == null ? void 0 : (_mergedColumns$column = mergedColumns[columnIndex]) == null ? void 0 : _mergedColumns$column.dataIndex];\n        // Check if the column has a render function\n        const render = (_mergedColumns$column2 = mergedColumns[columnIndex]) == null ? void 0 : _mergedColumns$column2.render;\n        if (typeof render === 'function') {\n          // Use render function to generate formatted content using column's render function\n          content = render(content, data, rowIndex);\n        }\n        if (allowHTML && typeof content === 'string') {\n          content = safeHtmlSpan(content);\n        }\n        return _jsx(StyledCell, { className: classNames('virtual-table-cell', {\n            'virtual-table-cell-last': columnIndex === mergedColumns.length - 1\n          }), style: style, title: typeof content === 'string' ? content : undefined, theme: theme, height: cellSize, children:\n          content }\n        );\n      } }\n    );\n  };\n  const modifiedPagination = {\n    ...pagination,\n    onChange: onPageChange\n  };\n  return _jsx(\"div\", { ref: ref, children:\n    _jsx(StyledTable, { ...props, sticky: false, className: \"virtual-table\", columns: mergedColumns, components: {\n        body: renderVirtualList\n      }, pagination: pagination ? modifiedPagination : false }) }\n  );\n};\nexport default VirtualTable;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}