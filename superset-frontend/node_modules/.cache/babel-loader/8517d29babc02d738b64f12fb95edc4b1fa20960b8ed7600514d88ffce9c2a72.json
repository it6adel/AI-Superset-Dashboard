{"ast":null,"code":"import _isObject from \"lodash/isObject\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef } from 'react';\nimport { useDispatch } from 'react-redux';\n\nimport rison from 'rison';\nimport { SupersetClient, runningQueryStateList } from '@superset-ui/core';\nimport useInterval from 'src/SqlLab/utils/useInterval';\nimport { refreshQueries, clearInactiveQueries } from 'src/SqlLab/actions/sqlLab';\nexport const QUERY_UPDATE_FREQ = 2000;\nconst QUERY_UPDATE_BUFFER_MS = 5000;\nconst MAX_QUERY_AGE_TO_POLL = 21600000;\nconst QUERY_TIMEOUT_LIMIT = 10000;\n// returns true if the Query.state matches one of the specific values indicating the query is still processing on server\nexport const isQueryRunning = (q) => runningQueryStateList.includes(q == null ? void 0 : q.state);\n// returns true if at least one query is running and within the max age to poll timeframe\nexport const shouldCheckForQueries = (queryList) => {\n  let shouldCheck = false;\n  const now = Date.now();\n  if (_isObject(queryList)) {\n    shouldCheck = Object.values(queryList).some((q) => isQueryRunning(q) && now - (q == null ? void 0 : q.startDttm) < MAX_QUERY_AGE_TO_POLL);\n  }\n  return shouldCheck;\n};\nfunction QueryAutoRefresh({ queries, queriesLastUpdate }) {\n  // We do not want to spam requests in the case of slow connections and potentially receive responses out of order\n  // pendingRequest check ensures we only have one active http call to check for query statuses\n  const pendingRequestRef = useRef(false);\n  const cleanInactiveRequestRef = useRef(false);\n  const dispatch = useDispatch();\n  const checkForRefresh = () => {\n    const shouldRequestChecking = shouldCheckForQueries(queries);\n    if (!pendingRequestRef.current && shouldRequestChecking) {\n      const params = rison.encode({\n        last_updated_ms: queriesLastUpdate - QUERY_UPDATE_BUFFER_MS\n      });\n      const controller = new AbortController();\n      pendingRequestRef.current = true;\n      SupersetClient.get({\n        endpoint: `/api/v1/query/updated_since?q=${params}`,\n        timeout: QUERY_TIMEOUT_LIMIT,\n        parseMethod: 'json-bigint',\n        signal: controller.signal\n      }).\n      then(({ json }) => {\n        if (json) {var _jsonPayload$result;\n          const jsonPayload = json;\n          if (jsonPayload != null && (_jsonPayload$result = jsonPayload.result) != null && _jsonPayload$result.length) {var _jsonPayload$result$r, _jsonPayload$result2;\n            const queries = (_jsonPayload$result$r = jsonPayload == null ? void 0 : (_jsonPayload$result2 = jsonPayload.result) == null ? void 0 : _jsonPayload$result2.reduce((acc, current) => {\n              acc[current.id] = current;\n              return acc;\n            }, {})) != null ? _jsonPayload$result$r : {};\n            dispatch(refreshQueries(queries));\n          } else\n          {\n            dispatch(clearInactiveQueries(QUERY_UPDATE_FREQ));\n          }\n        }\n      }).\n      catch(() => {\n        controller.abort();\n      }).\n      finally(() => {\n        pendingRequestRef.current = false;\n      });\n    }\n    if (!cleanInactiveRequestRef.current && !shouldRequestChecking) {\n      dispatch(clearInactiveQueries(QUERY_UPDATE_FREQ));\n      cleanInactiveRequestRef.current = true;\n    }\n  };\n  // Solves issue where direct usage of setInterval in function components\n  // uses stale props / state from closure\n  // See comments in the useInterval.ts file for more information\n  useInterval(() => {\n    checkForRefresh();\n  }, QUERY_UPDATE_FREQ);\n  return null;\n}\nexport default QueryAutoRefresh;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}