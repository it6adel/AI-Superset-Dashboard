{"ast":null,"code":"import { extent } from 'd3-array';\nimport { CategoricalColorNamespace, getNumberFormatter, AxisType, getMetricLabel, tooltipHtml } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA, MINIMUM_BUBBLE_SIZE } from './constants';\nimport { defaultGrid } from '../defaults';\nimport { getLegendProps, getMinAndMaxFromBounds } from '../utils/series';\nimport { parseAxisBound } from '../utils/controls';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getPadding } from '../Timeseries/transformers';\nimport { convertInteger } from '../utils/convertInteger';\nimport { NULL_STRING } from '../constants';\nconst isIterable = (obj) => obj != null && typeof obj[Symbol.iterator] === 'function';\nfunction normalizeSymbolSize(nodes, maxBubbleValue) {\n  const [bubbleMinValue, bubbleMaxValue] = extent(nodes, (x) => {var _x$data;\n    const tmpValue = (_x$data = x.data) == null ? void 0 : _x$data[0];\n    const result = isIterable(tmpValue) ? tmpValue[2] : null;\n    if (typeof result === 'number') {\n      return result;\n    }\n    return null;\n  });\n  if (bubbleMinValue !== undefined && bubbleMaxValue !== undefined) {\n    const nodeSpread = bubbleMaxValue - bubbleMinValue;\n    nodes.forEach((node) => {var _node$data;\n      const tmpValue = (_node$data = node.data) == null ? void 0 : _node$data[0];\n      const calculated = isIterable(tmpValue) ? tmpValue[2] : null;\n      if (typeof calculated === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        node.symbolSize =\n        ((calculated - bubbleMinValue) / nodeSpread * (\n        maxBubbleValue * 2) || 0) + MINIMUM_BUBBLE_SIZE;\n      }\n    });\n  }\n}\nexport function formatTooltip(params, xAxisLabel, yAxisLabel, sizeLabel, xAxisFormatter, yAxisFormatter, tooltipSizeFormatter) {\n  const title = params.data[4] ?\n  `${params.data[4]} (${params.data[3]})` :\n  params.data[3];\n  return tooltipHtml([\n  [xAxisLabel, xAxisFormatter(params.data[0])],\n  [yAxisLabel, yAxisFormatter(params.data[1])],\n  [sizeLabel, tooltipSizeFormatter(params.data[2])]],\n  title);\n}\nexport default function transformProps(chartProps) {\n  const { height, width, hooks, queriesData, formData, inContextMenu, theme } = chartProps;\n  const { data = [] } = queriesData[0];\n  const { x, y, size, entity, maxBubbleSize, colorScheme, series: bubbleSeries, xAxisLabel: bubbleXAxisTitle, yAxisLabel: bubbleYAxisTitle, xAxisBounds, xAxisFormat, yAxisFormat, yAxisBounds, logXAxis, logYAxis, xAxisTitleMargin, yAxisTitleMargin, truncateXAxis, truncateYAxis, xAxisLabelRotation, yAxisLabelRotation, tooltipSizeFormat, opacity, showLegend, legendOrientation, legendMargin, legendType, sliceId } = { ...DEFAULT_FORM_DATA, ...formData };\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const legends = new Set();\n  const series = [];\n  const xAxisLabel = getMetricLabel(x);\n  const yAxisLabel = getMetricLabel(y);\n  const sizeLabel = getMetricLabel(size);\n  const refs = {};\n  data.forEach((datum) => {\n    const dataName = bubbleSeries ? datum[bubbleSeries] : datum[entity];\n    const name = dataName ? String(dataName) : NULL_STRING;\n    const bubbleSeriesValue = bubbleSeries ? datum[bubbleSeries] : null;\n    series.push({\n      name,\n      data: [\n      [\n      datum[xAxisLabel],\n      datum[yAxisLabel],\n      datum[sizeLabel],\n      datum[entity],\n      bubbleSeriesValue]],\n\n\n      type: 'scatter',\n      itemStyle: {\n        color: colorFn(name, sliceId),\n        opacity\n      }\n    });\n    legends.add(name);\n  });\n  normalizeSymbolSize(series, maxBubbleSize);\n  const xAxisFormatter = getNumberFormatter(xAxisFormat);\n  const yAxisFormatter = getNumberFormatter(yAxisFormat);\n  const tooltipSizeFormatter = getNumberFormatter(tooltipSizeFormat);\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  const [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  const padding = getPadding(showLegend, legendOrientation, true, false, legendMargin, true, 'Left', convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const xAxisType = logXAxis ? AxisType.Log : AxisType.Value;\n  const echartOptions = {\n    series,\n    xAxis: {\n      axisLabel: { formatter: xAxisFormatter },\n      splitLine: {\n        lineStyle: {\n          type: 'dashed'\n        }\n      },\n      nameRotate: xAxisLabelRotation,\n      scale: true,\n      name: bubbleXAxisTitle,\n      nameLocation: 'middle',\n      nameTextStyle: {\n        fontWeight: 'bolder'\n      },\n      nameGap: convertInteger(xAxisTitleMargin),\n      type: xAxisType,\n      ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax)\n    },\n    yAxis: {\n      axisLabel: { formatter: yAxisFormatter },\n      splitLine: {\n        lineStyle: {\n          type: 'dashed'\n        }\n      },\n      nameRotate: yAxisLabelRotation,\n      scale: truncateYAxis,\n      name: bubbleYAxisTitle,\n      nameLocation: 'middle',\n      nameTextStyle: {\n        fontWeight: 'bolder'\n      },\n      nameGap: convertInteger(yAxisTitleMargin),\n      min: yAxisMin,\n      max: yAxisMax,\n      type: logYAxis ? AxisType.Log : AxisType.Value\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: Array.from(legends)\n    },\n    tooltip: {\n      show: !inContextMenu,\n      ...getDefaultTooltip(refs),\n      formatter: (params) => formatTooltip(params, xAxisLabel, yAxisLabel, sizeLabel, xAxisFormatter, yAxisFormatter, tooltipSizeFormatter)\n    },\n    grid: { ...defaultGrid, ...padding }\n  };\n  const { onContextMenu, setDataMask = () => {} } = hooks;\n  return {\n    refs,\n    height,\n    width,\n    echartOptions,\n    onContextMenu,\n    setDataMask,\n    formData\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}