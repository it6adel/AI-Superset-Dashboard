{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { SupersetClient, t, getClientErrorObject } from '@superset-ui/core';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nconst FETCH_SLICES_PAGE_SIZE = 200;\nexport function getDatasourceParameter(datasourceId, datasourceType) {\n  return `${datasourceId}__${datasourceType}`;\n}\nexport const ADD_SLICES = 'ADD_SLICES';\nfunction addSlices(slices) {\n  return { type: ADD_SLICES, payload: { slices } };\n}\nexport const SET_SLICES = 'SET_SLICES';\nfunction setSlices(slices) {\n  return { type: SET_SLICES, payload: { slices } };\n}\nexport const FETCH_ALL_SLICES_STARTED = 'FETCH_ALL_SLICES_STARTED';\nfunction fetchAllSlicesStarted() {\n  return { type: FETCH_ALL_SLICES_STARTED };\n}\nexport const FETCH_ALL_SLICES_FAILED = 'FETCH_ALL_SLICES_FAILED';\nfunction fetchAllSlicesFailed(error) {\n  return { type: FETCH_ALL_SLICES_FAILED, payload: { error } };\n}\nconst parseResult = (result) => result.reduce((slices, slice) => {\n  let form_data = JSON.parse(slice.params);\n  form_data = {\n    ...form_data,\n    // force using datasource stored in relational table prop\n    datasource: getDatasourceParameter(slice.datasource_id, slice.datasource_type) ||\n    form_data.datasource\n  };\n  return {\n    ...slices,\n    [slice.id]: {\n      slice_id: slice.id,\n      slice_url: slice.url,\n      slice_name: slice.slice_name,\n      form_data,\n      datasource_name: slice.datasource_name_text,\n      datasource_url: slice.datasource_url,\n      datasource_id: slice.datasource_id,\n      datasource_type: slice.datasource_type,\n      changed_on: new Date(slice.changed_on_utc).getTime(),\n      description: slice.description,\n      description_markdown: slice.description_markeddown,\n      viz_type: slice.viz_type,\n      modified: slice.changed_on_delta_humanized,\n      changed_on_humanized: slice.changed_on_delta_humanized,\n      thumbnail_url: slice.thumbnail_url,\n      owners: slice.owners,\n      created_by: slice.created_by\n    }\n  };\n}, {});\nexport function updateSlices(slices) {\n  return (dispatch) => {\n    dispatch(setSlices(slices));\n  };\n}\nexport function fetchSlices(userId, filter_value, sortColumn = 'changed_on') {\n  return (dispatch) => {\n    dispatch(fetchAllSlicesStarted());\n    const filters = filter_value ?\n    [{ col: 'slice_name', opr: 'chart_all_text', value: filter_value }] :\n    [];\n    if (userId) {\n      filters.push({ col: 'owners', opr: 'rel_m_m', value: userId });\n    }\n    return SupersetClient.get({\n      endpoint: `/api/v1/chart/?q=${rison.encode({\n        columns: [\n        'changed_on_delta_humanized',\n        'changed_on_utc',\n        'datasource_id',\n        'datasource_type',\n        'datasource_url',\n        'datasource_name_text',\n        'description_markeddown',\n        'description',\n        'id',\n        'params',\n        'slice_name',\n        'thumbnail_url',\n        'url',\n        'viz_type',\n        'owners.id',\n        'created_by.id'],\n\n        filters,\n        page_size: FETCH_SLICES_PAGE_SIZE,\n        order_column: sortColumn === 'changed_on' ?\n        'changed_on_delta_humanized' :\n        sortColumn,\n        order_direction: sortColumn === 'changed_on' ? 'desc' : 'asc'\n      })}`\n    }).\n    then(({ json }) => {\n      const { result } = json;\n      const slices = parseResult(result);\n      return dispatch(addSlices(slices));\n    }).\n    catch((errorResponse) => getClientErrorObject(errorResponse).then(({ error }) => {\n      dispatch(fetchAllSlicesFailed(error || t('Could not fetch all saved charts')));\n      dispatch(addDangerToast(t('Sorry there was an error fetching saved charts: ') + error));\n    }));\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}