{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { PureComponent } from 'react';\nimport rison from 'rison';\nimport PropTypes from 'prop-types';\nimport { CompactPicker } from 'react-color';\nimport Button from 'src/components/Button';\nimport {\n  t,\n  SupersetClient,\n  getCategoricalSchemeRegistry,\n  getChartMetadataRegistry,\n  validateNonEmpty,\n  isValidExpression,\n  styled,\n  getColumnLabel,\n  withTheme } from\n'@superset-ui/core';\nimport SelectControl from 'src/explore/components/controls/SelectControl';\nimport { AsyncSelect } from 'src/components';\nimport TextControl from 'src/explore/components/controls/TextControl';\nimport CheckboxControl from 'src/explore/components/controls/CheckboxControl';\nimport PopoverSection from 'src/components/PopoverSection';\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { EmptyState } from 'src/components/EmptyState';\nimport {\n  ANNOTATION_SOURCE_TYPES,\n  ANNOTATION_TYPES,\n  ANNOTATION_TYPES_METADATA,\n  DEFAULT_ANNOTATION_TYPE,\n  requiresQuery,\n  ANNOTATION_SOURCE_TYPES_METADATA } from\n'./AnnotationTypes';import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"@emotion/react/jsx-runtime\";\n\nconst AUTOMATIC_COLOR = '';\n\nconst propTypes = {\n  name: PropTypes.string,\n  annotationType: PropTypes.string,\n  sourceType: PropTypes.string,\n  color: PropTypes.string,\n  opacity: PropTypes.string,\n  style: PropTypes.string,\n  width: PropTypes.number,\n  showMarkers: PropTypes.bool,\n  hideLine: PropTypes.bool,\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  overrides: PropTypes.object,\n  show: PropTypes.bool,\n  showLabel: PropTypes.bool,\n  titleColumn: PropTypes.string,\n  descriptionColumns: PropTypes.arrayOf(PropTypes.string),\n  timeColumn: PropTypes.string,\n  intervalEndColumn: PropTypes.string,\n  vizType: PropTypes.string,\n\n  error: PropTypes.string,\n  colorScheme: PropTypes.string,\n\n  addAnnotationLayer: PropTypes.func,\n  removeAnnotationLayer: PropTypes.func,\n  close: PropTypes.func\n};\n\nconst defaultProps = {\n  name: '',\n  annotationType: DEFAULT_ANNOTATION_TYPE,\n  sourceType: '',\n  color: AUTOMATIC_COLOR,\n  opacity: '',\n  style: 'solid',\n  width: 1,\n  showMarkers: false,\n  hideLine: false,\n  overrides: {},\n  colorScheme: 'd3Category10',\n  show: true,\n  showLabel: false,\n  titleColumn: '',\n  descriptionColumns: [],\n  timeColumn: '',\n  intervalEndColumn: '',\n\n  addAnnotationLayer: () => {},\n  removeAnnotationLayer: () => {},\n  close: () => {}\n};\n\nconst NotFoundContentWrapper = styled.div`\n  && > div:first-child {\n    padding-left: 0;\n    padding-right: 0;\n  }\n`;\n\nconst NotFoundContent = () =>\n_jsx(NotFoundContentWrapper, { children:\n  _jsx(EmptyState, {\n    title: t('No annotation layers'),\n    size: \"small\",\n    description:\n    _jsxs(\"span\", { children: [\n      t('Add an annotation layer'), ' ',\n      _jsx(\"a\", {\n        href: \"/annotationlayer/list\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\", children:\n\n        t('here') }\n      ), \".\"] }\n\n    ),\n\n    image: \"empty.svg\" }\n  ) }\n);\n\n\nclass AnnotationLayer extends PureComponent {\n  constructor(props) {\n    super(props);this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    fetchNativeAnnotations = async (search, page, pageSize) => {\n      const queryParams = rison.encode({\n        filters: [\n        {\n          col: 'name',\n          opr: 'ct',\n          value: search\n        }],\n\n        columns: ['id', 'name'],\n        page,\n        page_size: pageSize\n      });\n\n      const { json } = await SupersetClient.get({\n        endpoint: `/api/v1/annotation_layer/?q=${queryParams}`\n      });\n\n      const { result, count } = json;\n\n      const layersArray = result.map((layer) => ({\n        value: layer.id,\n        label: layer.name\n      }));\n\n      return {\n        data: layersArray,\n        totalCount: count\n      };\n    };this.\n\n    fetchCharts = async (search, page, pageSize) => {\n      const { annotationType } = this.state;\n\n      const queryParams = rison.encode({\n        filters: [\n        { col: 'slice_name', opr: 'chart_all_text', value: search },\n        {\n          col: 'id',\n          opr: 'chart_owned_created_favored_by_me',\n          value: true\n        }],\n\n        columns: ['id', 'slice_name', 'viz_type'],\n        order_column: 'slice_name',\n        order_direction: 'asc',\n        page,\n        page_size: pageSize\n      });\n      const { json } = await SupersetClient.get({\n        endpoint: `/api/v1/chart/?q=${queryParams}`\n      });\n\n      const { result, count } = json;\n      const registry = getChartMetadataRegistry();\n\n      const chartsArray = result.\n      filter((chart) => {\n        const metadata = registry.get(chart.viz_type);\n        return metadata && metadata.canBeAnnotationType(annotationType);\n      }).\n      map((chart) => ({\n        value: chart.id,\n        label: chart.slice_name,\n        viz_type: chart.viz_type\n      }));\n\n      return {\n        data: chartsArray,\n        totalCount: count\n      };\n    };this.\n\n    fetchOptions = (search, page, pageSize) => {\n      const { sourceType } = this.state;\n\n      if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n        return this.fetchNativeAnnotations(search, page, pageSize);\n      }\n      return this.fetchCharts(search, page, pageSize);\n    };this.\n\n    fetchSliceData = (id) => {\n      const queryParams = rison.encode({\n        columns: ['query_context']\n      });\n      SupersetClient.get({\n        endpoint: `/api/v1/chart/${id}?q=${queryParams}`\n      }).then(({ json }) => {var _formData$groupby;\n        const { result } = json;\n        const queryContext = result.query_context;\n        const formData = JSON.parse(queryContext).form_data;\n        const dataObject = {\n          data: {\n            ...formData,\n            groupby: (_formData$groupby = formData.groupby) == null ? void 0 : _formData$groupby.map((column) => getColumnLabel(column))\n          }\n        };\n        this.setState({\n          slice: dataObject\n        });\n      });\n    };const { name, annotationType: _annotationType, sourceType: _sourceType, color, opacity, style, width, showMarkers, hideLine, value, overrides, show, showLabel, titleColumn, descriptionColumns, timeColumn, intervalEndColumn, vizType } = props; // Only allow override whole time_range\n    if ('since' in overrides || 'until' in overrides) {overrides.time_range = null;delete overrides.since;delete overrides.until;} // Check if annotationType is supported by this chart\n    const _metadata = getChartMetadataRegistry().get(vizType);const supportedAnnotationTypes = (_metadata == null ? void 0 : _metadata.supportedAnnotationTypes) || [];const validAnnotationType = supportedAnnotationTypes.includes(_annotationType) ? _annotationType : supportedAnnotationTypes[0];this.state = { // base\n      name, annotationType: validAnnotationType, sourceType: _sourceType, value, overrides, show, showLabel, // slice\n      titleColumn, descriptionColumns, timeColumn, intervalEndColumn, // display\n      color: color || AUTOMATIC_COLOR, opacity, style, width, showMarkers, hideLine, // refData\n      isNew: !name, slice: null };this.submitAnnotation = this.submitAnnotation.bind(this);this.deleteAnnotation = this.deleteAnnotation.bind(this);this.applyAnnotation = this.applyAnnotation.bind(this);this.isValidForm = this.isValidForm.bind(this); // Handlers\n    this.handleAnnotationType = this.handleAnnotationType.bind(this);this.handleAnnotationSourceType = this.handleAnnotationSourceType.bind(this);this.handleSelectValue = this.handleSelectValue.bind(this);this.handleTextValue = this.handleTextValue.bind(this); // Fetch related functions\n    this.fetchOptions = this.fetchOptions.bind(this);this.fetchCharts = this.fetchCharts.bind(this);this.fetchNativeAnnotations = this.fetchNativeAnnotations.bind(this);this.fetchAppliedAnnotation = this.fetchAppliedAnnotation.bind(this);this.fetchSliceData = this.fetchSliceData.bind(this);this.shouldFetchSliceData = this.shouldFetchSliceData.bind(this);this.fetchAppliedChart = this.fetchAppliedChart.bind(this);this.fetchAppliedNativeAnnotation = this.fetchAppliedNativeAnnotation.bind(this);this.shouldFetchAppliedAnnotation = this.shouldFetchAppliedAnnotation.bind(this);}componentDidMount() {if (this.shouldFetchAppliedAnnotation()) {const { value } = this.state; /* The value prop is the id of the chart/native. This function will set\n      value in state to an object with the id as value.value to be used by\n      AsyncSelect */this.fetchAppliedAnnotation(value);}}componentDidUpdate(prevProps, prevState) {if (this.shouldFetchSliceData(prevState)) {const { value } = this.state;this.fetchSliceData(value.value);}}getSupportedSourceTypes(annotationType) {var _ANNOTATION_TYPES_MET; // Get vis types that can be source.\n    const sources = getChartMetadataRegistry().entries().filter(({ value: chartMetadata }) => chartMetadata.canBeAnnotationType(annotationType)).map(({ key, value: chartMetadata }) => ({ value: key, label: chartMetadata.name })); // Prepend native source if applicable\n    if ((_ANNOTATION_TYPES_MET = ANNOTATION_TYPES_METADATA[annotationType]) != null && _ANNOTATION_TYPES_MET.supportNativeSource) {sources.unshift(ANNOTATION_SOURCE_TYPES_METADATA.NATIVE);}return sources;}shouldFetchAppliedAnnotation() {const { value, sourceType } = this.state;return value && requiresQuery(sourceType);}shouldFetchSliceData(prevState) {const { value, sourceType } = this.state;const isChart = sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE && requiresQuery(sourceType);const valueIsNew = value && prevState.value !== value;return valueIsNew && isChart;}isValidFormulaAnnotation(expression, annotationType) {if (annotationType === ANNOTATION_TYPES.FORMULA) {return isValidExpression(expression);}return true;}isValidForm() {const { name, annotationType, sourceType, value, timeColumn, intervalEndColumn } = this.state;const errors = [validateNonEmpty(name), validateNonEmpty(annotationType), validateNonEmpty(value)];if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE) {if (annotationType === ANNOTATION_TYPES.EVENT) {errors.push(validateNonEmpty(timeColumn));}if (annotationType === ANNOTATION_TYPES.INTERVAL) {errors.push(validateNonEmpty(timeColumn));errors.push(validateNonEmpty(intervalEndColumn));}}errors.push(!this.isValidFormulaAnnotation(value, annotationType));return !errors.filter((x) => x).length;}handleAnnotationType(annotationType) {this.setState({ annotationType, sourceType: null, value: null, slice: null });}handleAnnotationSourceType(sourceType) {const { sourceType: prevSourceType } = this.state;if (prevSourceType !== sourceType) {this.setState({ sourceType, value: null, slice: null });}}handleSelectValue(selectedValueObject) {this.setState({ value: selectedValueObject, descriptionColumns: [], intervalEndColumn: null, timeColumn: null, titleColumn: null, overrides: { time_range: null } });}handleTextValue(inputValue) {this.setState({ value: inputValue });}fetchAppliedChart(id) {const { annotationType } = this.state;const registry = getChartMetadataRegistry();const queryParams = rison.encode({ columns: ['slice_name', 'query_context', 'viz_type'] });SupersetClient.get({ endpoint: `/api/v1/chart/${id}?q=${queryParams}` }).then(({ json }) => {const { result } = json;const sliceName = result.slice_name;\n        const queryContext = result.query_context;\n        const vizType = result.viz_type;\n        const formData = JSON.parse(queryContext).form_data;\n        const metadata = registry.get(vizType);\n        const canBeAnnotationType =\n        metadata && metadata.canBeAnnotationType(annotationType);\n        if (canBeAnnotationType) {var _formData$groupby2;\n          this.setState({\n            value: {\n              value: id,\n              label: sliceName\n            },\n            slice: {\n              data: {\n                ...formData,\n                groupby: (_formData$groupby2 = formData.groupby) == null ? void 0 : _formData$groupby2.map((column) => getColumnLabel(column))\n              }\n            }\n          });\n        }\n      });\n  }\n\n  fetchAppliedNativeAnnotation(id) {\n    SupersetClient.get({\n      endpoint: `/api/v1/annotation_layer/${id}`\n    }).then(({ json }) => {\n      const { result } = json;\n      const layer = result;\n      this.setState({\n        value: {\n          value: layer.id,\n          label: layer.name\n        }\n      });\n    });\n  }\n\n  fetchAppliedAnnotation(id) {\n    const { sourceType } = this.state;\n\n    if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n      return this.fetchAppliedNativeAnnotation(id);\n    }\n    return this.fetchAppliedChart(id);\n  }\n\n  deleteAnnotation() {\n    this.props.removeAnnotationLayer();\n    this.props.close();\n  }\n\n  applyAnnotation() {\n    const { value, sourceType } = this.state;\n    if (this.isValidForm()) {\n      const annotationFields = [\n      'name',\n      'annotationType',\n      'sourceType',\n      'color',\n      'opacity',\n      'style',\n      'width',\n      'showMarkers',\n      'hideLine',\n      'overrides',\n      'show',\n      'showLabel',\n      'titleColumn',\n      'descriptionColumns',\n      'timeColumn',\n      'intervalEndColumn'];\n\n      const newAnnotation = {};\n      annotationFields.forEach((field) => {\n        if (this.state[field] !== null) {\n          newAnnotation[field] = this.state[field];\n        }\n      });\n\n      // Prepare newAnnotation.value for use in runAnnotationQuery()\n      const applicableValue = requiresQuery(sourceType) ? value.value : value;\n      newAnnotation.value = applicableValue;\n\n      if (newAnnotation.color === AUTOMATIC_COLOR) {\n        newAnnotation.color = null;\n      }\n\n      this.props.addAnnotationLayer(newAnnotation);\n      this.setState({ isNew: false });\n    }\n  }\n\n  submitAnnotation() {\n    this.applyAnnotation();\n    this.props.close();\n  }\n\n  renderChartHeader(label, description, value) {\n    return (\n      _jsx(ControlHeader, {\n        hovered: true,\n        label: label,\n        description: description,\n        validationErrors: !value ? ['Mandatory'] : [] }\n      ));\n\n  }\n\n  renderValueConfiguration() {\n    const { annotationType, sourceType, value } = this.state;\n    let label = '';\n    let description = '';\n    if (requiresQuery(sourceType)) {\n      if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n        label = t('Annotation layer');\n        description = t('Select the Annotation Layer you would like to use.');\n      } else {\n        label = t('Chart');\n        description = t(\n          `Use another existing chart as a source for annotations and overlays.\n          Your chart must be one of these visualization types: [%s]`,\n          this.getSupportedSourceTypes(annotationType).\n          map((x) => x.label).\n          join(', ')\n        );\n      }\n    } else if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      label = t('Formula');\n      description = t(`Expects a formula with depending time parameter 'x'\n        in milliseconds since epoch. mathjs is used to evaluate the formulas.\n        Example: '2x+5'`);\n    }\n    if (requiresQuery(sourceType)) {\n      return (\n        _jsx(AsyncSelect\n        /* key to force re-render on sourceType change */, {\n\n          ariaLabel: t('Annotation layer value'),\n          name: \"annotation-layer-value\",\n          header: this.renderChartHeader(label, description, value),\n          options: this.fetchOptions,\n          value: value || null,\n          onChange: this.handleSelectValue,\n          notFoundContent: _jsx(NotFoundContent, {}) }, sourceType\n        ));\n\n    }\n    if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      return (\n        _jsx(TextControl, {\n          name: \"annotation-layer-value\",\n          hovered: true,\n          showHeader: true,\n          description: description,\n          label: label,\n          placeholder: \"\",\n          value: value,\n          onChange: this.handleTextValue,\n          validationErrors:\n          !this.isValidFormulaAnnotation(value, annotationType) ?\n          [t('Bad formula.')] :\n          [] }\n\n        ));\n\n    }\n    return '';\n  }\n\n  renderSliceConfiguration() {\n    const {\n      annotationType,\n      sourceType,\n      value,\n      slice,\n      overrides,\n      titleColumn,\n      timeColumn,\n      intervalEndColumn,\n      descriptionColumns\n    } = this.state;\n\n    if (!slice || !value) {\n      return '';\n    }\n\n    if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE && slice) {\n      const columns = (slice.data.groupby || []).\n      concat(slice.data.all_columns || []).\n      map((x) => ({ value: x, label: x }));\n      const timeColumnOptions = slice.data.include_time ?\n      [{ value: '__timestamp', label: '__timestamp' }].concat(columns) :\n      columns;\n      return (\n        _jsx(\"div\", { style: { marginRight: '2rem' }, children:\n          _jsxs(PopoverSection, {\n            isSelected: true,\n            title: t('Annotation Slice Configuration'),\n            info: t(`This section allows you to configure how to use the slice\n              to generate annotations.`), children: [\n\n            (annotationType === ANNOTATION_TYPES.EVENT ||\n            annotationType === ANNOTATION_TYPES.INTERVAL) &&\n            _jsx(SelectControl, {\n              ariaLabel: t('Annotation layer time column'),\n              hovered: true,\n              name: \"annotation-layer-time-column\",\n              label:\n              annotationType === ANNOTATION_TYPES.INTERVAL ?\n              t('Interval start column') :\n              t('Event time column'),\n\n              description: t(\n                'This column must contain date/time information.'\n              ),\n              validationErrors: !timeColumn ? ['Mandatory'] : [],\n              clearable: false,\n              options: timeColumnOptions,\n              value: timeColumn,\n              onChange: (v) => this.setState({ timeColumn: v }) }\n            ),\n\n            annotationType === ANNOTATION_TYPES.INTERVAL &&\n            _jsx(SelectControl, {\n              ariaLabel: t('Annotation layer interval end'),\n              hovered: true,\n              name: \"annotation-layer-intervalEnd\",\n              label: t('Interval End column'),\n              description: t(\n                'This column must contain date/time information.'\n              ),\n              validationErrors: !intervalEndColumn ? ['Mandatory'] : [],\n              options: columns,\n              value: intervalEndColumn,\n              onChange: (value) => this.setState({ intervalEndColumn: value }) }\n            ),\n\n            _jsx(SelectControl, {\n              ariaLabel: t('Annotation layer title column'),\n              hovered: true,\n              name: \"annotation-layer-title\",\n              label: t('Title Column'),\n              description: t('Pick a title for you annotation.'),\n              options: [{ value: '', label: t('None') }].concat(columns),\n              value: titleColumn,\n              onChange: (value) => this.setState({ titleColumn: value }) }\n            ),\n            annotationType !== ANNOTATION_TYPES.TIME_SERIES &&\n            _jsx(SelectControl, {\n              ariaLabel: t('Annotation layer description columns'),\n              hovered: true,\n              name: \"annotation-layer-title\",\n              label: t('Description Columns'),\n              description: t(\n                \"Pick one or more columns that should be shown in the annotation. If you don't select a column all of them will be shown.\"\n              ),\n              multi: true,\n              options: columns,\n              value: descriptionColumns,\n              onChange: (value) => this.setState({ descriptionColumns: value }) }\n            ),\n\n            _jsxs(\"div\", { style: { marginTop: '1rem' }, children: [\n              _jsx(CheckboxControl, {\n                hovered: true,\n                name: \"annotation-override-time_range\",\n                label: t('Override time range'),\n                description: t(`This controls whether the \"time_range\" field from the current\n                  view should be passed down to the chart containing the annotation data.`),\n                value: 'time_range' in overrides,\n                onChange: (v) => {\n                  delete overrides.time_range;\n                  if (v) {\n                    this.setState({\n                      overrides: { ...overrides, time_range: null }\n                    });\n                  } else {\n                    this.setState({ overrides: { ...overrides } });\n                  }\n                } }\n              ),\n              _jsx(CheckboxControl, {\n                hovered: true,\n                name: \"annotation-override-timegrain\",\n                label: t('Override time grain'),\n                description: t(`This controls whether the time grain field from the current\n                  view should be passed down to the chart containing the annotation data.`),\n                value: 'time_grain_sqla' in overrides,\n                onChange: (v) => {\n                  delete overrides.time_grain_sqla;\n                  delete overrides.granularity;\n                  if (v) {\n                    this.setState({\n                      overrides: {\n                        ...overrides,\n                        time_grain_sqla: null,\n                        granularity: null\n                      }\n                    });\n                  } else {\n                    this.setState({ overrides: { ...overrides } });\n                  }\n                } }\n              ),\n              _jsx(TextControl, {\n                hovered: true,\n                name: \"annotation-layer-timeshift\",\n                label: t('Time Shift'),\n                description: t(`Time delta in natural language\n                  (example:  24 hours, 7 days, 56 weeks, 365 days)`),\n                placeholder: \"\",\n                value: overrides.time_shift,\n                onChange: (v) =>\n                this.setState({ overrides: { ...overrides, time_shift: v } }) }\n\n              )] }\n            )] }\n          ) }\n        ));\n\n    }\n    return '';\n  }\n\n  renderDisplayConfiguration() {\n    const {\n      color,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      annotationType\n    } = this.state;\n    const colorScheme = getCategoricalSchemeRegistry().\n    get(this.props.colorScheme).\n    colors.concat();\n    if (\n    color &&\n    color !== AUTOMATIC_COLOR &&\n    !colorScheme.find((x) => x.toLowerCase() === color.toLowerCase()))\n    {\n      colorScheme.push(color);\n    }\n    return (\n      _jsxs(PopoverSection, {\n        isSelected: true,\n        title: t('Display configuration'),\n        info: t('Configure your how you overlay is displayed here.'), children: [\n\n        _jsx(SelectControl, {\n          ariaLabel: t('Annotation layer stroke'),\n          name: \"annotation-layer-stroke\",\n          label: t('Style')\n          // see '../../../visualizations/nvd3_vis.css'\n          , options: [\n          { value: 'solid', label: t('Solid') },\n          { value: 'dashed', label: t('Dashed') },\n          { value: 'longDashed', label: t('Long dashed') },\n          { value: 'dotted', label: t('Dotted') }],\n\n          value: style,\n          clearable: false,\n          onChange: (v) => this.setState({ style: v }) }\n        ),\n        _jsx(SelectControl, {\n          ariaLabel: t('Annotation layer opacity'),\n          name: \"annotation-layer-opacity\",\n          label: t('Opacity')\n          // see '../../../visualizations/nvd3_vis.css'\n          , options: [\n          { value: '', label: t('Solid') },\n          { value: 'opacityLow', label: '0.2' },\n          { value: 'opacityMedium', label: '0.5' },\n          { value: 'opacityHigh', label: '0.8' }],\n\n          value: opacity,\n          onChange: (value) => this.setState({ opacity: value }) }\n        ),\n        _jsxs(\"div\", { children: [\n          _jsx(ControlHeader, { label: t('Color') }),\n          _jsxs(\"div\", { style: { display: 'flex', flexDirection: 'column' }, children: [\n            _jsx(CompactPicker, {\n              color: color,\n              colors: colorScheme,\n              onChangeComplete: (v) => this.setState({ color: v.hex }) }\n            ),\n            _jsx(Button, {\n              style: { marginTop: '0.5rem', marginBottom: '0.5rem' },\n              buttonStyle: color === AUTOMATIC_COLOR ? 'success' : 'default',\n              buttonSize: \"xsmall\",\n              onClick: () => this.setState({ color: AUTOMATIC_COLOR }), children:\n\n              t('Automatic Color') }\n            )] }\n          )] }\n        ),\n        _jsx(TextControl, {\n          name: \"annotation-layer-stroke-width\",\n          label: t('Line width'),\n          isInt: true,\n          value: width,\n          onChange: (v) => this.setState({ width: v }) }\n        ),\n        annotationType === ANNOTATION_TYPES.TIME_SERIES &&\n        _jsx(CheckboxControl, {\n          hovered: true,\n          name: \"annotation-layer-show-markers\",\n          label: t('Show Markers'),\n          description: t('Shows or hides markers for the time series'),\n          value: showMarkers,\n          onChange: (v) => this.setState({ showMarkers: v }) }\n        ),\n\n        annotationType === ANNOTATION_TYPES.TIME_SERIES &&\n        _jsx(CheckboxControl, {\n          hovered: true,\n          name: \"annotation-layer-hide-line\",\n          label: t('Hide Line'),\n          description: t('Hides the Line for the time series'),\n          value: hideLine,\n          onChange: (v) => this.setState({ hideLine: v }) }\n        )] }\n\n      ));\n\n  }\n\n  render() {\n    const { isNew, name, annotationType, sourceType, show, showLabel } =\n    this.state;\n    const isValid = this.isValidForm();\n    const metadata = getChartMetadataRegistry().get(this.props.vizType);\n    const supportedAnnotationTypes = metadata ?\n    metadata.supportedAnnotationTypes.map(\n      (type) => ANNOTATION_TYPES_METADATA[type]\n    ) :\n    [];\n    const supportedSourceTypes = this.getSupportedSourceTypes(annotationType);\n\n    return (\n      _jsxs(_Fragment, { children: [\n        this.props.error &&\n        _jsxs(\"span\", { style: { color: this.props.theme.colors.error.base }, children: [\"ERROR: \",\n          this.props.error] }\n        ),\n\n        _jsxs(\"div\", { style: { display: 'flex', flexDirection: 'row' }, children: [\n          _jsx(\"div\", { style: { marginRight: '2rem' }, children:\n            _jsxs(PopoverSection, {\n              isSelected: true,\n              title: t('Layer configuration'),\n              info: t('Configure the basics of your Annotation Layer.'), children: [\n\n              _jsx(TextControl, {\n                name: \"annotation-layer-name\",\n                label: t('Name'),\n                placeholder: \"\",\n                value: name,\n                onChange: (v) => this.setState({ name: v }),\n                validationErrors: !name ? [t('Mandatory')] : [] }\n              ),\n              _jsx(CheckboxControl, {\n                name: \"annotation-layer-hide\",\n                label: t('Hide layer'),\n                value: !show,\n                onChange: (v) => this.setState({ show: !v }) }\n              ),\n              _jsx(CheckboxControl, {\n                name: \"annotation-label-show\",\n                label: t('Show label'),\n                value: showLabel,\n                hovered: true,\n                description: t('Whether to always show the annotation label'),\n                onChange: (v) => this.setState({ showLabel: v }) }\n              ),\n              _jsx(SelectControl, {\n                ariaLabel: t('Annotation layer type'),\n                hovered: true,\n                description: t('Choose the annotation layer type'),\n                label: t('Annotation layer type'),\n                name: \"annotation-layer-type\",\n                clearable: false,\n                options: supportedAnnotationTypes,\n                value: annotationType,\n                onChange: this.handleAnnotationType }\n              ),\n              supportedSourceTypes.length > 0 &&\n              _jsx(SelectControl, {\n                ariaLabel: t('Annotation source type'),\n                hovered: true,\n                description: t('Choose the source of your annotations'),\n                label: t('Annotation source'),\n                name: \"annotation-source-type\",\n                options: supportedSourceTypes,\n                notFoundContent: _jsx(NotFoundContent, {}),\n                value: sourceType,\n                onChange: this.handleAnnotationSourceType,\n                validationErrors: !sourceType ? [t('Mandatory')] : [] }\n              ),\n\n              this.renderValueConfiguration()] }\n            ) }\n          ),\n          this.renderSliceConfiguration(),\n          this.renderDisplayConfiguration()] }\n        ),\n        _jsxs(\"div\", { style: { display: 'flex', justifyContent: 'space-between' }, children: [\n          isNew ?\n          _jsx(Button, { buttonSize: \"small\", onClick: () => this.props.close(), children:\n            t('Cancel') }\n          ) :\n\n          _jsx(Button, { buttonSize: \"small\", onClick: this.deleteAnnotation, children:\n            t('Remove') }\n          ),\n\n          _jsxs(\"div\", { children: [\n            _jsx(Button, {\n              buttonSize: \"small\",\n              disabled: !isValid,\n              onClick: this.applyAnnotation, children:\n\n              t('Apply') }\n            ),\n\n            _jsx(Button, {\n              buttonSize: \"small\",\n              buttonStyle: \"primary\",\n              disabled: !isValid,\n              onClick: this.submitAnnotation, children:\n\n              t('OK') }\n            )] }\n          )] }\n        )] }\n      ));\n\n  }\n}\n\nAnnotationLayer.propTypes = propTypes;\nAnnotationLayer.defaultProps = defaultProps;\n\nexport default withTheme(AnnotationLayer);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}