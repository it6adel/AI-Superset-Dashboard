{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nconst modulePromises = {};\nconst withNamespace = (name) => `__superset__/${name}`;\n/**\n * Dependency management using global variables, because for the life of me\n * I can't figure out how to hook into UMD from a dynamically imported package.\n *\n * This defines a dynamically imported js module that can be used to import from\n * multiple different plugins.\n *\n * When importing a common module (such as react or lodash or superset-ui)\n * from a plugin, the plugin's build config will be able to\n * reference these globals instead of rebuilding them.\n *\n * @param name the module's name (should match name in package.json)\n * @param promise the promise resulting from a call to `import(name)`\n */\nexport async function defineSharedModule(name, fetchModule) {\n  // this field on window is used by dynamic plugins to reference the module\n  const moduleKey = withNamespace(name);\n  if (!window[moduleKey] && !modulePromises[name]) {\n    // if the module has not been loaded, load it\n    const modulePromise = fetchModule();\n    modulePromises[name] = modulePromise;\n    // wait for the module to load, and attach the result to window\n    // so that it can be referenced by plugins\n    window[moduleKey] = await modulePromise;\n  }\n  // we always return a reference to the promise.\n  // Multiple consumers can `.then()` or `await` the same promise,\n  // even long after it has completed,\n  // and it will always call back with the same reference.\n  return modulePromises[name];\n}\n/**\n * Define multiple shared modules at once, using a map of name -> `import(name)`\n *\n * @see defineSharedModule\n * @param moduleMap\n */\nexport async function defineSharedModules(moduleMap) {\n  return Promise.all(Object.entries(moduleMap).map(([name, fetchModule]) => defineSharedModule(name, fetchModule)));\n}\n// only exposed for tests\nexport function reset() {\n  Object.keys(modulePromises).forEach((key) => {\n    delete window[withNamespace(key)];\n    delete modulePromises[key];\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}