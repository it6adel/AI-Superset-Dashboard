{"ast":null,"code":"import _debounce from \"lodash/debounce\";import _isEqual from \"lodash/isEqual\";import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable no-param-reassign */\nimport { memo, useEffect, useState, useCallback, useRef, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { SLOW_DEBOUNCE, isNativeFilter, usePrevious, styled } from '@superset-ui/core';\nimport { useHistory } from 'react-router-dom';\nimport { updateDataMask, clearDataMask } from 'src/dataMask/actions';\nimport { useImmer } from 'use-immer';\n\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { useTabId } from 'src/hooks/useTabId';\nimport { logEvent } from 'src/logger/actions';\nimport { LOG_ACTIONS_CHANGE_DASHBOARD_FILTER } from 'src/logger/LogUtils';\nimport { FilterBarOrientation } from 'src/dashboard/types';\nimport { checkIsApplyDisabled } from './utils';\nimport { useNativeFiltersDataMask, useFilters, useFilterUpdates, useInitialization } from './state';\nimport { createFilterKey, updateFilterKey } from './keyValue';\nimport ActionButtons from './ActionButtons';\nimport Horizontal from './Horizontal';\nimport Vertical from './Vertical';\nimport { useSelectFiltersInScope } from '../state';\n// FilterBar is just being hidden as it must still\n// render fully due to encapsulated logics\nimport { jsx as _jsx } from \"@emotion/react/jsx-runtime\";const HiddenFilterBar = styled.div`\n  display: none;\n`;\nconst EXCLUDED_URL_PARAMS = [\nURL_PARAMS.nativeFilters.name,\nURL_PARAMS.permalinkKey.name];\n\nconst publishDataMask = _debounce(async (history, dashboardId, updateKey, dataMaskSelected, tabId) => {\n  const { location } = history;\n  const { search } = location;\n  const previousParams = new URLSearchParams(search);\n  const newParams = new URLSearchParams();\n  let dataMaskKey;\n  previousParams.forEach((value, key) => {\n    if (!EXCLUDED_URL_PARAMS.includes(key)) {\n      newParams.append(key, value);\n    }\n  });\n  const nativeFiltersCacheKey = getUrlParam(URL_PARAMS.nativeFiltersKey);\n  const dataMask = JSON.stringify(dataMaskSelected);\n  if (updateKey &&\n  nativeFiltersCacheKey && (\n  await updateFilterKey(dashboardId, dataMask, nativeFiltersCacheKey, tabId))) {\n    dataMaskKey = nativeFiltersCacheKey;\n  } else\n  {\n    dataMaskKey = await createFilterKey(dashboardId, dataMask, tabId);\n  }\n  if (dataMaskKey) {\n    newParams.set(URL_PARAMS.nativeFiltersKey.name, dataMaskKey);\n  }\n  // pathname could be updated somewhere else through window.history\n  // keep react router history in sync with window history\n  // replace params only when current page is /superset/dashboard\n  // this prevents a race condition between updating filters and navigating to Explore\n  if (window.location.pathname.includes('/superset/dashboard')) {\n    history.location.pathname = window.location.pathname;\n    history.replace({\n      search: newParams.toString()\n    });\n  }\n}, SLOW_DEBOUNCE);\nconst FilterBar = ({ orientation = FilterBarOrientation.Vertical, verticalConfig, hidden = false }) => {\n  const history = useHistory();\n  const dataMaskApplied = useNativeFiltersDataMask();\n  const [dataMaskSelected, setDataMaskSelected] = useImmer(dataMaskApplied);\n  const dispatch = useDispatch();\n  const [updateKey, setUpdateKey] = useState(0);\n  const tabId = useTabId();\n  const filters = useFilters();\n  const previousFilters = usePrevious(filters);\n  const filterValues = useMemo(() => Object.values(filters), [filters]);\n  const nativeFilterValues = useMemo(() => filterValues.filter(isNativeFilter), [filterValues]);\n  const dashboardId = useSelector(({ dashboardInfo }) => dashboardInfo == null ? void 0 : dashboardInfo.id);\n  const previousDashboardId = usePrevious(dashboardId);\n  const canEdit = useSelector(({ dashboardInfo }) => dashboardInfo.dash_edit_perm);\n  const user = useSelector((state) => state.user);\n  const [filtersInScope] = useSelectFiltersInScope(nativeFilterValues);\n  const dataMaskSelectedRef = useRef(dataMaskSelected);\n  dataMaskSelectedRef.current = dataMaskSelected;\n  const handleFilterSelectionChange = useCallback((filter, dataMask) => {\n    setDataMaskSelected((draft) => {var _dataMask$filterState, _dataMaskSelectedRef$, _dataMaskSelectedRef$2;\n      // force instant updating on initialization for filters with `requiredFirst` is true or instant filters\n      if (\n      // filterState.value === undefined - means that value not initialized\n      ((_dataMask$filterState = dataMask.filterState) == null ? void 0 : _dataMask$filterState.value) !== undefined &&\n      ((_dataMaskSelectedRef$ = dataMaskSelectedRef.current[filter.id]) == null ? void 0 : (_dataMaskSelectedRef$2 = _dataMaskSelectedRef$.filterState) == null ? void 0 : _dataMaskSelectedRef$2.value) ===\n      undefined &&\n      filter.requiredFirst) {\n        dispatch(updateDataMask(filter.id, dataMask));\n      }\n      draft[filter.id] = {\n        ...getInitialDataMask(filter.id),\n        ...dataMask\n      };\n    });\n  }, [dispatch, setDataMaskSelected]);\n  useEffect(() => {\n    if (previousFilters && dashboardId === previousDashboardId) {\n      const updates = {};\n      Object.values(filters).forEach((currentFilter) => {\n        const previousFilter = previousFilters == null ? void 0 : previousFilters[currentFilter.id];\n        if (!previousFilter) {\n          return;\n        }\n        const currentType = currentFilter.filterType;\n        const currentTargets = currentFilter.targets;\n        const currentDataMask = currentFilter.defaultDataMask;\n        const previousType = previousFilter == null ? void 0 : previousFilter.filterType;\n        const previousTargets = previousFilter == null ? void 0 : previousFilter.targets;\n        const previousDataMask = previousFilter == null ? void 0 : previousFilter.defaultDataMask;\n        const typeChanged = currentType !== previousType;\n        const targetsChanged = !_isEqual(currentTargets, previousTargets);\n        const dataMaskChanged = !_isEqual(currentDataMask, previousDataMask);\n        if (typeChanged || targetsChanged || dataMaskChanged) {\n          updates[currentFilter.id] = getInitialDataMask(currentFilter.id);\n        }\n      });\n      if (!_isEmpty(updates)) {\n        setDataMaskSelected((draft) => ({ ...draft, ...updates }));\n      }\n    }\n  }, [dashboardId, filters, previousDashboardId, setDataMaskSelected]);\n  const dataMaskAppliedText = JSON.stringify(dataMaskApplied);\n  useEffect(() => {\n    setDataMaskSelected(() => dataMaskApplied);\n  }, [dataMaskAppliedText, setDataMaskSelected]);\n  useEffect(() => {\n    // embedded users can't persist filter combinations\n    if (user != null && user.userId) {\n      publishDataMask(history, dashboardId, updateKey, dataMaskApplied, tabId);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dashboardId, dataMaskAppliedText, history, updateKey, tabId]);\n  const handleApply = useCallback(() => {\n    dispatch(logEvent(LOG_ACTIONS_CHANGE_DASHBOARD_FILTER, {}));\n    const filterIds = Object.keys(dataMaskSelected);\n    setUpdateKey(1);\n    filterIds.forEach((filterId) => {\n      if (dataMaskSelected[filterId]) {\n        dispatch(updateDataMask(filterId, dataMaskSelected[filterId]));\n      }\n    });\n  }, [dataMaskSelected, dispatch]);\n  const handleClearAll = useCallback(() => {\n    const clearDataMaskIds = [];\n    let dispatchAllowed = false;\n    filtersInScope.filter(isNativeFilter).forEach((filter) => {\n      const { id } = filter;\n      if (dataMaskSelected[id]) {var _filter$controlValues;\n        if ((_filter$controlValues = filter.controlValues) != null && _filter$controlValues.enableEmptyFilter) {\n          dispatchAllowed = false;\n        }\n        clearDataMaskIds.push(id);\n        setDataMaskSelected((draft) => {var _draft$id$filterState;\n          if (((_draft$id$filterState = draft[id].filterState) == null ? void 0 : _draft$id$filterState.value) !== undefined) {\n            draft[id].filterState.value = undefined;\n          }\n        });\n      }\n    });\n    if (dispatchAllowed) {\n      clearDataMaskIds.forEach((id) => dispatch(clearDataMask(id)));\n    }\n  }, [dataMaskSelected, dispatch, filtersInScope, setDataMaskSelected]);\n  useFilterUpdates(dataMaskSelected, setDataMaskSelected);\n  const isApplyDisabled = checkIsApplyDisabled(dataMaskSelected, dataMaskApplied, filtersInScope.filter(isNativeFilter));\n  const isInitialized = useInitialization();\n  const actions = useMemo(() => _jsx(ActionButtons, { filterBarOrientation: orientation, width: verticalConfig == null ? void 0 : verticalConfig.width, onApply: handleApply, onClearAll: handleClearAll, dataMaskSelected: dataMaskSelected, dataMaskApplied: dataMaskApplied, isApplyDisabled: isApplyDisabled }), [\n  orientation,\n  verticalConfig == null ? void 0 : verticalConfig.width,\n  handleApply,\n  handleClearAll,\n  dataMaskSelected,\n  dataMaskAppliedText,\n  isApplyDisabled]\n  );\n  const filterBarComponent = orientation === FilterBarOrientation.Horizontal ? _jsx(Horizontal, { actions: actions, canEdit: canEdit, dashboardId: dashboardId, dataMaskSelected: dataMaskSelected, filterValues: filterValues, isInitialized: isInitialized, onSelectionChange: handleFilterSelectionChange }) : verticalConfig ? _jsx(Vertical, { actions: actions, canEdit: canEdit, dataMaskSelected: dataMaskSelected, filtersOpen: verticalConfig.filtersOpen, filterValues: filterValues, isInitialized: isInitialized, height: verticalConfig.height, offset: verticalConfig.offset, onSelectionChange: handleFilterSelectionChange, toggleFiltersBar: verticalConfig.toggleFiltersBar, width: verticalConfig.width }) : null;\n  return hidden ? _jsx(HiddenFilterBar, { children: filterBarComponent }) : filterBarComponent;\n};\nexport default /*#__PURE__*/memo(FilterBar);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}