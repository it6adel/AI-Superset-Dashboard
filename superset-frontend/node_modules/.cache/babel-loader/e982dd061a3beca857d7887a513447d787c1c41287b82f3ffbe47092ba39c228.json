{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useState, useMemo, useEffect, useRef, useCallback } from 'react';\nimport { styled, SupersetClient, t } from '@superset-ui/core';\nimport rison from 'rison';\nimport { AsyncSelect, Select } from 'src/components';\nimport ErrorMessageWithStackTrace from 'src/components/ErrorMessage/ErrorMessageWithStackTrace';\nimport Label from 'src/components/Label';\nimport { FormLabel } from 'src/components/Form';\nimport RefreshLabel from 'src/components/RefreshLabel';\nimport { useToasts } from 'src/components/MessageToasts/withToasts';\nimport { useCatalogs, useSchemas } from 'src/hooks/apiResources';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst DatabaseSelectorWrapper = styled.div`\n  ${({ theme }) => `\n    .refresh {\n      display: flex;\n      align-items: center;\n      width: 30px;\n      margin-left: ${theme.gridUnit}px;\n      margin-top: ${theme.gridUnit * 5}px;\n    }\n\n    .section {\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n    }\n\n    .select {\n      width: calc(100% - 30px - ${theme.gridUnit}px);\n      flex: 1;\n    }\n\n    & > div {\n      margin-bottom: ${theme.gridUnit * 4}px;\n    }\n  `}\n`;\nconst LabelStyle = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  margin-left: ${({ theme }) => theme.gridUnit - 2}px;\n\n  .backend {\n    overflow: visible;\n  }\n\n  .name {\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n`;\nconst SelectLabel = ({ backend, databaseName }) => _jsxs(LabelStyle, { children: [\n  _jsx(Label, { className: \"backend\", children: backend || '' }),\n  _jsx(\"span\", { className: \"name\", title: databaseName, children:\n    databaseName }\n  )] }\n);\nconst EMPTY_CATALOG_OPTIONS = [];\nconst EMPTY_SCHEMA_OPTIONS = [];\nexport default function DatabaseSelector({ db, formMode = false, emptyState, getDbList, handleError, isDatabaseSelectEnabled = true, onDbChange, onEmptyResults, onCatalogChange, catalog, onSchemaChange, schema, readOnly = false, sqlLabMode = false }) {\n  const showCatalogSelector = !!(db != null && db.allow_multi_catalog);\n  const [currentDb, setCurrentDb] = useState();\n  const [errorPayload, setErrorPayload] = useState();\n  const [currentCatalog, setCurrentCatalog] = useState(catalog ? { label: catalog, value: catalog, title: catalog } : undefined);\n  const catalogRef = useRef(catalog);\n  catalogRef.current = catalog;\n  const [currentSchema, setCurrentSchema] = useState(schema ? { label: schema, value: schema, title: schema } : undefined);\n  const schemaRef = useRef(schema);\n  schemaRef.current = schema;\n  const { addSuccessToast } = useToasts();\n  const sortComparator = useCallback((itemA, itemB) => itemA.order - itemB.order, []);\n  const loadDatabases = useMemo(() => async (search, page, pageSize) => {\n    const queryParams = rison.encode({\n      order_column: 'database_name',\n      order_direction: 'asc',\n      page,\n      page_size: pageSize,\n      ...(formMode || !sqlLabMode ?\n      { filters: [{ col: 'database_name', opr: 'ct', value: search }] } :\n      {\n        filters: [\n        { col: 'database_name', opr: 'ct', value: search },\n        {\n          col: 'expose_in_sqllab',\n          opr: 'eq',\n          value: true\n        }]\n\n      })\n    });\n    const endpoint = `/api/v1/database/?q=${queryParams}`;\n    return SupersetClient.get({ endpoint }).then(({ json }) => {\n      const { result, count } = json;\n      if (getDbList) {\n        getDbList(result);\n      }\n      if (result.length === 0) {\n        if (onEmptyResults)\n        onEmptyResults(search);\n      }\n      const options = result.map((row, order) => ({\n        label: _jsx(SelectLabel, { backend: row.backend, databaseName: row.database_name }),\n        value: row.id,\n        id: row.id,\n        database_name: row.database_name,\n        backend: row.backend,\n        allow_multi_catalog: row.allow_multi_catalog,\n        order\n      }));\n      return {\n        data: options,\n        totalCount: count != null ? count : options.length\n      };\n    });\n  }, [formMode, getDbList, sqlLabMode, onEmptyResults]);\n  useEffect(() => {\n    setCurrentDb((current) => (current == null ? void 0 : current.id) !== (db == null ? void 0 : db.id) ?\n    db ?\n    {\n      label: _jsx(SelectLabel, { backend: db.backend, databaseName: db.database_name }),\n      value: db.id,\n      ...db\n    } :\n    undefined :\n    current);\n  }, [db]);\n  function changeSchema(schema) {\n    setCurrentSchema(schema);\n    if (onSchemaChange && (schema == null ? void 0 : schema.value) !== schemaRef.current) {\n      onSchemaChange(schema == null ? void 0 : schema.value);\n    }\n  }\n  const { currentData: schemaData, isFetching: loadingSchemas, refetch: refetchSchemas } = useSchemas({\n    dbId: currentDb == null ? void 0 : currentDb.value,\n    catalog: currentCatalog == null ? void 0 : currentCatalog.value,\n    onSuccess: (schemas, isFetched) => {\n      setErrorPayload(null);\n      if (schemas.length === 1) {\n        changeSchema(schemas[0]);\n      } else\n      if (!schemas.find((schemaOption) => schemaRef.current === schemaOption.value)) {\n        changeSchema(undefined);\n      }\n      if (isFetched) {\n        addSuccessToast('List refreshed');\n      }\n    },\n    onError: (error) => {\n      if (error != null && error.errors) {var _error$errors;\n        setErrorPayload(error == null ? void 0 : (_error$errors = error.errors) == null ? void 0 : _error$errors[0]);\n      } else\n      {\n        handleError(t('There was an error loading the schemas'));\n      }\n    }\n  });\n  const schemaOptions = schemaData || EMPTY_SCHEMA_OPTIONS;\n  function changeCatalog(catalog) {\n    setCurrentCatalog(catalog);\n    setCurrentSchema(undefined);\n    if (onCatalogChange && (catalog == null ? void 0 : catalog.value) !== catalogRef.current) {\n      onCatalogChange(catalog == null ? void 0 : catalog.value);\n    }\n  }\n  const { data: catalogData, isFetching: loadingCatalogs, refetch: refetchCatalogs } = useCatalogs({\n    dbId: showCatalogSelector ? currentDb == null ? void 0 : currentDb.value : undefined,\n    onSuccess: (catalogs, isFetched) => {\n      setErrorPayload(null);\n      if (!showCatalogSelector) {\n        changeCatalog(null);\n      } else\n      if (catalogs.length === 1) {\n        changeCatalog(catalogs[0]);\n      } else\n      if (!catalogs.find((catalogOption) => catalogRef.current === catalogOption.value)) {\n        changeCatalog(undefined);\n      }\n      if (showCatalogSelector && isFetched) {\n        addSuccessToast('List refreshed');\n      }\n    },\n    onError: (error) => {\n      if (showCatalogSelector) {\n        if (error != null && error.errors) {var _error$errors2;\n          setErrorPayload(error == null ? void 0 : (_error$errors2 = error.errors) == null ? void 0 : _error$errors2[0]);\n        } else\n        {\n          handleError(t('There was an error loading the catalogs'));\n        }\n      }\n    }\n  });\n  const catalogOptions = catalogData || EMPTY_CATALOG_OPTIONS;\n  function changeDatabase(value, database) {\n    setCurrentDb(database);\n    setCurrentCatalog(undefined);\n    setCurrentSchema(undefined);\n    if (onDbChange) {\n      onDbChange(database);\n    }\n    if (onCatalogChange) {\n      onCatalogChange(undefined);\n    }\n    if (onSchemaChange) {\n      onSchemaChange(undefined);\n    }\n  }\n  function renderSelectRow(select, refreshBtn) {\n    return _jsxs(\"div\", { className: \"section\", children: [\n      _jsx(\"span\", { className: \"select\", children: select }),\n      _jsx(\"span\", { className: \"refresh\", children: refreshBtn })] }\n    );\n  }\n  function renderDatabaseSelect() {\n    return renderSelectRow(_jsx(AsyncSelect, { ariaLabel: t('Select database or type to search databases'), optionFilterProps: ['database_name', 'value'], header: _jsx(FormLabel, { children: t('Database') }), lazyLoading: false, notFoundContent: emptyState, onChange: changeDatabase, value: currentDb, placeholder: t('Select database or type to search databases'), disabled: !isDatabaseSelectEnabled || readOnly, options: loadDatabases, sortComparator: sortComparator }), null);\n  }\n  function renderCatalogSelect() {\n    const refreshIcon = !readOnly && _jsx(RefreshLabel, { onClick: refetchCatalogs, tooltipContent: t('Force refresh catalog list') });\n    return renderSelectRow(_jsx(Select, { ariaLabel: t('Select catalog or type to search catalogs'), disabled: !currentDb || readOnly, header: _jsx(FormLabel, { children: t('Catalog') }), labelInValue: true, loading: loadingCatalogs, name: \"select-catalog\", notFoundContent: t('No compatible catalog found'), placeholder: t('Select catalog or type to search catalogs'), onChange: (item) => changeCatalog(item), options: catalogOptions, showSearch: true, value: currentCatalog || undefined, allowClear: true }), refreshIcon);\n  }\n  function renderSchemaSelect() {\n    const refreshIcon = !readOnly && _jsx(RefreshLabel, { onClick: refetchSchemas, tooltipContent: t('Force refresh schema list') });\n    return renderSelectRow(_jsx(Select, { ariaLabel: t('Select schema or type to search schemas'), disabled: !currentDb || readOnly, header: _jsx(FormLabel, { children: t('Schema') }), labelInValue: true, loading: loadingSchemas, name: \"select-schema\", notFoundContent: t('No compatible schema found'), placeholder: t('Select schema or type to search schemas'), onChange: (item) => changeSchema(item), options: schemaOptions, showSearch: true, value: currentSchema, allowClear: true }), refreshIcon);\n  }\n  function renderError() {\n    return errorPayload ? _jsx(ErrorMessageWithStackTrace, { error: errorPayload, source: \"crud\" }) : null;\n  }\n  return _jsxs(DatabaseSelectorWrapper, { children: [\n    renderDatabaseSelect(),\n    renderError(),\n    showCatalogSelector && renderCatalogSelect(),\n    renderSchemaSelect()] }\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}