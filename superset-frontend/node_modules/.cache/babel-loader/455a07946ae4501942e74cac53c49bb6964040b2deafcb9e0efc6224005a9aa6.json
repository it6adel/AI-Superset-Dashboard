{"ast":null,"code":"import _pick from \"lodash/pick\";import _omit from \"lodash/omit\";import _intersection from \"lodash/intersection\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, ensureIsArray, getCategoricalSchemeRegistry, getLabelsColorMap } from '@superset-ui/core';\n\nimport { areObjectsEqual } from 'src/reduxUtils';\nconst EMPTY_ARRAY = [];\n/**\n * Force falsy namespace values to undefined to default to GLOBAL\n *\n * @param namespace\n * @returns - namespace or default undefined\n */\nexport const getColorNamespace = (namespace) => namespace || undefined;\n/**\n *\n * Field shared_label_colors used to be a dict of all colors for all labels.\n * Force shared_label_colors field to be a list of actual shared labels.\n *\n * @param sharedLabelsColors - the shared label colors list\n * @returns string[]\n */\nexport const enforceSharedLabelsColorsArray = (sharedLabelsColors) => Array.isArray(sharedLabelsColors) ? sharedLabelsColors : EMPTY_ARRAY;\n/**\n * Get labels shared across all charts in a dashboard.\n * Merges a fresh instance of shared label colors with a stored one.\n *\n * @param currentSharedLabels - existing shared labels to merge with fresh\n * @returns Record<string, string>\n */\nexport const getFreshSharedLabels = (currentSharedLabels = []) => {\n  const { chartsLabelsMap } = getLabelsColorMap();\n  const allLabels = Array.from(chartsLabelsMap.values()).flatMap(({ labels }) => labels);\n  const duplicates = Array.from(allLabels.reduce((counts, label) => counts.set(label, (counts.get(label) || 0) + 1), new Map())).\n  filter(([, count]) => count > 1).\n  map(([label]) => label);\n  return Array.from(new Set([...ensureIsArray(currentSharedLabels), ...duplicates]));\n};\nexport const getSharedLabelsColorMapEntries = (currentColorMap, sharedLabels) => Object.fromEntries(Object.entries(currentColorMap).filter(([label]) => sharedLabels.includes(label)));\n/**\n * Returns all entries (labels and colors) except custom label colors.\n *\n * @param customLabelsColor - the custom label colors in label_colors field\n * @returns all color entries except custom label colors\n */\nexport const getFreshLabelsColorMapEntries = (customLabelsColor = {}) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const allEntries = Object.fromEntries(labelsColorMapInstance.getColorMap());\n  // custom label colors are applied and stored separetely via label_colors\n  Object.keys(customLabelsColor).forEach((label) => {\n    delete allEntries[label];\n  });\n  return allEntries;\n};\n/**\n * Returns all dynamic labels and colors (excluding custom label colors).\n *\n * @param labelsColorMap - the labels color map\n * @param customLabelsColor - the custom label colors in label_colors field\n * @returns all color entries except custom label colors\n */\nexport const getDynamicLabelsColors = (fullLabelsColors, customLabelsColor = {}) => _omit(fullLabelsColors, Object.keys(customLabelsColor));\nexport const getColorSchemeDomain = (colorScheme) => {var _getCategoricalScheme;return ((_getCategoricalScheme = getCategoricalSchemeRegistry().get(colorScheme)) == null ? void 0 : _getCategoricalScheme.colors) || [];};\n/**\n * Compare the current labels color map with a fresh one\n *\n * @param currentLabelsColorMap - the current labels color map\n * @returns true if the labels color map is the same as fresh\n */\nexport const isLabelsColorMapSynced = (storedLabelsColors, freshLabelsColors, customLabelColors) => {\n  const freshLabelsCount = Object.keys(freshLabelsColors).length;\n  // still updating, pass\n  if (!freshLabelsCount)\n  return true;\n  const commonKeys = _intersection(Object.keys(storedLabelsColors), Object.keys(freshLabelsColors));\n  const comparableStoredLabelsColors = _pick(storedLabelsColors, commonKeys);\n  const comparableFreshLabelsColors = _pick(freshLabelsColors, commonKeys);\n  const isSynced = areObjectsEqual(comparableStoredLabelsColors, comparableFreshLabelsColors, {\n    ignoreFields: Object.keys(customLabelColors)\n  });\n  return isSynced;\n};\n/**\n * Annihilate color maps\n *\n * @param color_namespace - the categorical namespace\n */\nexport const resetColors = (color_namespace) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(getColorNamespace(color_namespace));\n  categoricalNamespace.resetColors();\n  labelsColorMapInstance.reset();\n};\n/**\n * Update the labels color map based on current color scheme\n * It will respect custom label colors if set via namespace\n *\n * @param namespace - the color namespace\n * @param colorScheme - the current color scheme\n */\nexport const refreshLabelsColorMap = (namespace, colorScheme, merge = false) => {\n  const colorNameSpace = getColorNamespace(namespace);\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const labelsColorMapInstance = getLabelsColorMap();\n  labelsColorMapInstance.updateColorMap(categoricalNamespace, colorScheme, merge);\n};\n/**\n * Merge labels colors with custom labels colors\n * Apply labels color based on chosen color scheme\n *\n * @param metadata - the dashboard metadata object\n */\nexport const applyColors = (metadata,\n// Create a fresh color map by changing color scheme\nfresh = false,\n// Catch new labels in the color map as they appear\nmerge = false,\n// Apply only label colors that are shared across multiple charts.\nshared = false) => {\n  const colorNameSpace = getColorNamespace(metadata == null ? void 0 : metadata.color_namespace);\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const colorScheme = metadata == null ? void 0 : metadata.color_scheme;\n  const fullLabelsColor = (metadata == null ? void 0 : metadata.map_label_colors) || {};\n  const sharedLabels = enforceSharedLabelsColorsArray(metadata == null ? void 0 : metadata.shared_label_colors);\n  const customLabelsColor = (metadata == null ? void 0 : metadata.label_colors) || {};\n  const sharedLabelsColor = getSharedLabelsColorMapEntries(fullLabelsColor, sharedLabels);\n  if (fresh && !Array.isArray(fresh)) {\n    // reset custom label colors\n    // re-evaluate all other label colors\n    categoricalNamespace.resetColors();\n  }\n  if (fresh && Array.isArray(fresh)) {\n    // when a color scheme is not set for the dashboard\n    // should only reset colors for charts that have changed scheme\n    // while keeping colors of existing shared label colors intact\n    // this is used also to reset custom label colors when added or removed\n    categoricalNamespace.resetColorsForLabels(fresh);\n  }\n  if (fresh || merge) {\n    // re-instantiate a fresh labels color map based on current scheme\n    // it consider just applied custom label colors if present and all forced colors\n    // it will merge with the existing color map new labels only when merge is true\n    refreshLabelsColorMap(metadata == null ? void 0 : metadata.color_namespace, colorScheme, merge);\n  }\n  let applicableColorMapEntries = fullLabelsColor;\n  if (fresh) {\n    // requires a new map all together\n    applicableColorMapEntries = {\n      ...getFreshLabelsColorMapEntries(customLabelsColor)\n    };\n  }\n  if (merge) {\n    // must only add up newly appearing labels\n    // without overriding existing ones\n    applicableColorMapEntries = {\n      ...fullLabelsColor,\n      ...getFreshLabelsColorMapEntries(customLabelsColor)\n    };\n  }\n  if (shared) {\n    // must apply the colors to only shared labels\n    applicableColorMapEntries = sharedLabelsColor;\n  }\n  applicableColorMapEntries = {\n    ...applicableColorMapEntries,\n    ...customLabelsColor\n  };\n  // apply the final color map\n  if (applicableColorMapEntries) {\n    Object.keys(applicableColorMapEntries).forEach((label) => {\n      categoricalNamespace.setColor(label, applicableColorMapEntries[label]);\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}