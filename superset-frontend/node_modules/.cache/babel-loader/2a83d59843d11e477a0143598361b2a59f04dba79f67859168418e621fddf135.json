{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, ensureIsInt, getColumnLabel, getMetricLabel, getNumberFormatter, getTimeFormatter } from '@superset-ui/core';\nimport { DEFAULT_FORM_DATA as DEFAULT_RADAR_FORM_DATA, EchartsRadarLabelType } from './types';\nimport { DEFAULT_LEGEND_FORM_DATA, OpacityEnum } from '../constants';\nimport { extractGroupbyLabel, getChartPadding, getColtypesMapping, getLegendProps } from '../utils/series';\nimport { defaultGrid } from '../defaults';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function formatLabel({ params, labelType, numberFormatter }) {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsRadarLabelType.Value:\n      return formattedValue;\n    case EchartsRadarLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters } = chartProps;\n  const refs = {};\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { colorScheme, groupby, labelType, labelPosition, legendOrientation, legendType, legendMargin, metrics = [], numberFormat, dateFormat, showLabels, showLegend, isCircle, columnConfig, sliceId } = {\n    ...DEFAULT_LEGEND_FORM_DATA,\n    ...DEFAULT_RADAR_FORM_DATA,\n    ...formData\n  };\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter,\n    labelType\n  });\n  const metricLabels = metrics.map(getMetricLabel);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const metricLabelAndMaxValueMap = new Map();\n  const metricLabelAndMinValueMap = new Map();\n  const columnsLabelMap = new Map();\n  const transformedData = [];\n  data.forEach((datum) => {\n    const joinedName = extractGroupbyLabel({\n      datum,\n      groupby: groupbyLabels,\n      coltypeMapping,\n      timeFormatter: getTimeFormatter(dateFormat)\n    });\n    // map(joined_name: [columnLabel_1, columnLabel_2, ...])\n    columnsLabelMap.set(joinedName, groupbyLabels.map((col) => datum[col]));\n    // put max value of series into metricLabelAndMaxValueMap\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [metricLabel, value] of Object.entries(datum)) {\n      if (metricLabelAndMaxValueMap.has(metricLabel)) {\n        metricLabelAndMaxValueMap.set(metricLabel, Math.max(value, ensureIsInt(metricLabelAndMaxValueMap.get(metricLabel), Number.MIN_SAFE_INTEGER)));\n      } else\n      {\n        metricLabelAndMaxValueMap.set(metricLabel, value);\n      }\n      if (metricLabelAndMinValueMap.has(metricLabel)) {\n        metricLabelAndMinValueMap.set(metricLabel, Math.min(value, ensureIsInt(metricLabelAndMinValueMap.get(metricLabel), Number.MAX_SAFE_INTEGER)));\n      } else\n      {\n        metricLabelAndMinValueMap.set(metricLabel, value);\n      }\n    }\n    const isFiltered = filterState.selectedValues &&\n    !filterState.selectedValues.includes(joinedName);\n    // generate transformedData\n    transformedData.push({\n      value: metricLabels.map((metricLabel) => datum[metricLabel]),\n      name: joinedName,\n      itemStyle: {\n        color: colorFn(joinedName, sliceId),\n        opacity: isFiltered ?\n        OpacityEnum.Transparent :\n        OpacityEnum.NonTransparent\n      },\n      lineStyle: {\n        opacity: isFiltered ?\n        OpacityEnum.SemiTransparent :\n        OpacityEnum.NonTransparent\n      },\n      label: {\n        show: showLabels,\n        position: labelPosition,\n        formatter\n      }\n    });\n  });\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = transformedData.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  const indicator = metricLabels.map((metricLabel) => {var _columnConfig$metricL, _columnConfig$metricL2;\n    const maxValueInControl = columnConfig == null ? void 0 : (_columnConfig$metricL = columnConfig[metricLabel]) == null ? void 0 : _columnConfig$metricL.radarMetricMaxValue;\n    const minValueInControl = columnConfig == null ? void 0 : (_columnConfig$metricL2 = columnConfig[metricLabel]) == null ? void 0 : _columnConfig$metricL2.radarMetricMinValue;\n    // Ensure that 0 is at the center of the polar coordinates\n    const metricValueAsMax = metricLabelAndMaxValueMap.get(metricLabel) === 0 ?\n    Number.MAX_SAFE_INTEGER :\n    metricLabelAndMaxValueMap.get(metricLabel);\n    const max = maxValueInControl === null ? metricValueAsMax : maxValueInControl;\n    let min;\n    // If the min value doesn't exist, set it to 0 (default),\n    // if it is null, set it to the min value of the data,\n    // otherwise, use the value from the control\n    if (minValueInControl === undefined) {\n      min = 0;\n    } else\n    if (minValueInControl === null) {\n      min = metricLabelAndMinValueMap.get(metricLabel) || 0;\n    } else\n    {\n      min = minValueInControl;\n    }\n    return {\n      name: metricLabel,\n      max,\n      min\n    };\n  });\n  const series = [\n  {\n    type: 'radar',\n    ...getChartPadding(showLegend, legendOrientation, legendMargin),\n    animation: false,\n    emphasis: {\n      label: {\n        show: true,\n        fontWeight: 'bold',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    },\n    data: transformedData\n  }];\n\n  const echartOptions = {\n    grid: {\n      ...defaultGrid\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item'\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme),\n      data: Array.from(columnsLabelMap.keys())\n    },\n    series,\n    radar: {\n      shape: isCircle ? 'circle' : 'polygon',\n      indicator\n    }\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    emitCrossFilters,\n    setDataMask,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues,\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}