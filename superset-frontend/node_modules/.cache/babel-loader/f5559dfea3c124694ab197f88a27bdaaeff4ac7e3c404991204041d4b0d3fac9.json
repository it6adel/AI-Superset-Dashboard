{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getEmptyImage } from 'react-dnd-html5-backend';\nimport { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { TAB_TYPE } from 'src/dashboard/util/componentTypes';\nimport { DragSource, DropTarget } from 'react-dnd';\nimport cx from 'classnames';\nimport { css, styled } from '@superset-ui/core';\n\nimport { componentShape } from '../../util/propShapes';\nimport { dragConfig, dropConfig } from './dragDroppableConfig';\nimport { DROP_FORBIDDEN } from '../../util/getDropPosition';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\n\nconst propTypes = {\n  children: PropTypes.func,\n  className: PropTypes.string,\n  component: componentShape,\n  parentComponent: componentShape,\n  depth: PropTypes.number.isRequired,\n  disableDragDrop: PropTypes.bool,\n  dropToChild: PropTypes.bool,\n  orientation: PropTypes.oneOf(['row', 'column']),\n  index: PropTypes.number.isRequired,\n  style: PropTypes.object,\n  onDrop: PropTypes.func,\n  onHover: PropTypes.func,\n  onDropIndicatorChange: PropTypes.func,\n  onDragTab: PropTypes.func,\n  editMode: PropTypes.bool,\n  useEmptyDragPreview: PropTypes.bool,\n\n  // from react-dnd\n  isDragging: PropTypes.bool,\n  isDraggingOver: PropTypes.bool,\n  isDraggingOverShallow: PropTypes.bool,\n  dragComponentType: PropTypes.string,\n  dragComponentId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  droppableRef: PropTypes.func,\n  dragSourceRef: PropTypes.func,\n  dragPreviewRef: PropTypes.func\n};\n\nconst defaultProps = {\n  className: null,\n  style: null,\n  parentComponent: null,\n  disableDragDrop: false,\n  dropToChild: false,\n  children() {},\n  onDrop() {},\n  onHover() {},\n  onDropIndicatorChange() {},\n  onDragTab() {},\n  orientation: 'row',\n  useEmptyDragPreview: false,\n  isDragging: false,\n  isDraggingOver: false,\n  isDraggingOverShallow: false,\n  droppableRef() {},\n  dragSourceRef() {},\n  dragPreviewRef() {}\n};\n\nconst DragDroppableStyles = styled.div`\n  ${({ theme }) => css`\n    position: relative;\n    /*\n      Next line is a workaround for a bug in react-dnd where the drag\n      preview expands outside of the bounds of the drag source card, see:\n      https://github.com/react-dnd/react-dnd/issues/832#issuecomment-442071628\n    */\n    &.dragdroppable--edit-mode {\n      transform: translate3d(0, 0, 0);\n    }\n\n    &.dragdroppable--dragging {\n      opacity: 0.2;\n    }\n\n    &.dragdroppable-row {\n      width: 100%;\n    }\n\n    &.dragdroppable-column .resizable-container span div {\n      z-index: 10;\n    }\n\n    & {\n      .drop-indicator {\n        display: block;\n        background-color: ${theme.colors.primary.base};\n        position: absolute;\n        z-index: 10;\n        opacity: 0.3;\n        width: 100%;\n        height: 100%;\n        &.drop-indicator--forbidden {\n          background-color: ${theme.colors.error.light1};\n        }\n      }\n    }\n  `};\n`;\n// export unwrapped component for testing\nexport class UnwrappedDragDroppable extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      dropIndicator: null // this gets set/modified by the react-dnd HOCs\n    };\n    this.setRef = this.setRef.bind(this);\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      onDropIndicatorChange,\n      isDraggingOver,\n      component,\n      index,\n      dragComponentId,\n      onDragTab\n    } = this.props;\n    const { dropIndicator } = this.state;\n    const isTabsType = component.type === TAB_TYPE;\n    const validStateChange =\n    dropIndicator !== prevState.dropIndicator ||\n    isDraggingOver !== prevProps.isDraggingOver ||\n    index !== prevProps.index;\n\n    if (onDropIndicatorChange && isTabsType && validStateChange) {\n      onDropIndicatorChange({ dropIndicator, isDraggingOver, index });\n    }\n\n    if (dragComponentId !== prevProps.dragComponentId) {\n      setTimeout(() => {\n        /**\n         * This timeout ensures the dargSourceRef and dragPreviewRef are set\n         * before the component is removed in Tabs.jsx. Otherwise react-dnd\n         * will not render the drag preview.\n         */\n        onDragTab(dragComponentId);\n      });\n    }\n  }\n\n  setRef(ref) {var _this$props$droppable, _this$props;\n    this.ref = ref;\n    // this is needed for a custom drag preview\n    if (this.props.useEmptyDragPreview) {\n      this.props.dragPreviewRef(getEmptyImage(), {\n        // IE fallback: specify that we'd rather screenshot the node\n        // when it already knows it's being dragged so we can hide it with CSS.\n        captureDraggingState: true\n      });\n    } else {\n      this.props.dragPreviewRef(ref);\n    }\n    (_this$props$droppable = (_this$props = this.props).droppableRef) == null ? void 0 : _this$props$droppable.call(_this$props, ref);\n  }\n\n  render() {\n    const {\n      children,\n      className,\n      orientation,\n      dragSourceRef,\n      disableDragDrop,\n      isDragging,\n      isDraggingOver,\n      style,\n      editMode,\n      component,\n      dragComponentType\n    } = this.props;\n\n    const { dropIndicator } = this.state;\n    const dropIndicatorProps =\n    isDraggingOver && dropIndicator && !disableDragDrop ?\n    {\n      className: cx(\n        'drop-indicator',\n        dropIndicator === DROP_FORBIDDEN && 'drop-indicator--forbidden'\n      )\n    } :\n    null;\n\n    const draggingTabOnTab =\n    component.type === TAB_TYPE && dragComponentType === TAB_TYPE;\n\n    const childProps = editMode ?\n    {\n      dragSourceRef,\n      dropIndicatorProps,\n      draggingTabOnTab\n\n    } :\n    {\n\n    };\n\n    return (\n      _jsx(DragDroppableStyles, {\n        style: style,\n        ref: this.setRef,\n\n        className: cx(\n          'dragdroppable',\n          editMode && 'dragdroppable--edit-mode',\n          orientation === 'row' && 'dragdroppable-row',\n          orientation === 'column' && 'dragdroppable-column',\n          isDragging && 'dragdroppable--dragging',\n          className\n        ), children:\n\n        children(childProps) }\n      ));\n\n  }\n}\n\nUnwrappedDragDroppable.propTypes = propTypes;\nUnwrappedDragDroppable.defaultProps = defaultProps;\n\nexport const Draggable = DragSource(...dragConfig)(UnwrappedDragDroppable);\nexport const Droppable = DropTarget(...dropConfig)(UnwrappedDragDroppable);\n\n// note that the composition order here determines using\n// component.method() vs decoratedComponentInstance.method() in the drag/drop config\nexport const DragDroppable = DragSource(...dragConfig)(\n  DropTarget(...dropConfig)(UnwrappedDragDroppable)\n);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}