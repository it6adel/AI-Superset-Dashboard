{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { AnnotationOpacity, AnnotationType, AxisType, evalExpression, isRecordAnnotationResult, isTableAnnotationLayer, isTimeseriesAnnotationResult } from '@superset-ui/core';\nexport function evalFormula(formula, data, xAxis, xAxisType) {\n  const { value: expression } = formula;\n  return data.map((row) => {\n    let value = row[xAxis];\n    if (xAxisType === AxisType.Time) {\n      value = new Date(value).getTime();\n    }\n    return [value, evalExpression(expression, value || 0)];\n  });\n}\nexport function parseAnnotationOpacity(opacity) {\n  switch (opacity) {\n    case AnnotationOpacity.Low:\n      return 0.2;\n    case AnnotationOpacity.Medium:\n      return 0.5;\n    case AnnotationOpacity.High:\n      return 0.8;\n    default:\n      return 1;\n  }\n}\nconst NATIVE_COLUMN_NAMES = {\n  descriptionColumns: ['long_descr'],\n  intervalEndColumn: 'end_dttm',\n  timeColumn: 'start_dttm',\n  titleColumn: 'short_descr'\n};\nexport function extractRecordAnnotations(annotationLayer, annotationData) {\n  const { name } = annotationLayer;\n  const result = annotationData[name];\n  if (isRecordAnnotationResult(result)) {\n    const { records } = result;\n    const { descriptionColumns = [], intervalEndColumn = '', timeColumn = '', titleColumn = '' } = isTableAnnotationLayer(annotationLayer) ?\n    annotationLayer :\n    NATIVE_COLUMN_NAMES;\n    return records.map((record) => ({\n      descriptions: descriptionColumns.map((column) => record[column] || ''),\n      intervalEnd: record[intervalEndColumn] || '',\n      time: record[timeColumn] || '',\n      title: record[titleColumn] || ''\n    }));\n  }\n  throw new Error('Please rerun the query.');\n}\nexport function formatAnnotationLabel(name, title, descriptions = []) {\n  const labels = [];\n  const titleLabels = [];\n  const filteredDescriptions = descriptions.filter((description) => !!description);\n  if (name)\n  titleLabels.push(name);\n  if (title)\n  titleLabels.push(title);\n  if (titleLabels.length > 0)\n  labels.push(titleLabels.join(' - '));\n  if (filteredDescriptions.length > 0)\n  labels.push(filteredDescriptions.join('\\n'));\n  return labels.join('\\n\\n');\n}\nexport function extractAnnotationLabels(layers, data) {\n  const formulaAnnotationLabels = layers.\n  filter((anno) => anno.annotationType === AnnotationType.Formula && anno.show).\n  map((anno) => anno.name);\n  const timeseriesAnnotationLabels = layers.\n  filter((anno) => anno.annotationType === AnnotationType.Timeseries && anno.show).\n  flatMap((anno) => {\n    const result = data[anno.name];\n    return isTimeseriesAnnotationResult(result) ?\n    result.map((annoSeries) => annoSeries.key) :\n    [];\n  });\n  return formulaAnnotationLabels.concat(timeseriesAnnotationLabels);\n}\nexport function getAnnotationData(chartProps) {var _chartProps$queriesDa;\n  const data = chartProps == null ? void 0 : (_chartProps$queriesDa = chartProps.queriesData[0]) == null ? void 0 : _chartProps$queriesDa.annotation_data;\n  if (!_isEmpty(data)) {\n    return data;\n  }\n  return {};\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}