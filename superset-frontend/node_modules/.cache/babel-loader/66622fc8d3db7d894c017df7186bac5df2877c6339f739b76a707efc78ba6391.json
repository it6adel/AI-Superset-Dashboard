{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/no-array-index-key, react/jsx-no-bind */\nimport dist from 'distributions';\nimport { Component } from 'react';\nimport { Table, Tr, Td, Thead, Th } from 'reactable';\nimport PropTypes from 'prop-types';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\n\nexport const dataPropType = PropTypes.arrayOf(\n  PropTypes.shape({\n    group: PropTypes.arrayOf(PropTypes.string),\n    values: PropTypes.arrayOf(\n      PropTypes.shape({\n        x: PropTypes.number,\n        y: PropTypes.number\n      })\n    )\n  })\n);\n\nconst propTypes = {\n  alpha: PropTypes.number,\n  data: dataPropType.isRequired,\n  groups: PropTypes.arrayOf(PropTypes.string).isRequired,\n  liftValPrec: PropTypes.number,\n  metric: PropTypes.string.isRequired,\n  pValPrec: PropTypes.number\n};\n\nconst defaultProps = {\n  alpha: 0.05,\n  liftValPrec: 4,\n  pValPrec: 6\n};\n\nclass TTestTable extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      control: 0,\n      liftValues: [],\n      pValues: []\n    };\n  }\n\n  componentDidMount() {\n    const { control } = this.state;\n    this.computeTTest(control); // initially populate table\n  }\n\n  getLiftStatus(row) {\n    const { control, liftValues } = this.state;\n    // Get a css class name for coloring\n    if (row === control) {\n      return 'control';\n    }\n    const liftVal = liftValues[row];\n    if (Number.isNaN(liftVal) || !Number.isFinite(liftVal)) {\n      return 'invalid'; // infinite or NaN values\n    }\n\n    return liftVal >= 0 ? 'true' : 'false'; // green on true, red on false\n  }\n\n  getPValueStatus(row) {\n    const { control, pValues } = this.state;\n    if (row === control) {\n      return 'control';\n    }\n    const pVal = pValues[row];\n    if (Number.isNaN(pVal) || !Number.isFinite(pVal)) {\n      return 'invalid';\n    }\n\n    return ''; // p-values won't normally be colored\n  }\n\n  getSignificance(row) {\n    const { control, pValues } = this.state;\n    const { alpha } = this.props;\n    // Color significant as green, else red\n    if (row === control) {\n      return 'control';\n    }\n\n    // p-values significant below set threshold\n    return pValues[row] <= alpha;\n  }\n\n  computeLift(values, control) {\n    const { liftValPrec } = this.props;\n    // Compute the lift value between two time series\n    let sumValues = 0;\n    let sumControl = 0;\n    values.forEach((value, i) => {\n      sumValues += value.y;\n      sumControl += control[i].y;\n    });\n\n    return ((sumValues - sumControl) / sumControl * 100).toFixed(liftValPrec);\n  }\n\n  computePValue(values, control) {\n    const { pValPrec } = this.props;\n    // Compute the p-value from Student's t-test\n    // between two time series\n    let diffSum = 0;\n    let diffSqSum = 0;\n    let finiteCount = 0;\n    values.forEach((value, i) => {\n      const diff = control[i].y - value.y;\n      /* eslint-disable-next-line */\n      if (isFinite(diff)) {\n        finiteCount += 1;\n        diffSum += diff;\n        diffSqSum += diff * diff;\n      }\n    });\n    const tvalue = -Math.abs(\n      diffSum *\n      Math.sqrt(\n        (finiteCount - 1) / (finiteCount * diffSqSum - diffSum * diffSum)\n      )\n    );\n    try {\n      return (2 * new dist.Studentt(finiteCount - 1).cdf(tvalue)).toFixed(\n        pValPrec\n      ); // two-sided test\n    } catch (error) {\n      return NaN;\n    }\n  }\n\n  computeTTest(control) {\n    // Compute lift and p-values for each row\n    // against the selected control\n    const { data } = this.props;\n    const pValues = [];\n    const liftValues = [];\n    if (!data) {\n      return;\n    }\n    for (let i = 0; i < data.length; i += 1) {\n      if (i === control) {\n        pValues.push('control');\n        liftValues.push('control');\n      } else {\n        pValues.push(this.computePValue(data[i].values, data[control].values));\n        liftValues.push(this.computeLift(data[i].values, data[control].values));\n      }\n    }\n    this.setState({ control, liftValues, pValues });\n  }\n\n  render() {\n    const { data, metric, groups } = this.props;\n    const { control, liftValues, pValues } = this.state;\n\n    if (!Array.isArray(groups) || groups.length === 0) {\n      throw Error('Group by param is required');\n    }\n\n    // Render column header for each group\n    const columns = groups.map((group, i) =>\n    _jsx(Th, { column: group, children:\n      group }, i\n    )\n    );\n    const numGroups = groups.length;\n    // Columns for p-value, lift-value, and significance (true/false)\n    columns.push(\n      _jsx(Th, { column: \"pValue\", children: \"p-value\" }, numGroups + 1\n\n      )\n    );\n    columns.push(\n      _jsx(Th, { column: \"liftValue\", children: \"Lift %\" }, numGroups + 2\n\n      )\n    );\n    columns.push(\n      _jsx(Th, { column: \"significant\", children: \"Significant\" }, numGroups + 3\n\n      )\n    );\n    const rows = data.map((entry, i) => {\n      const values = groups.map(\n        (\n        group,\n        j // group names\n        ) => _jsx(Td, { column: group, data: entry.group[j] }, j)\n      );\n      values.push(\n        _jsx(Td, {\n\n          className: this.getPValueStatus(i),\n          column: \"pValue\",\n          data: pValues[i] }, numGroups + 1\n        )\n      );\n      values.push(\n        _jsx(Td, {\n\n          className: this.getLiftStatus(i),\n          column: \"liftValue\",\n          data: liftValues[i] }, numGroups + 2\n        )\n      );\n      values.push(\n        _jsx(Td, {\n\n          className: this.getSignificance(i).toString(),\n          column: \"significant\",\n          data: this.getSignificance(i) }, numGroups + 3\n        )\n      );\n\n      return (\n        _jsx(Tr, {\n\n          className: i === control ? 'control' : '',\n          onClick: this.computeTTest.bind(this, i), children:\n\n          values }, i\n        ));\n\n    });\n    // When sorted ascending, 'control' will always be at top\n    const sortConfig = groups.concat([\n    {\n      column: 'pValue',\n      sortFunction: (a, b) => {\n        if (a === 'control') {\n          return -1;\n        }\n        if (b === 'control') {\n          return 1;\n        }\n\n        return a > b ? 1 : -1; // p-values ascending\n      }\n    },\n    {\n      column: 'liftValue',\n      sortFunction: (a, b) => {\n        if (a === 'control') {\n          return -1;\n        }\n        if (b === 'control') {\n          return 1;\n        }\n\n        return parseFloat(a) > parseFloat(b) ? -1 : 1; // lift values descending\n      }\n    },\n    {\n      column: 'significant',\n      sortFunction: (a, b) => {\n        if (a === 'control') {\n          return -1;\n        }\n        if (b === 'control') {\n          return 1;\n        }\n\n        return a > b ? -1 : 1; // significant values first\n      }\n    }]\n    );\n\n    return (\n      _jsxs(\"div\", { children: [\n        _jsx(\"h3\", { children: metric }),\n        _jsxs(Table, { className: \"table\", id: `table_${metric}`, sortable: sortConfig, children: [\n          _jsx(Thead, { children: columns }),\n          rows] }\n        )] }\n      ));\n\n  }\n}\n\nTTestTable.propTypes = propTypes;\nTTestTable.defaultProps = defaultProps;\n\nexport default TTestTable;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}