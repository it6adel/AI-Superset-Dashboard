{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getClientErrorObject, SupersetClient, t } from '@superset-ui/core';\nimport rison from 'rison';\nimport { cacheWrapper } from 'src/utils/cacheWrapper';\nconst localCache = new Map();\nconst cachedSupersetGet = cacheWrapper(SupersetClient.get, localCache, ({ endpoint }) => endpoint || '');\nexport const tagToSelectOption = (tag) => ({\n  value: tag.id,\n  label: tag.name,\n  key: tag.id\n});\nexport const loadTags = async (search, page, pageSize) => {\n  const searchColumn = 'name';\n  const query = rison.encode({\n    filters: [\n    { col: searchColumn, opr: 'ct', value: search },\n    { col: 'type', opr: 'custom_tag', value: true }],\n\n    page,\n    page_size: pageSize,\n    order_column: searchColumn,\n    order_direction: 'asc'\n  });\n  const getErrorMessage = ({ error, message }) => {\n    let errorText = message || error || t('An error has occurred');\n    if (message === 'Forbidden') {\n      errorText = t('You do not have permission to read tags');\n    }\n    return errorText;\n  };\n  return cachedSupersetGet({\n    endpoint: `/api/v1/tag/?q=${query}`\n  }).\n  then((response) => {\n    const data = response.json.result.map(tagToSelectOption);\n    return {\n      data,\n      totalCount: response.json.count\n    };\n  }).\n  catch(async (error) => {\n    const errorMessage = getErrorMessage(await getClientErrorObject(error));\n    throw new Error(errorMessage);\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}