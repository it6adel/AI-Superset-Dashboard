{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getSequentialSchemeRegistry, getTimeFormatter, getValueFormatter, NumberFormats, t, tooltipHtml } from '@superset-ui/core';\nimport { NULL_STRING, OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder } from '../utils/treeBuilder';\nimport { EchartsSunburstLabelType } from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function getLinearDomain(treeData, callback) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree) {\n    tree.forEach((treeNode) => {var _treeNode$children;\n      if ((_treeNode$children = treeNode.children) != null && _treeNode$children.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp)\n        min = temp;\n        if (max < temp)\n        max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\nexport function formatLabel({ params, labelType, numberFormatter }) {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\nexport function formatTooltip({ params, primaryValueFormatter, secondaryValueFormatter, colorByCategory, totalValue, metricLabel, secondaryMetricLabel }) {\n  const { data, treePathInfo = [] } = params;\n  const node = data;\n  const formattedValue = primaryValueFormatter(node.value);\n  const formattedSecondaryValue = secondaryValueFormatter == null ? void 0 : secondaryValueFormatter(node.secondaryValue);\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(node.secondaryValue / node.value);\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode = treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n  const title = (node.name || NULL_STRING).\n  toString().\n  replaceAll('<', '&lt;').\n  replaceAll('>', '&gt;');\n  const rows = [[t('% of total'), absolutePercentage]];\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(node.value / parentNode.value);\n    rows.push([t('% of parent'), conditionalPercentage]);\n  }\n  rows.push([metricLabel, formattedValue]);\n  if (!colorByCategory) {\n    rows.push([\n    secondaryMetricLabel || NULL_STRING,\n    formattedSecondaryValue || NULL_STRING]\n    );\n    rows.push([\n    `${metricLabel}/${secondaryMetricLabel}`,\n    compareValuePercentage]\n    );\n  }\n  return tooltipHtml(rows, title);\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters, datasource } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { groupby = [], columns = [], metric = '', secondaryMetric = '', colorScheme, linearColorScheme, labelType, numberFormat, currencyFormat, dateFormat, showLabels, showLabelsThreshold, showTotal, sliceId } = formData;\n  const { currencyFormats = {}, columnFormats = {}, verboseMap = {} } = datasource;\n  const refs = {};\n  const primaryValueFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat, currencyFormat);\n  const secondaryValueFormatter = secondaryMetric ?\n  getValueFormatter(secondaryMetric, currencyFormats, columnFormats, numberFormat, currencyFormat) :\n  undefined;\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter: primaryValueFormatter,\n    labelType\n  });\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit\n  };\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric ?\n  getMetricLabel(secondaryMetric) :\n  undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(data, columnLabels, metricLabel, secondaryMetricLabel);\n  const totalValue = treeData.reduce((result, treeNode) => result + treeNode.value, 0);\n  const totalSecondaryValue = treeData.reduce((result, treeNode) => result + treeNode.secondaryValue, 0);\n  const categoricalColorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let linearColorScale;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {var _getSequentialSchemeR, _getSequentialSchemeR2;\n    const domain = getLinearDomain(treeData, (node) => node.secondaryValue / node.value);\n    colorByCategory = false;\n    linearColorScale = (_getSequentialSchemeR = getSequentialSchemeRegistry()) == null ? void 0 : (_getSequentialSchemeR2 = _getSequentialSchemeR.\n    get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR2.\n    createLinearScale(domain);\n  }\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else\n  {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n  const traverse = (treeNodes, path, pathRecords) => treeNodes.map((treeNode) => {var _treeNode$children2, _filterState$selected, _filterState$selected2;\n    const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n    const records = [...(pathRecords || []), nodeName];\n    let name = formatSeriesName(nodeName, {\n      numberFormatter,\n      timeFormatter: getTimeFormatter(dateFormat),\n      ...(coltypeMapping[groupBy] && {\n        coltype: coltypeMapping[groupBy]\n      })\n    });\n    const newPath = path.concat(name);\n    let item = {\n      records,\n      name,\n      value,\n      secondaryValue,\n      itemStyle: {\n        color: colorByCategory ?\n        categoricalColorScale(name, sliceId) :\n        linearColorScale(secondaryValue / value)\n      }\n    };\n    if ((_treeNode$children2 = treeNode.children) != null && _treeNode$children2.length) {\n      item.children = traverse(treeNode.children, newPath, records);\n    } else\n    {\n      name = newPath.join(',');\n    }\n    columnsLabelMap.set(name, newPath);\n    if (((_filterState$selected = filterState.selectedValues) == null ? void 0 : (_filterState$selected2 = _filterState$selected[0]) == null ? void 0 : _filterState$selected2.includes(name)) === false) {\n      item = {\n        ...item,\n        itemStyle: {\n          ...item.itemStyle,\n          opacity: OpacityEnum.SemiTransparent\n        },\n        label: {\n          color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})`\n        }\n      };\n    }\n    return item;\n  });\n  const echartOptions = {\n    grid: {\n      ...defaultGrid\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params) => formatTooltip({\n        params,\n        primaryValueFormatter,\n        secondaryValueFormatter,\n        colorByCategory,\n        totalValue,\n        metricLabel: verboseMap[metricLabel] || metricLabel,\n        secondaryMetricLabel: secondaryMetricLabel ?\n        verboseMap[secondaryMetricLabel] || secondaryMetricLabel :\n        undefined\n      })\n    },\n    series: [\n    {\n      type: 'sunburst',\n      ...padding,\n      nodeClick: false,\n      emphasis: {\n        focus: 'ancestor',\n        label: {\n          show: showLabels\n        }\n      },\n      label: {\n        width: radius * 0.6 / (columns.length || 1),\n        show: showLabels,\n        formatter,\n        color: theme.colors.grayscale.dark2,\n        minAngle: minShowLabelAngle,\n        overflow: 'breakAll'\n      },\n      radius: [radius * 0.3, radius],\n      data: traverse(treeData, [])\n    }],\n\n    graphic: showTotal ?\n    {\n      type: 'text',\n      top: 'center',\n      left: 'center',\n      style: {\n        text: t('Total: %s', primaryValueFormatter(totalValue)),\n        fontSize: 16,\n        fontWeight: 'bold'\n      },\n      z: 10\n    } :\n    null\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}