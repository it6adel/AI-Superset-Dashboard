{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { List } from 'src/components/List';\nimport { connect } from 'react-redux';\nimport { PureComponent } from 'react';\nimport { t, withTheme, css } from '@superset-ui/core';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport AsyncEsmComponent from 'src/components/AsyncEsmComponent';\nimport { getChartKey } from 'src/explore/exploreUtils';\nimport { runAnnotationQuery } from 'src/components/Chart/chartAction';\nimport CustomListItem from 'src/explore/components/controls/CustomListItem';\nimport Icons from 'src/components/Icons';\nimport ControlPopover, { getSectionContainerElement } from '../ControlPopover/ControlPopover';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst AnnotationLayer = AsyncEsmComponent(() => import('./AnnotationLayer'),\n// size of overlay inner content\n() => _jsx(\"div\", { style: { width: 450, height: 368 } }));\nconst defaultProps = {\n  vizType: '',\n  value: [],\n  annotationError: {},\n  annotationQuery: {},\n  onChange: () => {}\n};\nclass AnnotationLayerControl extends PureComponent {\n\n  constructor(props) {\n    super(props);this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    addAnnotationLayer = (originalAnnotation, newAnnotation) => {\n      let annotations = this.props.value;\n      if (originalAnnotation && annotations.includes(originalAnnotation)) {\n        annotations = annotations.map((anno) => anno === originalAnnotation ? newAnnotation : anno);\n      } else\n      {\n        annotations = [...annotations, newAnnotation];\n        this.setState({ addedAnnotationIndex: annotations.length - 1 });\n      }\n      this.props.refreshAnnotationData({\n        annotation: newAnnotation,\n        force: true\n      });\n      this.props.onChange(annotations);\n    };this.\n    handleVisibleChange = (visible, popoverKey) => {\n      this.setState((prevState) => ({\n        popoverVisible: { ...prevState.popoverVisible, [popoverKey]: visible }\n      }));\n    };this.\n\n\n\n\n\n\n\n\n\n    renderPopover = (popoverKey, annotation, error) => {\n      const id = (annotation == null ? void 0 : annotation.name) || '_new';\n      return _jsx(\"div\", { id: `annotation-pop-${id}`, children:\n        _jsx(AnnotationLayer, { ...(annotation || {}), error: error, colorScheme: this.props.colorScheme, vizType: this.props.vizType, addAnnotationLayer: (newAnnotation) => this.addAnnotationLayer(annotation, newAnnotation), removeAnnotationLayer: () => this.removeAnnotationLayer(annotation), close: () => {\n            this.handleVisibleChange(false, popoverKey);\n            this.setState({ addedAnnotationIndex: null });\n          } }) }\n      );\n    };this.state = { popoverVisible: {}, addedAnnotationIndex: null };this.addAnnotationLayer = this.addAnnotationLayer.bind(this);this.removeAnnotationLayer = this.removeAnnotationLayer.bind(this);this.handleVisibleChange = this.handleVisibleChange.bind(this);}componentDidMount() {// preload the AnnotationLayer component and dependent libraries i.e. mathjs\n    AnnotationLayer.preload();}UNSAFE_componentWillReceiveProps(nextProps) {const { name, annotationError, validationErrors, value } = nextProps;if (Object.keys(annotationError).length && !validationErrors.length) {this.props.actions.setControlValue(name, value, Object.keys(annotationError));}if (!Object.keys(annotationError).length && validationErrors.length) {this.props.actions.setControlValue(name, value, []);}}removeAnnotationLayer(annotation) {const annotations = this.props.value.filter((anno) => anno !== annotation); // So scrollbar doesnt get stuck on hidden\n    const element = getSectionContainerElement();if (element) {element.style.setProperty('overflow-y', 'auto', 'important');}this.props.onChange(annotations);}renderInfo(anno) {const { annotationError, annotationQuery, theme } = this.props;\n    if (annotationQuery[anno.name]) {\n      return _jsx(Icons.SyncOutlined, { iconColor: theme.colors.primary.base, iconSize: \"m\" });\n    }\n    if (annotationError[anno.name]) {\n      return _jsx(InfoTooltipWithTrigger, { label: \"validation-errors\", bsStyle: \"danger\", tooltip: annotationError[anno.name] });\n    }\n    if (!anno.show) {\n      return _jsx(\"span\", { style: { color: theme.colors.error.base }, children: \" Hidden \" });\n    }\n    return '';\n  }\n  render() {\n    const { addedAnnotationIndex } = this.state;\n    const { theme } = this.props;\n    const addedAnnotation = addedAnnotationIndex !== null ?\n    this.props.value[addedAnnotationIndex] :\n    null;\n    const annotations = this.props.value.map((anno, i) => _jsx(ControlPopover, { trigger: \"click\", title: t('Edit annotation layer'), css: (theme) => ({\n        '&:hover': {\n          cursor: 'pointer',\n          backgroundColor: theme.colors.grayscale.light4\n        }\n      }), content: this.renderPopover(i, anno, this.props.annotationError[anno.name]), open: this.state.popoverVisible[i], onOpenChange: (visible) => this.handleVisibleChange(visible, i), children:\n      _jsxs(CustomListItem, { selectable: true, children: [\n        _jsx(\"span\", { children: anno.name }),\n        _jsx(\"span\", { style: { float: 'right' }, children: this.renderInfo(anno) })] }\n      ) }, i\n    ));\n    const addLayerPopoverKey = 'add';\n    return _jsx(\"div\", { children:\n      _jsxs(List, { bordered: true, css: (theme) => ({ borderRadius: theme.gridUnit }), children: [\n        annotations,\n        _jsx(ControlPopover, { trigger: \"click\", content: this.renderPopover(addLayerPopoverKey, addedAnnotation, ''), title: t('Add annotation layer'), open: this.state.popoverVisible[addLayerPopoverKey], destroyTooltipOnHide: true, onOpenChange: (visible) => this.handleVisibleChange(visible, addLayerPopoverKey), children:\n          _jsxs(CustomListItem, { selectable: true, children: [\n            _jsx(Icons.PlusOutlined, { iconSize: \"m\", css: css`\n                  margin: auto ${theme.gridUnit}px auto 0;\n                  vertical-align: tex-top;\n                ` }),\n            t('Add annotation layer')] }\n          ) }\n        )] }\n      ) }\n    );\n  }\n}\n// Tried to hook this up through stores/control.jsx instead of using redux\n// directly, could not figure out how to get access to the color_scheme\nAnnotationLayerControl.defaultProps = defaultProps;function mapStateToProps({ charts, explore }) {var _explore$controls, _explore$controls$col, _chart$annotationErro, _chart$annotationQuer, _explore$controls2;\n  const chartKey = getChartKey(explore);\n  const defaultChartState = {\n    annotationError: {},\n    annotationQuery: {}\n  };\n  const chart = chartKey && charts[chartKey] ? charts[chartKey] : defaultChartState;\n  return {\n    // eslint-disable-next-line camelcase\n    colorScheme: (_explore$controls = explore.controls) == null ? void 0 : (_explore$controls$col = _explore$controls.color_scheme) == null ? void 0 : _explore$controls$col.value,\n    annotationError: (_chart$annotationErro = chart.annotationError) != null ? _chart$annotationErro : {},\n    annotationQuery: (_chart$annotationQuer = chart.annotationQuery) != null ? _chart$annotationQuer : {},\n    vizType: (_explore$controls2 = explore.controls) == null ? void 0 : _explore$controls2.viz_type.value\n  };\n}\nfunction mapDispatchToProps(dispatch) {\n  return {\n    refreshAnnotationData: (annotationObj) => dispatch(runAnnotationQuery(annotationObj))\n  };\n}\nconst themedAnnotationLayerControl = withTheme(AnnotationLayerControl);\nexport default connect(mapStateToProps, mapDispatchToProps)(themedAnnotationLayerControl);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}