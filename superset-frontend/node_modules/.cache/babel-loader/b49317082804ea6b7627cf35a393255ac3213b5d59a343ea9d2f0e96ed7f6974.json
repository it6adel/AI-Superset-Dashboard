{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataMaskType, ensureIsArray, getColumnLabel, NativeFilterType, NO_TIME_RANGE } from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { areObjectsEqual } from 'src/reduxUtils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\nexport const extractLabel = (filter) => {var _filter$label;\n  if (filter != null && filter.label && !(filter != null && (_filter$label = filter.label) != null && _filter$label.includes(undefined))) {\n    return filter.label;\n  }\n  if (filter != null && filter.value) {\n    return ensureIsArray(filter == null ? void 0 : filter.value).join(', ');\n  }\n  return null;\n};\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = ((columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).reduce((map, [key, value]) => ({\n      ...map,\n      [key]: value\n    }), {});\n    return arrValues.map((value) => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return Object.keys(filter.columns).\n  filter((column) => getChartIdsInFilterScope({\n    filterScope: filter.scopes[column]\n  }).includes(chartId)).\n  map((column) => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter\n  }));\n};\nconst getAppliedColumns = (chart) => {var _chart$queriesRespons, _chart$queriesRespons2;return new Set(((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).map((filter) => filter.column));};\nconst getRejectedColumns = (chart) => {var _chart$queriesRespons3, _chart$queriesRespons4;return new Set(((chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).map((filter) => getColumnLabel(filter.column)));};\nexport const getCrossFilterIndicator = (chartId, dataMask, chartLayoutItems) => {var _dataMask$extraFormDa, _filters$, _chartLayoutItem$meta, _chartLayoutItem$meta2, _chartLayoutItem$pare;\n  const filterState = dataMask == null ? void 0 : dataMask.filterState;\n  const filters = dataMask == null ? void 0 : (_dataMask$extraFormDa = dataMask.extraFormData) == null ? void 0 : _dataMask$extraFormDa.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState == null ? void 0 : filterState.filters;\n  const column = (filters == null ? void 0 : (_filters$ = filters[0]) == null ? void 0 : _filters$.col) || filtersState && Object.keys(filtersState)[0];\n  const chartLayoutItem = chartLayoutItems.find((layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartId;});\n  const filterObject = {\n    column,\n    name: (chartLayoutItem == null ? void 0 : (_chartLayoutItem$meta = chartLayoutItem.meta) == null ? void 0 : _chartLayoutItem$meta.sliceNameOverride) || (\n    chartLayoutItem == null ? void 0 : (_chartLayoutItem$meta2 = chartLayoutItem.meta) == null ? void 0 : _chartLayoutItem$meta2.sliceName) ||\n    '',\n    path: [...((_chartLayoutItem$pare = chartLayoutItem == null ? void 0 : chartLayoutItem.parents) != null ? _chartLayoutItem$pare : []), (chartLayoutItem == null ? void 0 : chartLayoutItem.id) || ''],\n    value: label\n  };\n  return filterObject;\n};\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, chart) => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter((filter) => filter.chartId !== chartId);\n  const matchingDatasources = Object.entries(datasources).\n  filter(([key]) => matchingFilters.find((filter) => filter.datasourceId === key)).\n  map(([, datasource]) => datasource);\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (cachedIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData.rejectedColumns, rejectedColumns) &&\n  areObjectsEqual(cachedFilterData.matchingFilters, matchingFilters) &&\n  areObjectsEqual(cachedFilterData.matchingDatasources, matchingDatasources)) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce((acc, filter) => acc.concat(selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources\n  };\n  return indicators;\n};\nconst getStatus = ({ label, column, type = DataMaskType.NativeFilters, rejectedColumns, appliedColumns }) => {\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS = type === DataMaskType.CrossFilters ?\n  IndicatorStatus.CrossFilterApplied :\n  IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns != null && rejectedColumns.has(column))\n  return IndicatorStatus.Incompatible;\n  if (column && appliedColumns != null && appliedColumns.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = (dataMask, chartId, chartLayoutItems, chartConfiguration = defaultChartConfig, appliedColumns, rejectedColumns, filterEmitter = false) => {\n  let crossFilterIndicators = [];\n  crossFilterIndicators = Object.values(chartConfiguration).\n  filter((chartConfig) => {var _chartConfig$crossFil, _chartConfig$crossFil2;\n    const inScope = (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : (_chartConfig$crossFil2 = _chartConfig$crossFil.chartsInScope) == null ? void 0 : _chartConfig$crossFil2.includes(chartId);\n    if (!filterEmitter && inScope) {\n      return true;\n    }\n    if (filterEmitter && !inScope) {\n      return true;\n    }\n    return false;\n  }).\n  map((chartConfig) => {\n    const filterIndicator = getCrossFilterIndicator(Number(chartConfig.id), dataMask[chartConfig.id], chartLayoutItems);\n    const filterStatus = getStatus({\n      label: filterIndicator.value,\n      column: filterIndicator.column ?\n      getColumnLabel(filterIndicator.column) :\n      undefined,\n      type: DataMaskType.CrossFilters,\n      appliedColumns,\n      rejectedColumns\n    });\n    return { ...filterIndicator, status: filterStatus };\n  }).\n  filter((filter) => filter.status === IndicatorStatus.CrossFilterApplied);\n  return crossFilterIndicators;\n};\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart = {};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, chart, chartLayoutItems, chartConfiguration = defaultChartConfig) => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (cachedNativeIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.nativeFilters) === nativeFilters &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartLayoutItems) === chartLayoutItems &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartConfiguration) === chartConfiguration &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dataMask) === dataMask) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  const nativeFilterIndicators = nativeFilters &&\n  Object.values(nativeFilters).\n  filter((nativeFilter) => {var _nativeFilter$chartsI;return nativeFilter.type === NativeFilterType.NativeFilter && ((_nativeFilter$chartsI =\n    nativeFilter.chartsInScope) == null ? void 0 : _nativeFilter$chartsI.includes(chartId));}).\n  map((nativeFilter) => {var _nativeFilter$targets, _nativeFilter$targets2, _nativeFilter$targets3, _dataMask$nativeFilte;\n    const column = (_nativeFilter$targets = nativeFilter.targets) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets[0]) == null ? void 0 : (_nativeFilter$targets3 = _nativeFilter$targets2.column) == null ? void 0 : _nativeFilter$targets3.name;\n    const filterState = (_dataMask$nativeFilte = dataMask[nativeFilter.id]) == null ? void 0 : _dataMask$nativeFilte.filterState;\n    const label = extractLabel(filterState);\n    return {\n      column,\n      name: nativeFilter.name,\n      path: [nativeFilter.id],\n      status: getStatus({\n        label,\n        column,\n        rejectedColumns,\n        appliedColumns\n      }),\n      value: label\n    };\n  });\n  let crossFilterIndicators = [];\n  crossFilterIndicators = selectChartCrossFilters(dataMask, chartId, chartLayoutItems, chartConfiguration, appliedColumns, rejectedColumns);\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    chartLayoutItems,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns\n  };\n  return indicators;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}