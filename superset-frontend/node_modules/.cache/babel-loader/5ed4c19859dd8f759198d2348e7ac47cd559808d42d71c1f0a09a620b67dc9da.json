{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useState, useCallback, useMemo } from 'react';\nimport { Resizable } from 're-resizable';\nimport cx from 'classnames';\nimport { css, styled } from '@superset-ui/core';\nimport { RightResizeHandle, BottomResizeHandle, BottomRightResizeHandle } from './ResizableHandle';\nimport resizableConfig from '../../util/resizableConfig';\nimport { GRID_BASE_UNIT, GRID_GUTTER_SIZE } from '../../util/constants';import { jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nconst proxyToInfinity = Number.MAX_VALUE;\n// because columns are not multiples of a single variable (width = n*cols + (n-1) * gutters)\n// we snap to the base unit and then snap to _actual_ column multiples on stop\nconst SNAP_TO_GRID = [GRID_BASE_UNIT, GRID_BASE_UNIT];\nconst HANDLE_CLASSES = {\n  right: 'resizable-container-handle--right',\n  bottom: 'resizable-container-handle--bottom'\n};\n// @ts-ignore\nconst StyledResizable = styled(Resizable)`\n  ${({ theme }) => css`\n    &.resizable-container {\n      background-color: transparent;\n      position: relative;\n\n      /* re-resizable sets an empty div to 100% width and height, which doesn't\n      play well with many 100% height containers we need */\n\n      & ~ div {\n        width: auto !important;\n        height: auto !important;\n      }\n    }\n\n    &.resizable-container--resizing {\n      /* after ensures border visibility on top of any children */\n\n      &:after {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        box-shadow: inset 0 0 0 2px ${theme.colors.primary.base};\n      }\n\n      & > span .resize-handle {\n        border-color: ${theme.colors.primary.base};\n      }\n    }\n\n    .resize-handle {\n      opacity: 0;\n      z-index: 10;\n\n      &--bottom-right {\n        position: absolute;\n        border-right: 1px solid ${theme.colors.text.label};\n        border-bottom: 1px solid ${theme.colors.text.label};\n        right: ${theme.gridUnit * 4}px;\n        bottom: ${theme.gridUnit * 4}px;\n        width: ${theme.gridUnit * 2}px;\n        height: ${theme.gridUnit * 2}px;\n      }\n\n      &--right {\n        width: ${theme.gridUnit / 2}px;\n        height: ${theme.gridUnit * 5}px;\n        right: ${theme.gridUnit}px;\n        top: 50%;\n        transform: translate(0, -50%);\n        position: absolute;\n        border-left: 1px solid ${theme.colors.text.label};\n        border-right: 1px solid ${theme.colors.text.label};\n      }\n\n      &--bottom {\n        height: ${theme.gridUnit / 2}px;\n        width: ${theme.gridUnit * 5}px;\n        bottom: ${theme.gridUnit}px;\n        left: 50%;\n        transform: translate(-50%);\n        position: absolute;\n        border-top: 1px solid ${theme.colors.text.label};\n        border-bottom: 1px solid ${theme.colors.text.label};\n      }\n    }\n  `}\n\n  &.resizable-container:hover .resize-handle,\n  &.resizable-container--resizing .resize-handle {\n    opacity: 1;\n  }\n\n  .dragdroppable-column & .resizable-container-handle--right {\n    /* override the default because the inner column's handle's mouse target is very small */\n    right: 0 !important;\n  }\n\n  & .resizable-container-handle--bottom {\n    bottom: 0 !important;\n  }\n`;\nexport default function ResizableContainer({ id, children, widthMultiple, heightMultiple, staticHeight, staticHeightMultiple, staticWidth, staticWidthMultiple, onResizeStop, onResize, onResizeStart, editMode, adjustableWidth = true, adjustableHeight = true, gutterWidth = GRID_GUTTER_SIZE, widthStep = GRID_BASE_UNIT, heightStep = GRID_BASE_UNIT, minWidthMultiple = 1, maxWidthMultiple = proxyToInfinity, minHeightMultiple = 1, maxHeightMultiple = proxyToInfinity }) {\n  const [isResizing, setIsResizing] = useState(false);\n  const handleResize = useCallback((event, direction, elementRef, delta) => {\n    if (onResize)\n    onResize(event, direction, elementRef, delta);\n  }, [onResize]);\n  const handleResizeStart = useCallback((e, dir, elementRef) => {\n    if (onResizeStart)\n    onResizeStart(e, dir, elementRef);\n    setIsResizing(true);\n  }, [onResizeStart]);\n  const handleResizeStop = useCallback((event, direction, elementRef, delta) => {\n    if (onResizeStop) {\n      const nextWidthMultiple = widthMultiple + Math.round(delta.width / (widthStep + gutterWidth));\n      const nextHeightMultiple = heightMultiple + Math.round(delta.height / heightStep);\n      onResizeStop(event, direction, elementRef, {\n        width: adjustableWidth ? nextWidthMultiple : 0,\n        height: adjustableHeight ? nextHeightMultiple : 0\n      },\n      // @ts-ignore\n      id);\n    }\n    setIsResizing(false);\n  }, [\n  onResizeStop,\n  widthMultiple,\n  heightMultiple,\n  widthStep,\n  heightStep,\n  gutterWidth,\n  adjustableWidth,\n  adjustableHeight,\n  id]\n  );\n  const size = useMemo(() => ({\n    width: adjustableWidth ?\n    (widthStep + gutterWidth) * widthMultiple - gutterWidth :\n    staticWidthMultiple && staticWidthMultiple * widthStep ||\n    staticWidth ||\n    undefined,\n    height: adjustableHeight ?\n    heightStep * heightMultiple :\n    staticHeightMultiple && staticHeightMultiple * heightStep ||\n    staticHeight ||\n    undefined\n  }), [\n  adjustableWidth,\n  widthStep,\n  gutterWidth,\n  widthMultiple,\n  staticWidthMultiple,\n  staticWidth,\n  adjustableHeight,\n  heightStep,\n  heightMultiple,\n  staticHeightMultiple,\n  staticHeight]\n  );\n  const handleComponent = useMemo(() => ({\n    right: _jsx(RightResizeHandle, {}),\n    bottom: _jsx(BottomResizeHandle, {}),\n    bottomRight: _jsx(BottomRightResizeHandle, {})\n  }), []);\n  const enableConfig = useMemo(() => {\n    if (editMode && adjustableWidth && adjustableHeight) {\n      return resizableConfig.widthAndHeight;\n    }\n    if (editMode && adjustableWidth) {\n      return resizableConfig.widthOnly;\n    }\n    if (editMode && adjustableHeight) {\n      return resizableConfig.heightOnly;\n    }\n    return resizableConfig.notAdjustable;\n  }, [editMode, adjustableWidth, adjustableHeight]);\n  return _jsx(StyledResizable, { enable: enableConfig, grid: SNAP_TO_GRID, gridGap: undefined, minWidth: adjustableWidth ?\n    minWidthMultiple * (widthStep + gutterWidth) - gutterWidth :\n    undefined, minHeight: adjustableHeight ? minHeightMultiple * heightStep : undefined, maxWidth: adjustableWidth && size.width ?\n    Math.max(size.width, Math.min(proxyToInfinity, maxWidthMultiple * (widthStep + gutterWidth) - gutterWidth)) :\n    undefined, maxHeight: adjustableHeight && size.height ?\n    Math.max(size.height, Math.min(proxyToInfinity, maxHeightMultiple * heightStep)) :\n    undefined, size: size, onResizeStart: handleResizeStart, onResize: handleResize, onResizeStop: handleResizeStop, handleComponent: handleComponent, className: cx('resizable-container', isResizing && 'resizable-container--resizing'), handleClasses: HANDLE_CLASSES, children:\n    children }\n  );\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}