{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { DatasourceType, SupersetClient, t } from '@superset-ui/core';\nimport { addSuccessToast } from 'src/components/MessageToasts/actions';\n\nimport { Operators } from '../constants';\nimport { buildV1ChartDataPayload } from '../exploreUtils';\nconst ADHOC_FILTER_REGEX = /^adhoc_filters/;\nexport const FETCH_DASHBOARDS_SUCCEEDED = 'FETCH_DASHBOARDS_SUCCEEDED';\nexport function fetchDashboardsSucceeded(choices) {\n  return { type: FETCH_DASHBOARDS_SUCCEEDED, choices };\n}\nexport const FETCH_DASHBOARDS_FAILED = 'FETCH_DASHBOARDS_FAILED';\nexport function fetchDashboardsFailed(userId) {\n  return { type: FETCH_DASHBOARDS_FAILED, userId };\n}\nexport const SET_SAVE_CHART_MODAL_VISIBILITY = 'SET_SAVE_CHART_MODAL_VISIBILITY';\nexport function setSaveChartModalVisibility(isVisible) {\n  return { type: SET_SAVE_CHART_MODAL_VISIBILITY, isVisible };\n}\nexport const SAVE_SLICE_FAILED = 'SAVE_SLICE_FAILED';\nexport function saveSliceFailed() {\n  return { type: SAVE_SLICE_FAILED };\n}\nexport const SAVE_SLICE_SUCCESS = 'SAVE_SLICE_SUCCESS';\nexport function saveSliceSuccess(data) {\n  return { type: SAVE_SLICE_SUCCESS, data };\n}\nfunction extractAdhocFiltersFromFormData(formDataToHandle) {\n  const result = {};\n  Object.entries(formDataToHandle).forEach(([key, value]) => {\n    if (ADHOC_FILTER_REGEX.test(key) && Array.isArray(value)) {\n      result[key] = value.filter((f) => !f.isExtra);\n    }\n  });\n  return result;\n}\nconst hasTemporalRangeFilter = (formData) => ((formData == null ? void 0 : formData.adhoc_filters) || []).some((filter) => filter.operator === Operators.TemporalRange);\nexport const getSlicePayload = (sliceName, formDataWithNativeFilters = {}, dashboards, owners, formDataFromSlice = {}) => {\n  const adhocFilters = extractAdhocFiltersFromFormData(formDataWithNativeFilters);\n  if (!_isEmpty(formDataFromSlice) &&\n  formDataWithNativeFilters.adhoc_filters &&\n  formDataWithNativeFilters.adhoc_filters.length > 0) {\n    Object.keys(adhocFilters).forEach((adhocFilterKey) => {\n      if (_isEmpty(adhocFilters[adhocFilterKey])) {\n        const sourceFilters = formDataFromSlice[adhocFilterKey];\n        if (Array.isArray(sourceFilters)) {\n          const targetArray = adhocFilters[adhocFilterKey] || [];\n          sourceFilters.forEach((filter) => {\n            if (filter.operator === Operators.TemporalRange) {\n              targetArray.push({\n                ...filter,\n                comparator: filter.comparator || 'No filter'\n              });\n            }\n          });\n          adhocFilters[adhocFilterKey] = targetArray;\n        }\n      }\n    });\n  }\n  if (!hasTemporalRangeFilter(adhocFilters)) {\n    const adhocFiltersKeys = Object.keys(formDataWithNativeFilters).filter((key) => ADHOC_FILTER_REGEX.test(key));\n    adhocFiltersKeys == null ? void 0 : adhocFiltersKeys.forEach((filtersKey) => {var _formDataWithNativeFi;\n      (_formDataWithNativeFi = formDataWithNativeFilters[filtersKey]) == null ? void 0 : _formDataWithNativeFi.forEach((filter) => {\n        if (filter.operator === Operators.TemporalRange && filter.isExtra) {\n          if (!adhocFilters[filtersKey]) {\n            adhocFilters[filtersKey] = [];\n          }\n          adhocFilters[filtersKey].push({\n            ...filter,\n            comparator: 'No filter'\n          });\n        }\n      });\n    });\n  }\n  const formData = {\n    ...formDataWithNativeFilters,\n    ...adhocFilters,\n    dashboards\n  };\n  let datasourceId = 0;\n  let datasourceType = DatasourceType.Table;\n  if (formData.datasource) {\n    const [id, typeString] = formData.datasource.split('__');\n    datasourceId = parseInt(id, 10);\n    const formattedTypeString = typeString.charAt(0).toUpperCase() + typeString.slice(1);\n    if (formattedTypeString in DatasourceType) {\n      datasourceType =\n      DatasourceType[formattedTypeString];\n    }\n  }\n  const payload = {\n    params: JSON.stringify(formData),\n    slice_name: sliceName,\n    viz_type: formData.viz_type,\n    datasource_id: datasourceId,\n    datasource_type: datasourceType,\n    dashboards,\n    owners,\n    query_context: JSON.stringify(buildV1ChartDataPayload({\n      formData,\n      force: false,\n      resultFormat: 'json',\n      resultType: 'full',\n      setDataMask: null,\n      ownState: null\n    }))\n  };\n  return payload;\n};\nconst addToasts = (isNewSlice, sliceName, addedToDashboard) => {\n  const toasts = [];\n  if (isNewSlice) {\n    toasts.push(addSuccessToast(t('Chart [%s] has been saved', sliceName)));\n  } else\n  {\n    toasts.push(addSuccessToast(t('Chart [%s] has been overwritten', sliceName)));\n  }\n  if (addedToDashboard) {\n    if (addedToDashboard.new) {\n      toasts.push(addSuccessToast(t('Dashboard [%s] just got created and chart [%s] was added to it', addedToDashboard.title, sliceName)));\n    } else\n    {\n      toasts.push(addSuccessToast(t('Chart [%s] was added to dashboard [%s]', sliceName, addedToDashboard.title)));\n    }\n  }\n  return toasts;\n};\nexport const updateSlice = (slice, sliceName, dashboards, addedToDashboard) => async (dispatch, getState) => {var _getState$explore;\n  const { slice_id: sliceId, owners, form_data: formDataFromSlice } = slice;\n  const formData = (_getState$explore = getState().explore) == null ? void 0 : _getState$explore.form_data;\n  try {\n    const response = await SupersetClient.put({\n      endpoint: `/api/v1/chart/${sliceId}`,\n      jsonPayload: getSlicePayload(sliceName, formData, dashboards, owners, formDataFromSlice)\n    });\n    dispatch(saveSliceSuccess(response.json));\n    addToasts(false, sliceName, addedToDashboard).map(dispatch);\n    return response.json;\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport const createSlice = (sliceName, dashboards, addedToDashboard) => async (dispatch, getState) => {var _getState$explore2;\n  const formData = (_getState$explore2 = getState().explore) == null ? void 0 : _getState$explore2.form_data;\n  try {\n    const response = await SupersetClient.post({\n      endpoint: `/api/v1/chart/`,\n      jsonPayload: getSlicePayload(sliceName, formData, dashboards, [], {})\n    });\n    dispatch(saveSliceSuccess(response.json));\n    addToasts(true, sliceName, addedToDashboard).map(dispatch);\n    return response.json;\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport const createDashboard = (dashboardName) => async (dispatch) => {\n  try {\n    const response = await SupersetClient.post({\n      endpoint: `/api/v1/dashboard/`,\n      jsonPayload: { dashboard_title: dashboardName }\n    });\n    return response.json;\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};\nexport const getSliceDashboards = (slice) => async (dispatch) => {\n  try {\n    const response = await SupersetClient.get({\n      endpoint: `/api/v1/chart/${slice.slice_id}?q=${rison.encode({\n        columns: ['dashboards.id']\n      })}`\n    });\n    return response.json.result.dashboards.map(({ id }) => id);\n  }\n  catch (error) {\n    dispatch(saveSliceFailed());\n    throw error;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}