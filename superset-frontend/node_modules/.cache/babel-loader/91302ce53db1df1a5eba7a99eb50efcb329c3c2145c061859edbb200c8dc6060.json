{"ast":null,"code":"import { CHART_TYPE, DASHBOARD_ROOT_TYPE, TAB_TYPE } from 'src/dashboard/util/componentTypes';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nimport { logging, t } from '@superset-ui/core';\nexport const isShowTypeInTree = ({ type }) => type === TAB_TYPE || type === CHART_TYPE || type === DASHBOARD_ROOT_TYPE;\nexport const getNodeTitle = (node) => {var _ref, _ref2, _ref3, _ref4, _node$meta$sliceNameO, _node$meta, _node$meta2, _node$meta3, _node$meta4, _node$id;return (_ref = (_ref2 = (_ref3 = (_ref4 = (_node$meta$sliceNameO = node == null ? void 0 : (_node$meta = node.meta) == null ? void 0 : _node$meta.sliceNameOverride) != null ? _node$meta$sliceNameO :\n  node == null ? void 0 : (_node$meta2 = node.meta) == null ? void 0 : _node$meta2.sliceName) != null ? _ref4 :\n  node == null ? void 0 : (_node$meta3 = node.meta) == null ? void 0 : _node$meta3.text) != null ? _ref3 :\n  node == null ? void 0 : (_node$meta4 = node.meta) == null ? void 0 : _node$meta4.defaultText) != null ? _ref2 :\n  node == null ? void 0 : (_node$id = node.id) == null ? void 0 : _node$id.toString == null ? void 0 : _node$id.toString()) != null ? _ref :\n  '';};\nexport const buildTree = (node, treeItem, layout, charts, validNodes, initiallyExcludedCharts, buildTreeLeafTitle) => {var _node$children;\n  let itemToPass = treeItem;\n  if (node &&\n  treeItem &&\n  isShowTypeInTree(node) &&\n  node.type !== DASHBOARD_ROOT_TYPE &&\n  validNodes != null && validNodes.includes != null && validNodes.includes(node.id)) {var _node$meta5;\n    const title = buildTreeLeafTitle(getNodeTitle(node), initiallyExcludedCharts == null ? void 0 : initiallyExcludedCharts.includes == null ? void 0 : initiallyExcludedCharts.includes((_node$meta5 = node.meta) == null ? void 0 : _node$meta5.chartId), t(\"This chart might be incompatible with the filter (datasets don't match)\"));\n    const currentTreeItem = {\n      key: node.id,\n      title,\n      children: []\n    };\n    treeItem.children.push(currentTreeItem);\n    itemToPass = currentTreeItem;\n  }\n  node == null ? void 0 : (_node$children = node.children) == null ? void 0 : _node$children.forEach == null ? void 0 : _node$children.forEach((child) => {\n    const node = layout == null ? void 0 : layout[child];\n    if (node) {\n      buildTree(node, itemToPass, layout, charts, validNodes, initiallyExcludedCharts, buildTreeLeafTitle);\n    } else\n    {\n      logging.warn(`Unable to find item with id: ${child} in the dashboard layout. This may indicate you have invalid references in your dashboard and the references to id: ${child} should be removed.`);\n    }\n  });\n};\nconst addInvisibleParents = (layout, item) => {var _layout$item;return [\n  ...(((_layout$item = layout[item]) == null ? void 0 : _layout$item.children) || []),\n  ...Object.values(layout).\n  filter((val) => val.parents &&\n  val.parents[val.parents.length - 1] === item &&\n  !isShowTypeInTree(layout[val.parents[val.parents.length - 1]])).\n  map(({ id }) => id)];};\n\n// Generate checked options for Ant tree from redux scope\nconst checkTreeItem = (checkedItems, layout, items, excluded) => {\n  items.forEach((item) => {var _layout$item2, _layout$item3;\n    checkTreeItem(checkedItems, layout, addInvisibleParents(layout, item), excluded);\n    if (((_layout$item2 = layout[item]) == null ? void 0 : _layout$item2.type) === CHART_TYPE &&\n    !excluded.includes((_layout$item3 = layout[item]) == null ? void 0 : _layout$item3.meta.chartId)) {\n      checkedItems.push(item);\n    }\n  });\n};\nexport const getTreeCheckedItems = (scope, layout) => {\n  const checkedItems = [];\n  checkTreeItem(checkedItems, layout, [...scope.rootPath], [...scope.excluded]);\n  return [...new Set(checkedItems)];\n};\n// Looking for first common parent for selected charts/tabs/tab\nexport const findFilterScope = (checkedKeys, layout) => {\n  if (!checkedKeys.length) {\n    return {\n      rootPath: [],\n      excluded: []\n    };\n  }\n  // Get arrays of parents for selected charts\n  const checkedItemParents = checkedKeys.\n  filter((item) => {var _layout$item4;return ((_layout$item4 = layout[item]) == null ? void 0 : _layout$item4.type) === CHART_TYPE;}).\n  map((key) => {var _layout$key;\n    const parents = [DASHBOARD_ROOT_ID, ...(((_layout$key = layout[key]) == null ? void 0 : _layout$key.parents) || [])];\n    return parents.filter((parent) => isShowTypeInTree(layout[parent]));\n  });\n  // Sort arrays of parents to get first shortest array of parents,\n  // that means on it's level of parents located common parent, from this place parents start be different\n  checkedItemParents.sort((p1, p2) => p1.length - p2.length);\n  const rootPath = checkedItemParents.map((parents) => parents[checkedItemParents[0].length - 1]);\n  const excluded = [];\n  const isExcluded = (parent, item) => rootPath.includes(parent) && !checkedKeys.includes(item);\n  // looking for charts to be excluded: iterate over all charts\n  // and looking for charts that have one of their parents in `rootPath` and not in selected items\n  Object.entries(layout).forEach(([key, value]) => {var _ref5;\n    const parents = value.parents || [];\n    if (value.type === CHART_TYPE && (_ref5 =\n    [DASHBOARD_ROOT_ID, ...parents]) != null && _ref5.find((parent) => isExcluded(parent, key))) {\n      excluded.push(value.meta.chartId);\n    }\n  });\n  return {\n    rootPath: [...new Set(rootPath)],\n    excluded\n  };\n};\nexport const getDefaultScopeValue = (chartId, initiallyExcludedCharts = []) => ({\n  rootPath: [DASHBOARD_ROOT_ID],\n  excluded: chartId ?\n  [chartId, ...initiallyExcludedCharts] :\n  initiallyExcludedCharts\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}